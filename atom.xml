<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吕小医&amp;BLOG</title>
  
  <subtitle>good good study</subtitle>
  <link href="https://lvxiaoyi.top/atom.xml" rel="self"/>
  
  <link href="https://lvxiaoyi.top/"/>
  <updated>2021-09-05T10:41:51.023Z</updated>
  <id>https://lvxiaoyi.top/</id>
  
  <author>
    <name>吕小医</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单例模式</title>
    <link href="https://lvxiaoyi.top/f1601c3e.html"/>
    <id>https://lvxiaoyi.top/f1601c3e.html</id>
    <published>2021-09-05T10:41:51.023Z</published>
    <updated>2021-09-05T10:41:51.023Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是单例模式&quot;&gt;&lt;a href=&quot;#什么是单例模式&quot; class=&quot;headerlink&quot; title=&quot;什么是单例模式&quot;&gt;&lt;/a&gt;什么是单例模式&lt;/h1&gt;&lt;p&gt;单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。&lt;/p&gt;
&lt;p&gt;许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lvxiaoyi.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lvxiaoyi.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://lvxiaoyi.top/0.html"/>
    <id>https://lvxiaoyi.top/0.html</id>
    <published>2021-09-05T10:41:50.992Z</published>
    <updated>2021-09-05T10:41:50.992Z</updated>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>netty基础-2</title>
    <link href="https://lvxiaoyi.top/de7d93c2.html"/>
    <id>https://lvxiaoyi.top/de7d93c2.html</id>
    <published>2021-09-05T10:41:50.990Z</published>
    <updated>2021-09-05T10:41:50.990Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Netty-概述&quot;&gt;&lt;a href=&quot;#Netty-概述&quot; class=&quot;headerlink&quot; title=&quot;Netty 概述&quot;&gt;&lt;/a&gt;Netty 概述&lt;/h1&gt;&lt;h2 id=&quot;原生-NIO-存在的问题&quot;&gt;&lt;a href=&quot;#原生-NIO-存在的问题&quot; class=&quot;headerlink&quot; title=&quot;原生 NIO 存在的问题&quot;&gt;&lt;/a&gt;原生 NIO 存在的问题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;NIO&lt;/code&gt; 的类库和 &lt;code&gt;API&lt;/code&gt; 繁杂，使用麻烦：需要熟练掌握 &lt;code&gt;Selector&lt;/code&gt;、&lt;code&gt;ServerSocketChannel&lt;/code&gt;、&lt;code&gt;SocketChannel&lt;/code&gt;、&lt;code&gt;ByteBuffer&lt;/code&gt;等。&lt;/li&gt;
&lt;li&gt;需要具备其他的额外技能：要熟悉 &lt;code&gt;Java&lt;/code&gt; 多线程编程，因为 &lt;code&gt;NIO&lt;/code&gt; 编程涉及到 &lt;code&gt;Reactor&lt;/code&gt; 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 &lt;code&gt;NIO&lt;/code&gt; 程序。&lt;/li&gt;
&lt;li&gt;开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JDK NIO&lt;/code&gt; 的 &lt;code&gt;Bug&lt;/code&gt;：例如臭名昭著的 &lt;code&gt;Epoll Bug&lt;/code&gt;，它会导致 &lt;code&gt;Selector&lt;/code&gt; 空轮询，最终导致 &lt;code&gt;CPU100%&lt;/code&gt;。直到 &lt;code&gt;JDK1.7&lt;/code&gt; 版本该问题仍旧存在，没有被根本解决。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://lvxiaoyi.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="netty" scheme="https://lvxiaoyi.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/"/>
    
    
  </entry>
  
  <entry>
    <title>netty基础-1</title>
    <link href="https://lvxiaoyi.top/de7d93c1.html"/>
    <id>https://lvxiaoyi.top/de7d93c1.html</id>
    <published>2021-09-05T10:41:50.987Z</published>
    <updated>2021-09-05T10:41:50.987Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Netty简介&quot;&gt;&lt;a href=&quot;#Netty简介&quot; class=&quot;headerlink&quot; title=&quot;Netty简介&quot;&gt;&lt;/a&gt;Netty简介&lt;/h1&gt;&lt;h2 id=&quot;Netty-的介绍&quot;&gt;&lt;a href=&quot;#Netty-的介绍&quot; class=&quot;headerlink&quot; title=&quot;Netty 的介绍&quot;&gt;&lt;/a&gt;Netty 的介绍&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Netty&lt;/code&gt; 是由 &lt;code&gt;JBOSS&lt;/code&gt; 提供的一个 &lt;code&gt;Java&lt;/code&gt; 开源框架，现为 &lt;code&gt;Github&lt;/code&gt; 上的独立项目。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Netty&lt;/code&gt; 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 &lt;code&gt;IO&lt;/code&gt; 程序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Netty&lt;/code&gt; 主要针对在 &lt;code&gt;TCP&lt;/code&gt; 协议下，面向 &lt;code&gt;Client&lt;/code&gt; 端的高并发应用，或者 &lt;code&gt;Peer-to-Peer&lt;/code&gt; 场景下的大量数据持续传输的应用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Netty&lt;/code&gt; 本质是一个 &lt;code&gt;NIO&lt;/code&gt; 框架，适用于服务器通讯相关的多种应用场景。&lt;/li&gt;
&lt;li&gt;要透彻理解 &lt;code&gt;Netty&lt;/code&gt;，需要先学习 &lt;code&gt;NIO&lt;/code&gt;，这样我们才能阅读 &lt;code&gt;Netty&lt;/code&gt; 的源码。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://lvxiaoyi.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="netty" scheme="https://lvxiaoyi.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/netty/"/>
    
    
  </entry>
  
  <entry>
    <title>Jmeter基础一</title>
    <link href="https://lvxiaoyi.top/60bbc03b.html"/>
    <id>https://lvxiaoyi.top/60bbc03b.html</id>
    <published>2021-09-05T10:41:50.984Z</published>
    <updated>2021-09-05T10:41:50.984Z</updated>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;Jmeter介绍&quot;&gt;&lt;a href=&quot;#Jmeter介绍&quot; class=&quot;headerlink&quot; title=&quot;Jmeter介绍&quot;&gt;&lt;/a&gt;Jmeter介绍&lt;/h1&gt;&lt;h1 id=&quot;Jmeter入门&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="测试" scheme="https://lvxiaoyi.top/categories/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="Jmeter" scheme="https://lvxiaoyi.top/categories/%E6%B5%8B%E8%AF%95/Jmeter/"/>
    
    
    <category term="测试" scheme="https://lvxiaoyi.top/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>协程</title>
    <link href="https://lvxiaoyi.top/bb1e53b0.html"/>
    <id>https://lvxiaoyi.top/bb1e53b0.html</id>
    <published>2021-09-05T10:41:50.981Z</published>
    <updated>2021-09-05T10:41:50.981Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;进程和线程的痛点&quot;&gt;&lt;a href=&quot;#进程和线程的痛点&quot; class=&quot;headerlink&quot; title=&quot;进程和线程的痛点&quot;&gt;&lt;/a&gt;进程和线程的痛点&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;线程之间的通讯要设计到同步锁&lt;/li&gt;
&lt;li&gt;涉及到线程上下文切换&lt;/li&gt;
&lt;li&gt;涉及到阻塞状态和运行状态切换&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://lvxiaoyi.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://lvxiaoyi.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>多线程1</title>
    <link href="https://lvxiaoyi.top/cfe2d636.html"/>
    <id>https://lvxiaoyi.top/cfe2d636.html</id>
    <published>2021-09-05T10:41:50.978Z</published>
    <updated>2021-09-05T10:41:50.979Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;线程、进程、协程-纤程&quot;&gt;&lt;a href=&quot;#线程、进程、协程-纤程&quot; class=&quot;headerlink&quot; title=&quot;线程、进程、协程/纤程&quot;&gt;&lt;/a&gt;线程、进程、协程/纤程&lt;/h1&gt;&lt;p&gt;进程是资源分配的基本单位，一个进程中包括过个线程，各个进程之间互不影响&lt;/p&gt;
&lt;p&gt;线程是资源调度的基本单位，线程之间共享进程的部分资源&lt;/p&gt;
&lt;p&gt;协程：协程是一种程序组件，一个线程中可以有多个协程，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。&lt;/p&gt;</summary>
    
    
    
    <category term="多线程" scheme="https://lvxiaoyi.top/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="多线程理论篇" scheme="https://lvxiaoyi.top/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%90%86%E8%AE%BA%E7%AF%87/"/>
    
    
    <category term="多线程" scheme="https://lvxiaoyi.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>偏向锁四秒延迟探究</title>
    <link href="https://lvxiaoyi.top/77ed6e38.html"/>
    <id>https://lvxiaoyi.top/77ed6e38.html</id>
    <published>2021-09-05T10:41:50.975Z</published>
    <updated>2021-09-05T10:41:50.976Z</updated>
    
    
    <summary type="html">&lt;p&gt;在项目中发现偏向锁并不是立即生效的，而是有着一个默认延迟，下面深入探究一下，为什么偏向锁有着四秒延迟，以及怎么调优&lt;/p&gt;</summary>
    
    
    
    <category term="多线程" scheme="https://lvxiaoyi.top/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="多线程理论篇" scheme="https://lvxiaoyi.top/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%90%86%E8%AE%BA%E7%AF%87/"/>
    
    
    <category term="多线程" scheme="https://lvxiaoyi.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>volatile的底层实现</title>
    <link href="https://lvxiaoyi.top/db022879.html"/>
    <id>https://lvxiaoyi.top/db022879.html</id>
    <published>2021-09-05T10:41:50.965Z</published>
    <updated>2021-09-05T10:41:50.965Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h1&gt;&lt;h2 id=&quot;计算机组成&quot;&gt;&lt;a href=&quot;#计算机组成&quot; class=&quot;headerlink&quot; title=&quot;计算机组成&quot;&gt;&lt;/a&gt;计算机组成&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210827154138917.png&quot; alt=&quot;image-20210827154138917&quot;&gt;</summary>
    
    
    
    <category term="多线程" scheme="https://lvxiaoyi.top/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="多线程理论篇" scheme="https://lvxiaoyi.top/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%90%86%E8%AE%BA%E7%AF%87/"/>
    
    
    <category term="多线程" scheme="https://lvxiaoyi.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>hospot虚拟机中的synchronized底层实现</title>
    <link href="https://lvxiaoyi.top/cbd84e4c.html"/>
    <id>https://lvxiaoyi.top/cbd84e4c.html</id>
    <published>2021-09-05T10:41:50.950Z</published>
    <updated>2021-09-05T10:41:50.950Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;synchronized作用&quot;&gt;&lt;a href=&quot;#synchronized作用&quot; class=&quot;headerlink&quot; title=&quot;synchronized作用&quot;&gt;&lt;/a&gt;synchronized作用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;原子性：synchronized保证语句块内操作是原子的&lt;/li&gt;
&lt;li&gt;可见性：synchronized保证可见性（通过“在执行unlock之前，必须先把此变量同步回主内存”实现）&lt;/li&gt;
&lt;li&gt;有序性：synchronized保证有序性（通过“一个变量在同一时刻只允许一条线程对其进行lock操作”）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;synchronized的使用&quot;&gt;&lt;a href=&quot;#synchronized的使用&quot; class=&quot;headerlink&quot; title=&quot;synchronized的使用&quot;&gt;&lt;/a&gt;synchronized的使用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;修饰实例方法，对当前实例对象加锁&lt;/li&gt;
&lt;li&gt;修饰静态方法，多当前类的Class对象加锁&lt;/li&gt;
&lt;li&gt;修饰代码块，对synchronized括号内的对象加锁&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="多线程" scheme="https://lvxiaoyi.top/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="多线程理论篇" scheme="https://lvxiaoyi.top/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%90%86%E8%AE%BA%E7%AF%87/"/>
    
    
    <category term="多线程" scheme="https://lvxiaoyi.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock底层实现原理</title>
    <link href="https://lvxiaoyi.top/9682c195.html"/>
    <id>https://lvxiaoyi.top/9682c195.html</id>
    <published>2021-09-05T10:41:50.947Z</published>
    <updated>2021-09-05T10:41:50.947Z</updated>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</summary>
      
    
    
    
    <category term="多线程" scheme="https://lvxiaoyi.top/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="多线程理论篇" scheme="https://lvxiaoyi.top/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%90%86%E8%AE%BA%E7%AF%87/"/>
    
    
    <category term="多线程" scheme="https://lvxiaoyi.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JOL使用</title>
    <link href="https://lvxiaoyi.top/9fbd3b67.html"/>
    <id>https://lvxiaoyi.top/9fbd3b67.html</id>
    <published>2021-09-05T10:41:50.945Z</published>
    <updated>2021-09-05T10:41:50.945Z</updated>
    
    
    <summary type="html">&lt;p&gt;查看普通java对象的内部布局工具JOL(JAVA OBJECT LAYOUT)&lt;/p&gt;
&lt;p&gt;使用此工具可以查看new出来的一个java对象的内部布局,以及一个普通的java对象占用多少字节。&lt;/p&gt;</summary>
    
    
    
    <category term="多线程" scheme="https://lvxiaoyi.top/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="多线程理论篇" scheme="https://lvxiaoyi.top/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%90%86%E8%AE%BA%E7%AF%87/"/>
    
    
    <category term="多线程" scheme="https://lvxiaoyi.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CAS</title>
    <link href="https://lvxiaoyi.top/969d9481.html"/>
    <id>https://lvxiaoyi.top/969d9481.html</id>
    <published>2021-09-05T10:41:50.942Z</published>
    <updated>2021-09-05T10:41:50.942Z</updated>
    
    
    <summary type="html">&lt;p&gt;CAS：compar and swap，是一种自旋锁&lt;/p&gt;
&lt;img src=&quot;https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210826103838080.png&quot; alt=&quot;image-20210826103838080&quot; style=&quot;zoom:33%;&quot; /&gt;

&lt;p&gt;属于乐观锁，是解决多线程并行情况下使用锁造成性能损耗的一种机制，CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值。CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。&lt;/p&gt;</summary>
    
    
    
    <category term="多线程" scheme="https://lvxiaoyi.top/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="多线程理论篇" scheme="https://lvxiaoyi.top/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%90%86%E8%AE%BA%E7%AF%87/"/>
    
    
    <category term="多线程" scheme="https://lvxiaoyi.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>百万数据快速插入数据库</title>
    <link href="https://lvxiaoyi.top/859f2ea9.html"/>
    <id>https://lvxiaoyi.top/859f2ea9.html</id>
    <published>2021-09-05T10:41:50.938Z</published>
    <updated>2021-09-05T10:41:50.939Z</updated>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zl1zl2zl3/article/details/105007492?utm_medium=distribute.pc_relevant.none-task-b</summary>
      
    
    
    
    <category term="多线程" scheme="https://lvxiaoyi.top/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="多线程实战篇" scheme="https://lvxiaoyi.top/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AF%87/"/>
    
    
    <category term="多线程实战" scheme="https://lvxiaoyi.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>lua基础教程2-基础语法</title>
    <link href="https://lvxiaoyi.top/ef2fc5a3.html"/>
    <id>https://lvxiaoyi.top/ef2fc5a3.html</id>
    <published>2021-09-05T10:41:50.936Z</published>
    <updated>2021-09-05T10:41:50.937Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;hello-world&quot;&gt;&lt;a href=&quot;#hello-world&quot; class=&quot;headerlink&quot; title=&quot;hello world&quot;&gt;&lt;/a&gt;hello world&lt;/h1&gt;&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;hello world!&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="lua" scheme="https://lvxiaoyi.top/categories/lua/"/>
    
    <category term="基础" scheme="https://lvxiaoyi.top/categories/lua/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="lua" scheme="https://lvxiaoyi.top/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua基础教程1-环境安装</title>
    <link href="https://lvxiaoyi.top/b35e3780.html"/>
    <id>https://lvxiaoyi.top/b35e3780.html</id>
    <published>2021-09-05T10:41:50.934Z</published>
    <updated>2021-09-05T10:41:50.934Z</updated>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;什么是lua&quot;&gt;&lt;a href=&quot;#什么是lua&quot; class=&quot;headerlink&quot; title=&quot;什么是lua&quot;&gt;&lt;/a&gt;什么是lua&lt;/h1&gt;&lt;p&gt;Lua 是由巴西里约热内卢天主教大学（Pontifical</summary>
      
    
    
    
    <category term="lua" scheme="https://lvxiaoyi.top/categories/lua/"/>
    
    <category term="基础" scheme="https://lvxiaoyi.top/categories/lua/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="lua" scheme="https://lvxiaoyi.top/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>jvm中对象的内存布局</title>
    <link href="https://lvxiaoyi.top/561c47f9.html"/>
    <id>https://lvxiaoyi.top/561c47f9.html</id>
    <published>2021-09-05T10:41:50.931Z</published>
    <updated>2021-09-05T10:41:50.931Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;对象的创建、内存布局和访问定位&quot;&gt;&lt;a href=&quot;#对象的创建、内存布局和访问定位&quot; class=&quot;headerlink&quot; title=&quot;对象的创建、内存布局和访问定位&quot;&gt;&lt;/a&gt;对象的创建、内存布局和访问定位&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;1-对象创建&quot;&gt;&lt;a href=&quot;#1-对象创建&quot; class=&quot;headerlink&quot; title=&quot;1. 对象创建&quot;&gt;&lt;/a&gt;1. 对象创建&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在开发使用时，创建 &lt;code&gt;Java&lt;/code&gt; 对象仅仅只是是通过关键字&lt;code&gt;new&lt;/code&gt;：&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="jvm" scheme="https://lvxiaoyi.top/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://lvxiaoyi.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>spring核心知识点</title>
    <link href="https://lvxiaoyi.top/de7e93c2.html"/>
    <id>https://lvxiaoyi.top/de7e93c2.html</id>
    <published>2021-09-05T10:41:50.915Z</published>
    <updated>2021-09-05T10:41:50.915Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;说一下spring-ioc的理解，原理和实现&quot;&gt;&lt;a href=&quot;#说一下spring-ioc的理解，原理和实现&quot; class=&quot;headerlink&quot; title=&quot;说一下spring ioc的理解，原理和实现&quot;&gt;&lt;/a&gt;说一下spring ioc的理解，原理和实现&lt;/h2&gt;&lt;h3 id=&quot;总&quot;&gt;&lt;a href=&quot;#总&quot; class=&quot;headerlink&quot; title=&quot;总&quot;&gt;&lt;/a&gt;总&lt;/h3&gt;&lt;p&gt;ioc：控制反转。原来的对象是由使用者来控制的，有了spring，就直接把整个对象交给spring来帮我们管理。&lt;/p&gt;
&lt;p&gt;​    DI：依赖注入。把对应的属性的值注入到具体的对象中，@autowired，populatebean完成属性值得注入&lt;/p&gt;
&lt;p&gt;容器：存储对象，使用map结构存储，在spring中一般存在三级缓存，singletonOBjects存放文章的bean对象，在整个bean的生命周期中，从创建到使用到销毁都是由容器来管理的。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://lvxiaoyi.top/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://lvxiaoyi.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>深究Spring中Bean的生命周期</title>
    <link href="https://lvxiaoyi.top/440fb577.html"/>
    <id>https://lvxiaoyi.top/440fb577.html</id>
    <published>2021-09-05T10:41:50.906Z</published>
    <updated>2021-09-05T10:41:50.906Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;深究Spring中Bean的生命周期&quot;&gt;&lt;a href=&quot;#深究Spring中Bean的生命周期&quot; class=&quot;headerlink&quot; title=&quot;深究Spring中Bean的生命周期&quot;&gt;&lt;/a&gt;深究Spring中Bean的生命周期&lt;/h2&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这其实是一道面试题，是我在面试百度的时候被问到的，当时没有答出来(因为自己真的很菜)，后来在网上寻找答案，看到也是一头雾水，直到看到了《Spring in action》这本书，书上有对Bean声明周期的大致解释，但是没有代码分析，所以就自己上网寻找资料，一定要把这个Bean生命周期弄明白！&lt;/p&gt;
&lt;p&gt;网上大部分都是验证的Bean 在面试问的生命周期，其实查阅JDK还有一个完整的Bean生命周期，这同时也验证了书是具有片面性的，最fresh 的资料还是查阅原始JDK!!!&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://lvxiaoyi.top/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://lvxiaoyi.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>分布式id的生成方案</title>
    <link href="https://lvxiaoyi.top/d56bbc9.html"/>
    <id>https://lvxiaoyi.top/d56bbc9.html</id>
    <published>2021-09-05T10:41:50.897Z</published>
    <updated>2021-09-05T10:41:50.897Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;分布式id的生成方案&quot;&gt;&lt;a href=&quot;#分布式id的生成方案&quot; class=&quot;headerlink&quot; title=&quot;分布式id的生成方案&quot;&gt;&lt;/a&gt;分布式id的生成方案&lt;/h1&gt;&lt;p&gt;ID是数据的唯一标识，传统的做法是利用UUID和数据库的自增ID，在互联网企业中，大部分公司使用的都是Mysql，并且因为需要事务支持，所以通常会使用Innodb存储引擎，UUID太长以及无序，所以并不适合在Innodb中来作为主键，自增ID比较合适，但是随着公司的业务发展，数据量将越来越大，需要对数据进行分表，而分表后，每个表中的数据都会按自己的节奏进行自增，很有可能出现ID冲突。这时就需要一个单独的机制来负责生成唯一ID，生成出来的ID也可以叫做分布式ID，或全局ID。下面来分析各个生成分布式ID的机制。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://lvxiaoyi.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="分布式ID" scheme="https://lvxiaoyi.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FID/"/>
    
    
    <category term="分布式" scheme="https://lvxiaoyi.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
</feed>
