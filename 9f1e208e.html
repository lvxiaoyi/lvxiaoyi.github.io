<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>jvm基础2之字节码与类的加载篇 | 吕小医's BLOG</title><meta name="keywords" content="jvm"><meta name="author" content="lvxiaoyi"><meta name="copyright" content="lvxiaoyi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="jvm基础2概述字节码文件的跨平台性Java语言：跨平台的语言（write once，run anywhere 当Java源代码成功编译成字节码后，如果想在不同的平台上运行，则无须再次编译 这个优势现在不在那么吸引人 Python、PHP、Perl、Ruby、LISP等都有强大的解释器   跨平台似乎快成为了一门语言必选的特性。  Java虚拟机：跨语言的平台">
<meta property="og:type" content="article">
<meta property="og:title" content="jvm基础2之字节码与类的加载篇">
<meta property="og:url" content="https://lvxiaoyi.top/9f1e208e.html">
<meta property="og:site_name" content="吕小医&#39;s BLOG">
<meta property="og:description" content="jvm基础2概述字节码文件的跨平台性Java语言：跨平台的语言（write once，run anywhere 当Java源代码成功编译成字节码后，如果想在不同的平台上运行，则无须再次编译 这个优势现在不在那么吸引人 Python、PHP、Perl、Ruby、LISP等都有强大的解释器   跨平台似乎快成为了一门语言必选的特性。  Java虚拟机：跨语言的平台">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.lvxiaoyi.top/typora-img/202111011421399.jpeg/lvxiaoyi">
<meta property="article:published_time" content="2022-09-12T07:22:48.759Z">
<meta property="article:modified_time" content="2022-09-12T07:22:48.759Z">
<meta property="article:author" content="lvxiaoyi">
<meta property="article:tag" content="jvm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.lvxiaoyi.top/typora-img/202111011421399.jpeg/lvxiaoyi"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lvxiaoyi.top/9f1e208e"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'jvm基础2之字节码与类的加载篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-12 15:22:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p0.meituan.net/csc/8a1b1d488e6a8ab5108c9c78f36b3a1776955.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">205</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">51</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 小医</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img.lvxiaoyi.top/typora-img/202111011421399.jpeg/lvxiaoyi')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">吕小医's BLOG</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 小医</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">jvm基础2之字节码与类的加载篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-12T07:22:48.759Z" title="发表于 2022-09-12 15:22:48">2022-09-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-12T07:22:48.759Z" title="更新于 2022-09-12 15:22:48">2022-09-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/jvm/">jvm</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/jvm/jvm%E7%90%86%E8%AE%BA/">jvm理论</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="jvm基础2之字节码与类的加载篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="jvm基础2"><a href="#jvm基础2" class="headerlink" title="jvm基础2"></a>jvm基础2</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="字节码文件的跨平台性"><a href="#字节码文件的跨平台性" class="headerlink" title="字节码文件的跨平台性"></a>字节码文件的跨平台性</h2><h3 id="Java语言：跨平台的语言（write-once，run-anywhere"><a href="#Java语言：跨平台的语言（write-once，run-anywhere" class="headerlink" title="Java语言：跨平台的语言（write once，run anywhere"></a>Java语言：跨平台的语言（write once，run anywhere</h3><ul>
<li>当Java源代码成功编译成字节码后，如果想在不同的平台上运行，则无须再次编译</li>
<li>这个优势现在不在那么吸引人<ul>
<li><code>Python</code>、<code>PHP</code>、<code>Perl</code>、<code>Ruby</code>、<code>LISP</code>等都有强大的解释器</li>
</ul>
</li>
<li>跨平台似乎快成为了一门语言必选的特性。</li>
</ul>
<h3 id="Java虚拟机：跨语言的平台"><a href="#Java虚拟机：跨语言的平台" class="headerlink" title="Java虚拟机：跨语言的平台"></a>Java虚拟机：跨语言的平台</h3><span id="more"></span>

<p>Java虚拟机不和包括Java在内的任何语言绑定，它只和“class文件”这种特点的二进制文件格式所关联。无论使用何种语言进行软件开发，只要能将源文件编译成正确的Class文件，那么这种语言就可以在Java虚拟机上运行。可以说，统一而强大的Class文件结构，就是Java虚拟机的基石、桥梁。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210913100058369.png/lvxiaoyi" alt="image-20210913100058369"></p>
<p>java文档说明：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/index.html">https://docs.oracle.com/javase/specs/index.html</a></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210913101146078.png/lvxiaoyi" alt="image-20210913101146078" style="zoom:67%;" />



<p>我们主要是查看java8：</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se8/html/index.html">https://docs.oracle.com/javase/specs/jls/se8/html/index.html</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p>
<ul>
<li>所有的Jvm全部遵守<code>Java</code>虚拟机规范，也就是说所有的<code>jvm</code>环境都是一样 的，这样一来字节码文件就可以在各种jvm上运行</li>
</ul>
<h3 id="java源码必须编译为符合jvm规范的字节码"><a href="#java源码必须编译为符合jvm规范的字节码" class="headerlink" title="java源码必须编译为符合jvm规范的字节码"></a>java源码必须编译为符合jvm规范的字节码</h3><ul>
<li>前端编译器的主要任务就是负责将符合Java语法规范的Java代码转换为符合Jvm规范的字节码文件。</li>
<li>javac是一种能够将Java源码编译为字节码的前端编译器</li>
<li>javac编译器在将java源码编译为一个有效的字节码文件过程中经历了4个阶段，分别是词法解析、语法解析、语义解析以及生成字节码</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210913102004220.png/lvxiaoyi" alt="image-20210913102004220"></p>
<p>Oracle的JDK软件包括两部分内容：</p>
<ul>
<li>一部分是将Java源代码编译成Java虚拟机的指令集的编译器</li>
<li>另一部分是用于实习Java虚拟机的运行环境</li>
</ul>
<h2 id="前端编译器和后端编译器"><a href="#前端编译器和后端编译器" class="headerlink" title="前端编译器和后端编译器"></a>前端编译器和后端编译器</h2><h3 id="前端编译器"><a href="#前端编译器" class="headerlink" title="前端编译器"></a>前端编译器</h3><p><strong>将java文件编译成class文件的编译器。</strong></p>
<p>​        Java源代码的编译结果是字节码，那么肯定需要一种编译器能够将Java源码编译为字节码，承当这个重要责任的就是配置在<code>path</code>环境变量中的j<code>avac</code>编译器。javac是一种能够将Java源码编译为字节码的前端编译器。</p>
<p>​        <code>HotSpot VM</code>并没有强制要求前端编译器只能使用javac来编译字节码，其实只要编译结果符合JVM规范可以被JVM所识别即可。在Java的前端编译器领域，除了<code>javac</code>之外，还有一种被大家经常用到的前端编译器，那就是内置在Eclipse中的<code>ECJ（Eclipse Compiler for java）</code>编译器。和javac的全量式编译不同，<code>ECJ</code>是一种增量式编译器。</p>
<ul>
<li>在<code>Eclipse</code>中，当开发人员编写完代码后，使用“Ctrl+s”快捷键时，ECJ编译器锁采用的编译方案是把未编译部分的源码逐行进行编译，而非每次都进行全量编译。因此<code>ECJ</code>的编译效率会比javac更加迅速和高效，当然编译质量和javac相比大致还是一样的。</li>
<li>ECJ不仅是Eclipse的默认内置前端编译器，在Tomcat中同样也是使用ECJ编译器来编译jsp文件。由于<code>ECJ</code>编译器是采用<code>GPLv2</code>开源协议进行源代码公开，所以，大家可以登录eclipse官网下载<code>ECJ</code>编译器的源码进行二次开发。</li>
<li>默认情况下，<code>Intelij IDEA</code>使用<code>javac</code>编译器。（还可以自己设置为<code>AspectJ </code>编译器<code> ajc</code>）</li>
</ul>
<p>前端编译器并不会直接涉及编译优化等方面的技术，而是将这些具体优化细节交给HotSpot的JIT编译器负责</p>
<p>复习：<code>AOT</code>（静态提前编译器，<code>Ahead of Time Compile</code>r） </p>
<h3 id="后端编译器"><a href="#后端编译器" class="headerlink" title="后端编译器"></a>后端编译器</h3><p>将Class文件编译为与本地机器上可以识别的二进制指令的编译器。</p>
<p>主要有解释执行的解释器和编译执行的编译器。</p>
<p>目前主流的虚拟机都是解释器和编译器并存的运行架构，解释器和编译器各有优势。</p>
<h2 id="深入字节码观察"><a href="#深入字节码观察" class="headerlink" title="深入字节码观察"></a>深入字节码观察</h2><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="面试题1"><a href="#面试题1" class="headerlink" title="面试题1"></a>面试题1</h4><p>类文件结构有几个部分</p>
<p>答案在Class文件结构章节</p>
<h4 id="面试题2"><a href="#面试题2" class="headerlink" title="面试题2"></a>面试题2</h4><p>知道字节码吗，字节码都有哪些？比较下面代码<code>x == y</code>都经过了哪些过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">interview</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer x = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line">        System.out.println(x == y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确答案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>通过idea的工具jClasslib插件查看main方法的code，发现：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210913142135732.png/lvxiaoyi" alt="image-20210913142135732"></p>
<p>然后我们去Integer中查看Valueof和intValue方法</p>
<h5 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.valueOf(parseInt(s, <span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里调用了</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="comment">// 如果在缓存里面，这从这个缓存数组中取出值（这个值是integer对象）</span></span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer的内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义最小值为-128</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="comment">// 定义一个缓存数组</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="comment">// high 的默认值为127</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        <span class="comment">// 从vm中拿到high的数值，这个数值可以通过vm参数配置</span></span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果拿到了这个值，说明进行了vm配置</span></span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 把这个值转化为int类型</span></span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                <span class="comment">// 这个值得最小值要大于等于127</span></span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                <span class="comment">// 这个值得最大值是2147483518，也就是整个cache数组的长度为Integer的最大值</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        high = h;</span><br><span class="line">		<span class="comment">// 定义cache数组的长度</span></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="comment">// 为这个cache填充值，这些都是Integer对象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="comment">// 断言这个值得最大值大于等于127</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 私有化构造方法，jvm级别单例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="intValue"><a href="#intValue" class="headerlink" title="intValue"></a>intValue</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回了int类型的一个值value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个vlaue在创建Integer对象的时候</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="comment">// 在一步调用了new Integer()的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol>
<li>在创建一个integer的对象的时候，回调用valueOf方法<ol>
<li>valueOf方法回去调用IntegerCache中的一个值<ol>
<li>IntegerCache<ol>
<li>如果没被初始化，则优先从jvm参数中读取值进行初始化</li>
<li>如果初始化过了则直接拿到值，直接就返回了</li>
</ol>
</li>
<li>然后调用new Integer(i)方法</li>
</ol>
</li>
</ol>
</li>
<li>然后把这个对象放入栈中的局部变量表</li>
<li>然后判断的时候，调用intValue方法，然后int类型的值</li>
<li>两个int类型的值进行判断</li>
</ol>
<h3 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h3><h4 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">interview2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Integer a1 = <span class="number">10</span>;</span><br><span class="line">        Integer a2 = <span class="number">10</span>;</span><br><span class="line">        System.out.println(a1 == a2);</span><br><span class="line"></span><br><span class="line">        Integer a3 = <span class="number">128</span>;</span><br><span class="line">        Integer a4 = <span class="number">128</span>;</span><br><span class="line">        System.out.println(a3 == a4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我的答案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>正确答案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>这道题我之前见过</p>
<p>详解参考上面，默认情况下-128到127的数都是存放在缓存数组中的</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>装箱类型</th>
<th>取值范围</th>
<th>是否缓存</th>
<th>缓存范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
<td>-128～127</td>
<td>是</td>
<td>-128～127</td>
</tr>
<tr>
<td>short</td>
<td>short</td>
<td>-2~15～(2^15 - 1)</td>
<td>是</td>
<td>-128～127</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
<td>-2~31 ~(2^31 - 1)</td>
<td>是</td>
<td>-128～127</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
<td>-2^63～(2^63- 1)</td>
<td>是</td>
<td>-128～127</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
<td>–</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
<td>–</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
<td>true、false</td>
<td>是</td>
<td>true、false</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
<td>\uoo00 ~ \uffff</td>
<td>是</td>
<td>\uo000 ~ \uffff</td>
</tr>
</tbody></table>
<h4 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">interview3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        String str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        str1 += <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;helloWorld&quot;</span>;</span><br><span class="line">        System.out.println(str == str1);</span><br><span class="line">        System.out.println(str == str2);</span><br><span class="line">        System.out.println(str1 == str2);</span><br><span class="line">        String str3 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        System.out.println(str2 == str3);</span><br><span class="line">        String str4 = <span class="string">&quot;helloWorld&quot;</span>;</span><br><span class="line">        System.out.println(str2 == str4);</span><br><span class="line">        String str5 = <span class="keyword">new</span> String(<span class="string">&quot;helloWorld&quot;</span>);</span><br><span class="line">        System.out.println(str2 == str5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我的答案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>正确答案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>因为在第一节学习的时候我记得，这个字符串全部是存在在常量池中的，创建一个字符串如果常量池中有这个字符串会直接指向字符串，而且字符串拼接的时候每次都会创建一个新的字符串对象。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210913153657364.png/lvxiaoyi" alt="image-20210913153657364" style="zoom:67%;" />

<p>通过字节码我们可以看出来，在每次传化为字符串的时候都调用了一个toString方法，而这个方法是新创建了一个string对象。两个不同的string对象用==肯定是不想等的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a copy, don&#x27;t share the array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="举例3"><a href="#举例3" class="headerlink" title="举例3"></a>举例3</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">interview4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println(father.x); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.print();</span><br><span class="line">            x = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Father.x = &quot;</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.print();</span><br><span class="line">            x = <span class="number">40</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Son.x = &quot;</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我的答案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Father.x = <span class="number">0</span></span><br><span class="line">Son.x = <span class="number">40</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>正确答案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Son.x = <span class="number">0</span></span><br><span class="line">Son.x = <span class="number">30</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>

<ol>
<li>父类、子类变量的默认初始化</li>
<li>初始化父类的成员变量，x = 10</li>
<li>执行父类的构造方法</li>
<li>执行print方法，然后发现当前子类的print方法对父类的方法进行了重写（多态性），这个时候就调用了son的print方法</li>
<li>应为son的变量只进行了默认初始化，所以这个时候打印的为0</li>
<li>继续执行父类构造器中x=20</li>
<li>回到子类，执行子类的成员变量赋值x=30</li>
<li>执行子类的构造器，调用print方法，打印的值为30</li>
<li>创建对象成功</li>
<li>打印Father对象的x对象（属性不存在多肽，没有重写）</li>
</ol>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>初始化顺序</p>
<ol>
<li><p>静态代码块、静态成员变量只有第一次加载类的时候才会执行</p>
</li>
<li><p>执行顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">默认初始化</span><br><span class="line">父类静态代码块及父类静态成员变量（并列优先级看代码顺序）</span><br><span class="line">子类静态代码块及子类静态成员变量（并列优先级看代码顺序）</span><br><span class="line">父类普通代码块及父类成员变量</span><br><span class="line">父类构造器</span><br><span class="line">子类普通代码块及子类成员变量</span><br><span class="line">子类构造器</span><br><span class="line">有了对象后，用直接对对象属性赋值    </span><br></pre></td></tr></table></figure></li>
<li><p>静态内部类，只有在第一次调用的时候才会被初始化</p>
</li>
</ol>
<h1 id="虚拟机的基石：Class文件"><a href="#虚拟机的基石：Class文件" class="headerlink" title="虚拟机的基石：Class文件"></a>虚拟机的基石：Class文件</h1><h2 id="字节码文件是什么"><a href="#字节码文件是什么" class="headerlink" title="字节码文件是什么"></a>字节码文件是什么</h2><p>源代码经过编译器编译后会生成一个字节码文件，字节码是一种二进制的类文件，它的内容是JVM的指令，而不像C、C++由编译器直接生成机器码</p>
<h2 id="什么是字节码指令（byte-code）"><a href="#什么是字节码指令（byte-code）" class="headerlink" title="什么是字节码指令（byte code）"></a>什么是字节码指令（byte code）</h2><p>Java虚拟机的指令由一个字节长、代表着某种特定操作含义的操作码（opcode）以及跟随其后的零至多个代表此操作所需参数的操作数（operand）所构成。虚拟机中许多指令并不包含操作数，只有一个操作码。</p>
<p>比如：操作码+操作数（操作数在有些指令中没有）</p>
<p>存放指令到本地变量（Store <code>reference</code> into local variable）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">astore_1</span><br><span class="line"><span class="comment">//只有一个操作码</span></span><br></pre></td></tr></table></figure>

<p>存放字节到操作数栈（Push <code>byte</code>，The immediate <em>byte</em> is sign-extended to an <code>int</code> <em>value</em>. That <em>value</em> is pushed onto the operand stack.）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bipush <span class="number">10</span></span><br><span class="line"><span class="comment">//操作码+操作数</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210913170148044.png/lvxiaoyi" alt="image-20210913170148044"></p>
<h2 id="如何解读"><a href="#如何解读" class="headerlink" title="如何解读"></a>如何解读</h2><p>那如何解读供虚拟机解释执行的二进制字节码？</p>
<h3 id="方法一：notepad"><a href="#方法一：notepad" class="headerlink" title="方法一：notepad++"></a>方法一：notepad++</h3><p>一个一个二进制的看。这里用的是notePad++，需要安装一个hex-editor插件，或者使用Binary Viewer</p>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>插件下载地址：<a target="_blank" rel="noopener" href="https://github.com/chcg/NPP_HexEdit/releases">https://github.com/chcg/NPP_HexEdit/releases</a></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210913171222155.png/lvxiaoyi" alt="image-20210913171222155" style="zoom:50%;" />

<p>我是x86_64位，选择x64的下载</p>
<p>arm64：arm架构的64位指令集，最近苹果M1芯片就是用的arm架构</p>
<p>Win32：：所有32位的平台，不仅仅是x86</p>
<p>X64：x86的64位,Inter和AMD的主流</p>
<p>source code(zip)：zip压缩的源代码文件，一般主要是windows</p>
<p>souce code（tar.gz）:tar.gz压缩的源代码文件，常用与windows</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ol>
<li><p>下载后，解压储一个dll文件</p>
</li>
<li><p>打开Notepad++，选择插件、打开插件目录，创建文件夹HexEditor</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210913171112450.png" alt="image-20210913171112450" style="zoom:67%;" /></li>
<li><p>然后把这个dll文件放在HexEditor目录中</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210913171208848.png/lvxiaoyi" alt="image-20210913171208848"></p>
</li>
<li><p>重启Notepad++</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210913172423198.png/lvxiaoyi" alt="image-20210913172423198"></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210913174409951.png" alt="image-20210913174409951" style="zoom:50%;" />

<p>但是这个没有看到CA FE BA BE，我猜测可能是因为读取进制的问题，但是我调整后没有成功</p>
<h3 id="方法二：使用Binary-Viewer"><a href="#方法二：使用Binary-Viewer" class="headerlink" title="方法二：使用Binary Viewer"></a>方法二：使用Binary Viewer</h3><p>这个直接搜索下载安装就行了，特别小</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210913174628188.png/lvxiaoyi" alt="image-20210913174628188"></p>
<h3 id="方法三：使用javap指令"><a href="#方法三：使用javap指令" class="headerlink" title="方法三：使用javap指令"></a>方法三：使用javap指令</h3><p>jdk自带的反解析工具</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210913174910767.png/lvxiaoyi" alt="image-20210913174910767"></p>
<h3 id="方法四：jclasslib-bytecode-viewer（推荐）"><a href="#方法四：jclasslib-bytecode-viewer（推荐）" class="headerlink" title="方法四：jclasslib bytecode viewer（推荐）"></a>方法四：jclasslib bytecode viewer（推荐）</h3><p>使用jclasslib bytecode viewer，这个在jvm基础1中安装过了，或者直接搜索安装教程就行</p>
<h1 id="Class-文件结构"><a href="#Class-文件结构" class="headerlink" title="Class 文件结构"></a>Class 文件结构</h1><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210911215600796.png/lvxiaoyi" alt="image-20210911215600796" style="zoom: 50%;" />





<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>官方文档位置：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p>
<h3 id="Class类的本质"><a href="#Class类的本质" class="headerlink" title="Class类的本质"></a>Class类的本质</h3><p>任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说Class文件实际上它并不一定以磁盘文件形式存在。Class文件是一组以字节为基础单位的二进制流，在内存中的表现形式为字节数组</p>
<h3 id="Class文件格式"><a href="#Class文件格式" class="headerlink" title="Class文件格式"></a>Class文件格式</h3><ul>
<li>Class的结构不像XML等描述语言，由于它没有任何分隔符号。所以在其中的数据项，无论是字节顺序还是数量，都是被严格限定的。哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变</li>
</ul>
<p>Class文件格式采用一种类似于C语言结构体的方式进行数据存储，这种结构中只有两种数据类型：无符号数和表  </p>
<ul>
<li><p>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节、8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值</p>
</li>
<li><p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以”_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。由于表没有固定长度，所以通常会在其前面加上个数说明</p>
</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        num = num + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="原始字节码文件"><a href="#原始字节码文件" class="headerlink" title="原始字节码文件"></a>原始字节码文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cafe babe <span class="number">0000</span> <span class="number">0034</span> <span class="number">0016</span> 0a00 <span class="number">0400</span> <span class="number">1209</span></span><br><span class="line"><span class="number">0003</span> <span class="number">0013</span> <span class="number">0700</span> <span class="number">1407</span> <span class="number">0015</span> <span class="number">0100</span> 036e <span class="number">756d</span></span><br><span class="line"><span class="number">0100</span> 0149 <span class="number">0100</span> 063c 696e <span class="number">6974</span> <span class="number">3e01</span> <span class="number">0003</span></span><br><span class="line"><span class="number">2829</span> <span class="number">5601</span> <span class="number">0004</span> <span class="number">436f</span> <span class="number">6465</span> <span class="number">0100</span> 0f4c 696e</span><br><span class="line">654e <span class="number">756d</span> <span class="number">6265</span> <span class="number">7254</span> <span class="number">6162</span> 6c65 <span class="number">0100</span> 124c</span><br><span class="line">6f63 616c <span class="number">5661</span> <span class="number">7269</span> <span class="number">6162</span> 6c65 <span class="number">5461</span> 626c</span><br><span class="line"><span class="number">6501</span> <span class="number">0004</span> <span class="number">7468</span> <span class="number">6973</span> <span class="number">0100</span> 184c <span class="number">636f</span> 6d2f</span><br><span class="line"><span class="number">6174</span> <span class="number">6775</span> <span class="number">6967</span> <span class="number">752f</span> 6a61 <span class="number">7661</span> <span class="number">312f</span> <span class="number">4465</span></span><br><span class="line">6d6f 3b01 <span class="number">0003</span> <span class="number">6164</span> <span class="number">6401</span> <span class="number">0003</span> <span class="number">2829</span> <span class="number">4901</span></span><br><span class="line">000a <span class="number">536f</span> <span class="number">7572</span> <span class="number">6365</span> <span class="number">4669</span> 6c65 <span class="number">0100</span> 0944</span><br><span class="line"><span class="number">656d</span> 6f2e 6a61 <span class="number">7661</span> 0c00 <span class="number">0700</span> 080c <span class="number">0005</span></span><br><span class="line"><span class="number">0006</span> <span class="number">0100</span> <span class="number">1663</span> 6f6d 2f61 <span class="number">7467</span> <span class="number">7569</span> <span class="number">6775</span></span><br><span class="line">2f6a <span class="number">6176</span> <span class="number">6131</span> 2f44 <span class="number">656d</span> 6f01 <span class="number">0010</span> 6a61</span><br><span class="line"><span class="number">7661</span> 2f6c 616e <span class="number">672f</span> 4f62 6a65 <span class="number">6374</span> <span class="number">0021</span></span><br><span class="line"><span class="number">0003</span> <span class="number">0004</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0002</span> <span class="number">0005</span> <span class="number">0006</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0002</span> <span class="number">0001</span> <span class="number">0007</span> 0008 <span class="number">0001</span> 0009 <span class="number">0000</span> 0038</span><br><span class="line"><span class="number">0002</span> <span class="number">0001</span> <span class="number">0000</span> 000a 2ab7 <span class="number">0001</span> 2a04 b500</span><br><span class="line">02b1 <span class="number">0000</span> <span class="number">0002</span> 000a <span class="number">0000</span> 000a <span class="number">0002</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0007</span> <span class="number">0004</span> 0008 000b <span class="number">0000</span> 000c <span class="number">0001</span> <span class="number">0000</span></span><br><span class="line">000a 000c <span class="number">000d</span> <span class="number">0000</span> <span class="number">0001</span> 000e <span class="number">000f</span> <span class="number">0001</span></span><br><span class="line">0009 <span class="number">0000</span> <span class="number">003d</span> <span class="number">0003</span> <span class="number">0001</span> <span class="number">0000</span> <span class="number">000f</span> 2a2a</span><br><span class="line">b400 <span class="number">0205</span> 60b5 <span class="number">0002</span> 2ab4 <span class="number">0002</span> ac00 <span class="number">0000</span></span><br><span class="line"><span class="number">0200</span> 0a00 <span class="number">0000</span> 0a00 <span class="number">0200</span> <span class="number">0000</span> <span class="number">0b00</span> 0a00</span><br><span class="line">0c00 <span class="number">0b00</span> <span class="number">0000</span> 0c00 <span class="number">0100</span> <span class="number">0000</span> 0f00 0c00</span><br><span class="line">0d00 <span class="number">0000</span> <span class="number">0100</span> <span class="number">1000</span> <span class="number">0000</span> <span class="number">0200</span> <span class="number">11</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/601902c4637689536e154818.png/lvxiaoyi" alt="601902c4637689536e154818"></p>
<h3 id="总体文件结构"><a href="#总体文件结构" class="headerlink" title="总体文件结构"></a>总体文件结构</h3><ul>
<li>魔数(magic)</li>
<li>Class文件版本(minor_version,major_version)</li>
<li>常量池(constant_pool_count)</li>
<li>访问标志(access_flags)</li>
<li>类索引，父类索引，接口索引集合(clsss/interfaces)</li>
<li>字段表集合(fields)</li>
<li>方法表集合(methods)</li>
<li>属性表集合(attribute)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210913213521629.png/lvxiaoyi" alt="image-20210913213521629"></p>
<h2 id="Class-字节码文件结构"><a href="#Class-字节码文件结构" class="headerlink" title="Class 字节码文件结构"></a>Class 字节码文件结构</h2><table>
<thead>
<tr>
<th></th>
<th>类型</th>
<th>名称</th>
<th>说明</th>
<th>长度</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>魔数</td>
<td>u4</td>
<td>magic</td>
<td>魔数,识别Class文件格式</td>
<td>4个字节</td>
<td>1</td>
</tr>
<tr>
<td>版本号</td>
<td>u2</td>
<td>minor_version</td>
<td>副版本号(小版本)</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>major_version</td>
<td>主版本号(大版本)</td>
<td>2个字节</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>常量池集合</td>
<td>u2</td>
<td>constant_pool_count</td>
<td>常量池计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>常量池表</td>
<td>n个字节</td>
<td>constant_pool_count - 1</td>
<td></td>
</tr>
<tr>
<td>访问标识</td>
<td>u2</td>
<td>access_flags</td>
<td>访问标识</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>索引集合</td>
<td>u2</td>
<td>this_class</td>
<td>类索引</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>父类索引</td>
<td>2个字节</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
<td>接口计数器</td>
<td>2个字节</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>u2</td>
<td>interfaces</td>
<td>接口索引集合</td>
<td>2个字节</td>
<td>interfaces_count</td>
<td></td>
</tr>
<tr>
<td>字段表集合</td>
<td>u2</td>
<td>fields_count</td>
<td>字段计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>字段表</td>
<td>n个字节</td>
<td>fields_count</td>
<td></td>
</tr>
<tr>
<td>方法表集合</td>
<td>u2</td>
<td>methods_count</td>
<td>方法计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods</td>
<td>方法表</td>
<td>n个字节</td>
<td>methods_count</td>
<td></td>
</tr>
<tr>
<td>属性表集合</td>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性表</td>
<td>n个字节</td>
<td>attributes_count</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Class-文件数据类型"><a href="#Class-文件数据类型" class="headerlink" title="Class 文件数据类型"></a>Class 文件数据类型</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>定义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>无符号数</td>
<td>无符号数可以用来描述数字、索引引用、数量值或按照 utf-8 编码构成的字符串值。</td>
<td>其中无符号数属于基本的数据类型。 以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节</td>
</tr>
<tr>
<td>表</td>
<td>表是由多个无符号数或其他表构成的复合数据结构。</td>
<td>所有的表都以“_info”结尾。 由于表没有固定长度，所以通常会在其前面加上个数说明。</td>
</tr>
</tbody></table>
<h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><p><strong>Magic Number（魔数）</strong></p>
<ul>
<li><p>每个 Class 文件开头的 4 个字节（<code>ca fe ba be</code>）的无符号整数称为魔数（Magic Number）</p>
<ul>
<li><p>魔数不仅仅应用于class，在每个类型的文件用二进制打开都有这样的魔数标志</p>
</li>
<li><p>例如：</p>
<ul>
<li>png</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210913212011402.png/lvxiaoyi" alt="image-20210913212011402"></p>
</li>
</ul>
</li>
<li><p>它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的 Class 文件。即：魔数是 Class 文件的标识符。</p>
</li>
<li><p>魔数值固定为 0xCAFEBABE。不会改变。</p>
</li>
<li><p>如果一个 Class 文件不以 0xCAFEBABE 开头，虚拟机在进行文件校验的时候就会直接抛出以下错误：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: A JNI error has occurred, please check your installation and try again</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassFormatError: Incompatible magic value 1885430635 in class file StringTest</span><br></pre></td></tr></table></figure>

<ul>
<li>使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。</li>
</ul>
<h2 id="文件版本号"><a href="#文件版本号" class="headerlink" title="文件版本号"></a>文件版本号</h2><p>紧接着魔数的 4 个字节存储的是 Class 文件的版本号。同样也是 4 个字节。第 5 个和第 6 个字节所代表的含义就是编译的副版本号 minor_version，而第 7 个和第 8 个字节就是编译的主版本号 major_version。</p>
<p>它们共同构成了 class 文件的格式版本号。譬如某个 Class 文件的主版本号为 M，副版本号为 m，那么这个 Class 文件的格式版本号就确定为 M.m。</p>
<p>版本号和 Java 编译器的对应关系如下表：</p>
<h3 id="Class-文件版本号对应关系"><a href="#Class-文件版本号对应关系" class="headerlink" title="Class 文件版本号对应关系"></a>Class 文件版本号对应关系</h3><table>
<thead>
<tr>
<th>主版本（十进制）</th>
<th>副版本（十进制）</th>
<th>编译器版本</th>
</tr>
</thead>
<tbody><tr>
<td>45</td>
<td>3</td>
<td>1.1</td>
</tr>
<tr>
<td>46</td>
<td>0</td>
<td>1.2</td>
</tr>
<tr>
<td>47</td>
<td>0</td>
<td>1.3</td>
</tr>
<tr>
<td>48</td>
<td>0</td>
<td>1.4</td>
</tr>
<tr>
<td>49</td>
<td>0</td>
<td>1.5</td>
</tr>
<tr>
<td>50</td>
<td>0</td>
<td>1.6</td>
</tr>
<tr>
<td>51</td>
<td>0</td>
<td>1.7</td>
</tr>
<tr>
<td><strong>52</strong></td>
<td><strong>0</strong></td>
<td><strong>1.8</strong></td>
</tr>
<tr>
<td>53</td>
<td>0</td>
<td>1.9</td>
</tr>
<tr>
<td>54</td>
<td>0</td>
<td>1.10</td>
</tr>
<tr>
<td>55</td>
<td>0</td>
<td>1.11</td>
</tr>
</tbody></table>
<p>Java 的版本号是从 45 开始的，JDK1.1 之后的每个 JDK 大版本发布主版本号向上加 1。</p>
<p>不同版本的 Java 编译器编译的 Class 文件对应的版本是不一样的。目前，高版本的 Java 虚拟机可以执行由低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行由高版本编译器生成的 Class 文件。否则 JVM 会抛出 java.lang.UnsupportedClassVersionError 异常。（向下兼容）</p>
<p>在实际应用中，由于开发环境和生产环境的不同，可能会导致该问题的发生。因此，需要我们在开发时，特别注意开发编译的 JDK 版本和生产环境中的 JDK 版本是否一致。</p>
<ul>
<li>虚拟机 JDK 版本为 1.k（k&gt;=2）时，对应的 class 文件格式版本号的范围为 45.0 - 44+k.0（含两端）。</li>
</ul>
<h2 id="常量池集合"><a href="#常量池集合" class="headerlink" title="常量池集合"></a>常量池集合</h2><p>常量池是 Class 文件中内容最为丰富的区域之一。常量池对于 Class 文件中的字段和方法解析也有着至关重要的作用。</p>
<p>随着 Java 虚拟机的不断发展，常量池的内容也日渐丰富。可以说，常量池是整个 Class 文件的基石。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210913213608155.png/lvxiaoyi" alt="image-20210913213608155"></p>
<p>在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项。</p>
<p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的无符号数，代表常量池容量计数值（constant_pool_count）。与 Java 中语言习惯不一样的是，这个容量计数是从 1 而不是 0 开始的。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>u2（无符号数）</td>
<td>constant_pool_count</td>
<td>1</td>
<td>常量池计数器</td>
</tr>
<tr>
<td>cp_info（表）</td>
<td>constant_pool</td>
<td>constant_pool_count - 1</td>
<td>常量池表</td>
</tr>
</tbody></table>
<p>由上表可见，Class 文件使用了一个前置的容量计数器（constant_pool_count）加若干个连续的数据项（constant_pool）的形式来描述常量池内容。我们把这一系列连续常量池数据称为常量池集合。</p>
<ul>
<li>常量池表项中，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放</li>
</ul>
<h3 id="常量池计数器"><a href="#常量池计数器" class="headerlink" title="常量池计数器"></a>常量池计数器</h3><p><strong>constant_pool_count（常量池计数器）</strong></p>
<ul>
<li>由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示常量池容量计数值。</li>
<li>常量池容量计数值（u2 类型）：从 1 开始，表示常量池中有多少项常量。即 constant_pool_count=1 表示常量池中有 0 个常量项。</li>
<li>Demo 的值为：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/a17ef03e0783c664a51491aafde85d2a.png/lvxiaoyi" alt="image-20210508234020104"></p>
<p>其值为 0x0016，掐指一算，也就是 22。需要注意的是，这实际上只有 21 项常量。索引为范围是 1-21。为什么呢？</p>
<p>通常我们写代码时都是从 0 开始的，但是这里的常量池却是从 1 开始，因为它把第 0 项常量空出来了。这是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“<strong>不引用任何一个常量池项目</strong>”的含义，这种情况可用索引值 0 来表示。</p>
<h3 id="常量池表"><a href="#常量池表" class="headerlink" title="常量池表"></a>常量池表</h3><p>constant_pool 是一种表结构，以 1 ~ constant_pool_count - 1 为索引。表明了后面有多少个常量项。</p>
<p>常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）</p>
<p>它包含了 class 文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第 1 个字节作为类型标记，用于确定该项的格式，这个字节称为 tag byte（标记字节、标签字节）。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志(或标识)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_Utf8_info</td>
<td>1</td>
<td>UTF-8 编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>5</td>
<td>长整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>6</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>7</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>8</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段或方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_MethodType_info</td>
<td>16</td>
<td>标志方法类型</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td>18</td>
<td>表示一个动态方法调用点</td>
</tr>
</tbody></table>
<h4 id="字面量和符号引用"><a href="#字面量和符号引用" class="headerlink" title="字面量和符号引用"></a>字面量和符号引用</h4><p>在对这些常量解读前，我们需要搞清楚几个概念。</p>
<p>常量池主要存放两大类常量：字面量（<code>Literal</code>）和符号引用（<code>Symbolic References</code>）。如下表：</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>具体的常量</th>
</tr>
</thead>
<tbody><tr>
<td>字面量</td>
<td>文本字符串</td>
</tr>
<tr>
<td></td>
<td>声明为 final 的常量值</td>
</tr>
<tr>
<td>符号引用</td>
<td>类和接口的全限定名</td>
</tr>
<tr>
<td></td>
<td>字段的名称和描述符</td>
</tr>
<tr>
<td></td>
<td>方法的名称和描述符</td>
</tr>
</tbody></table>
<p><strong>全限定名</strong></p>
<p>全类名：<code>top.lvxiaoyi.classstruct.Demo</code></p>
<p>全限定名：<code>top/lvxiaoyi/classstruct/Demo</code></p>
<p>仅仅是把包名的“.“替换成”/”，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“**;**”表示全限定名结束。</p>
<p><strong>简单名称</strong></p>
<p>简单名称是指没有类型和参数修饰的方法或者字段名称，上面例子中的类的 <code>add()</code>方法和 <code>num</code> 字段的简单名称分别是<code> add</code> 和<code>num</code>。</p>
<p><strong>描述符</strong></p>
<p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的 void 类型都用一个大写字符来表示，而对象类型则用字符 L 加对象的全限定名来表示，详见下表：</p>
<table>
<thead>
<tr>
<th>标志符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>基本数据类型 byte</td>
</tr>
<tr>
<td>C</td>
<td>基本数据类型 char</td>
</tr>
<tr>
<td>D</td>
<td>基本数据类型 double</td>
</tr>
<tr>
<td>F</td>
<td>基本数据类型 float</td>
</tr>
<tr>
<td>I</td>
<td>基本数据类型 int</td>
</tr>
<tr>
<td>J</td>
<td>基本数据类型 long</td>
</tr>
<tr>
<td>S</td>
<td>基本数据类型 short</td>
</tr>
<tr>
<td>Z</td>
<td>基本数据类型 boolean</td>
</tr>
<tr>
<td>V</td>
<td>代表 void 类型</td>
</tr>
<tr>
<td>L</td>
<td>对象类型，比如：<code>Ljava/lang/Object;</code></td>
</tr>
<tr>
<td>[</td>
<td>数组类型，代表一维数组。比如：`double[] is [D</td>
</tr>
</tbody></table>
<p>用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法<code> java.lang.String tostring()</code>的描述符为<code>()Ljava/lang/String;</code> ，方法 <code>int abc(int[]x, int y)</code>的描述符为<code>([II)I</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object[] arr = <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">        System.out.println(arr);</span><br><span class="line"></span><br><span class="line">        String[] arr1 = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">        System.out.println(arr1);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span>[][] arr2 = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">        System.out.println(arr2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hashcode只有在运行的时候才有，这个时候已经是直接引用了而不是符号引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组+对象+全限定名+分号+hashcode</span></span><br><span class="line">[Ljava.lang.Object;@4554617c</span><br><span class="line"><span class="comment">// 数组+对象+全限定名+分号+hashcode</span></span><br><span class="line">[Ljava.lang.String;@74a14482</span><br><span class="line"><span class="comment">// 二维数组+long+hashcode</span></span><br><span class="line">[[J@<span class="number">1540e19d</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>补充说明：</strong></p>
<p>​        虚拟机在加载 Class 文件时才会进行动态链接，也就是说，<strong>Class 文件中不会保存各个方法和字段的最终内存布局信息</strong>。因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当<strong>虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中。</strong></p>
<p>这里说明下符号引用和直接引用的区别与关联：</p>
<ul>
<li>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。</li>
<li>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</li>
</ul>
<h4 id="常量类型和结构"><a href="#常量类型和结构" class="headerlink" title="常量类型和结构"></a>常量类型和结构</h4><p>常量池中每一项常量都是一个表，J0K1.7 之后共有 14 种不同的表结构数据。如下表格所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/8266c05b4b1506d4c456b427b90b1b75.png/lvxiaoyi" alt="image-20210509001319088"></p>
<p>根据上图每个类型的描述我们也可以知道每个类型是用来描述常量池中哪些内容（主要是字面量、符号引用）的。比如： CONSTANT_Integer_info 是用来描述常量池中字面量信息的，而且只是整型字面量信息。</p>
<p>标志为 15、16、18 的常量项类型是用来支持动态语言调用的（jdk1.7 时才加入的）。</p>
<p><strong>细节说明：</strong></p>
<ul>
<li>CONSTANT_Class_info 结构用于表示类或接口</li>
<li>CONSTAT_Fieldref_info、CONSTAHT_Methodref_infoF 和 lCONSTANIT_InterfaceMethodref_info 结构表示字段、方汇和按口小法</li>
<li>CONSTANT_String_info 结构用于表示示 String 类型的常量对象</li>
<li>CONSTANT_Integer_info 和 CONSTANT_Float_info 表示 4 字节（int 和 float）的数值常量<ul>
<li>这里面没有byte、short、char、boolean。因为这四个都可以转化为int来表示</li>
</ul>
</li>
<li>CONSTANT_Long_info 和 CONSTAT_Double_info 结构表示 8 字作（long 和 double）的数值常量<ul>
<li>在 class 文件的常最池表中，所行的 a 字节常借均占两个表成员（项）的空问。如果一个 CONSTAHT_Long_info 和 CNSTAHT_Double_info 结构在常量池中的索引位 n，则常量池中一个可用的索引位 n+2，此时常量池长中索引为 n+1 的项仍然有效但必须视为不可用的。</li>
</ul>
</li>
<li>CONSTANT_NameAndType_info 结构用于表示字段或方法，但是和之前的 3 个结构不同，CONSTANT_NameAndType_info 结构没有指明该字段或方法所属的类或接口。</li>
<li>CONSTANT_Utf8_info 用于表示字符常量的值</li>
<li>CONSTANT_MethodHandle_info 结构用于表示方法句柄</li>
<li>CONSTANT_MethodType_info 结构表示方法类型</li>
<li>CONSTANT_InvokeDynamic_info 结构表示 invokedynamic 指令所用到的引导方法(bootstrap method)、引导方法所用到的动态调用名称(dynamic invocation name)、参数和返回类型，并可以给引导方法传入一系列称为静态参数（static argument）的常量。</li>
</ul>
<p><strong>解析方法：</strong></p>
<ul>
<li><p>一个字节一个字节的解析</p>
</li>
<li><p>使用 javap 命令解析：javap-verbose Demo.class 或 jclasslib 工具会更方便。</p>
</li>
</ul>
<p><strong>总结 1：</strong></p>
<ul>
<li>这 14 种表（或者常量项结构）的共同点是：表开始的第一位是一个 u1 类型的标志位（tag），代表当前这个常量项使用的是哪种表结构，即哪种常量类型。</li>
<li>在常量池列表中，CONSTANT_Utf8_info 常量项是一种使用改进过的 UTF-8 编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息。</li>
<li>这 14 种常量项结构还有一个特点是，其中 13 个常量项占用的字节固定，只有 CONSTANT_Utf8_info 占用字节不固定，其大小由 length 决定。为什么呢？因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定，比如你定义一个类，类名可以取长取短，所以在没编译前，大小不固定，编译后，通过 utf-8 编码，就可以知道其长度。</li>
</ul>
<p><strong>总结 2：</strong></p>
<ul>
<li>常量池：可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用 Class 文件空间最大的数据项目之一。</li>
<li>常量池中为什么要包含这些内容？Java 代码在进行 Javac 编译的时候，并不像 C 和 C++那样有“连接”这一步骤，而是在虚拟机加载 C1ass 文件的时候进行动态链接。也就是说，在 Class 文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。关于类的创建和动态链接的内容，在虚拟机类加载过程时再进行详细讲解</li>
</ul>
<h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p><strong>访问标识（access_flag、访问标志、访问标记）</strong></p>
<p>在常量池后，紧跟着访问标记。该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等。各种访问标记如下所示：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>标志为 public 类型</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>标志被声明为 final，只有类可以设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>标志允许使用 invokespecial 字节码指令的新语义，JDK1.0.2 之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标志这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为 abstract 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标志这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标志这是一个枚举</td>
</tr>
</tbody></table>
<p>类的访问权限通常为 ACC_开头的常量。</p>
<p>每一种类型的表示都是通过设置访问标记的 32 位中的特定位来实现的。比如，若是 public final 的类，则该标记为 ACC_PUBLIC | ACC_FINAL。</p>
<p>使用 ACC_SUPER 可以让类更准确地定位到父类的方法 super.method()，现代编译器都会设置并且使用这个标记。</p>
<p><strong>补充说明：</strong></p>
<ol>
<li>带有 ACC_INTERFACE 标志的 class 文件表示的是接口而不是类，反之则表示的是类而不是接口。<ul>
<li>如果一个 class 文件被设置了 ACC_INTERFACE 标志，那么同时也得设置 ACC_ABSTRACT 标志。同时它不能再设置 ACC_FINAL、ACC_SUPER 或 ACC_ENUM 标志。</li>
<li>如果没有设置 ACC_INTERFACE 标志，那么这个 class 文件可以具有上表中除 ACC_ANNOTATION 外的其他所有标志。当然，ACC_FINAL 和 ACC_ABSTRACT 这类互斥的标志除外。这两个标志不得同时设置。</li>
</ul>
</li>
<li>ACC_SUPER 标志用于确定类或接口里面的 invokespecial 指令使用的是哪一种执行语义。针对 Java 虚拟机指令集的编译器都应当设置这个标志。对于 Java SE 8 及后续版本来说，无论 class 文件中这个标志的实际值是什么，也不管 class 文件的版本号是多少，Java 虚拟机都认为每个 class 文件均设置了 ACC_SUPER 标志。<ul>
<li>ACC_SUPER 标志是为了向后兼容由旧 Java 编译器所编译的代码而设计的。目前的 ACC_SUPER 标志在由 JDK1.0.2 之前的编译器所生成的 access_flags 中是没有确定含义的，如果设置了该标志，那么 0racle 的 Java 虚拟机实现会将其忽略。</li>
</ul>
</li>
<li>ACC_SYNTHETIC 标志意味着该类或接口是由编译器生成的，而不是由源代码生成的。</li>
<li>注解类型必须设置 ACC_ANNOTATION 标志。如果设置了 ACC_ANNOTATION 标志，那么也必须设置 ACC_INTERFACE 标志。</li>
<li>ACC_ENUM 标志表明该类或其父类为枚举类型。</li>
</ol>
<h2 id="类索引、父类索引、接口索引"><a href="#类索引、父类索引、接口索引" class="headerlink" title="类索引、父类索引、接口索引"></a>类索引、父类索引、接口索引</h2><p>在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>this_class</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces[interfaces_count]</td>
</tr>
</tbody></table>
<p>这三项数据来确定这个类的继承关系：</p>
<ul>
<li>类索引用于确定这个类的全限定名</li>
<li>父类索引用于确定这个类的父类的全限定名。由于 Java 语言不允许多重继承，所以父类索引只有一个，除了 java.1ang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 e。</li>
<li>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身是一个接口，则应当是 extends 语句）后的接口顺序从左到右排列在接口索引集合中。</li>
</ul>
<h3 id="this-class（类索引）"><a href="#this-class（类索引）" class="headerlink" title="this_class（类索引）"></a>this_class（类索引）</h3><p>2 字节无符号整数，指向常量池的索引。它提供了类的全限定名，如 com/atguigu/java1/Demo。this_class 的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为 CONSTANT_Class_info 类型结构体，该结构体表示这个 class 文件所定义的类或接口。</p>
<h3 id="super-class（父类索引）"><a href="#super-class（父类索引）" class="headerlink" title="super_class（父类索引）"></a>super_class（父类索引）</h3><p>2 字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是 java/lang/object 类。同时，由于 Java 不支持多继承，所以其父类只有一个。</p>
<p>super_class 指向的父类不能是 final。</p>
<h3 id="interfaces"><a href="#interfaces" class="headerlink" title="interfaces"></a>interfaces</h3><p>指向常量池索引集合，它提供了一个符号引用到所有已实现的接口</p>
<p>由于一个类可以实现多个接口，因此需要以数组形式保存多个接口的索引，表示接口的每个索引也是一个指向常量池的 CONSTANT_Class（当然这里就必须是接口，而不是类）。</p>
<h4 id="interfaces-count（接口计数器）"><a href="#interfaces-count（接口计数器）" class="headerlink" title="interfaces_count（接口计数器）"></a>interfaces_count（接口计数器）</h4><p>interfaces_count 项的值表示当前类或接口的直接超接口数量。</p>
<h4 id="interfaces-（接口索引集合）"><a href="#interfaces-（接口索引集合）" class="headerlink" title="interfaces[]（接口索引集合）"></a>interfaces[]（接口索引集合）</h4><p><code>interfaces[]</code>中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为 <code>interfaces_count</code>。每个成员<code> interfaces[i]</code>必须为 <code>CONSTANT_Class_info</code> 结构，其中 <code>0 &lt;= i &lt; interfaces_count</code>。在 <code>interfaces[]</code>中，各成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即<code> interfaces[0]</code>对应的是源代码中最左边的接口。</p>
<h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p><strong>fields</strong></p>
<p>用于描述接口或类中声明的变量。字段（field）包括类级变量（静态变量）以及实例级变量（局部变量），但是<strong>不包括方法内部、代码块内部声明的局部变量</strong>（local varibales）。</p>
<p>字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</p>
<p>它指向常量池索引集合，它描述了每个字段的完整信息。比如字段的标识符、访问修饰符（public、private 或 protected）、是类变量还是实例变量（static 修饰符）、是否是常量（final 修饰符）等。</p>
<p><strong>注意事项：</strong></p>
<ul>
<li>字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原本 Java 代码之中不存在的字段。譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</li>
<li>在 Java 语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。</li>
</ul>
<h3 id="1-8-1-字段计数器"><a href="#1-8-1-字段计数器" class="headerlink" title="1.8.1. 字段计数器"></a>1.8.1. 字段计数器</h3><p><strong>fields_count（字段计数器）</strong></p>
<p>fields_count 的值表示当前 class 文件 fields 表的成员个数。使用两个字节来表示。</p>
<p>fields 表中每个成员都是一个 field_info 结构，用于表示该类或接口所声明的所有类字段或者实例字段，不包括方法内部声明的变量，也不包括从父类或父接口继承的那些字段。</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>字段名索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>描述符索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性集合</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<h3 id="1-8-2-字段表"><a href="#1-8-2-字段表" class="headerlink" title="1.8.2. 字段表"></a>1.8.2. 字段表</h3><h4 id="Ⅰ-字段表访问标识"><a href="#Ⅰ-字段表访问标识" class="headerlink" title="Ⅰ. 字段表访问标识"></a>Ⅰ. 字段表访问标识</h4><p>我们知道，一个字段可以被各种关键字去修饰，比如：作用域修饰符（public、private、protected）、static 修饰符、final 修饰符、volatile 修饰符等等。因此，其可像类的访问标志那样，使用一些标志来标记字段。字段的访问标志有如下这些：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>字段是否为 public</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>字段是否为 private</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>字段是否为 protected</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>字段是否为 static</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>字段是否为 final</td>
</tr>
<tr>
<td>ACC_VOLATILE</td>
<td>0x0040</td>
<td>字段是否为 volatile</td>
</tr>
<tr>
<td>ACC_TRANSTENT</td>
<td>0x0080</td>
<td>字段是否为 transient</td>
</tr>
<tr>
<td>ACC_SYNCHETIC</td>
<td>0x1000</td>
<td>字段是否为由编译器自动产生</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>字段是否为 enum</td>
</tr>
</tbody></table>
<h4 id="Ⅱ-描述符索引"><a href="#Ⅱ-描述符索引" class="headerlink" title="Ⅱ. 描述符索引"></a>Ⅱ. 描述符索引</h4><p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte，char，double，float，int，long，short，boolean）及代表无返回值的 void 类型都用一个大写字符来表示，而对象则用字符 L 加对象的全限定名来表示，如下所示：</p>
<table>
<thead>
<tr>
<th>标志符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>基本数据类型 byte</td>
</tr>
<tr>
<td>C</td>
<td>基本数据类型 char</td>
</tr>
<tr>
<td>D</td>
<td>基本数据类型 double</td>
</tr>
<tr>
<td>F</td>
<td>基本数据类型 float</td>
</tr>
<tr>
<td>I</td>
<td>基本数据类型 int</td>
</tr>
<tr>
<td>J</td>
<td>基本数据类型 long</td>
</tr>
<tr>
<td>S</td>
<td>基本数据类型 short</td>
</tr>
<tr>
<td>Z</td>
<td>基本数据类型 boolean</td>
</tr>
<tr>
<td>V</td>
<td>代表 void 类型</td>
</tr>
<tr>
<td>L</td>
<td>对象类型，比如：<code>Ljava/lang/Object;</code></td>
</tr>
<tr>
<td>[</td>
<td>数组类型，代表一维数组。比如：`double[][][] is [[[D</td>
</tr>
</tbody></table>
<h4 id="Ⅲ-属性表集合"><a href="#Ⅲ-属性表集合" class="headerlink" title="Ⅲ. 属性表集合"></a>Ⅲ. 属性表集合</h4><p>一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性个数存放在 attribute_count 中，属性具体内容存放在 attributes 数组中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以常量属性为例，结构为：</span></span><br><span class="line">ConstantValue_attribute&#123;</span><br><span class="line">	u2 attribute_name_index;</span><br><span class="line">	u4 attribute_length;</span><br><span class="line">    u2 constantvalue_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：对于常量属性而言，attribute_length 值恒为 2。</p>
<h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p>methods：指向常量池索引集合，它完整描述了每个方法的签名。</p>
<ul>
<li>在字节码文件中，每一个 method_info 项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符（public、private 或 protected），方法的返回值类型以及方法的参数信息等。</li>
<li>如果这个方法不是抽象的或者不是 native 的，那么字节码中会体现出来。</li>
<li>一方面，methods 表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods 表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息（比如：类（接口）初始化方法<code>&lt;clinit&gt;()</code>和实例初始化方法<code>&lt;init&gt;()</code>）。</li>
</ul>
<p><strong>使用注意事项：</strong></p>
<p>在 Java 语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此 Java 语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个 class 文件中。</p>
<p>也就是说，尽管 Java 语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和 Java 语法规范相反，字节码文件中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同。</p>
<h3 id="方法计数器"><a href="#方法计数器" class="headerlink" title="方法计数器"></a>方法计数器</h3><p><strong>methods_count（方法计数器）</strong></p>
<p>methods_count 的值表示当前 class 文件 methods 表的成员个数。使用两个字节来表示。</p>
<p>methods 表中每个成员都是一个 method_info 结构。</p>
<h3 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h3><p><strong>methods[]（方法表）</strong></p>
<p>methods 表中的每个成员都必须是一个 method_info 结构，用于表示当前类或接口中某个方法的完整描述。如果某个 method_info 结构的 access_flags 项既没有设置 ACC_NATIVE 标志也没有设置 ACC_ABSTRACT 标志，那么该结构中也应包含实现这个方法所用的 Java 虚拟机指令。</p>
<p>method_info 结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法</p>
<p>方法表的结构实际跟字段表是一样的，方法表结构如下：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>方法名索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>描述符索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性集合</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<p><strong>方法表访问标志</strong></p>
<p>跟字段表一样，方法表也有访问标志，而且他们的标志有部分相同，部分则不同，方法表的具体访问标志如下：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>public，方法可以从包外访问</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>private，方法只能本类访问</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>protected，方法在自身和子类可以访问</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>static，静态方法</td>
</tr>
</tbody></table>
<h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><p>方法表集合之后的属性表集合，指的是 class 文件所携带的辅助信息，比如该 class 文件的源文件的名称。以及任何带有 RetentionPolicy.CLASS 或者 RetentionPolicy.RUNTIME 的注解。这类信息通常被用于 Java 虚拟机的验证和运行，以及 Java 程序的调试，一般无须深入了解。</p>
<p>此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息。</p>
<p>属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但 Java 虚拟机运行时会忽略掉它不认识的属性。</p>
<h3 id="属性计数器"><a href="#属性计数器" class="headerlink" title="属性计数器"></a>属性计数器</h3><p><strong>attributes_count（属性计数器）</strong></p>
<p>attributes_count 的值表示当前 class 文件属性表的成员个数。属性表中每一项都是一个 attribute_info 结构。</p>
<h3 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h3><p><strong>attributes[]（属性表）</strong></p>
<p>属性表的每个项的值必须是 attribute_info 结构。属性表的结构比较灵活，各种不同的属性只要满足以下结构即可。</p>
<p><strong>属性的通用格式</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>属性名索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td>u1</td>
<td>info</td>
<td>attribute_length</td>
<td>属性表</td>
</tr>
</tbody></table>
<p><strong>属性类型</strong></p>
<p>属性表实际上可以有很多类型，上面看到的 Code 属性只是其中一种，Java8 里面定义了 23 种属性。下面这些是虚拟机中预定义的属性：</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>使用位置</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Code</td>
<td>方法表</td>
<td>Java 代码编译成的字节码指令</td>
</tr>
<tr>
<td>ConstantValue</td>
<td>字段表</td>
<td>final 关键字定义的常量池</td>
</tr>
<tr>
<td>Deprecated</td>
<td>类，方法，字段表</td>
<td>被声明为 deprecated 的方法和字段</td>
</tr>
<tr>
<td>Exceptions</td>
<td>方法表</td>
<td>方法抛出的异常</td>
</tr>
<tr>
<td>EnclosingMethod</td>
<td>类文件</td>
<td>仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td>
</tr>
<tr>
<td>InnerClass</td>
<td>类文件</td>
<td>内部类列表</td>
</tr>
<tr>
<td>LineNumberTable</td>
<td>Code 属性</td>
<td>Java 源码的行号与字节码指令的对应关系</td>
</tr>
<tr>
<td>LocalVariableTable</td>
<td>Code 属性</td>
<td>方法的局部变量描述</td>
</tr>
<tr>
<td>StackMapTable</td>
<td>Code 属性</td>
<td>JDK1.6 中新增的属性，供新的类型检查检验器和处理目标方法的局部变量和操作数有所需要的类是否匹配</td>
</tr>
<tr>
<td>Signature</td>
<td>类，方法表，字段表</td>
<td>用于支持泛型情况下的方法签名</td>
</tr>
<tr>
<td>SourceFile</td>
<td>类文件</td>
<td>记录源文件名称</td>
</tr>
<tr>
<td>SourceDebugExtension</td>
<td>类文件</td>
<td>用于存储额外的调试信息</td>
</tr>
<tr>
<td>Synthetic</td>
<td>类，方法表，字段表</td>
<td>标志方法或字段为编译器自动生成的</td>
</tr>
<tr>
<td>LocalVariableTypeTable</td>
<td>类</td>
<td>是哟很难过特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td>
</tr>
<tr>
<td>RuntimeVisibleAnnotations</td>
<td>类，方法表，字段表</td>
<td>为动态注解提供支持</td>
</tr>
<tr>
<td>RuntimeInvisibleAnnotations</td>
<td>类，方法表，字段表</td>
<td>用于指明哪些注解是运行时不可见的</td>
</tr>
<tr>
<td>RuntimeVisibleParameterAnnotation</td>
<td>方法表</td>
<td>作用与 RuntimeVisibleAnnotations 属性类似，只不过作用对象或方法</td>
</tr>
<tr>
<td>RuntimeInvisibleParameterAnnotation</td>
<td>方法表</td>
<td>作用与 RuntimeInvisibleAnnotations 属性类似，只不过作用对象或方法</td>
</tr>
<tr>
<td>AnnotationDefault</td>
<td>方法表</td>
<td>用于记录注解类元素的默认值</td>
</tr>
<tr>
<td>BootstrapMethods</td>
<td>类文件</td>
<td>用于保存 invokeddynamic 指令引用的引导方法限定符</td>
</tr>
</tbody></table>
<p>或者（查看官网）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/412a7e52bfb1ee0aa8229db1402ae58a.png/lvxiaoyi" alt="image-20210421235232911"></p>
<p><strong>部分属性详解</strong></p>
<p><strong>① ConstantValue 属性</strong></p>
<p>ConstantValue 属性表示一个常量字段的值。位于 field_info 结构的属性表中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute&#123;</span><br><span class="line">	u2 attribute_name_index;</span><br><span class="line">	u4 attribute_length;</span><br><span class="line">	u2 constantvalue_index;<span class="comment">//字段值在常量池中的索引，常量池在该索引处的项给出该属性表示的常量值。（例如，值是1ong型的，在常量池中便是CONSTANT_Long）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>② Deprecated 属性</strong></p>
<p>Deprecated 属性是在 JDK1.1 为了支持注释中的关键词@deprecated 而引入的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Deprecated_attribute&#123;</span><br><span class="line">	u2 attribute_name_index;</span><br><span class="line">	u4 attribute_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>③ Code 属性</strong></p>
<p>Code 属性就是存放方法体里面的代码。但是，并非所有方法表都有 Code 属性。像接口或者抽象方法，他们没有具体的方法体，因此也就不会有 Code 属性了。Code 属性表的结构，如下图：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>属性名索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td>u2</td>
<td>max_stack</td>
<td>1</td>
<td>操作数栈深度的最大值</td>
</tr>
<tr>
<td>u2</td>
<td>max_locals</td>
<td>1</td>
<td>局部变量表所需的存续空间</td>
</tr>
<tr>
<td>u4</td>
<td>code_length</td>
<td>1</td>
<td>字节码指令的长度</td>
</tr>
<tr>
<td>u1</td>
<td>code</td>
<td>code_lenth</td>
<td>存储字节码指令</td>
</tr>
<tr>
<td>u2</td>
<td>exception_table_length</td>
<td>1</td>
<td>异常表长度</td>
</tr>
<tr>
<td>exception_info</td>
<td>exception_table</td>
<td>exception_length</td>
<td>异常表</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
<td>属性集合计数器</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
<td>属性集合</td>
</tr>
</tbody></table>
<p>可以看到：Code 属性表的前两项跟属性表是一致的，即 Code 属性表遵循属性表的结构，后面那些则是他自定义的结构。</p>
<p><strong>④ InnerClasses 属性</strong></p>
<p>为了方便说明特别定义一个表示类或接口的 Class 格式为 C。如果 C 的常量池中包含某个 CONSTANT_Class_info 成员，且这个成员所表示的类或接口不属于任何一个包，那么 C 的 ClassFile 结构的属性表中就必须含有对应的 InnerClasses 属性。InnerClasses 属性是在 JDK1.1 中为了支持内部类和内部接口而引入的，位于 ClassFile 结构的属性表。</p>
<p><strong>⑤ LineNumberTable 属性</strong></p>
<p>LineNumberTable 属性是可选变长属性，位于 Code 结构的属性表。</p>
<p>LineNumberTable 属性是用来描述 Java 源码行号与字节码行号之间的对应关系。这个属性可以用来在调试的时候定位代码执行的行数。</p>
<ul>
<li>start_pc，即字节码行号；1ine_number，即 Java 源代码行号。</li>
</ul>
<p>在 Code 属性的属性表中，LineNumberTable 属性可以按照任意顺序出现，此外，多个 LineNumberTable 属性可以共同表示一个行号在源文件中表示的内容，即 LineNumberTable 属性不需要与源文件的行一一对应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LineNumberTable属性表结构：</span></span><br><span class="line">LineNumberTable_attribute&#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 line_number_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2 start_pc;</span><br><span class="line">        u2 line_number;</span><br><span class="line">    &#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>⑥ LocalVariableTable 属性</strong></p>
<p>LocalVariableTable 是可选变长属性，位于 Code 属性的属性表中。它被调试器用于确定方法在执行过程中局部变量的信息。在 Code 属性的属性表中，LocalVariableTable 属性可以按照任意顺序出现。Code 属性中的每个局部变量最多只能有一个 LocalVariableTable 属性。</p>
<ul>
<li>start pc + length 表示这个变量在字节码中的生命周期起始和结束的偏移位置（this 生命周期从头 e 到结尾 10）</li>
<li>index 就是这个变量在局部变量表中的槽位（槽位可复用）</li>
<li>name 就是变量名</li>
<li>Descriptor 表示局部变量类型描述</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LocalVariableTable属性表结构：</span></span><br><span class="line">LocalVariableTable_attribute&#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 local_variable_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2 start_pc;</span><br><span class="line">        u2 length;</span><br><span class="line">        u2 name_index;</span><br><span class="line">        u2 descriptor_index;</span><br><span class="line">        u2 index;</span><br><span class="line">    &#125; local_variable_table[local_variable_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>⑦ Signature 属性</strong></p>
<p>Signature 属性是可选的定长属性，位于 ClassFile，field_info 或 method_info 结构的属性表中。在 Java 语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则 Signature 属性会为它记录泛型签名信息。</p>
<p><strong>⑧ SourceFile 属性</strong></p>
<p>SourceFile 属性结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>属性名索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td>u2</td>
<td>sourcefile index</td>
<td>1</td>
<td>源码文件索引（能找到文件名）</td>
</tr>
</tbody></table>
<p>可以看到，其长度总是固定的 8 个字节。</p>
<p><strong>⑨ 其他属性</strong></p>
<p>Java 虚拟机中预定义的属性有 20 多个，这里就不一一介绍了，通过上面几个属性的介绍，只要领会其精髓，其他属性的解读也是易如反掌。</p>
<h2 id="javap指令解析Class文件"><a href="#javap指令解析Class文件" class="headerlink" title="javap指令解析Class文件"></a>javap指令解析Class文件</h2><h3 id="解析字节码作用"><a href="#解析字节码作用" class="headerlink" title="解析字节码作用"></a>解析字节码作用</h3><p>通过反编译生成的字节码文件，我们可以深入的了解java代码的工作机制。但是，自己分析类文件结构太麻烦了!除了使用第三方的jclasslib工具之外，oracle官方也提供了工具： javap。</p>
<p>javap是jdk自带的反解析工具。它的作用就是根据class字节码文件，反解析出当前类对应的code区(字节码指令)、局部变量表、异常表和代码行偏移量映射表、常量池等信息。</p>
<p>通过局部变量表，我们可以查看局部变量的作用域范围、所在槽位等信息，甚至可以看到槽位复用等信息。</p>
<h3 id="javac-g-操作"><a href="#javac-g-操作" class="headerlink" title="javac -g 操作"></a>javac -g 操作</h3><p>解析字节码文件得到的信息中，有些信息（如局部变量表、指令和代码行偏移量映射表、常量池中方法的参数名称等等）需要在使用javac编译成class文件时，指定参数才能输出。</p>
<p>比如，你直接javac xx.java，就不会在生成对应的局部变量表等信息，如果你使用javac -g xx.java就可以生成所有相关信息了。如果你使用的eclipse或IDEA，则默认情况下，eclipse、IDEA在编译时会帮你生成局部变量表、指令和代码行偏移量映射表等信息的。</p>
<h3 id="javap的用法"><a href="#javap的用法" class="headerlink" title="javap的用法"></a>javap的用法</h3><p>javap的用法格式：</p>
<p><code>javap &lt;options&gt; &lt;classes&gt;</code></p>
<p>其中，classes就是你要反编译的class文件。</p>
<p>在命令行中直接输入javap或javap -help可以看到javap的options有如下选项：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210914175009520.png/lvxiaoyi" alt="image-20210914175009520"></p>
<p>重组后：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>-help –help -?</td>
<td>输出此用法消息</td>
</tr>
<tr>
<td>-version</td>
<td>版本信息，其实是当前javap所在jdk的版本信息，不是class在哪个jdk下生成的。</td>
</tr>
<tr>
<td>-public</td>
<td>仅显示公共类和成员</td>
</tr>
<tr>
<td>-protected</td>
<td>显示受保护的/公共类和成员</td>
</tr>
<tr>
<td>-p -private</td>
<td>显示所有类和成员</td>
</tr>
<tr>
<td>-package</td>
<td>显示程序包/受保扩的/公共类和成员（默认)</td>
</tr>
<tr>
<td>-sysinfo</td>
<td>显示正在处理的类的系统信息(路径，大小，日期,，MD5散列,源文件名)</td>
</tr>
<tr>
<td>-constants</td>
<td>显示静态最终常量</td>
</tr>
<tr>
<td>-s</td>
<td>输出内部类型签名</td>
</tr>
<tr>
<td>-l</td>
<td>输出行号和本地变量表</td>
</tr>
<tr>
<td>-c</td>
<td>对代码进行反江编</td>
</tr>
<tr>
<td>-v  -verbose</td>
<td>输出附加信息(包括行号、本地变吊表，反汇编等详细信息)</td>
</tr>
<tr>
<td>-classpath <code>&lt;path&gt;</code></td>
<td>指定查找用户类文件的位置</td>
</tr>
<tr>
<td>-cp <code>&lt;path&gt;</code></td>
<td>指定查找用户类文件的位置</td>
</tr>
<tr>
<td>-bootclasspath <code>&lt;path&gt;</code></td>
<td>覆盖引导类文件的位置</td>
</tr>
</tbody></table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/20210305121851799.png/lvxiaoyi" alt="在这里插入图片描述"></p>
<p>一般常用的是-v -l -c三个选项。</p>
<p>javap -l会输出行号和本地变量表信息。</p>
<p>javap -c会对当前class字节码进行反编译生成汇编代码。</p>
<p>javap -v classxx除了包含-c内容外，还会输出行号、局部变量表信息、常量池等信息。</p>
<p>注意：</p>
<p>①-v相当于-c -l</p>
<p>②-v也不会输出私有的字段、方法等信息，所以如果想输出私有的信息，那需要在-v后面加上-p才行</p>
<h3 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavapTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="keyword">public</span> String info;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNTS = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        String url = <span class="string">&quot;https://lvxiaoyi.top/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        info = <span class="string">&quot;java&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavapTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JavapTest</span><span class="params">(<span class="keyword">boolean</span> falg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num + i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">char</span> <span class="title">showGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">        System.out.println(info + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cmd命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v -p JavaTest.class&gt;javaptest.txt</span><br></pre></td></tr></table></figure>



<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>查看javaptest.txt文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字节码文件所属的路径</span></span><br><span class="line">Classfile /D:/interview/jvm/target/classes/top/lvxiaoyi/classstruct/JavapTest.class</span><br><span class="line"><span class="comment">// 最后修改时间，字节码文件的大小</span></span><br><span class="line">  Last modified <span class="number">2021</span>-<span class="number">9</span>-<span class="number">14</span>; size <span class="number">1388</span> bytes</span><br><span class="line"><span class="comment">// MD5散列值</span></span><br><span class="line">  MD5 checksum ff5063fc3ef67a8d2714a639d2fc4c50</span><br><span class="line">  Compiled from <span class="string">&quot;JavapTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">top</span>.<span class="title">lvxiaoyi</span>.<span class="title">classstruct</span>.<span class="title">JavapTest</span></span></span><br><span class="line"><span class="class">// 副版本</span></span><br><span class="line"><span class="class">  <span class="title">minor</span> <span class="title">version</span>: 0</span></span><br><span class="line"><span class="class">  // 主版本 <span class="title">JDK1</span>.8用52表示，副班本只有<span class="title">JDK1</span>.1的时候有数字</span></span><br><span class="line"><span class="class">  <span class="title">major</span> <span class="title">version</span>: 52</span></span><br><span class="line"><span class="class">  // 访问标识 公共和<span class="title">super</span></span></span><br><span class="line"><span class="class">  // <span class="title">super</span>在<span class="title">javaSE8</span> 后，默认为每个<span class="title">Class</span>文件都添加这个标识，为了向后兼容</span></span><br><span class="line"><span class="class">  <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_SUPER</span></span></span><br><span class="line"><span class="class"> // *************************** 常量池********************************</span></span><br><span class="line"><span class="class"><span class="title">Constant</span> <span class="title">pool</span>:</span></span><br><span class="line"><span class="class">   #1 </span>= Methodref          #<span class="number">16.</span>#<span class="number">47</span>        <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = String             #<span class="number">48</span>            <span class="comment">// java</span></span><br><span class="line">   #<span class="number">3</span> = Fieldref           #<span class="number">15.</span>#<span class="number">49</span>        <span class="comment">// top/lvxiaoyi/classstruct/JavapTest.info:Ljava/lang/String;</span></span><br><span class="line">   #<span class="number">4</span> = Fieldref           #<span class="number">15.</span>#<span class="number">50</span>        <span class="comment">// top/lvxiaoyi/classstruct/JavapTest.flag:Z</span></span><br><span class="line">   #<span class="number">5</span> = Fieldref           #<span class="number">15.</span>#<span class="number">51</span>        <span class="comment">// top/lvxiaoyi/classstruct/JavapTest.num:I</span></span><br><span class="line">   #<span class="number">6</span> = Fieldref           #<span class="number">15.</span>#<span class="number">52</span>        <span class="comment">// top/lvxiaoyi/classstruct/JavapTest.gender:C</span></span><br><span class="line">   #<span class="number">7</span> = Fieldref           #<span class="number">53.</span>#<span class="number">54</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">8</span> = Class              #<span class="number">55</span>            <span class="comment">// java/lang/StringBuilder</span></span><br><span class="line">   #<span class="number">9</span> = Methodref          #<span class="number">8.</span>#<span class="number">47</span>         <span class="comment">// java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">10</span> = Methodref          #<span class="number">8.</span>#<span class="number">56</span>         <span class="comment">// java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">11</span> = Methodref          #<span class="number">8.</span>#<span class="number">57</span>         <span class="comment">// java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">12</span> = Methodref          #<span class="number">8.</span>#<span class="number">58</span>         <span class="comment">// java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">13</span> = Methodref          #<span class="number">59.</span>#<span class="number">60</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">14</span> = String             #<span class="number">61</span>            <span class="comment">// https://lvxiaoyi.top/</span></span><br><span class="line">  #<span class="number">15</span> = Class              #<span class="number">62</span>            <span class="comment">// top/lvxiaoyi/classstruct/JavapTest</span></span><br><span class="line">  #<span class="number">16</span> = Class              #<span class="number">63</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">17</span> = Utf8               num</span><br><span class="line">  #<span class="number">18</span> = Utf8               I</span><br><span class="line">  #<span class="number">19</span> = Utf8               flag</span><br><span class="line">  #<span class="number">20</span> = Utf8               Z</span><br><span class="line">  #<span class="number">21</span> = Utf8               gender</span><br><span class="line">  #<span class="number">22</span> = Utf8               C</span><br><span class="line">  #<span class="number">23</span> = Utf8               info</span><br><span class="line">  #<span class="number">24</span> = Utf8               Ljava/lang/String;</span><br><span class="line">  #<span class="number">25</span> = Utf8               COUNTS</span><br><span class="line">  #<span class="number">26</span> = Utf8               ConstantValue</span><br><span class="line">  #<span class="number">27</span> = Integer            <span class="number">1</span></span><br><span class="line">  #<span class="number">28</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">29</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">30</span> = Utf8               Code</span><br><span class="line">  #<span class="number">31</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">32</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">33</span> = Utf8               <span class="keyword">this</span></span><br><span class="line">  #<span class="number">34</span> = Utf8               Ltop/lvxiaoyi/classstruct/JavapTest;</span><br><span class="line">  #<span class="number">35</span> = Utf8               (Z)V</span><br><span class="line">  #<span class="number">36</span> = Utf8               falg</span><br><span class="line">  #<span class="number">37</span> = Utf8               methodPrivate</span><br><span class="line">  #<span class="number">38</span> = Utf8               getNum</span><br><span class="line">  #<span class="number">39</span> = Utf8               (I)I</span><br><span class="line">  #<span class="number">40</span> = Utf8               i</span><br><span class="line">  #<span class="number">41</span> = Utf8               showGender</span><br><span class="line">  #<span class="number">42</span> = Utf8               ()C</span><br><span class="line">  #<span class="number">43</span> = Utf8               showInfo</span><br><span class="line">  #<span class="number">44</span> = Utf8               &lt;clinit&gt;</span><br><span class="line">  #<span class="number">45</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">46</span> = Utf8               JavapTest.java</span><br><span class="line">  #<span class="number">47</span> = NameAndType        #<span class="number">28</span>:#<span class="number">29</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">48</span> = Utf8               java</span><br><span class="line">  #<span class="number">49</span> = NameAndType        #<span class="number">23</span>:#<span class="number">24</span>        <span class="comment">// info:Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">50</span> = NameAndType        #<span class="number">19</span>:#<span class="number">20</span>        <span class="comment">// flag:Z</span></span><br><span class="line">  #<span class="number">51</span> = NameAndType        #<span class="number">17</span>:#<span class="number">18</span>        <span class="comment">// num:I</span></span><br><span class="line">  #<span class="number">52</span> = NameAndType        #<span class="number">21</span>:#<span class="number">22</span>        <span class="comment">// gender:C</span></span><br><span class="line">  #<span class="number">53</span> = Class              #<span class="number">64</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">54</span> = NameAndType        #<span class="number">65</span>:#<span class="number">66</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">55</span> = Utf8               java/lang/StringBuilder</span><br><span class="line">  #<span class="number">56</span> = NameAndType        #<span class="number">67</span>:#<span class="number">68</span>        <span class="comment">// append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">57</span> = NameAndType        #<span class="number">67</span>:#<span class="number">69</span>        <span class="comment">// append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">58</span> = NameAndType        #<span class="number">70</span>:#<span class="number">71</span>        <span class="comment">// toString:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">59</span> = Class              #<span class="number">72</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">60</span> = NameAndType        #<span class="number">73</span>:#<span class="number">74</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">61</span> = Utf8               https:<span class="comment">//lvxiaoyi.top/</span></span><br><span class="line">  #<span class="number">62</span> = Utf8               top/lvxiaoyi/classstruct/JavapTest</span><br><span class="line">  #<span class="number">63</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">64</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">65</span> = Utf8               out</span><br><span class="line">  #<span class="number">66</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">67</span> = Utf8               append</span><br><span class="line">  #<span class="number">68</span> = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #<span class="number">69</span> = Utf8               (I)Ljava/lang/StringBuilder;</span><br><span class="line">  #<span class="number">70</span> = Utf8               toString</span><br><span class="line">  #<span class="number">71</span> = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #<span class="number">72</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">73</span> = Utf8               println</span><br><span class="line">  #<span class="number">74</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  <span class="comment">//******************************字段表集合的信息**************************************</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 字段名</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">   <span class="comment">// 字段表集合的信息,I 表示int</span></span><br><span class="line">    descriptor: I</span><br><span class="line">	<span class="comment">// 字段的访问标识 ACC_PRIVATE表示为私有</span></span><br><span class="line">    flags: ACC_PRIVATE</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> flag;</span><br><span class="line">    descriptor: Z</span><br><span class="line">    flags:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">char</span> gender;</span><br><span class="line">    descriptor: C</span><br><span class="line">    flags: ACC_PROTECTED</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.String info;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNTS;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line"><span class="comment">// 常量字段的属性：ConstantValue</span></span><br><span class="line">    ConstantValue: <span class="keyword">int</span> <span class="number">1</span></span><br><span class="line"><span class="comment">//******************************方法表集合的信息**************************************</span></span><br><span class="line"><span class="comment">// 无参构造器方法信息</span></span><br><span class="line">  <span class="keyword">public</span> top.lvxiaoyi.classstruct.JavapTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String java</span></span><br><span class="line">         <span class="number">7</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field info:Ljava/lang/String;</span></span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">19</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">10</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ltop/lvxiaoyi/classstruct/JavapTest;</span><br><span class="line"><span class="comment">// 单个参数构造器方法信息</span></span><br><span class="line">  <span class="keyword">private</span> top.lvxiaoyi.classstruct.JavapTest(<span class="keyword">boolean</span>);</span><br><span class="line">    descriptor: (Z)V</span><br><span class="line">    flags: ACC_PRIVATE</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String java</span></span><br><span class="line">         <span class="number">7</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field info:Ljava/lang/String;</span></span><br><span class="line">        <span class="number">10</span>: aload_0</span><br><span class="line">        <span class="number">11</span>: aload_0</span><br><span class="line">        <span class="number">12</span>: getfield      #<span class="number">4</span>                  <span class="comment">// Field flag:Z</span></span><br><span class="line">        <span class="number">15</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field flag:Z</span></span><br><span class="line">        <span class="number">18</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">23</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">24</span>: <span class="number">10</span></span><br><span class="line">        line <span class="number">25</span>: <span class="number">18</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">19</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ltop/lvxiaoyi/classstruct/JavapTest;</span><br><span class="line">            <span class="number">0</span>      <span class="number">19</span>     <span class="number">1</span>  <span class="function">falg   Z</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PRIVATE</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">29</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ltop/lvxiaoyi/classstruct/JavapTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    descriptor: (I)I</span><br><span class="line">    flags:</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: getfield      #<span class="number">5</span>                  <span class="comment">// Field num:I</span></span><br><span class="line">         <span class="number">4</span>: iload_1</span><br><span class="line">         <span class="number">5</span>: iadd</span><br><span class="line">         <span class="number">6</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">32</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ltop/lvxiaoyi/classstruct/JavapTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">1</span>     <span class="function">i   I</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">protected</span> <span class="keyword">char</span> <span class="title">showGender</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()C</span><br><span class="line">    flags: ACC_PROTECTED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: getfield      #<span class="number">6</span>                  <span class="comment">// Field gender:C</span></span><br><span class="line">         <span class="number">4</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">36</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ltop/lvxiaoyi/classstruct/JavapTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 方法的描述符：方法的形参列表、返回值类型（空参和void返回值）</span></span><br><span class="line">    descriptor: ()V</span><br><span class="line"><span class="comment">// 方法的访问标识（public）</span></span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"><span class="comment">// 方法的Code属性</span></span><br><span class="line">    Code:</span><br><span class="line"><span class="comment">// stack：操作数栈的最大深度   locals：局部变量表的长度   args_size：方法接受参数的个数</span></span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line"> <span class="comment">// 偏移量   操作码     操作数</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">100</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="number">3</span>: getstatic     #<span class="number">7</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">6</span>: <span class="keyword">new</span>           #<span class="number">8</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        <span class="number">10</span>: invokespecial #<span class="number">9</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">13</span>: aload_0</span><br><span class="line">        <span class="number">14</span>: getfield      #<span class="number">3</span>                  <span class="comment">// Field info:Ljava/lang/String;</span></span><br><span class="line">        <span class="number">17</span>: invokevirtual #<span class="number">10</span>                 <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">20</span>: iload_1</span><br><span class="line">        <span class="number">21</span>: invokevirtual #<span class="number">11</span>                 <span class="comment">// Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">24</span>: invokevirtual #<span class="number">12</span>                 <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">        <span class="number">27</span>: invokevirtual #<span class="number">13</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">30</span>: <span class="keyword">return</span></span><br><span class="line"><span class="comment">// 行号表：指明字节码指令的偏移量与java源代码中代码的行号的一一对应关系</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">40</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">41</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">42</span>: <span class="number">30</span></span><br><span class="line"> <span class="comment">// 局部变量表：描述内部局部变量的相关信息</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">31</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ltop/lvxiaoyi/classstruct/JavapTest;</span><br><span class="line">            <span class="number">3</span>      <span class="number">28</span>     <span class="number">1</span>     i   I</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">14</span>                 <span class="comment">// String https://lvxiaoyi.top/</span></span><br><span class="line">         <span class="number">2</span>: astore_0</span><br><span class="line">         <span class="number">3</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">3</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 附加属性：指明当前字节码文件对应的源程序文件名</span></span><br><span class="line">SourceFile: <span class="string">&quot;JavapTest.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Jclasslib分析"><a href="#Jclasslib分析" class="headerlink" title="Jclasslib分析"></a>Jclasslib分析</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210914182038375.png/lvxiaoyi" alt="image-20210914182038375"></p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1、通过javap命令可以查看一个java类反汇编得到的Class文件版本号、常量池、访问标识、变量表指令代码行号表等信息。不显示类索引、父类索引、接口索引集合、<code>&lt;clinit&gt;()</code>、<code>&lt;init&gt;()</code>等结构</p>
<p>2、通过对前面例子代码反汇编文件的简单分析，可以发现，一个方法的执行通常会涉及下面几块内存的操作：</p>
<p>(1) java栈中：局部变量表、操作数栈。</p>
<p>(2) java堆。通过对象的地址引用去操作。</p>
<p>(3）常量池。</p>
<p>(4）其他如帧数据区、方法区的剩余部分等情况，测试中没有显示出来，这里说明一下。</p>
<p>3、平常，我们比较关注的是java类中每个方法的反汇编中的指令操作过程，这些指令都是顺序执行的可以参考官方文档查看每个指令的含义，很简单：</p>
<p>官方文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html</a></p>
<h1 id="字节码指令集"><a href="#字节码指令集" class="headerlink" title="字节码指令集"></a>字节码指令集</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>​        Java字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行命令</p>
<p>​        Java虚拟机的<code>指令</code>由一个字节长度的，代表着某种特定操作含义的数字（称为操作码：<code>Opcode</code>）以及跟随其后的零至多个代表此操作所需参数（称为操作数：<code>Operands</code>）构成</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>操作码</th>
<th>操作数</th>
</tr>
</thead>
<tbody><tr>
<td>aload_0</td>
<td>aload_0</td>
<td>无</td>
</tr>
<tr>
<td>invokespecial #1</td>
<td>invokespecial</td>
<td>#1 （符号引用地址）</td>
</tr>
</tbody></table>
<p>​        由于Java虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码由于限制了Java虚拟机操作码的长度为一个字节（即0 ~ 255），这意味着指令集的操作码总数不可能超过256条 。</p>
<p>官方文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html</a></p>
<p>​        熟悉虚拟机的指令对于动态字节码生成、反编译Class文件、Class文件修补都有着非常重要的价值。因此，阅读字节码作为了解Java虚拟机的基础技能，需要熟练掌握常见指令。</p>
<h3 id="执行模型"><a href="#执行模型" class="headerlink" title="执行模型"></a>执行模型</h3><p>如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    自动计算PC寄存器的值加<span class="number">1</span>;</span><br><span class="line">    根据PC寄存器的指示位置，从字节码流中取出操作码;</span><br><span class="line">    <span class="keyword">if</span> (字节码存在操作数)</span><br><span class="line">        从字节码流中取出操作数;</span><br><span class="line">        执行操作码所定义的操作;</span><br><span class="line">&#125; <span class="keyword">while</span> (字节码长度 &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<h3 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h3><p>在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息</p>
<p>例如，iload指令用于从局部变量表中加载int类型的数据到操作数栈中，而fload指令加载的则是float类型的数据</p>
<p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务</p>
<ul>
<li><code>i </code>代表对int类型的数据操作</li>
<li><code>l</code> 代表long</li>
<li><code>s</code> 代表short</li>
<li><code>b</code> 代表byte</li>
<li><code>c</code> 代表char</li>
<li><code>f</code> 代表float</li>
<li><code>d</code> 代表double</li>
</ul>
<p>也有一些指令的助记符中没有明确地指明操作类型的字母，如arraylength指令，它没有代表数据类型的特殊字符，住操作数永远只能是一个数组类型的对象。</p>
<p>还有一些指令，比如无条件跳转指令goto则是与数据类型无关</p>
<h3 id="指令的分类"><a href="#指令的分类" class="headerlink" title="指令的分类"></a>指令的分类</h3><p>大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展(Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展(Zero-Extend)为相应的int类型数据。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型。</p>
<p>由于完全介绍和学习这些指令需要花费大量时间。为了让大家能够更快地熟悉和了解这些基本指令，这里将JVM中的字节码指令集按用途大致分成9类。</p>
<ul>
<li><p>加载与存储指令</p>
<ul>
<li>加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递</li>
</ul>
</li>
<li><p>算术指令</p>
<ul>
<li>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈</li>
</ul>
</li>
<li><p>类型转换指令</p>
<ul>
<li>将两种不同的数值类型进行相互转换</li>
</ul>
</li>
<li><p>对象的创建与访问指令</p>
<ul>
<li>创建对象、访问字段、数组操作和类型检查</li>
</ul>
</li>
<li><p>方法调用与返回指令</p>
<ul>
<li>进行方法调用，结束方法以及放回相应的值</li>
</ul>
</li>
<li><p>操作数栈管理指令</p>
<ul>
<li>用于操作操作数栈</li>
</ul>
</li>
<li><p>比较控制指令</p>
<ul>
<li>进行流程控制例如if、if…else、if…else if…else、switch、for、while等</li>
</ul>
</li>
<li><p>异常处理指令</p>
<ul>
<li>例如对于throw等关键字的处理</li>
</ul>
</li>
<li><p>同步控制指令</p>
<ul>
<li>使用了synchronized关键字的处理</li>
</ul>
</li>
<li><p>(说在前面)在做值相关操作时：</p>
<ul>
<li>一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据（可能是值，可能是对象的引用）被压入操作数栈。</li>
<li>一个指令，也可以从操作数栈中取出一到多个值(pop多次），完成赋值、加减乘除、方法传参、系统调用等等操作。  </li>
</ul>
</li>
</ul>
<h2 id="加载与存储指令"><a href="#加载与存储指令" class="headerlink" title="加载与存储指令"></a>加载与存储指令</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递。</p>
<h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><ol>
<li><p>【局部变量压栈指令】将一个局部变量加载到操作数栈：</p>
<p><code>xload</code>、<code>xload_&lt;n&gt;</code>（其中x为i、l、f、d、a，n为0到3)</p>
</li>
<li><p>【常量入栈指令】将一个常量加载到操作数栈：</p>
<p> <strong>bipush</strong>、sipush、<strong>ldc</strong>、ldc_w、ldc2_w、aconst_null、iconst_m1、<code>iconst_&lt;i&gt;</code>、<code>lconst_&lt;1&gt;</code>、<code>fconst_&lt;f&gt;</code>、<code>dconst_&lt;d&gt;</code></p>
</li>
<li><p>【出栈装入局部变量表指令】将一个数值从操作数栈存储到局部变量表：</p>
<p><code> xstore</code>、<code>xstore_&lt;n&gt;</code>(其叶x为i、l、f、d、a，n为0到3) ; xastore（其中x为i、l、f、d、a、b、c、s)</p>
</li>
<li><p>扩充局部变量表的访问索引的指令：</p>
<p> wide</p>
</li>
</ol>
<p>上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如<code>iload_&lt;n&gt;</code>)。这些指令助记符实际上代表了一组指令(例如 <code>iload_&lt;n&gt;</code>代表了<code>iload_0</code>、<code>iload_1</code>、<code>iload_2</code>和<code>iload_3</code>这几个指令)。这几组指令都是某个带有一个操作数的通用指令（例如 iload）的特殊形式，<strong>对于这若干组特殊指令来说，它们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中。</strong></p>
<h5 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h5><p><code>iload_0</code>：将局部变量表中索引为0位置上的数据压入操作数栈中。是jvm提供好的操作码，但是只有<code>iload_0</code>、<code>iload_1</code>、<code>iload_2</code>和<code>iload_3</code>这几个指令，因为指令一共就256个，不能无限使用</p>
<p><code>iload 0</code>：与<code>iload_0</code>表达同样的含义，但是<code>iload_0</code>更节省空间因为这只是一个操作码；<code>iload 0</code>是操作码+操作数。</p>
<p>除此之外，它们的语义与原生的通用指令完全一致（例如 iload_0的语义与操作数为0时的 iload 指令语义完全一致)。在尖括号之间的字母指定了指令隐含操作数的数据类型，<code>&lt;n&gt;</code>代表非负的整数，<code>&lt;i&gt;</code>代表是int类型数据，<code>&lt;l&gt;</code>代表long类型，<code>&lt;f&gt;</code>代表float类型，<code>&lt;d&gt;</code>代表double类型。</p>
<p>操作byte、char、short和boolean类型数据时，经常用int类型的指令来表示。</p>
<h3 id="复习：操作数栈与局部变量表"><a href="#复习：操作数栈与局部变量表" class="headerlink" title="复习：操作数栈与局部变量表"></a>复习：操作数栈与局部变量表</h3><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>我们知道，Java字节码是Java虚拟机所使用的指令集。因此，它与Java虚拟机基于栈的计算模型是密不可分的。</p>
<p>在解释执行过程中，每当为Java方法分配栈桢时，Java虚拟机往往需要开辟一块额外的空间作为操作数栈，来存放计算的操作数以及返回结果。</p>
<p>具体来说便是：<strong>执行每一条指令之前，Java虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时Java虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中</strong>。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">c  = a + b;</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210914144515697.png/lvxiaoyi" alt="image-20210914144515697" style="zoom:50%;" />

<p>以加法指令<code>iadd</code>为例。假设在执行该指令前，栈顶的两个元素分别为int值1和 int值2，那么 iadd指令将弹出这两个int，并将求得的和int值3压入栈中。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210914144528308.png/lvxiaoyi" alt="image-20210914144528308" style="zoom:50%;" />

<p>由于 iadd 指令只消耗栈顶的两个元素，因此，对于离栈顶距离为2的元素，即图中的问号，iadd 指令并不关心它是否存在，更加不会对其进行修改。</p>
<h4 id="局部变量表（Local-Variables）"><a href="#局部变量表（Local-Variables）" class="headerlink" title="局部变量表（Local Variables）"></a>局部变量表（Local Variables）</h4><p>Java方法栈桢的另外一个重要组成部分则是局部变量区，<strong>字节码程序可以将计算的结果缓存在局部变量区之中</strong>。</p>
<p>实际上，Java虚拟机将局部变量区<strong>当成一个数组</strong>，依次存放 this 指针（仅非静态方法），所传入的参数，以及字节码中的局部变量。</p>
<p>和操作数栈一样，long类型以及 double类型的值将占据两个单元，其余类型仅占据一个单元。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210915100050782.png/lvxiaoyi" alt="image-20210915100050782" style="zoom:50%;" />

<p>一个solt占据四个字节，而long和double都是占据两个solt</p>
<p>对应举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">long</span> l, <span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        String s = <span class="string">&quot;hello, lvxiaoyi&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210914144613329.png/lvxiaoyi" alt="image-20210914144613329" style="zoom:50%;" />

<h5 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h5><p>this肯定是需要占据一个solt，因为这个方法是非静态的</p>
<p>long 型的参数l占据两个solt</p>
<p>float型的参数f占据一个solt</p>
<p>i/s这两个变量占据一个solt</p>
<p>​    <code>i/s</code>共同占据一个槽位是因为槽位的复用，首先i占据了占个index为4的solt，然后出了大括号就是出了作用于，然后被回收了，s再次占据index为4的solt</p>
<p>在栈帧中，与<strong>性能调优关系最为密切的部分就是局部变量表</strong>。局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p>
<p>在方法执行时,虚拟机使用局部变量表完成方法的传递。</p>
<h3 id="局部变量压栈指令"><a href="#局部变量压栈指令" class="headerlink" title="局部变量压栈指令"></a>局部变量压栈指令</h3><h4 id="局部变量压栈指令-1"><a href="#局部变量压栈指令-1" class="headerlink" title="局部变量压栈指令"></a>局部变量压栈指令</h4><p>局部变量压栈指令将给定的局部变量表中的数据压入操作数栈。</p>
<p>这类指令大体可以分为：</p>
<p>​    <code>xload_&lt;n&gt;(x为i、1、f、d、a，n为0到3)</code></p>
<p>​    <code>&gt; xload (x为i、1、f、d、a)</code></p>
<p>说明：在这里，x的取值表示数据类型。</p>
<p>指令xload_n表示将第n个局部变量压入操作数栈，比如iload_1、fload_0、aload_0等指令。其中aload_n表示将个对象引用压栈。</p>
<p>指令xload通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了4个，比如指令iload、fload等。</p>
<p>举例分析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(<span class="keyword">int</span> num, Object obj, <span class="keyword">long</span> count, <span class="keyword">boolean</span> flag, <span class="keyword">short</span>[] arr)</span> </span>&#123;</span><br><span class="line">	System.out.println(num);</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">    System.out.println(flag);</span><br><span class="line">    System.out.println(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/deb49e69ed62ed9d71c7059748299b59.png/lvxiaoyi" alt="3"></p>
<h4 id="局部变量压栈常用指令集"><a href="#局部变量压栈常用指令集" class="headerlink" title="局部变量压栈常用指令集"></a>局部变量压栈常用指令集</h4><blockquote>
<p>iload 从局部变量中装载int类型值</p>
<p>lload 从局部变量中装载long类型值</p>
<p>fload 从局部变量中装载float类型值</p>
<p>dload 从局部变量中装载double类型值</p>
<p>aload 从局部变量中装载引用类型值（refernce）</p>
<p>iload_0 从局部变量0中装载int类型值</p>
<p>iload_1 从局部变量1中装载int类型值</p>
<p>iload_2 从局部变量2中装载int类型值</p>
<p>iload_3 从局部变量3中装载int类型值</p>
<p>lload_0 从局部变量0中装载long类型值</p>
<p>lload_1 从局部变量1中装载long类型值</p>
<p>lload_2 从局部变量2中装载long类型值</p>
<p>lload_3 从局部变量3中装载long类型值</p>
<p>fload_0 从局部变量0中装载float类型值</p>
<p>fload_1 从局部变量1中装载float类型值</p>
<p>fload_2 从局部变量2中装载float类型值</p>
<p>fload_3 从局部变量3中装载float类型值</p>
<p>dload_0 从局部变量0中装载double类型值</p>
<p>dload_1 从局部变量1中装载double类型值</p>
<p>dload_2 从局部变量2中装载double类型值</p>
<p>dload_3 从局部变量3中装载double类型值</p>
<p>aload_0 从局部变量0中装载引用类型值</p>
<p>aload_1 从局部变量1中装载引用类型值</p>
<p>aload_2 从局部变量2中装载引用类型值</p>
<p>aload_3 从局部变量3中装载引用类型值</p>
<p>iaload 从数组中装载int类型值</p>
<p>laload 从数组中装载long类型值</p>
<p>faload 从数组中装载float类型值</p>
<p>daload 从数组中装载double类型值</p>
<p>aaload 从数组中装载引用类型值</p>
<p>baload 从数组中装载byte类型或boolean类型值</p>
<p>caload 从数组中装载char类型值</p>
<p>saload 从数组中装载short类型值</p>
</blockquote>
<table>
<thead>
<tr>
<th>xload_n</th>
<th>xload_0</th>
<th>xload_1</th>
<th>xload_2</th>
<th>xload_3</th>
</tr>
</thead>
<tbody><tr>
<td><strong>iload_n</strong></td>
<td>iload_0</td>
<td>iload_1</td>
<td>iload_2</td>
<td>iload_3</td>
</tr>
<tr>
<td><strong>lload_n</strong></td>
<td>lload_0</td>
<td>lload_1</td>
<td>lload_2</td>
<td>lload_3</td>
</tr>
<tr>
<td><strong>fload_n</strong></td>
<td>fload_0</td>
<td>fload_1</td>
<td>fload_2</td>
<td>fload_3</td>
</tr>
<tr>
<td><strong>dload_n</strong></td>
<td>dload_0</td>
<td>dload_1</td>
<td>dload_2</td>
<td>dload_3</td>
</tr>
<tr>
<td><strong>aload_n</strong></td>
<td>aload_0</td>
<td>aload_1</td>
<td>aload_2</td>
<td>aload_3</td>
</tr>
</tbody></table>
<h3 id="常量入栈指令"><a href="#常量入栈指令" class="headerlink" title="常量入栈指令"></a>常量入栈指令</h3><h4 id="常量入栈指令剖析"><a href="#常量入栈指令剖析" class="headerlink" title="常量入栈指令剖析"></a>常量入栈指令剖析</h4><p>常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为<code>const</code>系列、<code>push</code>系列和<code>ldc</code>指令。</p>
<h5 id="指令const系列："><a href="#指令const系列：" class="headerlink" title="指令const系列："></a>指令const系列：</h5><p>用于对特定的常量入栈，入栈的常量隐含在指令本身里。指令有：<code> iconst_&lt;i&gt;(i从-1到5)</code>、<code>lconst_&lt;l&gt;(1从0到1)</code>、<code>fconst_&lt;f&gt;(f从e到2)</code>、<code>dconst_&lt;d&gt;(d从e到1)</code>、<code>aconst_null</code>。</p>
<p>比如：</p>
<ul>
<li><p>iconst_m1将<code>-1</code>压入操作数栈;</p>
</li>
<li><p>iconst_x (x为0到5）将x压入栈：  </p>
</li>
<li><p>lconst_0、lconst_1分别将长整数0和1压入栈;</p>
</li>
<li><p>fconst_0、fconst_1、fconst_2分别将浮点数0、1、2压入栈;</p>
</li>
<li><p>dconst_a和dconst_1分别将double型0和1压入栈。</p>
</li>
<li><p>aconst_null将null压入操作数栈;</p>
</li>
</ul>
<p>​          从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，i表示整数，1表示长整数,f表示浮点数，d表示双精度浮点，习惯上用a表示对象引用。如果指令隐含操作的参数，会以下划线形式给出。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// iconst_3</span></span><br><span class="line"><span class="comment">// iconst_&lt;i&gt;的范围是-1到5，如果大于这个范围则使用push指令</span></span><br></pre></td></tr></table></figure>

<h5 id="指令push系列："><a href="#指令push系列：" class="headerlink" title="指令push系列："></a>指令push系列：</h5><p>主要包括bipush和sipush。它们的区别在于接收数据类型的不同，bipush接收8位整数作为参数，sipush接收16位整数，它们都将参数压入栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// bipush 6</span></span><br><span class="line"><span class="comment">// sipush的范围是[-32768, 32767]，如果大于这个范围则使用ldc指令</span></span><br></pre></td></tr></table></figure>

<h5 id="指令ldc系列："><a href="#指令ldc系列：" class="headerlink" title="指令ldc系列："></a>指令ldc系列：</h5><p>如果以上指令都不能满足需求，那么可以使用万能的1dc指令，它可以接收一个8位的参数，该参数指向常量池中的int、float或者String的索引，将指定的内容压入堆栈。</p>
<p>类似的还有ldc_w，它接收两个8位参数，能支持的索引范围大于ldc。</p>
<p>如果要压入的元素是long或者double类型的,则使用ldc2_w指令，使用方式都是类似的。</p>
<p>总结如下： </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>常数指令</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>int(boolean,byte,char,short)</td>
<td>iconst</td>
<td>[-1, 5]</td>
</tr>
<tr>
<td></td>
<td>bipush</td>
<td>[-128, 127]</td>
</tr>
<tr>
<td></td>
<td>sipush</td>
<td>[-32768, 32767]</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>any int value</td>
</tr>
<tr>
<td>long</td>
<td>lconst</td>
<td>0, 1</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>any long value</td>
</tr>
<tr>
<td>float</td>
<td>fconst</td>
<td>0, 1, 2</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>any float value</td>
</tr>
<tr>
<td>double</td>
<td>dconst</td>
<td>0, 1</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>any double value</td>
</tr>
<tr>
<td>reference</td>
<td>aconst</td>
<td>null</td>
</tr>
<tr>
<td>l</td>
<td>dc</td>
<td>String literal, Class literal</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushConstLdc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">32767</span>;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">constLdc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> a2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">float</span> b1 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">float</span> b2 = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">double</span> c1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> c2 = <span class="number">2</span>;</span><br><span class="line">    Date d = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pushConstLdc</span></span><br><span class="line"><span class="number">0</span> iconst_m1</span><br><span class="line"> <span class="number">1</span> istore_1</span><br><span class="line"> <span class="number">2</span> iconst_5</span><br><span class="line"> <span class="number">3</span> istore_2</span><br><span class="line"> <span class="number">4</span> bipush <span class="number">6</span></span><br><span class="line"> <span class="number">6</span> istore_3</span><br><span class="line"> <span class="number">7</span> bipush <span class="number">127</span></span><br><span class="line"> <span class="number">9</span> istore <span class="number">4</span></span><br><span class="line"><span class="number">11</span> sipush <span class="number">128</span></span><br><span class="line"><span class="number">14</span> istore <span class="number">5</span></span><br><span class="line"><span class="number">16</span> sipush <span class="number">32767</span></span><br><span class="line"><span class="number">19</span> istore <span class="number">6</span></span><br><span class="line"><span class="number">21</span> ldc #<span class="number">7</span> &lt;<span class="number">32768</span>&gt;</span><br><span class="line"><span class="number">23</span> istore <span class="number">7</span></span><br><span class="line"><span class="number">25</span> <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//constLdc</span></span><br><span class="line"> <span class="number">0</span> lconst_1</span><br><span class="line"> <span class="number">1</span> lstore_1</span><br><span class="line"> <span class="number">2</span> ldc2_w #<span class="number">8</span> &lt;<span class="number">2</span>&gt;</span><br><span class="line"> <span class="number">5</span> lstore_3</span><br><span class="line"> <span class="number">6</span> fconst_2</span><br><span class="line"> <span class="number">7</span> fstore <span class="number">5</span></span><br><span class="line"> <span class="number">9</span> ldc #<span class="number">10</span> &lt;<span class="number">3.0</span>&gt;</span><br><span class="line"><span class="number">11</span> fstore <span class="number">6</span></span><br><span class="line"><span class="number">13</span> dconst_1</span><br><span class="line"><span class="number">14</span> dstore <span class="number">7</span></span><br><span class="line"><span class="number">16</span> ldc2_w #<span class="number">11</span> &lt;<span class="number">2.0</span>&gt;</span><br><span class="line"><span class="number">19</span> dstore <span class="number">9</span></span><br><span class="line"><span class="number">21</span> aconst_null</span><br><span class="line"><span class="number">22</span> astore <span class="number">11</span></span><br><span class="line"><span class="number">24</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/59982d71dc70f7d7b873f50130281c21.png/lvxiaoyi" alt="566b9397-5afe-4a3f-9e17-9ebf504dfc80"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/cd990ebc801bf53b4f7b1966d9974345.png/lvxiaoyi" alt="b59702d2-4c93-44df-87f1-01a5dfe53b61"></p>
<h4 id="常量入栈常用指令集"><a href="#常量入栈常用指令集" class="headerlink" title="常量入栈常用指令集"></a>常量入栈常用指令集</h4><table>
<thead>
<tr>
<th>xconst_n</th>
<th>范围</th>
<th>xconst_null</th>
<th>xconst_m1</th>
<th>xconst_0</th>
<th>xconst_1</th>
<th>xconst_2</th>
<th>xconst_3</th>
<th>xconst_4</th>
<th>xconst_5</th>
</tr>
</thead>
<tbody><tr>
<td><strong>iconst_n</strong></td>
<td>[-1, 5]</td>
<td></td>
<td>iconst_m1</td>
<td>iconst_0</td>
<td>iconst_1</td>
<td>iconst_2</td>
<td>iconst_3</td>
<td>iconst_4</td>
<td>iconst_5</td>
</tr>
<tr>
<td><strong>lconst_n</strong></td>
<td>0, 1</td>
<td></td>
<td></td>
<td>lconst_0</td>
<td>lconst_1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>fconst_n</strong></td>
<td>0, 1, 2</td>
<td></td>
<td></td>
<td>fconst_0</td>
<td>fconst_1</td>
<td>fconst_2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>dconst_n</strong></td>
<td>0, 1</td>
<td></td>
<td></td>
<td>dconst_0</td>
<td>dconst_1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>aconst_n</strong></td>
<td>null, String literal, Class literal</td>
<td>aconst_null</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>bipush</strong></td>
<td>一个字节，2^8^，[-2^7^, 2^7^ - 1]，即[-128, 127]</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>sipush</strong></td>
<td>两个字节，2^16^，[-2^15^, 2^15^ - 1]，即[-32768, 32767]</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>ldc</strong></td>
<td>四个字节，2^32^，[-2^31^, 2^31^ - 1]</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>ldc_w</strong></td>
<td>宽索引</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>ldc2_w</strong></td>
<td>宽索引，long或double</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>aconst_null 将null对象引用压入栈</p>
<p>iconst_m1 将int类型常量-1压入栈</p>
<p>iconst_0 将int类型常量0压入栈</p>
<p>iconst_1 将int类型常量1压入栈</p>
<p>iconst_2 将int类型常量2压入栈</p>
<p>iconst_3 将int类型常量3压入栈</p>
<p>iconst_4 将int类型常量4压入栈</p>
<p>iconst_5 将int类型常量5压入栈</p>
<p>lconst_0 将long类型常量0压入栈</p>
<p>lconst_1 将long类型常量1压入栈</p>
<p>fconst_0 将float类型常量0压入栈</p>
<p>fconst_1 将float类型常量1压入栈</p>
<p>dconst_0 将double类型常量0压入栈</p>
<p>dconst_1 将double类型常量1压入栈</p>
<p>bipush 将一个8位带符号整数压入栈</p>
<p>sipush 将16位带符号整数压入栈</p>
<p>ldc 把常量池中的项压入栈</p>
<p>ldc_w 把常量池中的项压入栈（使用宽索引）</p>
<p>ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）</p>
</blockquote>
<h3 id="出栈装入局部变量表指令"><a href="#出栈装入局部变量表指令" class="headerlink" title="出栈装入局部变量表指令"></a>出栈装入局部变量表指令</h3><h4 id="出栈装入局部变量表指令剖析"><a href="#出栈装入局部变量表指令剖析" class="headerlink" title="出栈装入局部变量表指令剖析"></a>出栈装入局部变量表指令剖析</h4><p>出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值。</p>
<p>这类指令主要以store的形式存在，比如xstore (x为i、1、f、d、a)、 xstore_n (x为i、1、f、d、a，n 为0至3)。</p>
<ul>
<li>其中，指令istore_n将从操作数栈中弹出一个整数，并把它赋值给局部变量索引n位置。</li>
<li>指令xstore由于没有隐含参数信息，故需要提供一个byte类型的参数类指定目标局部变量表的位置。</li>
</ul>
<p>说明：</p>
<p>一般说来，类似像store这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置。但是，为了尽可能压缩指令大小，使用专门的istore_1指令表示将弹出的元素放置在局部变量表第1个位置。类似的还有istore_0、istore_2、istore_3,它们分别表示从操作数栈顶弹出一个元素，存放在局部变量表第0、2、3个位置。</p>
<p>由于局部变量表前几个位置总是非常常用，因此这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码的体积。如果局部变量表很大，需要存储的槽位大于3,那么可以使用istore指令，外加一个参数，用来表示需要存放的槽位位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = k + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">long</span> l = <span class="number">12</span>;</span><br><span class="line">    String str = <span class="string">&quot;lvxiaoyi&quot;</span>;</span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">10.0F</span>;</span><br><span class="line">    d = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iload_1</span><br><span class="line"> <span class="number">1</span> iconst_2</span><br><span class="line"> <span class="number">2</span> iadd</span><br><span class="line"> <span class="number">3</span> istore <span class="number">4</span></span><br><span class="line"> <span class="number">5</span> ldc2_w #<span class="number">13</span> &lt;<span class="number">12</span>&gt;</span><br><span class="line"> <span class="number">8</span> lstore <span class="number">5</span></span><br><span class="line"><span class="number">10</span> ldc #<span class="number">15</span> &lt;lvxiaoyi&gt;</span><br><span class="line"><span class="number">12</span> astore <span class="number">7</span></span><br><span class="line"><span class="number">14</span> ldc #<span class="number">16</span> &lt;<span class="number">10.0</span>&gt;</span><br><span class="line"><span class="number">16</span> fstore <span class="number">8</span></span><br><span class="line"><span class="number">18</span> ldc2_w #<span class="number">17</span> &lt;<span class="number">10.0</span>&gt;</span><br><span class="line"><span class="number">21</span> dstore_2</span><br><span class="line"><span class="number">22</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/4adce45129332dd04b89f4aa8ffc6e28.png/lvxiaoyi" alt="2"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/e4665e8fc25e2d63bff2e8423b60b1dc.png/lvxiaoyi" alt="3"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">long</span> l, <span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        String s = <span class="string">&quot;hello,lvxiaoyi&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> iconst_0</span><br><span class="line"><span class="number">1</span> istore <span class="number">4</span></span><br><span class="line"><span class="number">3</span> ldc #<span class="number">19</span> &lt;hello,lvxiaoyi&gt;</span><br><span class="line"><span class="number">5</span> astore <span class="number">4</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="出栈装入局部变量表常用指令集"><a href="#出栈装入局部变量表常用指令集" class="headerlink" title="出栈装入局部变量表常用指令集"></a>出栈装入局部变量表常用指令集</h4><table>
<thead>
<tr>
<th>xstore_n</th>
<th>xstore_0</th>
<th>xstore_1</th>
<th>xstore_2</th>
<th>xstore_3</th>
</tr>
</thead>
<tbody><tr>
<td><strong>istore_n</strong></td>
<td>istore_0</td>
<td>istore_1</td>
<td>istore_2</td>
<td>istore_3</td>
</tr>
<tr>
<td><strong>lstore_n</strong></td>
<td>lstore_0</td>
<td>lstore_1</td>
<td>lstore_2</td>
<td>lstore_3</td>
</tr>
<tr>
<td><strong>fstore_n</strong></td>
<td>fstore_0</td>
<td>fstore_1</td>
<td>fstore_2</td>
<td>fstore_3</td>
</tr>
<tr>
<td><strong>dstore_n</strong></td>
<td>dstore_0</td>
<td>dstore_1</td>
<td>dstore_2</td>
<td>dstore_3</td>
</tr>
<tr>
<td><strong>astore_n</strong></td>
<td>astore_0</td>
<td>astore_1</td>
<td>astore_2</td>
<td>astore_3</td>
</tr>
</tbody></table>
<blockquote>
<p>istore 将int类型值存入局部变量</p>
<p>lstore 将long类型值存入局部变量</p>
<p>fstore 将float类型值存入局部变量</p>
<p>dstore 将double类型值存入局部变量</p>
<p>astore 将将引用类型或returnAddress类型值存入局部变量</p>
<p>istore_0 将int类型值存入局部变量0</p>
<p>istore_1 将int类型值存入局部变量1</p>
<p>istore_2 将int类型值存入局部变量2</p>
<p>istore_3 将int类型值存入局部变量3</p>
<p>lstore_0 将long类型值存入局部变量0</p>
<p>lstore_1 将long类型值存入局部变量1</p>
<p>lstore_2 将long类型值存入局部变量2</p>
<p>lstore_3 将long类型值存入局部变量3</p>
<p>fstore_0 将float类型值存入局部变量0</p>
<p>fstore_1 将float类型值存入局部变量1</p>
<p>fstore_2 将float类型值存入局部变量2</p>
<p>fstore_3 将float类型值存入局部变量3</p>
<p>dstore_0 将double类型值存入局部变量0</p>
<p>dstore_1 将double类型值存入局部变量1</p>
<p>dstore_2 将double类型值存入局部变量2</p>
<p>dstore_3 将double类型值存入局部变量3</p>
<p>astore_0 将引用类型或returnAddress类型值存入局部变量0</p>
<p>astore_1 将引用类型或returnAddress类型值存入局部变量1</p>
<p>astore_2 将引用类型或returnAddress类型值存入局部变量2</p>
<p>astore_3 将引用类型或returnAddress类型值存入局部变量3</p>
<p>iastore 将int类型值存入数组中</p>
<p>lastore 将long类型值存入数组中</p>
<p>fastore 将float类型值存入数组中</p>
<p>dastore 将double类型值存入数组中</p>
<p>aastore 将引用类型值存入数组中</p>
<p>bastore 将byte类型或者boolean类型值存入数组中</p>
<p>castore 将char类型值存入数组中</p>
<p>sastore 将short类型值存入数组中</p>
<p>wide指令</p>
<p>wide 使用附加字节扩展局部变量索引</p>
</blockquote>
<h2 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>算术指令用于对<strong>两个操作数栈上的值</strong>进行某种特定运算，并把结果重新压入操作数栈。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>大体上算术指令可以分为两种：对整型数据进行运算的指令与对汗点类型数据进行运算的指令。</p>
<h4 id="byte、short、char和boolean类型说明"><a href="#byte、short、char和boolean类型说明" class="headerlink" title="byte、short、char和boolean类型说明"></a>byte、short、char和boolean类型说明</h4><p>在每一大类中，都有针对Java虚拟机具体数据类型的专用算术指令。但没有直接支持byte、short、char和boolean类型的算术指令，对于这些数据的运算，都使用int类型的指令来处理。此外，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。</p>
<h5 id="java虚拟机中的实际类型与运算类型"><a href="#java虚拟机中的实际类型与运算类型" class="headerlink" title="java虚拟机中的实际类型与运算类型"></a>java虚拟机中的实际类型与运算类型</h5><table>
<thead>
<tr>
<th>实际类型</th>
<th>运算类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>int</td>
</tr>
<tr>
<td>byte</td>
<td>int</td>
</tr>
<tr>
<td>char</td>
<td>int</td>
</tr>
<tr>
<td>short</td>
<td>int</td>
</tr>
<tr>
<td>int</td>
<td>int</td>
</tr>
<tr>
<td>float</td>
<td>float</td>
</tr>
<tr>
<td>reference</td>
<td>reference</td>
</tr>
<tr>
<td>returnAddress</td>
<td>returnAddress</td>
</tr>
<tr>
<td>long</td>
<td>long</td>
</tr>
<tr>
<td>double</td>
<td>double</td>
</tr>
</tbody></table>
<h4 id="运算时的溢出"><a href="#运算时的溢出" class="headerlink" title="运算时的溢出"></a>运算时的溢出</h4><p>数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实Java虚拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有除法指令以及求余指令中当出现除数为e时会导致虚拟机抛出异常ArithmeticException。</p>
<h4 id="运算模式"><a href="#运算模式" class="headerlink" title="运算模式"></a>运算模式</h4><ul>
<li>向最接近数舍入模式：JVM要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的;</li>
<li>向零舍入模式：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果; </li>
</ul>
<h4 id="NAN的使用"><a href="#NAN的使用" class="headerlink" title="NAN的使用"></a>NAN的使用</h4><p>当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义的话.将会使用NaN值来表示。而且所有使用NaN值作为操作数的算术操作，结果都会返回 NaN;</p>
<p>数值类型的数据，才可以谈大小！</p>
<p>boolean、引用数据类型不能比较大小。</p>
<blockquote>
<p>注意：NaN(Not a Number)表示不是一个数字</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArithmeticTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Method1Test method1Test = <span class="keyword">new</span> Method1Test();</span><br><span class="line">        method1Test.method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 这里直接除以0会报错，因为0是绝对0</span></span><br><span class="line">        <span class="comment">// 0.0代表着无穷小</span></span><br><span class="line">        <span class="keyword">double</span> j = i / <span class="number">0.0</span>;</span><br><span class="line">        System.out.println(j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> d1 = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">double</span> d2 = d1 / <span class="number">0.0</span>;</span><br><span class="line">        System.out.println(d2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> iload_1</span><br><span class="line"> <span class="number">4</span> i2d</span><br><span class="line"> <span class="number">5</span> dconst_0</span><br><span class="line"> <span class="number">6</span> ddiv</span><br><span class="line"> <span class="number">7</span> dstore_2</span><br><span class="line"> <span class="number">8</span> getstatic #<span class="number">8</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">11</span> dload_2</span><br><span class="line"><span class="number">12</span> invokevirtual #<span class="number">9</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">15</span> dconst_0</span><br><span class="line"><span class="number">16</span> dstore <span class="number">4</span></span><br><span class="line"><span class="number">18</span> dload <span class="number">4</span></span><br><span class="line"><span class="number">20</span> dconst_0</span><br><span class="line"><span class="number">21</span> ddiv</span><br><span class="line"><span class="number">22</span> dstore <span class="number">6</span></span><br><span class="line"><span class="number">24</span> getstatic #<span class="number">8</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">27</span> dload <span class="number">6</span></span><br><span class="line"><span class="number">29</span> invokevirtual #<span class="number">9</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">32</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无穷大</span></span><br><span class="line">Infinity</span><br><span class="line"><span class="comment">// not a number</span></span><br><span class="line">NaN</span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<h3 id="算术指令集"><a href="#算术指令集" class="headerlink" title="算术指令集"></a>算术指令集</h3><blockquote>
<h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><p>iadd 执行int类型的加法</p>
<p>ladd 执行long类型的加法</p>
<p>isub 执行int类型的减法</p>
<p>lsub 执行long类型的减法</p>
<p>imul 执行int类型的乘法</p>
<p>lmul 执行long类型的乘法</p>
<p>idiv 执行int类型的除法</p>
<p>ldiv 执行long类型的除法</p>
<p>irem 计算int类型除法的余数</p>
<p>lrem 计算long类型除法的余数</p>
<p>ineg 对一个int类型值进行取反操作</p>
<p>lneg 对一个long类型值进行取反操作</p>
<p>iinc 把一个常量值加到一个int类型的局部变量上</p>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><p>ishl 执行int类型的向左移位操作</p>
<p>lshl 执行long类型的向左移位操作</p>
<p>ishr 执行int类型的向右移位操作</p>
<p>lshr 执行long类型的向右移位操作</p>
<p>iushr 执行int类型的向右逻辑移位操作</p>
<p>lushr 执行long类型的向右逻辑移位操作</p>
<h3 id="按位布尔运算"><a href="#按位布尔运算" class="headerlink" title="按位布尔运算"></a>按位布尔运算</h3><p>iand 对int类型值进行“逻辑与”操作</p>
<p>land 对long类型值进行“逻辑与”操作</p>
<p>ior 对int类型值进行“逻辑或”操作</p>
<p>lor 对long类型值进行“逻辑或”操作</p>
<p>ixor 对int类型值进行“逻辑异或”操作</p>
<p>lxor 对long类型值进行“逻辑异或”操作</p>
<h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>fadd 执行float类型的加法</p>
<p>dadd 执行double类型的加法</p>
<p>fsub 执行float类型的减法</p>
<p>dsub 执行double类型的减法</p>
<p>fmul 执行float类型的乘法</p>
<p>dmul 执行double类型的乘法</p>
<p>fdiv 执行float类型的除法</p>
<p>ddiv 执行double类型的除法</p>
<p>frem 计算float类型除法的余数</p>
<p>drem 计算double类型除法的余数</p>
<p>fneg 将一个float类型的数值取反</p>
<p>dneg 将一个double类型的数值取反</p>
</blockquote>
<table>
<thead>
<tr>
<th>算数指令</th>
<th>int(boolean,byte,char,short)</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>加法指令</td>
<td>iadd</td>
<td>ladd</td>
<td>fadd</td>
<td>dadd</td>
<td></td>
</tr>
<tr>
<td>减法指令</td>
<td>isub</td>
<td>lsub</td>
<td>fsub</td>
<td>dsub</td>
<td></td>
</tr>
<tr>
<td>乘法指令</td>
<td>imul</td>
<td>lmul</td>
<td>fmul</td>
<td>dmul</td>
<td></td>
</tr>
<tr>
<td>除法指令</td>
<td>idiv</td>
<td>ldiv</td>
<td>fdiv</td>
<td>ddiv</td>
<td></td>
</tr>
<tr>
<td>求余指令</td>
<td>irem</td>
<td>lrem</td>
<td>frem</td>
<td>drem</td>
<td></td>
</tr>
<tr>
<td>取反指令</td>
<td>ineg</td>
<td>lneg</td>
<td>fneg</td>
<td>dneg</td>
<td></td>
</tr>
<tr>
<td>自增指令</td>
<td>iinc</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>位运算指令</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>位移指令</td>
<td>ishl、ishr、iushr</td>
<td>lshl、lshr、lushr</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>按位或指令</td>
<td>ior</td>
<td>lor</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>按位与指令</td>
<td>iand</td>
<td>land</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>按位异或指令</td>
<td>ixor</td>
<td>lxor</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>比较指令</td>
<td></td>
<td>lcmp</td>
<td>fcmpg / fcmpl</td>
<td>dcmpg / dcmpl</td>
<td></td>
</tr>
</tbody></table>
<h4 id="算术指令举例"><a href="#算术指令举例" class="headerlink" title="算术指令举例"></a>算术指令举例</h4><h5 id="举例1-1"><a href="#举例1-1" class="headerlink" title="举例1"></a>举例1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((i + <span class="number">1</span>) - <span class="number">2</span>) * <span class="number">3</span> / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/256d8a8ec2309b6d396795e9a7e79959.png/lvxiaoyi" alt="a54c2ac8-dd36-49f4-a49d-9afd725e8365" style="zoom: 50%;" />

<h5 id="举例2-1"><a href="#举例2-1" class="headerlink" title="举例2"></a>举例2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">byte</span> i = <span class="number">15</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">int</span> k = i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/58c6064f2d2103610c6e2f9c9472f122.png/lvxiaoyi" alt="image-20210424210710750"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/d0257760ed00864d7e36421c2df971ca.png/lvxiaoyi" alt="2"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/df724aebb307c6dda0780bbf5d4e1f92.png/lvxiaoyi" alt="3"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/f2edaef3312398b63decea146718f2d6.gif/lvxiaoyi" alt="img"></p>
<h5 id="举例3-1"><a href="#举例3-1" class="headerlink" title="举例3"></a>举例3</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">500</span>;</span><br><span class="line">	<span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">int</span> a = x / y;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">50</span>;</span><br><span class="line">	System.out.println(a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/ce924815ec9c6ddc5cd98f18538c250e.png/lvxiaoyi" alt="c43c0407-020f-4ec4-bd27-e4c109640b39"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/918a9850ced5114086db35ce59e651af.png/lvxiaoyi" alt="04282df1-4e52-4c3d-a47b-84023159b624"></p>
<h4 id="再举例"><a href="#再举例" class="headerlink" title="再举例"></a>再举例</h4><h5 id="举例二"><a href="#举例二" class="headerlink" title="举例二"></a>举例二</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 从本地变量表中加载i到栈中，使用feg取负数，然后把栈中的数据放入局部变量表的j的位置</span></span><br><span class="line">    <span class="keyword">float</span> j = -i;</span><br><span class="line">    <span class="comment">// 从本地变量表中加载j到栈中，使用feg取负数，然后把栈中的数据放入局部变量表i的位置</span></span><br><span class="line">    i = -j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> ldc #<span class="number">10</span> &lt;<span class="number">10.0</span>&gt;</span><br><span class="line"><span class="number">2</span> fstore_1</span><br><span class="line"><span class="number">3</span> fload_1</span><br><span class="line"><span class="number">4</span> fneg</span><br><span class="line"><span class="number">5</span> fstore_2</span><br><span class="line"><span class="number">6</span> fload_2</span><br><span class="line"><span class="number">7</span> fneg</span><br><span class="line"><span class="number">8</span> fstore_1</span><br><span class="line"><span class="number">9</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h5 id="举例三"><a href="#举例三" class="headerlink" title="举例三"></a>举例三</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 从本地变量表中加载i到栈中，push一个10到栈中，使用add相加，然后把栈中的数据放入局部变量表i的位置</span></span><br><span class="line">    i = i + <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 直接在本地变量表中使用`iinc 2 by 10`命令，在局部变量表上直接相加</span></span><br><span class="line">    i += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> bipush <span class="number">100</span></span><br><span class="line"><span class="number">2</span> istore_2</span><br><span class="line"><span class="number">3</span> iload_2</span><br><span class="line"><span class="number">4</span> bipush <span class="number">10</span></span><br><span class="line"><span class="number">6</span> iadd</span><br><span class="line"><span class="number">7</span> istore_2</span><br><span class="line"><span class="number">8</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h5 id="举例四"><a href="#举例四" class="headerlink" title="举例四"></a>举例四</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int method4() &#123;</span><br><span class="line">    int a = 80;</span><br><span class="line">    int b = 7;</span><br><span class="line">    int c = 10;</span><br><span class="line">    // 这里就是正常的指令</span><br><span class="line">    // 线板adc放入局部变量表中，然后把ab读入到栈中使用add命令相加，然后把c放入栈中使用imul命令相乘，适应ireturn返回int类型</span><br><span class="line">    return (a + b) * c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">80</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> bipush <span class="number">7</span></span><br><span class="line"> <span class="number">5</span> istore_2</span><br><span class="line"> <span class="number">6</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">8</span> istore_3</span><br><span class="line"> <span class="number">9</span> iload_1</span><br><span class="line"><span class="number">10</span> iload_2</span><br><span class="line"><span class="number">11</span> iadd</span><br><span class="line"><span class="number">12</span> iload_3</span><br><span class="line"><span class="number">13</span> imul</span><br><span class="line"><span class="number">14</span> ireturn</span><br></pre></td></tr></table></figure>



<h5 id="举例五"><a href="#举例五" class="headerlink" title="举例五"></a>举例五</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method5</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把ij直接放入栈中（参数传递）使用add命令相加，栈中加入常量1使用sub命令相减</span></span><br><span class="line">    <span class="comment">// 栈中加入常量-1，使用xor明亮异或</span></span><br><span class="line">    <span class="comment">// 然后取栈顶的两个元素and操作</span></span><br><span class="line">    <span class="keyword">return</span> ((i + j - <span class="number">1</span>) &amp; ~(j - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iload_1</span><br><span class="line"> <span class="number">1</span> iload_2</span><br><span class="line"> <span class="number">2</span> iadd</span><br><span class="line"> <span class="number">3</span> iconst_1</span><br><span class="line"> <span class="number">4</span> isub</span><br><span class="line"> <span class="number">5</span> iload_2</span><br><span class="line"> <span class="number">6</span> iconst_1</span><br><span class="line"> <span class="number">7</span> isub</span><br><span class="line"> <span class="number">8</span> iconst_m1</span><br><span class="line"> <span class="number">9</span> ixor</span><br><span class="line"><span class="number">10</span> iand</span><br><span class="line"><span class="number">11</span> ireturn</span><br></pre></td></tr></table></figure>



<h5 id="举例六"><a href="#举例六" class="headerlink" title="举例六"></a>举例六</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 两者都是使用的`iinc 1 by 1`指令</span></span><br><span class="line">    i++;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> bipush <span class="number">10</span></span><br><span class="line"><span class="number">2</span> istore_1</span><br><span class="line"><span class="number">3</span> iinc <span class="number">1</span> by <span class="number">1</span></span><br><span class="line"><span class="number">6</span> iinc <span class="number">1</span> by <span class="number">1</span></span><br><span class="line"><span class="number">9</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<h5 id="举例七"><a href="#举例七" class="headerlink" title="举例七"></a>举例七</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// i++;先将i的值从本地变量表入栈，然后使用`iinc 1 by 1`指令在局部变量表上++；然后把栈中的数据放入局部变量表的next的index，这里的index就是a</span></span><br><span class="line">    <span class="keyword">int</span> a = i++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// i++; 使用`iinc 1 by 1`指令在局部变量表上++；然后先将i的值从本地变量表入栈，然后把栈中的数据放入局部变量表的next的index，这里的index就是b</span></span><br><span class="line">    <span class="keyword">int</span> b = ++j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> iload_1</span><br><span class="line"> <span class="number">4</span> iinc <span class="number">1</span> by <span class="number">1</span></span><br><span class="line"> <span class="number">7</span> istore_2</span><br><span class="line"> <span class="number">8</span> bipush <span class="number">20</span></span><br><span class="line"><span class="number">10</span> istore_3</span><br><span class="line"><span class="number">11</span> iinc <span class="number">3</span> by <span class="number">1</span></span><br><span class="line"><span class="number">14</span> iload_3</span><br><span class="line"><span class="number">15</span> istore <span class="number">4</span></span><br><span class="line"><span class="number">17</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<h5 id="举例八"><a href="#举例八" class="headerlink" title="举例八"></a>举例八</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//i++;先将i的值从本地变量表入栈，然后使用`iinc 1 by 1`指令在局部变量表上++，这里的i就变成了11</span></span><br><span class="line">    <span class="comment">// 然后把栈中的数据放入局部变量表的next的index，这里的index就是i，这里覆盖了原来的11，所以最后导致的诗句为10</span></span><br><span class="line">    i = i++;</span><br><span class="line">    <span class="comment">// 这里打印的是10</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> iload_1</span><br><span class="line"> <span class="number">4</span> iinc <span class="number">1</span> by <span class="number">1</span></span><br><span class="line"> <span class="number">7</span> istore_1</span><br><span class="line"> <span class="number">8</span> getstatic #<span class="number">8</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">11</span> iload_1</span><br><span class="line"><span class="number">12</span> invokevirtual #<span class="number">11</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">15</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="举例九"><a href="#举例九" class="headerlink" title="举例九"></a>举例九</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">metthod9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> b = <span class="keyword">false</span>;</span><br><span class="line">    a = a % <span class="number">10</span>;</span><br><span class="line">    b = !b;</span><br><span class="line">    a = a ^ a;</span><br><span class="line">    b = (b &amp; b) &amp;&amp; b;</span><br><span class="line">    b = (b | b) || b;</span><br><span class="line">    a = ((a + <span class="number">1</span>) - <span class="number">1</span>) * <span class="number">1</span> / <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_0</span><br><span class="line"> <span class="number">1</span> istore_1</span><br><span class="line"> <span class="number">2</span> iconst_0</span><br><span class="line"> <span class="number">3</span> istore_2</span><br><span class="line"> <span class="number">4</span> iload_1</span><br><span class="line"> <span class="number">5</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">7</span> irem</span><br><span class="line"> <span class="number">8</span> istore_1</span><br><span class="line"> <span class="number">9</span> iload_2</span><br><span class="line"><span class="number">10</span> ifne <span class="number">17</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">13</span> iconst_1</span><br><span class="line"><span class="number">14</span> goto <span class="number">18</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">17</span> iconst_0</span><br><span class="line"><span class="number">18</span> istore_2</span><br><span class="line"><span class="number">19</span> iload_1</span><br><span class="line"><span class="number">20</span> iload_1</span><br><span class="line"><span class="number">21</span> ixor</span><br><span class="line"><span class="number">22</span> istore_1</span><br><span class="line"><span class="number">23</span> iload_2</span><br><span class="line"><span class="number">24</span> iload_2</span><br><span class="line"><span class="number">25</span> iand</span><br><span class="line"><span class="number">26</span> ifeq <span class="number">37</span> (+<span class="number">11</span>)</span><br><span class="line"><span class="number">29</span> iload_2</span><br><span class="line"><span class="number">30</span> ifeq <span class="number">37</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">33</span> iconst_1</span><br><span class="line"><span class="number">34</span> goto <span class="number">38</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">37</span> iconst_0</span><br><span class="line"><span class="number">38</span> istore_2</span><br><span class="line"><span class="number">39</span> iload_2</span><br><span class="line"><span class="number">40</span> iload_2</span><br><span class="line"><span class="number">41</span> ior</span><br><span class="line"><span class="number">42</span> ifne <span class="number">49</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">45</span> iload_2</span><br><span class="line"><span class="number">46</span> ifeq <span class="number">53</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">49</span> iconst_1</span><br><span class="line"><span class="number">50</span> goto <span class="number">54</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">53</span> iconst_0</span><br><span class="line"><span class="number">54</span> istore_2</span><br><span class="line"><span class="number">55</span> iload_1</span><br><span class="line"><span class="number">56</span> iconst_1</span><br><span class="line"><span class="number">57</span> iadd</span><br><span class="line"><span class="number">58</span> iconst_1</span><br><span class="line"><span class="number">59</span> isub</span><br><span class="line"><span class="number">60</span> iconst_1</span><br><span class="line"><span class="number">61</span> imul</span><br><span class="line"><span class="number">62</span> iconst_1</span><br><span class="line"><span class="number">63</span> idiv</span><br><span class="line"><span class="number">64</span> istore_1</span><br><span class="line"><span class="number">65</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<p>这里主要区分哪些是往栈里面存放数据，哪些是往局部变量表里面存放数据，<strong>其中store是往局部变量表里面存放数据</strong>。还有就是清除每个指令的意思</p>
<p>简单记忆：push往栈里面存放数据、store往局部变量表里存放数据、load从局部变量表里向栈里面存放数据、add相加、sub相减、imul相乘</p>
<p>常量：<code>constant</code></p>
<p>加：<code>add</code></p>
<p>减：<code>substract</code></p>
<p>乘：<code>multiply</code></p>
<p>除：<code>divide</code></p>
<p>取反：<code>negation</code></p>
<p>异或：<code>xor</code></p>
<p>取余（取模）：<code>remainder</code></p>
<p>与：<code>and</code></p>
<p>或：<code>or</code></p>
<h3 id="比较指令的说明"><a href="#比较指令的说明" class="headerlink" title="比较指令的说明"></a>比较指令的说明</h3><p>比较指令的说明</p>
<p>比较：<code>compare</code></p>
<ul>
<li><p>比较指令的作用是比较栈顶两个元素的大小，并将比较结果入栈。</p>
</li>
<li><p>比较指令有： dcmpg, dcmpl、 fcmpg、fcmp1、lcmp.</p>
<ul>
<li>与前面讲解的指令类似，首字符d表示double类型，f表示float,l表示long。</li>
</ul>
</li>
<li><p>对于double和float类型的数字，由于NaN的存在，各有两个版本的比较指令。以float为例，有fcmpg和fcmpi两个指令，它们的区别在于在数字比较时，若遇到NaN值，处理结果不同。</p>
</li>
<li><p>指令dcmpl和dcmpg也是类似的，根据其命名可以推测其含义，在此不再赘述。</p>
</li>
<li><p>指令lcmp针对long型整数，由于long型整数没有NaN值，故无需准备两套指令。</p>
</li>
</ul>
<p>举例：</p>
<p>指令fcmpg和fcmpl都从栈中弹出两个操作数，并将它们做比较，设栈顶的元素为v2,栈顶顺位第2位的元素为v1,若v1=v2,则压入0;若v1&gt;v2则压入1;若v1&lt;v2则压入-1。</p>
<p>两个指令的不同之处在于，如果遇到NaN值，fcmpg会压入1,而fcmpl会压入-1。</p>
<p><strong>demo请看控制转移指令</strong></p>
<h2 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>类型转换指令说明</p>
<ul>
<li><p>类型转换指令可以将两种不同的数值类型进行相互转换。</p>
</li>
<li><p>这些转换操作一般用于实现用户代码中的<strong>显式类型转换操作</strong>，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p>
</li>
</ul>
<blockquote>
<h2 id="宽化类型转换"><a href="#宽化类型转换" class="headerlink" title="宽化类型转换"></a>宽化类型转换</h2><p>i2l 把int类型的数据转化为long类型</p>
<p>i2f 把int类型的数据转化为float类型</p>
<p>i2d 把int类型的数据转化为double类型</p>
<p>l2f 把long类型的数据转化为float类型</p>
<p>l2d 把long类型的数据转化为double类型</p>
<p>f2d 把float类型的数据转化为double类型</p>
<h2 id="窄化类型转换"><a href="#窄化类型转换" class="headerlink" title="窄化类型转换"></a>窄化类型转换</h2><p>i2b 把int类型的数据转化为byte类型</p>
<p>i2c 把int类型的数据转化为char类型</p>
<p>i2s 把int类型的数据转化为short类型</p>
<p>l2i 把long类型的数据转化为int类型</p>
<p>f2i 把float类型的数据转化为int类型</p>
<p>f2l 把float类型的数据转化为long类型</p>
<p>d2i 把double类型的数据转化为int类型</p>
<p>d2l 把double类型的数据转化为long类型</p>
<p>d2f 把double类型的数据转化为float类型</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th><strong>byte</strong></th>
<th><strong>char</strong></th>
<th><strong>short</strong></th>
<th><strong>int</strong></th>
<th><strong>long</strong></th>
<th><strong>float</strong></th>
<th><strong>double</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>int</strong></td>
<td>i2b</td>
<td>i2c</td>
<td>i2s</td>
<td></td>
<td>i2l</td>
<td>i2f</td>
<td>i2d</td>
</tr>
<tr>
<td><strong>long</strong></td>
<td>l2i i2b</td>
<td>l2i i2c</td>
<td>l2i i2s</td>
<td>l2i</td>
<td></td>
<td>l2f</td>
<td>l2d</td>
</tr>
<tr>
<td><strong>float</strong></td>
<td>f2i i2b</td>
<td>f2i i2c</td>
<td>f2i i2s</td>
<td>f2i</td>
<td>f2l</td>
<td></td>
<td>f2d</td>
</tr>
<tr>
<td><strong>double</strong></td>
<td>d2i i2b</td>
<td>d2i i2c</td>
<td>d2i i2s</td>
<td>d2i</td>
<td>d2l</td>
<td>d2f</td>
<td></td>
</tr>
</tbody></table>
<h3 id="宽化类型转换剖析"><a href="#宽化类型转换剖析" class="headerlink" title="宽化类型转换剖析"></a>宽化类型转换剖析</h3><p>宽化类型转换( Widening Numeric Conversions)</p>
<h4 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h4><p>Java虚拟机直接支持以下数值的宽化类型转换（ widening numeric conversion，<strong>小范围类型向大范围类型的安全转换</strong>）。也就是说，并不需要指令执行，包括：</p>
<ul>
<li><p>从int类型到long、float或者 double类型。对应的指令为：i21、i2f、i2d</p>
</li>
<li><p>从long类型到float、 double类型。对应的指令为：l2f、l2d</p>
</li>
<li><p>从float类型到double类型。对应的指令为：f2d </p>
</li>
</ul>
<p>简化为：int –&gt; long –&gt; float -&gt; double</p>
<p>简化理解：也就是2 == to，这样的简化在英语用比较常见，英语中 4 == for</p>
<p>比如：log4j == log for java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upCast1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">long</span> l = i;</span><br><span class="line">    <span class="keyword">float</span> f = i;</span><br><span class="line">    <span class="keyword">double</span> d = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> f1 = l;</span><br><span class="line">    <span class="keyword">double</span> d1 = l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> d2 = f1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> iload_1</span><br><span class="line"> <span class="number">4</span> i2l</span><br><span class="line"> <span class="number">5</span> lstore_2</span><br><span class="line"> <span class="number">6</span> iload_1</span><br><span class="line"> <span class="number">7</span> i2f</span><br><span class="line"> <span class="number">8</span> fstore <span class="number">4</span></span><br><span class="line"><span class="number">10</span> iload_1</span><br><span class="line"><span class="number">11</span> i2d</span><br><span class="line"><span class="number">12</span> dstore <span class="number">5</span></span><br><span class="line"><span class="number">14</span> lload_2</span><br><span class="line"><span class="number">15</span> l2f</span><br><span class="line"><span class="number">16</span> fstore <span class="number">7</span></span><br><span class="line"><span class="number">18</span> lload_2</span><br><span class="line"><span class="number">19</span> l2d</span><br><span class="line"><span class="number">20</span> dstore <span class="number">8</span></span><br><span class="line"><span class="number">22</span> fload <span class="number">7</span></span><br><span class="line"><span class="number">24</span> f2d</span><br><span class="line"><span class="number">25</span> dstore <span class="number">10</span></span><br><span class="line"><span class="number">27</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<h4 id="精度损失问题"><a href="#精度损失问题" class="headerlink" title="精度损失问题"></a>精度损失问题</h4><ul>
<li><p>宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从int转换到long,或者从int转换到double,都不会丢失任何信息，转换前后的值是精确相等的。</p>
</li>
<li><p>从int、long类型数值转换到float,或者long类型数值转换到double时，将可能发生精度丢失一一可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据IEEE754最接近含入模式所得到的正确整数值。</p>
</li>
</ul>
<p>尽管宽化类型转换实际上是可能发生精度丢失的，但是这种转换永远<strong>不会导致Java虚拟机抛出运行时异常</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upCast2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">123123123</span>;</span><br><span class="line">    <span class="keyword">float</span> f = i;</span><br><span class="line">    System.out.println(f);<span class="comment">//1.2312312E8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> l = <span class="number">123123123123L</span>;</span><br><span class="line">    <span class="keyword">double</span> d = l;</span><br><span class="line">    System.out.println(d);<span class="comment">//1.23123123123E11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>float组成：符号位、指数位、有效位（下面举例的位数可以转变，也就是可以转变精度）</p>
<p>​       第一个字节  第二个字节  第三个字节  第四个字节</p>
<p>​    <font color=blue>0</font><font color=orange>101 0000  0</font><font color=green>000 0000 0000 0000 0000 0000</font></p>
<p>​    蓝色：符号位（ 31 ）</p>
<p>​    橘黄色：幂指数位（23－－30）</p>
<p>​    绿色：有效位 （0－－22）</p>
<p>浮点数的32位在内存的排列情况，其中的前23位是有效位，占23个比特位，第24位到31位为幂指数位，占8个比特位，第32位依旧是符号位。</p>
<p>所以float一共就四个字节，其中有效位只占据一部分，所以在同样字节转换的时候有可能会发生精度丢失</p>
<h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><p>从byte、char和 short类型到int类型的宽化类型转换实际上是不存在的。对于byte类型转为int,拟机并没有做实质性的转化处理，只是简单地通过操作数栈交換了两个数据。而将byte转为long时，使用的是i2l,可以看到在内部，byte在这里已经等同于int类型处理，类似的还有 short类型，这种处理方式有两个特点：</p>
<p>一方面可以减少实际的数据类型，如果为 short和byte都准备一套指令，那么指令的数量就会大増，而虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过256个，为了节省指令资源，将 short和byte当做int处理也在情理之中。</p>
<p>另一方面，由于局部变量表中的槽位固定为32位，无论是byte或者 short存入局部变量表，都会占用32位空间。从这个角度说，也没有必要特意区分这几种数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upCast3</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = b;</span><br><span class="line">    <span class="keyword">long</span> l = b;</span><br><span class="line">    <span class="keyword">double</span> d = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upCast4</span><span class="params">(<span class="keyword">short</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = s;</span><br><span class="line">    <span class="keyword">long</span> l = s;</span><br><span class="line">    <span class="keyword">float</span> f = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//upCast3</span></span><br><span class="line"><span class="number">0</span> iload_1</span><br><span class="line"><span class="number">1</span> istore_2</span><br><span class="line"><span class="number">2</span> iload_1</span><br><span class="line"><span class="number">3</span> i2l</span><br><span class="line"><span class="number">4</span> lstore_3</span><br><span class="line"><span class="number">5</span> iload_1</span><br><span class="line"><span class="number">6</span> i2d</span><br><span class="line"><span class="number">7</span> dstore <span class="number">5</span></span><br><span class="line"><span class="number">9</span> <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//upCast4</span></span><br><span class="line"><span class="number">0</span> iload_1</span><br><span class="line"><span class="number">1</span> istore_2</span><br><span class="line"><span class="number">2</span> iload_1</span><br><span class="line"><span class="number">3</span> i2l</span><br><span class="line"><span class="number">4</span> lstore_3</span><br><span class="line"><span class="number">5</span> iload_1</span><br><span class="line"><span class="number">6</span> i2f</span><br><span class="line"><span class="number">7</span> fstore <span class="number">5</span></span><br><span class="line"><span class="number">9</span> <span class="keyword">return</span>    </span><br></pre></td></tr></table></figure>

<p>然后我们发现没有从byte和short到int的转换，byte到int和到double的转换都是用的int转long和转double</p>
<h3 id="窄化类型转换剖析"><a href="#窄化类型转换剖析" class="headerlink" title="窄化类型转换剖析"></a>窄化类型转换剖析</h3><p>窄化类型转换( Narrowing Numeric Conversion)</p>
<h4 id="转换规则-1"><a href="#转换规则-1" class="headerlink" title="转换规则"></a>转换规则</h4><p>Java虚拟机也直接支持以下窄化类型转换：</p>
<p>从int类型至byte、 short或者char类型。对应的指令有：<code>i2b</code>、<code>i2s</code>、<code>i2c</code></p>
<p>从long类型到int类型。对应的指令有：<code>l2i</code></p>
<p>从float类型到int或者long类型。对应的指令有：<code>f2i</code>、<code>f2l</code></p>
<p>从double类型到int、long或者float类型。对应的指令有：<code>d2i</code>、<code>d2l</code>、<code>d2f</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downCast1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">    <span class="keyword">short</span> s = (<span class="keyword">short</span>) i;</span><br><span class="line">    <span class="keyword">char</span> c = (<span class="keyword">char</span>) i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> l = <span class="number">10L</span>;</span><br><span class="line">    <span class="keyword">int</span> i1 = (<span class="keyword">int</span>) l;</span><br><span class="line">    <span class="comment">// 重点在这里，这里把一个long类型转化为byte类型用到了两个指令，l2i和l2b，先把long转化为int，在吧int转化为byte</span></span><br><span class="line">    <span class="keyword">byte</span> b1 = (<span class="keyword">byte</span>) l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downCast2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">long</span> l = (<span class="keyword">long</span>)f;</span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)f;</span><br><span class="line">    <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)f;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 这里用的d2i 和 i2d</span></span><br><span class="line">    <span class="keyword">byte</span> b1 = (<span class="keyword">byte</span>)d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//downCast1()</span></span><br><span class="line"><span class="number">0</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> iload_1</span><br><span class="line"> <span class="number">4</span> i2b</span><br><span class="line"> <span class="number">5</span> istore_2</span><br><span class="line"> <span class="number">6</span> iload_1</span><br><span class="line"> <span class="number">7</span> i2s</span><br><span class="line"> <span class="number">8</span> istore_3</span><br><span class="line"> <span class="number">9</span> iload_1</span><br><span class="line"><span class="number">10</span> i2c</span><br><span class="line"><span class="number">11</span> istore <span class="number">4</span></span><br><span class="line"><span class="number">13</span> ldc2_w #<span class="number">11</span> &lt;<span class="number">10</span>&gt;</span><br><span class="line"><span class="number">16</span> lstore <span class="number">5</span></span><br><span class="line"><span class="number">18</span> lload <span class="number">5</span></span><br><span class="line"><span class="number">20</span> l2i</span><br><span class="line"><span class="number">21</span> istore <span class="number">7</span></span><br><span class="line"><span class="number">23</span> lload <span class="number">5</span></span><br><span class="line"><span class="number">25</span> l2i</span><br><span class="line"><span class="number">26</span> i2b</span><br><span class="line"><span class="number">27</span> istore <span class="number">8</span></span><br><span class="line"><span class="number">29</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<h4 id="精度损失问题-1"><a href="#精度损失问题-1" class="headerlink" title="精度损失问题"></a>精度损失问题</h4><p>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度。</p>
<p>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downCast4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;</span><br><span class="line">    System.out.println(b);<span class="comment">// -128</span></span><br><span class="line">    <span class="comment">// 因为128的int二进制为0000 ... 0000 1000 0000</span></span><br><span class="line">    <span class="comment">// 然后转化为byte后高位截取保留8位，剩余1000 0000就是`-128`</span></span><br><span class="line">    <span class="comment">// 计算机存储数据是用的补码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-128的机器码原码实际是：110000000，反码101111111，补码110000000，截取低8位即10000000</p>
<h4 id="补充说明-1"><a href="#补充说明-1" class="headerlink" title="补充说明"></a>补充说明</h4><h5 id="当将一个浮点值窄化转换为整数类型T-T限于int或long类型之一-的时候，将遵循以下转换规则："><a href="#当将一个浮点值窄化转换为整数类型T-T限于int或long类型之一-的时候，将遵循以下转换规则：" class="headerlink" title="当将一个浮点值窄化转换为整数类型T(T限于int或long类型之一)的时候，将遵循以下转换规则："></a>当将一个浮点值窄化转换为整数类型T(T限于int或long类型之一)的时候，将遵循以下转换规则：</h5><ul>
<li><p>如果浮点值是NaN,那转换结果就是int或long类型的0.</p>
</li>
<li><p>如果浮点值不是无穷大的话，浮点值使用IEEE754的向零含入模式取整，获得整数值V，如果v在目标类型T(int或long)的表示范围之内，那转换结果就是v。否则，将根据v的符号，转换为T所能表示的最大或者最小正数</p>
</li>
</ul>
<h5 id="当将一个double类型窄化转换为float类型时，将遵循以下转换规则："><a href="#当将一个double类型窄化转换为float类型时，将遵循以下转换规则：" class="headerlink" title="当将一个double类型窄化转换为float类型时，将遵循以下转换规则："></a>当将一个double类型窄化转换为float类型时，将遵循以下转换规则：</h5><p>通过向最接近数舍入模式舍入一个可以使用float类型表示的数字。最后结果根据下面这3条规则判断</p>
<ul>
<li><p>如果转换结果的绝对值太小而无法使用float来表示，将返回float类型的正负零</p>
</li>
<li><p>如果转换结果的绝对值太大而无法使用float来表示，将返回float类型的正负无穷大。</p>
</li>
<li><p>对于double类型的NaN值将按规定转換为float类型的NaN值。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downCast5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d1 = Double.NaN;</span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>) d1;</span><br><span class="line">    <span class="keyword">float</span> f = (<span class="keyword">float</span>) d1;</span><br><span class="line">    <span class="comment">// NaN</span></span><br><span class="line">    System.out.println(d1);</span><br><span class="line">    <span class="comment">// int类型没有NaN</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">    <span class="comment">// float的NaN</span></span><br><span class="line">    System.out.println(f);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d2为double的正向无穷大</span></span><br><span class="line">    <span class="keyword">double</span> d2 = Double.POSITIVE_INFINITY;</span><br><span class="line">    <span class="keyword">long</span> l = (<span class="keyword">long</span>) d2;</span><br><span class="line">    <span class="keyword">int</span> j = (<span class="keyword">int</span>) d2;</span><br><span class="line">    <span class="keyword">float</span> f2 = (<span class="keyword">float</span>) d2;</span><br><span class="line">    <span class="comment">// 转化为long的正向最大值</span></span><br><span class="line">    System.out.println(l);</span><br><span class="line">    <span class="comment">// 转化为int的正向最大值</span></span><br><span class="line">    System.out.println(j);</span><br><span class="line">    <span class="comment">// 转为float的正向最大值：Infinity</span></span><br><span class="line">    System.out.println(f2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NaN</span><br><span class="line"><span class="number">0</span></span><br><span class="line">NaN</span><br><span class="line"><span class="number">9223372036854775807</span></span><br><span class="line"><span class="number">2147483647</span></span><br><span class="line">Infinity</span><br></pre></td></tr></table></figure>



<h2 id="对象的创建与访问指令"><a href="#对象的创建与访问指令" class="headerlink" title="对象的创建与访问指令"></a>对象的创建与访问指令</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>Java是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为创建指令、字段访问指令、数组操作指令、类型检查指令。</p>
<blockquote>
<h2 id="对象操作指令"><a href="#对象操作指令" class="headerlink" title="对象操作指令"></a>对象操作指令</h2><p>new 创建一个新对象</p>
<p>getfield 从对象中获取字段</p>
<p>putfield 设置对象中字段的值</p>
<p>getstatic 从类中获取静态字段</p>
<p>putstatic 设置类中静态字段的值</p>
<p>checkcast 确定对象为所给定的类型。后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。如果不是便抛出异常</p>
<p>instanceof 判断对象是否为给定的类型。后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。是则压入 1，否则压入 0</p>
<h2 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h2><p>newarray 分配数据成员类型为基本上数据类型的新数组</p>
<p>anewarray 分配数据成员类型为引用类型的新数组</p>
<p>arraylength 获取数组长度</p>
<p>multianewarray 分配新的多维数组</p>
</blockquote>
<h3 id="创建指令"><a href="#创建指令" class="headerlink" title="创建指令"></a>创建指令</h3><table>
<thead>
<tr>
<th>创建指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>new</td>
<td>创建类实例</td>
</tr>
<tr>
<td>newarray</td>
<td>创建基本类型数组</td>
</tr>
<tr>
<td>anewarray</td>
<td>创建引用类型数组</td>
</tr>
<tr>
<td>multilanewarra</td>
<td>创建多维数组</td>
</tr>
</tbody></table>
<p>一、创建指令</p>
<p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令：</p>
<p>1．创建类实例的指令：</p>
<ul>
<li>创建类实例的指令： new <ul>
<li>它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的引用压入栈。 </li>
</ul>
</li>
</ul>
<p>2．创建数组的指令：</p>
<ul>
<li><p>创建数组的指令：newarray、anewarray、multianewarray:</p>
<ul>
<li><p>newarray：创建基本类型数组</p>
</li>
<li><p>anewarray：创建引用类型数组</p>
</li>
<li><p>multianewarray：创建多维数组</p>
</li>
</ul>
</li>
</ul>
<p>上述创建指令可以用于创建对象或者数组，由于对象和数组在Java中的广泛使用，这些指令的使用频率也非常高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建指令</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;lvxiaoyi.avi&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> <span class="keyword">new</span> #<span class="number">2</span> &lt;java/lang/Object&gt;</span><br><span class="line"> <span class="number">3</span> dup							<span class="comment">//栈顶的数据复制一份</span></span><br><span class="line"> <span class="number">4</span> invokespecial #<span class="number">1</span> &lt;java/lang/Object.&lt;init&gt;&gt;  <span class="comment">// 调用Object的构造器方法，然后出栈</span></span><br><span class="line"> <span class="number">7</span> astore_1 <span class="comment">// 把栈顶存储到局部变量表1的位置</span></span><br><span class="line"> <span class="number">8</span> <span class="keyword">new</span> #<span class="number">3</span> &lt;java/io/File&gt; <span class="comment">//创建File实例</span></span><br><span class="line"><span class="number">11</span> dup			<span class="comment">//栈顶的数据复制一份</span></span><br><span class="line"><span class="number">12</span> ldc #<span class="number">4</span> &lt;lvxiaoyi.avi&gt; <span class="comment">// 把这个字符串存储到栈中</span></span><br><span class="line"><span class="number">14</span> invokespecial #<span class="number">5</span> &lt;java/io/File.&lt;init&gt;&gt;<span class="comment">// 调用File的构造器方法，然后出栈</span></span><br><span class="line"><span class="number">17</span> astore_2</span><br><span class="line"><span class="number">18</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    Object[] objArray = <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span>[][] mintArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    String[][] strArray = <span class="keyword">new</span> String[<span class="number">10</span>][];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">2</span> newarray <span class="number">10</span> (<span class="keyword">int</span>)</span><br><span class="line"> <span class="number">4</span> astore_1</span><br><span class="line"> <span class="number">5</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">7</span> anewarray #<span class="number">2</span> &lt;java/lang/Object&gt;<span class="comment">//创建引用类型数组</span></span><br><span class="line"><span class="number">10</span> astore_2</span><br><span class="line"><span class="number">11</span> bipush <span class="number">10</span></span><br><span class="line"><span class="number">13</span> bipush <span class="number">10</span>		</span><br><span class="line"><span class="number">15</span> multianewarray #<span class="number">6</span> &lt;[[I&gt; dim <span class="number">2</span><span class="comment">//创建多维类型数组</span></span><br><span class="line"><span class="number">19</span> astore_3</span><br><span class="line"><span class="number">20</span> bipush <span class="number">10</span></span><br><span class="line"><span class="number">22</span> anewarray #<span class="number">7</span> &lt;[Ljava/lang/String;&gt;<span class="comment">//还是创建引用类型数组，相当于一维的</span></span><br><span class="line"><span class="number">25</span> astore <span class="number">4</span></span><br><span class="line"><span class="number">27</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<h3 id="字段访问指令"><a href="#字段访问指令" class="headerlink" title="字段访问指令"></a>字段访问指令</h3><table>
<thead>
<tr>
<th>字段访问指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>getstatic、putstatic</td>
<td>访问类字段（static字段，或者称为类变量）的指令</td>
</tr>
<tr>
<td>getfield、 putfield</td>
<td>访问类实例字段（非static字段，或者称为实例变量）的指令</td>
</tr>
</tbody></table>
<p>二、字段访问指令</p>
<p>对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素。</p>
<ul>
<li>访问类字段(static字段，或者称为类变量〉的指令:getstatic、putstatic</li>
<li>访问类实例字段（非static字段，或者称为实例变量〉的指令： getfield、putfield</li>
</ul>
<p>举例：</p>
<p>以getstatic指令为例，它含有一个操作数，为指向常量池的Fieldref索引，它的作用就是获取Fieldref指定的对象或者值，并将其压入操作数栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello,lvxiaoyi&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的字节码指令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> getstatic #<span class="number">8</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">3</span> ldc #<span class="number">9</span> &lt;hello,lvxiaoyi&gt;</span><br><span class="line"><span class="number">5</span> invokevirtual #<span class="number">10</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">8</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>图示：</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/6f7033f9caaf3216c6ca6795de12f6a4.png/lvxiaoyi" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    order.id = <span class="number">1001</span>;</span><br><span class="line">    System.out.println(order.id);</span><br><span class="line"></span><br><span class="line">    Order.name = <span class="string">&quot;LVXIAOYI&quot;</span>;</span><br><span class="line">    System.out.println(Order.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> <span class="keyword">new</span> #<span class="number">11</span> &lt;top/lvxiaoyi/code5/Order&gt;<span class="comment">//在操作数栈中创建一个指针，执行堆中的实体</span></span><br><span class="line"> <span class="number">3</span> dup<span class="comment">//栈中复制一份</span></span><br><span class="line"> <span class="number">4</span> invokespecial #<span class="number">12</span> &lt;top/lvxiaoyi/code5/Order.&lt;init&gt;&gt;<span class="comment">//调用order的构造器方法，出栈</span></span><br><span class="line"> <span class="number">7</span> astore_1<span class="comment">//把对象指针放入局部变量</span></span><br><span class="line"> <span class="number">8</span> aload_1<span class="comment">//对象指针加载进栈中</span></span><br><span class="line"> <span class="number">9</span> sipush <span class="number">1001</span><span class="comment">//栈中放入1001</span></span><br><span class="line"><span class="number">12</span> putfield #<span class="number">13</span> &lt;top/lvxiaoyi/code5/Order.id&gt;<span class="comment">//把1001放入对象的名叫id的field字段，出栈</span></span><br><span class="line"><span class="number">15</span> getstatic #<span class="number">8</span> &lt;java/lang/System.out&gt;<span class="comment">//调用out属性</span></span><br><span class="line"><span class="number">18</span> aload_1<span class="comment">//对象指针加载进栈中</span></span><br><span class="line"><span class="number">19</span> getfield #<span class="number">13</span> &lt;top/lvxiaoyi/code5/Order.id&gt;<span class="comment">//拿对局对象指针拿到对象的field（id）</span></span><br><span class="line"><span class="number">22</span> invokevirtual #<span class="number">14</span> &lt;java/io/PrintStream.println&gt;<span class="comment">//执行println方法</span></span><br><span class="line"><span class="number">25</span> ldc #<span class="number">15</span> &lt;LVXIAOYI&gt;<span class="comment">//把字符串“LVXIAOYI&quot;压入栈中</span></span><br><span class="line"><span class="number">27</span> putstatic #<span class="number">16</span> &lt;top/lvxiaoyi/code5/Order.name&gt;<span class="comment">//调用静态的name放入栈中，赋值后出栈</span></span><br><span class="line"><span class="number">30</span> getstatic #<span class="number">8</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">33</span> getstatic #<span class="number">16</span> &lt;top/lvxiaoyi/code5/Order.name&gt;<span class="comment">//拿到的Order的静态name字段</span></span><br><span class="line"><span class="number">36</span> invokevirtual #<span class="number">10</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">39</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<h3 id="数组操作指令-1"><a href="#数组操作指令-1" class="headerlink" title="数组操作指令"></a>数组操作指令</h3><table>
<thead>
<tr>
<th>数组指令</th>
<th>byte(boolean)</th>
<th>char</th>
<th>short</th>
<th>long</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th>reference</th>
</tr>
</thead>
<tbody><tr>
<td><strong>xaload</strong></td>
<td>baload</td>
<td>caload</td>
<td>saload</td>
<td>iaload</td>
<td>laload</td>
<td>faload</td>
<td>daload</td>
<td>aaload</td>
</tr>
<tr>
<td><strong>xastore</strong></td>
<td>bastore</td>
<td>castore</td>
<td>sastore</td>
<td>iastore</td>
<td>lastore</td>
<td>fastore</td>
<td>dastore</td>
<td>aastore</td>
</tr>
</tbody></table>
<p>三、数组操作指令</p>
<p>数组操作指令主要有： xastore和xaload指令。具体为：</p>
<ul>
<li>把一个数组元素加载到操作数栈的指令： baload、caload、saload、iaload、laload、faload、daload、aaload</li>
<li>将一个操作数栈的值存储到数组元素中的指令： bastore、castore、sastore、iastore、fastore、dastore、aastore</li>
</ul>
<p>即：</p>
<table>
<thead>
<tr>
<th>数组指令</th>
<th>byte(boolean)</th>
<th>char</th>
<th>short</th>
<th>long</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th>reference</th>
</tr>
</thead>
<tbody><tr>
<td><strong>xaload</strong></td>
<td>baload</td>
<td>caload</td>
<td>saload</td>
<td>iaload</td>
<td>laload</td>
<td>faload</td>
<td>daload</td>
<td>aaload</td>
</tr>
<tr>
<td><strong>xastore</strong></td>
<td>bastore</td>
<td>castore</td>
<td>sastore</td>
<td>iastore</td>
<td>lastore</td>
<td>fastore</td>
<td>dastore</td>
<td>aastore</td>
</tr>
</tbody></table>
<ul>
<li>取数组长度的指令:arraylength<ul>
<li>该指令弹出栈顶的数组元素，获取数组的长度，将长度压入栈。</li>
</ul>
</li>
</ul>
<p>2．说明</p>
<ul>
<li>指令xaload表示将数组的元素压栈，比如saload、caload分别表示压入short数组和char数组。指令xaload在执行时，要求操作数中栈顶元素为数组索引i,栈顶顺位第2个元素为数组引用a,该指令会弹出栈顶这两个元素，并将a[i]重新压入栈。</li>
<li>xastore则专门针对数组操作，以iastore为例，它用于给一个int数组的给定索引赋值。在i<strong>astore执行前，操作数栈顶需要以此准备3个元素：值、索引、数组引用，iastore会弹出这3个值，并将值赋给数组中指定索引的位置。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    intArray[<span class="number">3</span>] = <span class="number">20</span>;</span><br><span class="line">    System.out.println(intArray[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span>[] arr = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">10</span>];</span><br><span class="line">    System.out.println(arr.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//serArray</span></span><br><span class="line"> <span class="number">0</span> bipush <span class="number">10</span><span class="comment">//占中放一个10</span></span><br><span class="line"> <span class="number">2</span> newarray <span class="number">10</span> (<span class="keyword">int</span>)<span class="comment">//创建一个数组，数组地址存放栈中</span></span><br><span class="line"> <span class="number">4</span> astore_1<span class="comment">//地址存放局部变量表</span></span><br><span class="line"> <span class="number">5</span> aload_1<span class="comment">//栈中放入数组对象地址</span></span><br><span class="line"> <span class="number">6</span> iconst_3<span class="comment">//栈中压入常量3</span></span><br><span class="line"> <span class="number">7</span> bipush <span class="number">20</span><span class="comment">//栈中放入20</span></span><br><span class="line"> <span class="number">9</span> iastore<span class="comment">//iastore命令给数组的index为3的值设置为20，出栈</span></span><br><span class="line"><span class="number">10</span> getstatic #<span class="number">8</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">13</span> aload_1</span><br><span class="line"><span class="number">14</span> iconst_1</span><br><span class="line"><span class="number">15</span> iaload</span><br><span class="line"><span class="number">16</span> invokevirtual #<span class="number">14</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">19</span> bipush <span class="number">10</span></span><br><span class="line"><span class="number">21</span> newarray <span class="number">7</span> (<span class="keyword">double</span>)</span><br><span class="line"><span class="number">23</span> astore_2</span><br><span class="line"><span class="number">24</span> getstatic #<span class="number">8</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">27</span> aload_2</span><br><span class="line"><span class="number">28</span> arraylength</span><br><span class="line"><span class="number">29</span> invokevirtual #<span class="number">14</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">32</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="类型检查指令"><a href="#类型检查指令" class="headerlink" title="类型检查指令"></a>类型检查指令</h3><table>
<thead>
<tr>
<th>类型检查指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>instanceof</td>
<td>检查类型强制转换是否可以进行</td>
</tr>
<tr>
<td>checkcast</td>
<td>判断给定对象是否是某一个类的实例</td>
</tr>
</tbody></table>
<p>四、类型检查指令</p>
<p>检查类实例或数组类型的指令： instanceof、checkcast。</p>
<ul>
<li>指令checkcast用于检查类型强制转换是否可以进行。如果可以进行，那么checkcast指令不会改变操作数栈，否则它会抛出ClasscastException异常。</li>
<li>指令instanceof用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型检查指令</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">checkCast</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> (String) obj;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0</span> aload_1 <span class="comment">// 直接把参数放入栈中 </span></span><br><span class="line"> <span class="number">1</span> <span class="keyword">instanceof</span> #<span class="number">17</span> &lt;java/lang/String&gt;<span class="comment">// 判断是不是String类型</span></span><br><span class="line"> <span class="number">4</span> ifeq <span class="number">12</span> (+<span class="number">8</span>)<span class="comment">//如果是往下走，如果不是到12行代码（aconst_null），出栈</span></span><br><span class="line"> <span class="number">7</span> aload_1<span class="comment">//把参数入站</span></span><br><span class="line"> <span class="number">8</span> checkcast #<span class="number">17</span> &lt;java/lang/String&gt;<span class="comment">// 把obj转为string类型</span></span><br><span class="line"><span class="number">11</span> areturn<span class="comment">//返回字符串</span></span><br><span class="line"><span class="number">12</span> aconst_null<span class="comment">//返回null</span></span><br><span class="line"><span class="number">13</span> areturn<span class="comment">//方法结束，默认加return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="方法调用与返回指令"><a href="#方法调用与返回指令" class="headerlink" title="方法调用与返回指令"></a>方法调用与返回指令</h2><blockquote>
<h2 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h2><p>invokcvirtual 运行时按照对象的类来调用实例方法</p>
<p>invokespecial 根据编译时类型来调用实例方法</p>
<p>invokestatic 调用类（静态）方法</p>
<p>invokcinterface 调用接口方法</p>
<h2 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h2><p>ireturn 从方法中返回int类型的数据</p>
<p>lreturn 从方法中返回long类型的数据</p>
<p>freturn 从方法中返回float类型的数据</p>
<p>dreturn 从方法中返回double类型的数据</p>
<p>areturn 从方法中返回引用类型的数据</p>
<p>return 从方法中返回，返回值为void</p>
</blockquote>
<h3 id="方法调用指令-1"><a href="#方法调用指令-1" class="headerlink" title="方法调用指令"></a>方法调用指令</h3><table>
<thead>
<tr>
<th>方法调用指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>invokevirtual</td>
<td>调用对象的实例方法</td>
</tr>
<tr>
<td>invokeinterface</td>
<td>调用接口方法</td>
</tr>
<tr>
<td>invokespecial</td>
<td>调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法</td>
</tr>
<tr>
<td>invokestatic</td>
<td>调用命名类中的类方法（static方法）</td>
</tr>
<tr>
<td>invokedynamic</td>
<td>调用动态绑定的方法</td>
</tr>
</tbody></table>
<p>方法调用指令：</p>
<p> invokevirtual、invokeinterface、invokespecial、invokestatic . invokedynamic</p>
<p>以下5条指令用于方法调用：</p>
<ul>
<li>invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是Java语言中最常见的方法分派方式。</li>
<li>invokeinterface指令：用于调用接口方法，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用。</li>
<li>invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器〉、私有方法和父类方法。这些方法都是静态类型绑定的，不会在调用时进行动态派发。</li>
<li>invokestatic指令：用于调用命名类中的类方法(static方法）。这是静态绑定的。</li>
<li>invokedynamic：调用动态绑定的方法，这个是JDK 1.7后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面4条调用指令的分派逻辑都固化在 java虚拟机内部，而 invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。  </li>
</ul>
<h4 id="举例一"><a href="#举例一" class="headerlink" title="举例一"></a>举例一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法调用指令：invokespecial</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 情况1：类实例构造器方法：&lt;init&gt; invokespecial</span></span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread();</span><br><span class="line">    <span class="comment">// 情况2：父类的方法  invokespecial</span></span><br><span class="line">    <span class="keyword">super</span>.toString();</span><br><span class="line">    <span class="comment">// 情况3：私有方法  invokespecial</span></span><br><span class="line">    methodPrivate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用静态方法：invokestatic</span></span><br><span class="line"><span class="comment">// 调用private static也是用的invokestatic</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    methodStatic();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread();</span><br><span class="line">    <span class="comment">// 调用Runnable接口的run方法 invokeinterface</span></span><br><span class="line">    ((Runnable) t1).run();</span><br><span class="line"></span><br><span class="line">    Comparable&lt;Integer&gt; com = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 这里调用了两个方法</span></span><br><span class="line">    <span class="comment">// 首先会调用Integer.valueof方法    invokestatic #10 &lt;java/lang/Integer.valueOf&gt;</span></span><br><span class="line">    <span class="comment">// 然后调用 invokeinterface #11 &lt;java/lang/Comparable.compareTo&gt; count 2</span></span><br><span class="line">    com.compareTo(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello,lvxiaoyi&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// prublc方法调用 invokevirtual</span></span><br><span class="line">    t1.run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="举例二-1"><a href="#举例二-1" class="headerlink" title="举例二"></a>举例二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lvxiaoyi.code6;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/16 10:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceMethodTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AA aa = <span class="keyword">new</span> BB();</span><br><span class="line">        System.out.println(AA.b);</span><br><span class="line">        aa.method2();</span><br><span class="line">        aa.method3();</span><br><span class="line">        AA.method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AA</span> <span class="keyword">extends</span> <span class="title">DD</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,lvxiaoyi. I&#x27;m static method1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,lvxiaoyi. I&#x27;m default method2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span> <span class="keyword">implements</span> <span class="title">AA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method8</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CC</span> <span class="keyword">implements</span> <span class="title">AA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,lvxiaoyi. I&#x27;m default method4()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,lvxiaoyi. I&#x27;m static method6&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DD</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method7</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method8</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到这里突然发现一个问题，接口里面的方法在jdk8（这里没有函数式注解），也可以有静态和默认（不是抽象的）的方法，也都可以有实现，这里大部分文章都是老的（天下文章一大抄），抽象方法不能有实现。</p>
<p>成员量只能是public static final，默认也是</p>
<p>接口中不能有代码块</p>
<p>还有就是接口可是继承接口，实现接口的类必须实习父类（还有祖父类）<strong>所有的抽象方法</strong>。</p>
<p>接口主要是为了对类的行为规范（对API的抽象）</p>
<p>抽象类是为了对类的规范（提高代码复用）</p>
<h3 id="方法返回指令-1"><a href="#方法返回指令-1" class="headerlink" title="方法返回指令"></a>方法返回指令</h3><table>
<thead>
<tr>
<th>方法返回指令</th>
<th>void</th>
<th>int</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th>reference</th>
</tr>
</thead>
<tbody><tr>
<td><strong>xreturn</strong></td>
<td>return</td>
<td>ireturn</td>
<td>lreturn</td>
<td>freutrn</td>
<td>dreturn</td>
<td>areturn</td>
</tr>
</tbody></table>
<p>方法返回指令：</p>
<p>方法调用结束前，需要进行返回。方法返回指令是<strong>根据返回值的类型区分</strong>的。</p>
<ul>
<li>包括ireturn（当返回值是 boolean、byte、char、short和int类型时使用)、lreturn、freturn、dreturn和areturn</li>
<li>另外还有一条return指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用。</li>
</ul>
<p>举例：</p>
<p>通过ireturn指令,将当前函数操作数栈的顶层元素弹出，并将这个元素压入调用者函数的操作数栈中（因为调用者非常关心函数的返回值），所有在当前函数操作数栈中的其他元素都会被丢弃。</p>
<p>如果当前返回的是synchronized方法，那么还会执行一个隐含的monitorexit指令，退出临界区。</p>
<p>最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">methodReturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">50</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (i + j) / k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/3fbd1f2ca9f4300eee5e0c4a0227a441.png/lvxiaoyi" alt="image-20210425222245665"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">returnInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">returnDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">returnString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello,lvxioayi&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] returnArr() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">returnFloat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 主要还是返回类型是什么   freturn</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">returnByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用的ireturn</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodReturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在另一个栈中调用 invokevirtual #17 &lt;top/lvxiaoyi/code6/MethodInvokeReturnTest.returnByte&gt;拿到方法返回值</span></span><br><span class="line">    <span class="comment">// 然后把方法返回值使用istore_1命令放入局部变量表</span></span><br><span class="line">    <span class="keyword">int</span> i = returnByte();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h2><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><blockquote>
<h2 id="通用-无类型）栈操作"><a href="#通用-无类型）栈操作" class="headerlink" title="通用(无类型）栈操作"></a>通用(无类型）栈操作</h2><p>nop 不做任何操作</p>
<p>pop 弹出栈顶端一个字长的内容</p>
<p>pop2 弹出栈顶端两个字长的内容</p>
<p>dup 复制栈顶部一个字长内容</p>
<p>dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈</p>
<p>dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈</p>
<p>dup2 复制栈顶部两个字长内容</p>
<p>dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈</p>
<p>dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈</p>
<p>swap 交换栈顶部两个字长内容</p>
</blockquote>
<p>操作数栈管理指令</p>
<p>如同操作一个普通数据结构中的堆栈那样，JVM提供的操作数栈管理指令，可以用于直接操作操作数栈的指令。</p>
<p>这类指令包括如下内容：</p>
<ul>
<li><p>将一个或两个元素从栈顶弹出，并且直接废弃:pop，pop2;</p>
</li>
<li><p>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶： dup,dup2，dup_x1,dup2_x1，dup_x2，dup2_x2;</p>
</li>
<li><p>将栈最顶端的两个Slot数值位置交换：swap。Java虚拟机没有提供交换两个64位数据类型（long、double）数值的指令。</p>
</li>
<li><p>指令nop,是一个非常特殊的指令，它的字节码为0x00。和汇编语言中的nop一样，它表示什么都不做。这条指令一般可用于调试、占位等。</p>
</li>
</ul>
<p>这些指令属于通用型，对栈的压入或者弹出无需指明数据类型。</p>
<p>说明：</p>
<ul>
<li>不带_x的指令是复制栈顶数据并压入栈顶。包括两个指令，dup和dup2.dup的系数代表要复制的slot个数。_<ul>
<li>dup开头的指令用于复制1个Slot的数据。例如1个int或1个reference类型数据</li>
<li> dup2开头的指令用于复制2个Slot的数据。例如1个long，或2个int，或1个int+1个float类型数据</li>
</ul>
</li>
<li>带_x的指令是复制栈顶数据并插入栈顶以下的某个位置。共有4个指令, dup_x1，dup2_x1,dup_x2，dup2_x2。对于带_x的复制插入指令，只要将指令的dup和x的系数相加，结果即为需要插入的位置。因此<ul>
<li>dup_x1插入位置：1+1=2，即栈顶2个slot下面. </li>
<li>dup_x2插入位置：1+2=3，即栈顶3个Slot下面.</li>
<li>dup2_x1插入位置：2+1=3，即栈顶3个slot下面.</li>
<li>dup2_x2插入位置：2+2=4，即栈顶4个Slot下面</li>
</ul>
</li>
<li>pop：将栈顶的1个Slot数值出栈。例如1个short类型数值</li>
<li>pop2：将栈顶的2个Slot数值出栈。例如1个double类型数值，或者2个int类型数值</li>
</ul>
<h3 id="举例一-1"><a href="#举例一-1" class="headerlink" title="举例一"></a>举例一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  9 invokevirtual #3 &lt;java/lang/Object.toString&gt;</span></span><br><span class="line"><span class="comment">     * 12 astore_2</span></span><br><span class="line"><span class="comment">     * 13 aload_1</span></span><br><span class="line"><span class="comment">     * 14 invokevirtual #3 &lt;java/lang/Object.toString&gt;</span></span><br><span class="line"><span class="comment">     * 17 pop</span></span><br><span class="line"><span class="comment">     * 18 return</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * pop指令是弹出栈顶的一个solt，因为obj.toString()不需要存储值也不需要返回，就直接弹出了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    String string = obj.toString();</span><br><span class="line">    obj.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里使用的pop2，因为long占据两个solt</span></span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="举例二-2"><a href="#举例二-2" class="headerlink" title="举例二"></a>举例二</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> aload_0 <span class="comment">// 把0放入栈中</span></span><br><span class="line"> <span class="number">1</span> dup<span class="comment">// 复制一份数据</span></span><br><span class="line"> <span class="number">2</span> getfield #<span class="number">2</span> &lt;top/lvxiaoyi/code7/StackOperateTest.index&gt;<span class="comment">// 给StackOperateTest.index赋值，弹出栈</span></span><br><span class="line"> <span class="number">5</span> dup2_x1<span class="comment">// 赋值一份数据，然后当前栈贞向下移动三个solt（2+1）</span></span><br><span class="line"> <span class="number">6</span> lconst_1<span class="comment">// 把1放入栈</span></span><br><span class="line"> <span class="number">7</span> ladd<span class="comment">// 执行++操作也就是add指令，选择栈顶的两个元素想加</span></span><br><span class="line"> <span class="number">8</span> putfield #<span class="number">2</span> &lt;top/lvxiaoyi/code7/StackOperateTest.index&gt;<span class="comment">// 给StackOperateTest.index赋值，弹出栈</span></span><br><span class="line"><span class="number">11</span> lreturn<span class="comment">// 返回栈顶元素也就是第五步复制前的数据，所以这里应该返回的是0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210916150200794.png/lvxiaoyi" alt="image-20210916150200794"></p>
<h2 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h2><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><p>程序流程离不开条件控制，为了支持条件跳转，虚拟机提供了大量字节码指令，大体上可以分为</p>
<ol>
<li>比较指令</li>
<li>条件跳转指令</li>
<li>比较条件跳转指令</li>
<li>多条件分支跳转指令</li>
<li>无条件跳转指令等</li>
</ol>
<blockquote>
<h2 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h2><p>lcmp 比较long类型值</p>
<p>fcmpl 比较float类型值（当遇到NaN时，返回-1）</p>
<p>fcmpg 比较float类型值（当遇到NaN时，返回1）</p>
<p>dcmpl 比较double类型值（当遇到NaN时，返回-1）</p>
<p>dcmpg 比较double类型值（当遇到NaN时，返回1）</p>
<h2 id="条件分支指令"><a href="#条件分支指令" class="headerlink" title="条件分支指令"></a>条件分支指令</h2><p>ifeq 如果等于0，则跳转</p>
<p>ifne 如果不等于0，则跳转</p>
<p>iflt 如果小于0，则跳转</p>
<p>ifge 如果大于等于0，则跳转</p>
<p>ifgt 如果大于0，则跳转</p>
<p>ifle 如果小于等于0，则跳转</p>
<h2 id="比较条件分支指令"><a href="#比较条件分支指令" class="headerlink" title="比较条件分支指令"></a>比较条件分支指令</h2><p>if_icmpeq 如果两个int值相等，则跳转</p>
<p>if_icmpne 如果两个int类型值不相等，则跳转</p>
<p>if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转</p>
<p>if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转</p>
<p>if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转</p>
<p>if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转</p>
<p>ifnull 如果等于null，则跳转</p>
<p>ifnonnull 如果不等于null，则跳转</p>
<p>if_acmpeq 如果两个对象引用相等，则跳转</p>
<p>if_acmpne 如果两个对象引用不相等，则跳转</p>
<h2 id="多条件分支跳转指令"><a href="#多条件分支跳转指令" class="headerlink" title="多条件分支跳转指令"></a>多条件分支跳转指令</h2><p>tableswitch 通过索引访问跳转表，并跳转</p>
<p>lookupswitch 通过键值匹配访问跳转表，并执行跳转操作</p>
<h2 id="无条件跳转指令"><a href="#无条件跳转指令" class="headerlink" title="无条件跳转指令"></a>无条件跳转指令</h2><p>goto 无条件跳转</p>
<p>goto_w 无条件跳转（宽索引）</p>
</blockquote>
<p>英语单词：</p>
<p>大于：<code>greater than</code></p>
<p>等于：<code>equal</code></p>
<p>小于：<code>less than</code></p>
<p>不等于：<code>unequal</code> 或者 not equal</p>
<h3 id="比较指令-1"><a href="#比较指令-1" class="headerlink" title="比较指令"></a>比较指令</h3><p>比较指令的作用是比较占栈顶两个元素的大小，并将比较结果入栽。</p>
<p>比较指令有： dcmpg、dcmpl、 fcmpg、fcmpl、lcmp</p>
<p>与前面讲解的指令类似，首字符d表示double类型，f表示float,l表示long.</p>
<p>对于double和float类型的数字，由于NaN的存在，各有两个版本的比较指令。以float为例，有fcmpg和fcmpl两个指令，它们的区别在于在数字比较时，若遇到NaN值，处理结果不同。</p>
<p>指令dcmpl和 dcmpg也是类似的，根据其命名可以推测其含义，在此不再赘述。</p>
<p>举例：</p>
<p>指令 fcmp和fcmpl都从中弹出两个操作数，并将它们做比较，设栈顶的元素为v2,顶顺位第2位的元素为v1,若v1=v2,则压入0:若v1&gt;v2则压入1:若v1&lt;v2则压入-1.</p>
<p><strong>两个指令的不同之处在于，如果遇到NaN值， fcmpg会压入1,而fcmpl会压入-1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compare2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f1 = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">float</span> f2 = <span class="number">10</span>;</span><br><span class="line">    System.out.println(f1 &lt; f2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> ldc #<span class="number">2</span> &lt;<span class="number">9.0</span>&gt;</span><br><span class="line"> <span class="number">2</span> fstore_1</span><br><span class="line"> <span class="number">3</span> ldc #<span class="number">3</span> &lt;<span class="number">10.0</span>&gt;</span><br><span class="line"> <span class="number">5</span> fstore_2</span><br><span class="line"> <span class="number">6</span> getstatic #<span class="number">4</span> &lt;java/lang/System.out&gt;</span><br><span class="line"> <span class="number">9</span> fload_1 <span class="comment">// 栈顶元素V1 9.0</span></span><br><span class="line"><span class="number">10</span> fload_2<span class="comment">// 栈顶元素V2 10.0</span></span><br><span class="line"><span class="number">11</span> fcmpg <span class="comment">// 弹出连个操作数进行比较， V1 less than V2 ,so  压入-1</span></span><br><span class="line"><span class="number">12</span> ifge <span class="number">19</span> (+<span class="number">7</span>)<span class="comment">// 如果大于0，调转到19行，否则继续执行，弹出</span></span><br><span class="line"><span class="number">15</span> iconst_1<span class="comment">// 栈中压入1</span></span><br><span class="line"><span class="number">16</span> goto <span class="number">20</span> (+<span class="number">4</span>)<span class="comment">// 跳转到20行</span></span><br><span class="line"><span class="number">19</span> iconst_0<span class="comment">// 栈中压入0</span></span><br><span class="line"><span class="number">20</span> invokevirtual #<span class="number">5</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">23</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="条件跳转指令"><a href="#条件跳转指令" class="headerlink" title="条件跳转指令"></a>条件跳转指令</h3><table>
<thead>
<tr>
<th>&lt;</th>
<th>&lt;=</th>
<th>==</th>
<th>!=</th>
<th>&gt;=</th>
<th>&gt;</th>
<th>null</th>
<th>not null</th>
</tr>
</thead>
<tbody><tr>
<td>iflt</td>
<td>ifle</td>
<td>ifeq</td>
<td>ifng</td>
<td>ifge</td>
<td>ifgt</td>
<td>ifnull</td>
<td>ifnonnull</td>
</tr>
</tbody></table>
<p>一、条件跳转指令.</p>
<p>条件跳转指令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转。</p>
<p>条件跳转指令有： ifeq， iflt， ifle，ifne，ifgt，ifge，ifnull，ifnonnull。这些指令都接收两个字节的操作数，用于计算跳转的位置(16位符号整数作为当前位置的offset)。</p>
<p>它们的统一含义为：弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定位置。</p>
<p>具体说明：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ifeq</td>
<td>当栈顶int类型数值等于0时跳转</td>
</tr>
<tr>
<td>ifne</td>
<td>当栈顶int类型数值不等于O时跳转</td>
</tr>
<tr>
<td>ifit</td>
<td>当栈]页int类型数值小于0时跳转</td>
</tr>
<tr>
<td>ifle</td>
<td>当栈顶int类型数值小于等于0时跳转</td>
</tr>
<tr>
<td>ifgt</td>
<td>当栈顶int类型数组大于0时跳转</td>
</tr>
<tr>
<td>ifge</td>
<td>当栈顶int类型数值大于等于0时跳转</td>
</tr>
<tr>
<td>ifnull</td>
<td>为null时跳转</td>
</tr>
<tr>
<td>ifnonnull</td>
<td>不为null时跳转</td>
</tr>
</tbody></table>
<p>注意：</p>
<p>1.与前面运算规则一致：</p>
<ul>
<li>对于boolean、byte、char、short类型的条件分支比较操作，都是使用int类型的比较指令完成</li>
<li>对于long、float、double类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转 </li>
</ul>
<p>2.由于各类型的比较最终都会转为 int类型的比较操作，所以Java虚拟机提供的int类型的条件分支指令是最为丰富和强大的。</p>
<h4 id="举例一-2"><a href="#举例一-2" class="headerlink" title="举例一"></a>举例一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compare1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>)&#123;</span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        a = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_0</span><br><span class="line"> <span class="number">1</span> istore_1</span><br><span class="line"> <span class="number">2</span> iload_1</span><br><span class="line"> <span class="number">3</span> ifne <span class="number">12</span> (+<span class="number">9</span>)   <span class="comment">//如果栈顶元素不等于0跳转到12行，等于0乡下执行</span></span><br><span class="line"> <span class="number">6</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">8</span> istore_1</span><br><span class="line"> <span class="number">9</span> goto <span class="number">15</span> (+<span class="number">6</span>)<span class="comment">// if里面的代码执行完毕，跳转到15行</span></span><br><span class="line"><span class="number">12</span> bipush <span class="number">20</span><span class="comment">//else里面的代码执行</span></span><br><span class="line"><span class="number">14</span> istore_1</span><br><span class="line"><span class="number">15</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h4 id="举例二-3"><a href="#举例二-3" class="headerlink" title="举例二"></a>举例二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareNull</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> aload_1<span class="comment">// 把str指针放入栈中</span></span><br><span class="line"><span class="number">1</span> ifnonnull <span class="number">6</span> (+<span class="number">5</span>)<span class="comment">//如果不是null 跳转到第六行</span></span><br><span class="line"><span class="number">4</span> iconst_1 <span class="comment">//栈中放入1</span></span><br><span class="line"><span class="number">5</span> ireturn</span><br><span class="line"><span class="number">6</span> iconst_0<span class="comment">// 栈中放入0 </span></span><br><span class="line"><span class="number">7</span> ireturn</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="比较条件跳转指令"><a href="#比较条件跳转指令" class="headerlink" title="比较条件跳转指令"></a>比较条件跳转指令</h3><table>
<thead>
<tr>
<th>&lt;</th>
<th>&lt;=</th>
<th>==</th>
<th>!=</th>
<th>&gt;=</th>
<th>&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>if_icmplt</td>
<td>if_icmple</td>
<td>if_icmpeq、if_acmpeq</td>
<td>if_icmpne、if_acmpne</td>
<td>if_icmpge</td>
<td>if_icmpgt</td>
</tr>
</tbody></table>
<p>二、比较条件跳转指令</p>
<p>比较条件跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一。</p>
<p>这类指令有： if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne。其中指令助记符加上“if_”后，以字符“i”开头的指令针对int型整数操作(也包括short和byte类型)，以字符“a”开头的指令表示对象引用的比较。</p>
<p>具体说明：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>if_icmpeq</td>
<td>比较栈顶两int类型数值大小，当前者等于后者时跳转</td>
</tr>
<tr>
<td>if_icmpne</td>
<td>比较栈顶两int类型数值大小，当前者不等于后者时跳转</td>
</tr>
<tr>
<td>if_icmplt</td>
<td>比较栈页两int类型数值大小，当前者小于后者时跳转</td>
</tr>
<tr>
<td>if_icmple</td>
<td>比较栈顶两int类型数值大小，当前者小于等于后者时跳转</td>
</tr>
<tr>
<td>if_icmpgt</td>
<td>比较栈顶两int类型数值大小，当前者大于后者时跳转</td>
</tr>
<tr>
<td>if_icmpge</td>
<td>比较栈顶两int类型数值大小，当前者大于等于后者时跳转</td>
</tr>
<tr>
<td>if_acmpeq</td>
<td>比较栈顶两引用类型数值，当结果相等时跳转</td>
</tr>
<tr>
<td>if_acmpne</td>
<td>比较栈页两引用类型数值，当结果不相等时跳转</td>
</tr>
</tbody></table>
<p>这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置。同时在执行指令时，栈顶需要准备两个元素进行比较。指令执行完成后，栈顶的这两个元素被清空，且没有任何数据入栈。如果预设条件成立，则执行跳转，否则，继续执行下一条语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ifCompare1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">    System.out.println(i &lt; j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ifCompare2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">short</span> s1 = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">byte</span> b1 = <span class="number">10</span>;</span><br><span class="line">    System.out.println(s1 &gt; b1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ifCompare3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">    Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line">    System.out.println(obj1 == obj2);</span><br><span class="line">    System.out.println(obj1 != obj2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//ifCompare1</span></span><br><span class="line"> <span class="number">0</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> bipush <span class="number">20</span></span><br><span class="line"> <span class="number">5</span> istore_2</span><br><span class="line"> <span class="number">6</span> getstatic #<span class="number">4</span> &lt;java/lang/System.out&gt;</span><br><span class="line"> <span class="number">9</span> iload_1 <span class="comment">//V1 10</span></span><br><span class="line"><span class="number">10</span> iload_2 <span class="comment">//v2 20</span></span><br><span class="line"><span class="number">11</span> if_icmpge <span class="number">18</span> (+<span class="number">7</span>)<span class="comment">// 如果V1大于等于V2则跳转到18行，否则继续执行</span></span><br><span class="line"><span class="number">14</span> iconst_1</span><br><span class="line"><span class="number">15</span> goto <span class="number">19</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">18</span> iconst_0</span><br><span class="line"><span class="number">19</span> invokevirtual #<span class="number">5</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">22</span> <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ifCompare2</span></span><br><span class="line"> <span class="number">0</span> bipush <span class="number">9</span> <span class="comment">// short 和 byte也都是用的int的类型</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">5</span> istore_2</span><br><span class="line"> <span class="number">6</span> getstatic #<span class="number">4</span> &lt;java/lang/System.out&gt;</span><br><span class="line"> <span class="number">9</span> iload_1</span><br><span class="line"><span class="number">10</span> iload_2</span><br><span class="line"><span class="number">11</span> if_icmple <span class="number">18</span> (+<span class="number">7</span>)<span class="comment">// 如果V1小于等于V2则跳转到18行，否则继续执行</span></span><br><span class="line"><span class="number">14</span> iconst_1</span><br><span class="line"><span class="number">15</span> goto <span class="number">19</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">18</span> iconst_0</span><br><span class="line"><span class="number">19</span> invokevirtual #<span class="number">5</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">22</span> <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ifCompare3</span></span><br><span class="line"> <span class="number">0</span> <span class="keyword">new</span> #<span class="number">8</span> &lt;java/lang/Object&gt;</span><br><span class="line"> <span class="number">3</span> dup</span><br><span class="line"> <span class="number">4</span> invokespecial #<span class="number">1</span> &lt;java/lang/Object.&lt;init&gt;&gt;</span><br><span class="line"> <span class="number">7</span> astore_1</span><br><span class="line"> <span class="number">8</span> <span class="keyword">new</span> #<span class="number">8</span> &lt;java/lang/Object&gt;</span><br><span class="line"><span class="number">11</span> dup</span><br><span class="line"><span class="number">12</span> invokespecial #<span class="number">1</span> &lt;java/lang/Object.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">15</span> astore_2</span><br><span class="line"><span class="number">16</span> getstatic #<span class="number">4</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">19</span> aload_1<span class="comment">//V1 obj1</span></span><br><span class="line"><span class="number">20</span> aload_2<span class="comment">//v2 obj2</span></span><br><span class="line"><span class="number">21</span> if_acmpne <span class="number">28</span> (+<span class="number">7</span>)<span class="comment">// 如果V1不等于V2则跳转到28行，否则继续执行</span></span><br><span class="line"><span class="number">24</span> iconst_1</span><br><span class="line"><span class="number">25</span> goto <span class="number">29</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">28</span> iconst_0</span><br><span class="line"><span class="number">29</span> invokevirtual #<span class="number">5</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">32</span> getstatic #<span class="number">4</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">35</span> aload_1<span class="comment">//V1 obj1</span></span><br><span class="line"><span class="number">36</span> aload_2<span class="comment">//v2 obj2</span></span><br><span class="line"><span class="number">37</span> if_acmpeq <span class="number">44</span> (+<span class="number">7</span>)<span class="comment">// 如果V1等于V2则跳转到44行，否则继续执行</span></span><br><span class="line"><span class="number">40</span> iconst_1</span><br><span class="line"><span class="number">41</span> goto <span class="number">45</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">44</span> iconst_0</span><br><span class="line"><span class="number">45</span> invokevirtual #<span class="number">5</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">48</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="多条件分支跳转"><a href="#多条件分支跳转" class="headerlink" title="多条件分支跳转"></a>多条件分支跳转</h3><p>三、多条件分支跳转指令</p>
<p>多条件分支跳转指令是专为switch-case语句设计的，主要有tableswitch和lookupswitch。</p>
<table>
<thead>
<tr>
<th>指令名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>tableswitch</td>
<td>用于switch条件跳转，case值连续</td>
</tr>
<tr>
<td>lookupswitch</td>
<td>用于switch条件跳转，case值不连续</td>
</tr>
</tbody></table>
<p>从助记符上看，两者都是switch语句的实现，它们的区别：</p>
<ul>
<li>tableswitch要求多个条件分支值是连续的，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数index，可以立即定位到跳转偏移量位置，因此效率比较高。</li>
<li>指令lookupswitch内部存放着各个离散的case-offset对，每次执行都要搜索全部的case-offset对，找到匹配的case值，并根据对应的offset计算跳转地址，因此效率较低。</li>
</ul>
<p>指令tableswitch的示意图如下图所示。由于tableswitch的case值是连续的，因此只需要记录最低值和最高值，以及每项对应的offset偏移量，根据给定的index值通过简单的计算即可直接定位到offset。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210914154108950.png/lvxiaoyi" alt="image-20210914154108950" style="zoom: 67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swtich1</span><span class="params">(<span class="keyword">int</span> select)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">switch</span> (select) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            num = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            num = <span class="number">20</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            num = <span class="number">30</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            num = <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iload_1</span><br><span class="line"> <span class="number">1</span> tableswitch <span class="number">1</span> to <span class="number">3</span>	<span class="comment">// switch 跳转1到3</span></span><br><span class="line">     		<span class="number">1</span>:  <span class="number">28</span> (+<span class="number">27</span>) <span class="comment">// 如果栈顶是1，跳转到28行</span></span><br><span class="line">            <span class="number">2</span>:  <span class="number">34</span> (+<span class="number">33</span>)<span class="comment">// 如果栈顶是2，跳转到34行</span></span><br><span class="line">            <span class="number">3</span>:  <span class="number">40</span> (+<span class="number">39</span>)<span class="comment">// 如果栈顶是3，跳转到40行</span></span><br><span class="line">            <span class="keyword">default</span>:  <span class="number">46</span> (+<span class="number">45</span>)<span class="comment">// 如果都不是，跳转到46行</span></span><br><span class="line"><span class="number">28</span> bipush <span class="number">10</span></span><br><span class="line"><span class="number">30</span> istore_2</span><br><span class="line"><span class="number">31</span> goto <span class="number">49</span> (+<span class="number">18</span>)<span class="comment">//如果没有break就没哟这个goto跳转指令，接着向下执行</span></span><br><span class="line"><span class="number">34</span> bipush <span class="number">20</span></span><br><span class="line"><span class="number">36</span> istore_2</span><br><span class="line"><span class="number">37</span> goto <span class="number">49</span> (+<span class="number">12</span>)</span><br><span class="line"><span class="number">40</span> bipush <span class="number">30</span></span><br><span class="line"><span class="number">42</span> istore_2</span><br><span class="line"><span class="number">43</span> goto <span class="number">49</span> (+<span class="number">6</span>)</span><br><span class="line"><span class="number">46</span> bipush <span class="number">40</span></span><br><span class="line"><span class="number">48</span> istore_2</span><br><span class="line"><span class="number">49</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>指令lookupswitch处理的是离散的case值，但是出于效率考虑，将case-offset对按照case值大小排序，给定index时，需要查找与index相等的case,获得其offset,如果找不到则跳转到default。指令lookupswitch 如下图所示。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210914154118957.png/lvxiaoyi" alt="image-20210914154118957" style="zoom: 67%;" />

<h4 id="举例一-3"><a href="#举例一-3" class="headerlink" title="举例一"></a>举例一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swtich2</span><span class="params">(<span class="keyword">int</span> select)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">switch</span> (select) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">            num = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">200</span>:</span><br><span class="line">            num = <span class="number">20</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">300</span>:</span><br><span class="line">            num = <span class="number">30</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            num = <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iload_1</span><br><span class="line"> <span class="number">1</span> lookupswitch <span class="number">3</span><span class="comment">// switch 中有3个case，这里不在连续的</span></span><br><span class="line">	<span class="number">100</span>:  <span class="number">36</span> (+<span class="number">35</span>)<span class="comment">// 还是和上面的一样，这里编译器会对case自动优化重排序，从小到大</span></span><br><span class="line">	<span class="number">200</span>:  <span class="number">42</span> (+<span class="number">41</span>)</span><br><span class="line">	<span class="number">300</span>:  <span class="number">48</span> (+<span class="number">47</span>)</span><br><span class="line">	<span class="keyword">default</span>:  <span class="number">54</span> (+<span class="number">53</span>)</span><br><span class="line"><span class="number">36</span> bipush <span class="number">10</span></span><br><span class="line"><span class="number">38</span> istore_2</span><br><span class="line"><span class="number">39</span> goto <span class="number">57</span> (+<span class="number">18</span>)</span><br><span class="line"><span class="number">42</span> bipush <span class="number">20</span></span><br><span class="line"><span class="number">44</span> istore_2</span><br><span class="line"><span class="number">45</span> goto <span class="number">57</span> (+<span class="number">12</span>)</span><br><span class="line"><span class="number">48</span> bipush <span class="number">30</span></span><br><span class="line"><span class="number">50</span> istore_2</span><br><span class="line"><span class="number">51</span> goto <span class="number">57</span> (+<span class="number">6</span>)</span><br><span class="line"><span class="number">54</span> bipush <span class="number">40</span></span><br><span class="line"><span class="number">56</span> istore_2</span><br><span class="line"><span class="number">57</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="举例二-4"><a href="#举例二-4" class="headerlink" title="举例二"></a>举例二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk7的时候引入string类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swtich3</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;xiaoyi lv&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;Taylor Swift&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;Justin Bieber&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;Ariana Grande&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0</span> aload_1</span><br><span class="line">  <span class="number">1</span> astore_3</span><br><span class="line">  <span class="number">2</span> iconst_m1</span><br><span class="line">  <span class="number">3</span> istore <span class="number">4</span></span><br><span class="line">  <span class="number">5</span> aload_3</span><br><span class="line">  <span class="number">6</span> invokevirtual #<span class="number">9</span> &lt;java/lang/String.hashCode&gt;</span><br><span class="line">  <span class="number">9</span> lookupswitch <span class="number">4</span></span><br><span class="line">	-<span class="number">1874518336</span>:  <span class="number">82</span> (+<span class="number">73</span>) <span class="comment">// 这里使用把字符串转为hashcode</span></span><br><span class="line">	-<span class="number">921402410</span>:  <span class="number">67</span> (+<span class="number">58</span>)</span><br><span class="line">	-<span class="number">870391555</span>:  <span class="number">97</span> (+<span class="number">88</span>)</span><br><span class="line">	-<span class="number">353424101</span>:  <span class="number">52</span> (+<span class="number">43</span>)</span><br><span class="line">	<span class="keyword">default</span>:  <span class="number">109</span> (+<span class="number">100</span>)</span><br><span class="line"> <span class="number">52</span> aload_3</span><br><span class="line"> <span class="number">53</span> ldc #<span class="number">10</span> &lt;xiaoyi lv&gt;</span><br><span class="line"> <span class="number">55</span> invokevirtual #<span class="number">11</span> &lt;java/lang/String.equals&gt;<span class="comment">// 这里使用equals方法判断是否相等</span></span><br><span class="line"> <span class="number">58</span> ifeq <span class="number">109</span> (+<span class="number">51</span>)</span><br><span class="line"> <span class="number">61</span> iconst_0</span><br><span class="line"> <span class="number">62</span> istore <span class="number">4</span></span><br><span class="line"> <span class="number">64</span> goto <span class="number">109</span> (+<span class="number">45</span>)</span><br><span class="line"> <span class="number">67</span> aload_3</span><br><span class="line"> <span class="number">68</span> ldc #<span class="number">12</span> &lt;Taylor Swift&gt;</span><br><span class="line"> <span class="number">70</span> invokevirtual #<span class="number">11</span> &lt;java/lang/String.equals&gt;</span><br><span class="line"> <span class="number">73</span> ifeq <span class="number">109</span> (+<span class="number">36</span>)</span><br><span class="line"> <span class="number">76</span> iconst_1</span><br><span class="line"> <span class="number">77</span> istore <span class="number">4</span></span><br><span class="line"> <span class="number">79</span> goto <span class="number">109</span> (+<span class="number">30</span>)</span><br><span class="line"> <span class="number">82</span> aload_3</span><br><span class="line"> <span class="number">83</span> ldc #<span class="number">13</span> &lt;Justin Bieber&gt;</span><br><span class="line"> <span class="number">85</span> invokevirtual #<span class="number">11</span> &lt;java/lang/String.equals&gt;</span><br><span class="line"> <span class="number">88</span> ifeq <span class="number">109</span> (+<span class="number">21</span>)</span><br><span class="line"> <span class="number">91</span> iconst_2</span><br><span class="line"> <span class="number">92</span> istore <span class="number">4</span></span><br><span class="line"> <span class="number">94</span> goto <span class="number">109</span> (+<span class="number">15</span>)</span><br><span class="line"> <span class="number">97</span> aload_3</span><br><span class="line"> <span class="number">98</span> ldc #<span class="number">14</span> &lt;Ariana Grande&gt;</span><br><span class="line"><span class="number">100</span> invokevirtual #<span class="number">11</span> &lt;java/lang/String.equals&gt;</span><br><span class="line"><span class="number">103</span> ifeq <span class="number">109</span> (+<span class="number">6</span>)</span><br><span class="line"><span class="number">106</span> iconst_3</span><br><span class="line"><span class="number">107</span> istore <span class="number">4</span></span><br><span class="line"><span class="number">109</span> iload <span class="number">4</span></span><br><span class="line"><span class="number">111</span> tableswitch <span class="number">0</span> to <span class="number">3</span>	<span class="number">0</span>:  <span class="number">140</span> (+<span class="number">29</span>)</span><br><span class="line">	<span class="number">1</span>:  <span class="number">143</span> (+<span class="number">32</span>)</span><br><span class="line">	<span class="number">2</span>:  <span class="number">146</span> (+<span class="number">35</span>)</span><br><span class="line">	<span class="number">3</span>:  <span class="number">149</span> (+<span class="number">38</span>)</span><br><span class="line">	<span class="keyword">default</span>:  <span class="number">149</span> (+<span class="number">38</span>)</span><br><span class="line"><span class="number">140</span> goto <span class="number">149</span> (+<span class="number">9</span>)</span><br><span class="line"><span class="number">143</span> goto <span class="number">149</span> (+<span class="number">6</span>)</span><br><span class="line"><span class="number">146</span> goto <span class="number">149</span> (+<span class="number">3</span>)</span><br><span class="line"><span class="number">149</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<h3 id="无条件跳转"><a href="#无条件跳转" class="headerlink" title="无条件跳转"></a>无条件跳转</h3><p>四、无条件跳转指令</p>
<p>目前主要的无条件跳转指令为goto。指令goto接收两个字节的操作数，共同组成一个带符号的整数，用于指定指令的偏移量，指令执行的目的就是跳转到偏移量给定的位置处。</p>
<p>如果指令偏移量太大，超过双字节的带符号整数的范围，则可以使用指令goto_w,它和goto有相同的作用，但是它接收4个字节的操作数，可以表示更大的地址范围。</p>
<p>指令jsr、jsr_w、ret虽然也是无条件跳转的，但主要用于try-finally语句，且已经被虚拟机逐渐废弃，故不在这里介绍这两个指令。</p>
<table>
<thead>
<tr>
<th>指令名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>goto</td>
<td>无条件跳转</td>
</tr>
<tr>
<td>goto_w</td>
<td>无条件跳转(宽索引)</td>
</tr>
<tr>
<td>jsr</td>
<td>跳转至指定16位offset位置，并将jsr下一条指令地址压入栈顶</td>
</tr>
<tr>
<td>jsr_w</td>
<td>跳转至指定32位offer位置，并将jsr_w下一条指令地址压入栈顶</td>
</tr>
<tr>
<td>ret</td>
<td>返回至由指定的局部变量所给出的指令位置(一般与jsr、jsr_w联合使用)</td>
</tr>
</tbody></table>
<h4 id="举例一-4"><a href="#举例一-4" class="headerlink" title="举例一"></a>举例一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whileInt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">100</span>)&#123;</span><br><span class="line">        String s = <span class="string">&quot;lvxiaoyi.top&quot;</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_0</span><br><span class="line"> <span class="number">1</span> istore_1</span><br><span class="line"> <span class="number">2</span> iload_1 <span class="comment">// 把0加载到栈中 V1</span></span><br><span class="line"> <span class="number">3</span> bipush <span class="number">100</span> <span class="comment">// 加载100 V2</span></span><br><span class="line"> <span class="number">5</span> if_icmpge <span class="number">17</span> (+<span class="number">12</span>)<span class="comment">// V1大于等于V2 跳转到17行，出栈</span></span><br><span class="line"> <span class="number">8</span> ldc #<span class="number">15</span> &lt;lvxiaoyi.top&gt; <span class="comment">// 记在字符串</span></span><br><span class="line"><span class="number">10</span> astore_2<span class="comment">// 指针放在局部变量表，出栈</span></span><br><span class="line"><span class="number">11</span> iinc <span class="number">1</span> by <span class="number">1</span><span class="comment">// 局部变量表直接加一</span></span><br><span class="line"><span class="number">14</span> goto <span class="number">2</span> (-<span class="number">12</span>)<span class="comment">// 跳转到第二行</span></span><br><span class="line"><span class="number">17</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="举例二-5"><a href="#举例二-5" class="headerlink" title="举例二"></a>举例二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whileDouble</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">while</span> (d &lt; <span class="number">100.1</span>)&#123;</span><br><span class="line">        String s = <span class="string">&quot;lvxiaoyi.top&quot;</span>;</span><br><span class="line">        d++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> dconst_0</span><br><span class="line"> <span class="number">1</span> dstore_1</span><br><span class="line"> <span class="number">2</span> dload_1</span><br><span class="line"> <span class="number">3</span> ldc2_w #<span class="number">16</span> &lt;<span class="number">100.1</span>&gt;</span><br><span class="line"> <span class="number">6</span> dcmpg</span><br><span class="line"> <span class="number">7</span> ifge <span class="number">20</span> (+<span class="number">13</span>)</span><br><span class="line"><span class="number">10</span> ldc #<span class="number">15</span> &lt;lvxiaoyi.top&gt;</span><br><span class="line"><span class="number">12</span> astore_3<span class="comment">// double占了两个solt</span></span><br><span class="line"><span class="number">13</span> dload_1<span class="comment">// 这里的i++分为了三个指令</span></span><br><span class="line"><span class="number">14</span> dconst_1 </span><br><span class="line"><span class="number">15</span> dadd</span><br><span class="line"><span class="number">16</span> dstore_1</span><br><span class="line"><span class="number">17</span> goto <span class="number">2</span> (-<span class="number">15</span>)</span><br><span class="line"><span class="number">20</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="举例三-1"><a href="#举例三-1" class="headerlink" title="举例三"></a>举例三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printFor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        String s = <span class="string">&quot;lvxiaoyi.top&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_0</span><br><span class="line"> <span class="number">1</span> istore_1</span><br><span class="line"> <span class="number">2</span> iload_1</span><br><span class="line"> <span class="number">3</span> bipush <span class="number">100</span></span><br><span class="line"> <span class="number">5</span> if_icmpge <span class="number">19</span> (+<span class="number">14</span>)</span><br><span class="line"> <span class="number">8</span> ldc #<span class="number">15</span> &lt;lvxiaoyi.top&gt;</span><br><span class="line"><span class="number">10</span> astore_2</span><br><span class="line"><span class="number">11</span> iload_1</span><br><span class="line"><span class="number">12</span> iconst_1</span><br><span class="line"><span class="number">13</span> iadd<span class="comment">// short使用的int类型</span></span><br><span class="line"><span class="number">14</span> i2s<span class="comment">// 这里需要进行窄化降级</span></span><br><span class="line"><span class="number">15</span> istore_1</span><br><span class="line"><span class="number">16</span> goto <span class="number">2</span> (-<span class="number">14</span>)</span><br><span class="line"><span class="number">19</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="举例四-1"><a href="#举例四-1" class="headerlink" title="举例四"></a>举例四</h4><p>这两个有什么区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whileTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在这里可以继续使用i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWhileTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//whileTest()</span></span><br><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> <span class="number">1</span> istore_1</span><br><span class="line"> <span class="number">2</span> iload_1</span><br><span class="line"> <span class="number">3</span> bipush <span class="number">100</span></span><br><span class="line"> <span class="number">5</span> if_icmpgt <span class="number">14</span> (+<span class="number">9</span>)</span><br><span class="line"> <span class="number">8</span> iinc <span class="number">1</span> by <span class="number">1</span></span><br><span class="line"><span class="number">11</span> goto <span class="number">2</span> (-<span class="number">9</span>)</span><br><span class="line"><span class="number">14</span> <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//forTest()</span></span><br><span class="line"> <span class="comment">//和whileTest()没有区别</span></span><br><span class="line"> <span class="number">0</span> iconst_0</span><br><span class="line"> <span class="number">1</span> istore_1</span><br><span class="line"> <span class="number">2</span> iload_1</span><br><span class="line"> <span class="number">3</span> bipush <span class="number">100</span></span><br><span class="line"> <span class="number">5</span> if_icmpgt <span class="number">14</span> (+<span class="number">9</span>)</span><br><span class="line"> <span class="number">8</span> iinc <span class="number">1</span> by <span class="number">1</span></span><br><span class="line"><span class="number">11</span> goto <span class="number">2</span> (-<span class="number">9</span>)</span><br><span class="line"><span class="number">14</span> <span class="keyword">return</span></span><br><span class="line">     </span><br><span class="line"><span class="comment">// doWhileTest</span></span><br><span class="line">     <span class="comment">//和whileTest()一个是先加加，一个是后加加</span></span><br><span class="line"><span class="number">0</span> iconst_1</span><br><span class="line"> <span class="number">1</span> istore_1</span><br><span class="line"> <span class="number">2</span> iinc <span class="number">1</span> by <span class="number">1</span></span><br><span class="line"> <span class="number">5</span> iload_1</span><br><span class="line"> <span class="number">6</span> bipush <span class="number">100</span></span><br><span class="line"> <span class="number">8</span> if_icmple <span class="number">2</span> (-<span class="number">6</span>)</span><br><span class="line"><span class="number">11</span> <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="举例五-1"><a href="#举例五-1" class="headerlink" title="举例五"></a>举例五</h4><p>我们在查看源码的时候经常看到ForTrue的写法来写死循环，看看为什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WhieTrue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ForTrue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WhieTrue()</span></span><br><span class="line"><span class="number">0</span> goto <span class="number">0</span> (<span class="number">0</span>)</span><br><span class="line"><span class="comment">//ForTrue</span></span><br><span class="line"><span class="number">0</span> goto <span class="number">0</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>我们可以看到这两个最后编译的指令都是一样的，看看是不是另有原因</p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/52311366">https://www.zhihu.com/question/52311366</a></p>
<p>结论：早期的C语言，两种写法性能会不一样。for语句编译器会优化成一条汇编指令，而while判断则编译器会生成好几条汇编指令；</p>
<p>在java中感觉while (true)更适合写死循环，没有最终结论</p>
<h2 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h2><h3 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h3><blockquote>
<h2 id="异常处理指令-1"><a href="#异常处理指令-1" class="headerlink" title="异常处理指令"></a>异常处理指令</h2><p>athrow 抛出异常或错误。将栈顶异常抛出</p>
<p>jsr 跳转到子例程</p>
<p>jsr_w 跳转到子例程（宽索引）</p>
<p>rct 从子例程返回</p>
</blockquote>
<p>(1) athrow指令</p>
<p>在3ava程序中显示抛出异常的操作（throw语句）都是由athrow指令来实现。</p>
<p>除了使用throw语句显示抛出异常情况之外，JVN规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如，在之前介绍的整数运算时，当除数为零时，虚拟机会在 idiv或ldiv指令中抛出ArithmeticException异常。</p>
<p>(2)注意</p>
<p>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是在抛异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上。</p>
<p>异常及异常的处理：</p>
<p>过程一：异常对象的生成过程 —&gt; throw（手动/自动）—&gt; 指令：athrow</p>
<p>过程二：异常的处理：抓抛模型。try-catch-finally       —&gt; 使用异常表</p>
<h3 id="抛出异常指令"><a href="#抛出异常指令" class="headerlink" title="抛出异常指令"></a>抛出异常指令</h3><p>athrow指令</p>
<p>在Java程序中显示抛出异常的操作(throw语句）都是由athrow指令来实现。</p>
<p>除了使用throw语句显示抛出异常情况之外，JVN规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如，在之前介绍的整数运算时，当除数为零时，虚拟机会在 idiv或ldiv指令中抛出ArithmeticException异常。</p>
<p>注意<br>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是在抛异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上。</p>
<p>异常表的含义是如果在Start PC和End PC之间（大于等于Start PC，小于End PC）出现对应的Catch Type异常问题（出现异常就匹配对应的异常），将会在操作数栈中压入相应的异常类对象，之后跳转到Handler PC的位置去执行对应的字节码指令</p>
<p>注意：</p>
<p>当异常出现的时候也会压入操作数栈，之后还会存储局部变量表中</p>
<p>如果使用throw new 异常名称()这种形式来抛出异常，那就会在代码中出现athrow指令，而在方法上面添加throw 异常名称这种形式来抛出异常，然后使用jclasslib的时候就会出现在方法下面多出现一个属性Exceptions，如下图所示：</p>
<h4 id="举例一-5"><a href="#举例一-5" class="headerlink" title="举例一"></a>举例一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwZero</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;参数值为0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iload_1</span><br><span class="line"> <span class="number">1</span> ifne <span class="number">14</span> (+<span class="number">13</span>) <span class="comment">// 如果不等于0则跳转到14行</span></span><br><span class="line"> <span class="number">4</span> <span class="keyword">new</span> #<span class="number">2</span> &lt;java/lang/RuntimeException&gt;</span><br><span class="line"> <span class="number">7</span> dup<span class="comment">// 复制一份</span></span><br><span class="line"> <span class="number">8</span> ldc #<span class="number">3</span> &lt;参数值为<span class="number">0</span>&gt;<span class="comment">// 把要打印的字符串放到栈中</span></span><br><span class="line"><span class="number">10</span> invokespecial #<span class="number">4</span> &lt;java/lang/RuntimeException.&lt;init&gt;&gt;<span class="comment">// 执行方法后出栈</span></span><br><span class="line"><span class="number">13</span> athrow<span class="comment">//把栈中的实例抛出，出栈</span></span><br><span class="line"><span class="number">14</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="举例二-6"><a href="#举例二-6" class="headerlink" title="举例二"></a>举例二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwOne</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;参数值为1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iload_1</span><br><span class="line"> <span class="number">1</span> iconst_1</span><br><span class="line"> <span class="number">2</span> if_icmpne <span class="number">15</span> (+<span class="number">13</span>)</span><br><span class="line"> <span class="number">5</span> <span class="keyword">new</span> #<span class="number">2</span> &lt;java/lang/RuntimeException&gt;</span><br><span class="line"> <span class="number">8</span> dup</span><br><span class="line"> <span class="number">9</span> ldc #<span class="number">5</span> &lt;参数值为<span class="number">1</span>&gt;</span><br><span class="line"><span class="number">11</span> invokespecial #<span class="number">4</span> &lt;java/lang/RuntimeException.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">14</span> athrow</span><br><span class="line"><span class="number">15</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwOne</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;参数值为1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iload_1</span><br><span class="line"> <span class="number">1</span> iconst_1</span><br><span class="line"> <span class="number">2</span> if_icmpne <span class="number">15</span> (+<span class="number">13</span>) <span class="comment">// 这里用的和1比较，如果不等于</span></span><br><span class="line"> <span class="number">5</span> <span class="keyword">new</span> #<span class="number">2</span> &lt;java/lang/RuntimeException&gt;</span><br><span class="line"> <span class="number">8</span> dup</span><br><span class="line"> <span class="number">9</span> ldc #<span class="number">3</span> &lt;参数值为<span class="number">1</span>&gt;</span><br><span class="line"><span class="number">11</span> invokespecial #<span class="number">4</span> &lt;java/lang/RuntimeException.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">14</span> athrow</span><br><span class="line"><span class="number">15</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>加不加 throws RuntimeException</p>
<p>多个一个与code并列的Exception</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210917173010920.png/lvxiaoyi" alt="image-20210917173010920" style="zoom:50%;" />



<h3 id="异常处理与异常表"><a href="#异常处理与异常表" class="headerlink" title="异常处理与异常表"></a>异常处理与异常表</h3><p>1、处理异常：<br>在Java虚拟机中，处理异常(catch语句）不是由字节码指令来实现的（早期使用jsr、ret指令），而是采用<strong>异常表</strong>来完成的。</p>
<p>2、异常表<br>如果一个方法定义了一个try-catch或者try-finally的异常处理，就会创建一个异常表。它包含了每个异常处理或者finally块的信息。异常表保存了每个异常处理信息。比如：</p>
<ul>
<li>起始位置</li>
<li>结束位置</li>
<li>程序计数器记录的代码处理的偏移地址</li>
<li>被捕获的异常类在常量池中的索引</li>
</ul>
<p>​         <strong>当一个异常被抛出时，JVA会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧</strong>，并且异常会重新抛给上层调用的方法(在调用方法栈帧)。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。如果这个异常在最后一个非守护线程里抛出，将会导致JVM自己终止，比如这个线程是个main线程。</p>
<p>​         不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行。在这种情况下，如果方法结束后没有抛出异常，仍然执行finally块，在return前，它直接跳到finally块来完成目标</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/daa25784fc259c12af58bb094d6ffc52.png/lvxiaoyi" alt="img"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/cba1429ffc09988d78008f5309a6374a.png/lvxiaoyi/lvxiaoyi" alt="img"></p>
<h4 id="举例一-6"><a href="#举例一-6" class="headerlink" title="举例一"></a>举例一</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void throwArithmetic() &#123;</span><br><span class="line">    int i = 10;</span><br><span class="line">    int j = i / 0;</span><br><span class="line">    System.out.println(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="举例二-7"><a href="#举例二-7" class="headerlink" title="举例二"></a>举例二</h4><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryCatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;d:/lvxiaoyi.txt&quot;</span>);</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        String info = <span class="string">&quot;hello! lvxiaoyi&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> <span class="keyword">new</span> #<span class="number">8</span> &lt;java/io/File&gt;</span><br><span class="line"> <span class="number">3</span> dup</span><br><span class="line"> <span class="number">4</span> ldc #<span class="number">9</span> &lt;d:/lvxiaoyi.txt&gt;</span><br><span class="line"> <span class="number">6</span> invokespecial #<span class="number">10</span> &lt;java/io/File.&lt;init&gt;&gt;<span class="comment">// File初始化，存放到局部变量表 </span></span><br><span class="line"> <span class="number">9</span> astore_1</span><br><span class="line"><span class="number">10</span> <span class="keyword">new</span> #<span class="number">11</span> &lt;java/io/FileInputStream&gt;<span class="comment">// </span></span><br><span class="line"><span class="number">13</span> dup</span><br><span class="line"><span class="number">14</span> aload_1</span><br><span class="line"><span class="number">15</span> invokespecial #<span class="number">12</span> &lt;java/io/FileInputStream.&lt;init&gt;&gt;<span class="comment">// FileInputStream初始化</span></span><br><span class="line"><span class="number">18</span> astore_2<span class="comment">// 存放到局部变量表</span></span><br><span class="line"><span class="number">19</span> ldc #<span class="number">13</span> &lt;hello! lvxiaoyi&gt;</span><br><span class="line"><span class="number">21</span> astore_3<span class="comment">// 字符串存放到局部变量表 跳转到38行，结束</span></span><br><span class="line"><span class="number">22</span> goto <span class="number">38</span> (+<span class="number">16</span>)</span><br><span class="line"><span class="number">25</span> astore_1<span class="comment">// 从这个地方开始就是异常的处理，得到异常类的对象，放入局部变量中</span></span><br><span class="line"><span class="number">26</span> aload_1</span><br><span class="line"><span class="number">27</span> invokevirtual #<span class="number">15</span> &lt;java/io/FileNotFoundException.printStackTrace&gt;<span class="comment">// 调用方法</span></span><br><span class="line"><span class="number">30</span> goto <span class="number">38</span> (+<span class="number">8</span>)</span><br><span class="line"><span class="number">33</span> astore_1</span><br><span class="line"><span class="number">34</span> aload_1</span><br><span class="line"><span class="number">35</span> invokevirtual #<span class="number">16</span> &lt;java/lang/RuntimeException.printStackTrace&gt;</span><br><span class="line"><span class="number">38</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="异常表："><a href="#异常表：" class="headerlink" title="异常表："></a>异常表：</h5><table>
<thead>
<tr>
<th>Nr.</th>
<th>起始PC</th>
<th>结束PC</th>
<th>跳转PC</th>
<th>捕获类型</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>22</td>
<td>25</td>
<td>cp_info #14<br />java/io/FileNotFoundException</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>22</td>
<td>33</td>
<td>cp_info #2<br />java/lang/RuntimeException</td>
</tr>
</tbody></table>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>从0到22如果出现FileNotFoundException异常，跳转到25行</p>
<p>从0到22如果出现java/lang/RuntimeException异常，跳转到33行</p>
<h4 id="举例三-2"><a href="#举例三-2" class="headerlink" title="举例三"></a>举例三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;lvxiaoyi&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> ldc #<span class="number">17</span> &lt;hello&gt;<span class="comment">// 把hello字符串地址放入栈</span></span><br><span class="line"> <span class="number">2</span> astore_0<span class="comment">// 放入局部变量表0的位置（静态的没有this）</span></span><br><span class="line"> <span class="number">3</span> aload_0<span class="comment">// 放入栈中</span></span><br><span class="line"> <span class="number">4</span> astore_1<span class="comment">// 放入局部变量表1的位置，相当于复制了有一份</span></span><br><span class="line"> <span class="number">5</span> ldc #<span class="number">18</span> &lt;lvxiaoyi&gt;<span class="comment">// lvxiaoyi放入局部变量表</span></span><br><span class="line"> <span class="number">7</span> astore_0<span class="comment">// 把lvxiaoyi，放入了局部变量表0的位置，把hello替换掉了</span></span><br><span class="line"> <span class="number">8</span> aload_1<span class="comment">// 放入栈中，这个是hello</span></span><br><span class="line"> <span class="number">9</span> areturn<span class="comment">// 所以这里返回的是hello复制的数据</span></span><br><span class="line"><span class="number">10</span> astore_2</span><br><span class="line"><span class="number">11</span> ldc #<span class="number">18</span> &lt;lvxiaoyi&gt;</span><br><span class="line"><span class="number">13</span> astore_0</span><br><span class="line"><span class="number">14</span> aload_2</span><br><span class="line"><span class="number">15</span> athrow</span><br></pre></td></tr></table></figure>

<p>异常表：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210917210549581.png/lvxiaoyi"></p>
<p>如果3到5行出现了异常，也就是没有执行到finally的哪一步，则从第10行开始执行，把lvxiaoyi放入局部变量表的str位置中</p>
<h2 id="同步控制指令"><a href="#同步控制指令" class="headerlink" title="同步控制指令"></a>同步控制指令</h2><blockquote>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>montiorenter 进入并获取对象监视器。即：为栈顶对象加锁</p>
<p>monitorexit 释放并退出对象监视器。即：为栈顶对象解锁</p>
</blockquote>
<h3 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h3><p>Java虚拟机支持两种同步结构：</p>
<p><strong>方法级的同步</strong>和<strong>方法内部一段指令序列的同步</strong>，这两种同步都是使用monitor来支持的</p>
<h3 id="方法级的同步"><a href="#方法级的同步" class="headerlink" title="方法级的同步"></a>方法级的同步</h3><p>​        方法级的同步：<strong>是隐式的</strong>，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法;</p>
<p>当调用方法时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否设置。</p>
<ul>
<li>如果设置了，执行线程将先持有同步锁，然后执行方法。最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁。</li>
<li>在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁。</li>
<li>如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> aload_0</span><br><span class="line"><span class="number">1</span> invokespecial #<span class="number">1</span> &lt;java/lang/Object.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">4</span> aload_0</span><br><span class="line"><span class="number">5</span> iconst_0</span><br><span class="line"><span class="number">6</span> putfield #<span class="number">2</span> &lt;top/lvxiaoyi/bytecodeinstruction/SynchronizedTest.i&gt;</span><br><span class="line"><span class="number">9</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>​        这段代码和普通的无同步操作的代码没有什么不同，没有使用monitorenter和monitorexit进行同步区控制。这是因为，对于同步方法而言，当虚拟机通过方法的访问标示符判断是一个同步方法时，会自动在方法调用前进行加锁，当同步方法执行完毕后，不管方法是正常结束还是有异常抛出，均会由虚拟机释放这个锁。因此，对于同步方法而言，monitorenter和monitorexit指令是隐式存在的，并未直接出现在字节码中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/84ff4ef05baf1b5774f43b203d6a6e23.png/lvxiaoyi/lvxiaoyi" alt="img"></p>
<h3 id="方法内指令指令序列的同步"><a href="#方法内指令指令序列的同步" class="headerlink" title="方法内指令指令序列的同步"></a>方法内指令指令序列的同步</h3><p>​        同步一段指令集序列：通常是由java中的synchronized语句块来表示的。jvm的指令集有 monitorenter和monitorexit两条指令来支持synchronized关键字的语义。</p>
<p>​        当一个线程进入同步代码块时，它使用monitorenter指令请求进入。如果当前对象的监视器计数器为0，则它会被准许进入，若为1,则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，直到对象的监视器计数器为0,才会被允许进入同步块。</p>
<p>​        当线程退出同步块时，需要使用monitorexit声明退出。在Java虚拟机中，任何对象都有一个监视器与之相关联用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。</p>
<p>​        指令monitorenter和monitorexit在执行时，都需要在操作数栈顶压入对象,之后monitorenter和monitorexit的锁定和释放都是针对这个对象的监视器进行的。</p>
<p>下图展示了监视器如何保护临界区代码不同时被多个线程访问，只有当线程4离开临界区后，线程1、2、3才有可能进入。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210917213055375.png/lvxiaoyi" alt="image-20210917213055375" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">substract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> aload_0<span class="comment">// 从局部变量表中把this放入栈中</span></span><br><span class="line"> <span class="number">1</span> getfield #<span class="number">4</span> &lt;top/lvxiaoyi/code10/SynchronizedTest.obj&gt; <span class="comment">// 拿到obj放入栈中</span></span><br><span class="line"> <span class="number">4</span> dup<span class="comment">// 复制一份</span></span><br><span class="line"> <span class="number">5</span> astore_1<span class="comment">// 保存到局部变量表，出栈</span></span><br><span class="line"> <span class="number">6</span> monitorenter<span class="comment">// 把obj对象的header信息中的锁状态由0变为1，出栈</span></span><br><span class="line"> <span class="number">7</span> aload_0<span class="comment">// 把this放入栈中</span></span><br><span class="line"> <span class="number">8</span> dup<span class="comment">// 复制一份</span></span><br><span class="line"> <span class="number">9</span> getfield #<span class="number">2</span> &lt;top/lvxiaoyi/code10/SynchronizedTest.i&gt;<span class="comment">// 获取属性i放入栈中（0），this出栈</span></span><br><span class="line"><span class="number">12</span> iconst_1<span class="comment">// 栈中放入1</span></span><br><span class="line"><span class="number">13</span> isub<span class="comment">// 减法，然后结果（-1）放入栈中</span></span><br><span class="line"><span class="number">14</span> putfield #<span class="number">2</span> &lt;top/lvxiaoyi/code10/SynchronizedTest.i&gt;<span class="comment">// 给i赋值，this出栈</span></span><br><span class="line"><span class="number">17</span> aload_1<span class="comment">// 把局部变量obj放入栈中</span></span><br><span class="line"><span class="number">18</span> monitorexit<span class="comment">// 修改obj对象的header信息中的锁装填由1变为0，出栈</span></span><br><span class="line"><span class="number">19</span> goto <span class="number">27</span> (+<span class="number">8</span>)<span class="comment">// 跳转到27行</span></span><br><span class="line"><span class="number">22</span> astore_2</span><br><span class="line"><span class="number">23</span> aload_1</span><br><span class="line"><span class="number">24</span> monitorexit</span><br><span class="line"><span class="number">25</span> aload_2</span><br><span class="line"><span class="number">26</span> athrow</span><br><span class="line"><span class="number">27</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>异常表：</p>
<table>
<thead>
<tr>
<th>Nr.</th>
<th>起始PC</th>
<th>结束PC</th>
<th>跳转PC</th>
<th>捕获类型</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>7</td>
<td>19</td>
<td>22</td>
<td>cp_info #0<br />any</td>
</tr>
<tr>
<td>1</td>
<td>22</td>
<td>25</td>
<td>22</td>
<td>cp_info #0<br />any</td>
</tr>
</tbody></table>
<p>7-19行如果出现任何异常，则跳转到22行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span> astore_2<span class="comment">// 把这个捕获异常的对象放到局部变量表中</span></span><br><span class="line"><span class="number">23</span> aload_1<span class="comment">// 把obj对象从局部变量表中放入栈中</span></span><br><span class="line"><span class="number">24</span> monitorexit<span class="comment">// 修改obj对象的header信息中的锁装填由1变为0，出栈</span></span><br><span class="line"><span class="number">25</span> aload_2<span class="comment">// 把捕获的异常对象放入栈中</span></span><br><span class="line"><span class="number">26</span> athrow<span class="comment">// 把对象抛出，出栈</span></span><br></pre></td></tr></table></figure>

<p>22-25行出现任何异常，跳转到22行，如果加锁成功必须要保证解锁成功</p>
<p>​        编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须执行其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。</p>
<p>​        为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行monitorexit指令 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/89199776b49d72ff70615f9b0ca8cbe2.png/lvxiaoyi" alt="img"></p>
<h1 id="类的加载过程（类的生命周期）详解"><a href="#类的加载过程（类的生命周期）详解" class="headerlink" title="类的加载过程（类的生命周期）详解"></a>类的加载过程（类的生命周期）详解</h1><h2 id="概述-11"><a href="#概述-11" class="headerlink" title="概述"></a>概述</h2><p>在 Java 中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。</p>
<p>按照 Java 虚拟机规范，从 class 文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括如下 7 个阶段：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/b73db20eea59665fa3de67e1dec6d4e5.png/lvxiaoyi" alt="image-20210430215050746" style="zoom:67%;" />

<p>其中，验证、准备、解析 3 个部分统称为链接（Linking）</p>
<p>从程序中类的使用过程看</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/c6e5a63339bb2574b9b52a9ed14ee9c5.png/lvxiaoyi" alt="image-20210430215236716" style="zoom:67%;" />

<h3 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h3><blockquote>
<p>蚂蚁金服：</p>
<p>描述一下 JVM 加载 Class 文件的原理机制？</p>
<p>一面：类加载过程</p>
<p>百度：</p>
<p>类加载的时机</p>
<p>java 类加载过程？</p>
<p>简述 java 类加载机制？</p>
<p>腾讯：</p>
<p>JVM 中类加载机制，类加载过程？</p>
<p>滴滴：</p>
<p>JVM 类加载机制</p>
<p>美团：</p>
<p>Java 类加载过程</p>
<p>描述一下 jvm 加载 class 文件的原理机制</p>
<p>京东：</p>
<p>什么是类的加载？</p>
<p>哪些情况会触发类的加载？</p>
<p>讲一下 JVM 加载一个类的过程 JVM 的类加载机制是什么？</p>
</blockquote>
<hr>
<h2 id="过程一：Loading（加载）阶段"><a href="#过程一：Loading（加载）阶段" class="headerlink" title="过程一：Loading（加载）阶段"></a>过程一：Loading（加载）阶段</h2><h3 id="加载完成的操作"><a href="#加载完成的操作" class="headerlink" title="加载完成的操作"></a>加载完成的操作</h3><p><strong>加载的理解</strong></p>
<p>所谓加载，简而言之就是将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型——类模板对象。所谓加载，简而言之就是将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型——类模板对象。所谓类模板对象，其实就是 Java 类在]VM 内存中的一个快照，JVM 将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样]VM 在运行期便能通过类模板而获取 Java 类中的任意信息，能够对 Java 类的成员变量进行遍历，也能进行 Java 方法的调用。</p>
<p>反射的机制即基于这一基础。如果 JVM 没有将 Java 类的声明信息存储起来，则 JVM 在运行期也无法反射。</p>
<p><strong>加载完成的操作</strong></p>
<p>加载阶段，简言之，查找并加载类的二进制数据，生成Class的实例。加载阶段，简言之，查找并加载类的二进制数据，生成Class的实例。</p>
<p>在加载类时，Java 虚拟机必须完成以下 3 件事情：</p>
<ul>
<li>通过类的全名，获取类的二进制数据流。</li>
<li>解析类的二进制数据流为方法区内的数据结构（Java 类模型）</li>
<li>创建 java.lang.Class 类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li>
</ul>
<h3 id="二进制流的获取方式"><a href="#二进制流的获取方式" class="headerlink" title="二进制流的获取方式"></a>二进制流的获取方式</h3><p>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。（只要所读取的字节码符合 JVM 规范即可）</p>
<ul>
<li>虚拟机可能通过文件系统读入一个 class 后缀的文件（最常见）（最常见）</li>
<li>读入 jar、zip 等归档数据包，提取类文件。</li>
<li>事先存放在数据库中的类的二进制数据</li>
<li>使用类似于 HTTP 之类的协议通过网络进行加载</li>
<li>在运行时生成一段 class 的二进制信息等</li>
<li>在获取到类的二进制信息后，Java 虚拟机就会处理这些数据，并最终转为一个 java.lang.Class 的实例。</li>
</ul>
<p>如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p>
<h3 id="类模型与-Class-实例的位置"><a href="#类模型与-Class-实例的位置" class="headerlink" title="类模型与 Class 实例的位置"></a>类模型与 Class 实例的位置</h3><p><strong>类模型的位置</strong></p>
<p>加载的类在 JVM 中创建相应的类结构，类结构会存储在方法区（JDKl.8 之前：永久代；J0Kl.8 及之后：元空间）。</p>
<p><strong>Class 实例的位置</strong></p>
<p>类将.class 文件加载至元空间后，会在堆中创建一个 Java.lang.Class 对象，用来封装类位于方法区内的数据结构，该 Class 对象是在加载类的过程中创建的，每个类都对应有一个 Class 类型的对象。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/10969de50477655b954b23bfe550fb1d.png/lvxiaoyi" alt="image-20210430221037898"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadintTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">            <span class="comment">//获取当前运行时类声明的所有方法</span></span><br><span class="line">            Method[] ms = clazz.getDeclaredMethods();</span><br><span class="line">            <span class="keyword">for</span> (Method m : ms) &#123;</span><br><span class="line">                <span class="comment">//获取方法的修饰符</span></span><br><span class="line">                String mod = Modifier.toString(m.getModifiers());</span><br><span class="line">                System.out.print(mod + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="comment">//获取方法的返回值类型</span></span><br><span class="line">                String returnType = (m.getReturnType()).getSimpleName();</span><br><span class="line">                System.out.print(returnType + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="comment">//获取方法名</span></span><br><span class="line">                System.out.print(m.getName() + <span class="string">&quot;(&quot;</span>);</span><br><span class="line">                <span class="comment">//获取方法的参数列表</span></span><br><span class="line">                Class&lt;?&gt;[] ps = m.getParameterTypes();</span><br><span class="line">                <span class="keyword">if</span> (ps.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.print(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ps.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">char</span> end = (i == ps.length - <span class="number">1</span>) ? <span class="string">&#x27;)&#x27;</span> : <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">                    <span class="comment">//获取参教的类型</span></span><br><span class="line">                    System.out.print(ps[i].getSimpleName() + end);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不通过加载对象也能获取方法区中的类信息</p>
<h3 id="数组类的加载"><a href="#数组类的加载" class="headerlink" title="数组类的加载"></a>数组类的加载</h3><p>创建数组类的情况稍微有些特殊，因为<strong>数组类本身并不是由类加载器负责创建</strong>，而是由 JVM 在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。创建数组类（下述简称 A）的过程：</p>
<ul>
<li>如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组 A 的元素类型；</li>
<li>JVM 使用指定的元素类型和数组维度来创建新的数组类。</li>
</ul>
<p>如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为 public。</p>
<h2 id="过程二：Linking（链接）阶段"><a href="#过程二：Linking（链接）阶段" class="headerlink" title="过程二：Linking（链接）阶段"></a>过程二：Linking（链接）阶段</h2><h3 id="环节-1：链接阶段之-Verification（验证）"><a href="#环节-1：链接阶段之-Verification（验证）" class="headerlink" title="环节 1：链接阶段之 Verification（验证）"></a>环节 1：链接阶段之 Verification（验证）</h3><p>当类加载到系统后，就开始链接操作，验证是链接操作的第一步。</p>
<p>它的目的是保证加载的字节码是合法、合理并符合规范的。它的目的是保证加载的字节码是合法、合理并符合规范的。</p>
<p>验证的步骤比较复杂，实际要验证的项目也很繁多，大体上 Java 虚拟机需要做以下检查，如图所示。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/2309ce7d4bdbffb86ae462e967af5dc9.png/lvxiaoyi" alt="image-20210430221736546" style="zoom: 80%;" />

<p><strong>整体说明：</strong></p>
<p>验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等。</p>
<ul>
<li>其中格式验证会和加载阶段一起执行其中格式验证会和加载阶段一起执行。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。</li>
<li>格式验证之外的验证操作将会在方法区中进行格式验证之外的验证操作将会在方法区中进行。</li>
</ul>
<p>链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查。（磨刀不误砍柴工）</p>
<p><strong>具体说明：</strong></p>
<ol>
<li><p>格式验证：是否以魔数 0XCAFEBABE 开头，主版本和副版本号是否在当前 Java 虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等。</p>
</li>
<li><p>语义检查：Java 虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如：</p>
<ul>
<li>是否所有的类都有父类的存在（在 Java 里，除了 object 外，其他类都应该有父类）</li>
<li>是否一些被定义为 final 的方法或者类被重写或继承了</li>
<li>非抽象类是否实现了所有抽象方法或者接口方法</li>
<li>是否存在不兼容的方法(比如方法的签名除了返回值不同，其他都一样，这种方法会让虚拟机无从下手调度；（abstract情况下的方法，就不能是final的了）</li>
</ul>
</li>
<li><p>字节码验证：Java 虚拟机还会进行字节码验证，字节码验证也是<strong>验证过程中最为复杂的一个过程</strong>。它试图通过对字节码流的分析，判断字节码是否可以被正确地执行。比如：</p>
<ul>
<li>在字节码的执行过程中，是否会跳转到一条不存在的指令</li>
<li>函数的调用是否传递了正确类型的参数</li>
<li>变量的赋值是不是给了正确的数据类型等</li>
</ul>
<p>栈映射帧（StackMapTable）就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。但遗憾的是，100%准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检查出可以预知的明显的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的。</p>
</li>
</ol>
<p>在前面3次检查中，已经排除了文件格式错误、语义错误以及字节码的不正确性。但是依然不能确保类是没有问题的。</p>
<ol start="4">
<li> 校验器还将进行符号引用的验证。</li>
</ol>
<p>   Class 文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，<strong>虚拟机就会检查这些类或者方法确实是存在的</strong>，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出 NoClassDefFoundError，如果一个方法无法被找到，则会抛出 NoSuchMethodError。</p>
<p>   此阶段在解析环节才会执行。</p>
<h3 id="3-2-环节-2：链接阶段之-Preparation（准备）"><a href="#3-2-环节-2：链接阶段之-Preparation（准备）" class="headerlink" title="3.2. 环节 2：链接阶段之 Preparation（准备）"></a>3.2. 环节 2：链接阶段之 Preparation（准备）</h3><p><strong>准备阶段（Preparation），简言之，为类的静态变分配内存，并将其初始化为默认值。</strong></p>
<p>当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。Java 虚拟机为各类型变量默认的初始值如表所示。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>char</td>
<td>\u0000</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody></table>
<p>Java 并不支持 boolean 类型，对于 boolean 类型，内部实现是 int，由于 int 的默认值是 0，故对应的，boolean 的默认值就是 false。</p>
<p><strong>注意</strong></p>
<ul>
<li>这里不包含基本数据类型的字段用<code>static final</code>修饰的情况，因为final在编译的时候就会分配了，准备阶段会显式赋值。</li>
</ul>
<ul>
<li>注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。</li>
<li>在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkingTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基本数据类型：</span></span><br><span class="line"><span class="comment">     *          非final修饰的变量，在解析环节进行默认初始化赋值。</span></span><br><span class="line"><span class="comment">     *          final修饰以后，再解析环节直接进行显示赋值。</span></span><br><span class="line"><span class="comment">     *  拓展：如果使用字面量的方式定义一个字符串的常量的话，也是在解析环节直接进行显示赋值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一般情况：static final修饰的基本数据类型、字符串类型字面量会在准备阶段赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String str1 = <span class="string">&quot;hello lvxiaoyi&quot;</span>;</span><br><span class="line">    <span class="comment">// 特殊情况：static final修饰的引用类型不会在准备阶段赋值，而是在初始化阶段赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String str2 = <span class="keyword">new</span> String(<span class="string">&quot;hello lvxiaoyi&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210918105309684.png/lvxiaoyi" alt="image-20210918105309684" style="zoom: 80%;" />

<p>​            我们发现只有num和str1在编译阶段（准备阶段）进行了赋值。</p>
<h3 id="3-3-环节-3：链接阶段之-Resolution（解析）"><a href="#3-3-环节-3：链接阶段之-Resolution（解析）" class="headerlink" title="3.3. 环节 3：链接阶段之 Resolution（解析）"></a>3.3. 环节 3：链接阶段之 Resolution（解析）</h3><p>在准备阶段完成后，就进入了解析阶段。解析阶段（Resolution），简言之，<strong>将类、接口、字段和方法的符号引用转为直接引用。</strong></p>
<h4 id="具体描述："><a href="#具体描述：" class="headerlink" title="具体描述："></a><strong>具体描述</strong>：</h4><p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在 Class 类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下 println()方法被调用时，系统需要明确知道该方法的位置。</p>
<h5 id="举例一-7"><a href="#举例一-7" class="headerlink" title="举例一"></a>举例一</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpinfo#<span class="number">25</span> getObj()Ljava/lang/Object;</span><br></pre></td></tr></table></figure>



<h5 id="举例二："><a href="#举例二：" class="headerlink" title="举例二："></a><strong>举例二</strong>：</h5><p>输出操作 System.out.println()对应的字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokevirtual #24 &lt;java/io/PrintStream.println&gt;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/b223d288b413f0ed0732357023a1dc7e.png/lvxiaoyi" alt="image-20210430225015932"></p>
<p>以方法为例，Java 虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>所谓解析就是将符号引用转为直接引用，也就是得到类、字段、方法在内存中的指针或者偏移量。因此可以说，如果直接引用存在，那么可以肯定系统中存在该类、方法或者字段。但只存在符号引用，不能确定系统中一定存在该结构。</p>
<p>不过Java虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行。</p>
<h4 id="字符串复习"><a href="#字符串复习" class="headerlink" title="字符串复习"></a>字符串复习</h4><p>最后，再来看一下CONSTANT_String的解析。由于字符串在程序开发中有着重要的作用，因此，读者有必要了解一下String在Java虚拟机中的处理。当在Java代码中直接使用字符串常量时，就会在类中出现CONSTANT_String，它表示字符串常量，并且会引用一个CONSTANT_UTF8的常量项。</p>
<p>在Java虚拟机内部运行中的常量池中，会维护一张字符串拘留表(intern)，它会保存所有出现过的字符串常量，并且没有重复项。只要以CONSTANT_String形式出现的字符串也都会在这张表中。使用<code>String.intern()</code>方法可以得到一个字符串在拘留表中的引用，因为该表中没有重复项，所以任何字面相同的字符串的<code>String.intern()</code>方法返回总是相等的。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tyyking/article/details/82496901">https://blog.csdn.net/tyyking/article/details/82496901</a></p>
<h2 id="过程三：Initialization（初始化）阶段"><a href="#过程三：Initialization（初始化）阶段" class="headerlink" title="过程三：Initialization（初始化）阶段"></a>过程三：Initialization（初始化）阶段</h2><h3 id="概述-12"><a href="#概述-12" class="headerlink" title="概述"></a>概述</h3><p>初始化阶段，简言之，为类的静态变量赋予正确的初始值。</p>
<h4 id="具体描述"><a href="#具体描述" class="headerlink" title="具体描述"></a>具体描述</h4><p>类的初始化是类装载的最后一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中。此时，类才会开始执行Java字节码。(即:<strong>到了初始化阶段，才真正开始执行类中定义的 Java程序代码</strong>。)</p>
<p>初始化阶段的重要工作是执行类的初始化方法:<code>&lt;clinit&gt;()</code>方法。</p>
<ul>
<li>该方法仅能由Java编译器生成并由JVM调用，程序开发者无法自定义一个同名的方法，更无法直接在Java程序中调用该方法，虽然该方法也是由字节码指令所组成。</li>
<li>它是<strong>由类静态成员的赋值语句以及static语句块合并产生的</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        number = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;father&#x27;s static&#123;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;clinit&gt;</code>是由类静态成员的赋值语句及static语句块合并产生的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> <span class="number">1</span> putstatic #<span class="number">2</span> &lt;top/lvxiaoyi/chapter03/code4/InitializationTest.id&gt;</span><br><span class="line"> <span class="number">4</span> iconst_2</span><br><span class="line"> <span class="number">5</span> putstatic #<span class="number">3</span> &lt;top/lvxiaoyi/chapter03/code4/InitializationTest.number&gt;</span><br><span class="line"> <span class="number">8</span> getstatic #<span class="number">4</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">11</span> ldc #<span class="number">5</span> &lt;father<span class="string">&#x27;s static&#123;&#125;&gt;</span></span><br><span class="line"><span class="string">13 invokevirtual #6 &lt;java/io/PrintStream.println&gt;</span></span><br><span class="line"><span class="string">16 return</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>



<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>在加载一个类之前，虚拟机总是会试图加载该类的父类，因此父类的<code>&lt;clinit&gt;</code>总是在子类<code>&lt;Clinit&gt;</code>之前被调用。也就是说，父类的static块优先级高于子类。</p>
<p>口诀：由父及子，静态先行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubInitialization</span> <span class="keyword">extends</span> <span class="title">InitializationTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 这里使用的父类的number，所以父类静态代码块必须优先执行</span></span><br><span class="line">        number = <span class="number">4</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;son&#x27;s static&#123;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">father<span class="string">&#x27;s static&#123;&#125;</span></span><br><span class="line"><span class="string">son&#x27;</span>s <span class="keyword">static</span>&#123;&#125;</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>Java编译器并不会为所有的类都产生<code>&lt;clinit&gt;()</code>初始化方法</strong>。哪些类在编译为字节码后，字节码文件中将不会包含<code>&lt;clinit&gt;()</code>方法?</p>
<ul>
<li><p>一个类中并没有声明任何的类变量，也没有静态代码块时</p>
</li>
<li><p>一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时</p>
</li>
<li><p>一个类中包含static final修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式</p>
</li>
</ul>
<h5 id="举例一-8"><a href="#举例一-8" class="headerlink" title="举例一"></a>举例一</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClintTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210918143434526.png/lvxiaoyi" alt="image-20210918143434526"></p>
<h3 id="static-与-final-的搭配问题"><a href="#static-与-final-的搭配问题" class="headerlink" title="static 与 final 的搭配问题"></a>static 与 final 的搭配问题</h3><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a><strong>说明</strong>：</h4><p>使用 static+ final 修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？</p>
<ul>
<li>情况 1：在链接阶段的准备环节赋值</li>
<li>情况 2：在初始化阶段<code>&lt;clinit&gt;()</code>中赋值</li>
</ul>
<h4 id="举例一-9"><a href="#举例一-9" class="headerlink" title="举例一"></a>举例一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 场景1：对应非静态的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 场景2：静态的字段，就没有显式赋值不会生成&lt;clinit&gt;方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num1;</span><br><span class="line">    <span class="comment">//场景3：对于声明为static final的基本数据类型的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num3 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="举例二-8"><a href="#举例二-8" class="headerlink" title="举例二"></a>举例二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lvxiaoyi</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 说明使用static + final修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？</span></span><br><span class="line"><span class="comment"> * 情况1：在链接阶段的准备环节赋值</span></span><br><span class="line"><span class="comment"> * 情况2：在初始化阶段&lt;clinit&gt;()赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链接阶段的准备环节赋值，在ConstantValue中进行赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT_CONSTANT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在初始化阶段clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer INTEGER_CONSTANT1 = Integer.valueOf(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 在初始化阶段&lt;clinit&gt;()中概值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer INTEGER_CONSTANT2 = Integer.valueOf(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 在链接阶段的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s0 = <span class="string">&quot;hello lvxiaoyi1&quot;</span>;</span><br><span class="line">    <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s1 = <span class="keyword">new</span> String(<span class="string">&quot;hello lvxiaoyi2&quot;</span>);</span><br><span class="line">    <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s2 = <span class="string">&quot;hello lvxiaoyi1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>结论</strong>： 在链接阶段的准备环节赋值的情况：</p>
<ul>
<li><p>对于基本数据类型的字段来说，如果使用 static final 修饰，则显式赋值(直接赋值常量，而非调用方法）<strong>通常是在链接阶段的准备环节进行</strong></p>
<ul>
<li>在准备阶段赋值，在Fields字段下面有ConstantValue的属性</li>
</ul>
</li>
<li><p>对于 String 来说，如果使用字面量的方式赋值，使用 static final 修饰的话，则显式赋值通常是在链接阶段的准备环节进行</p>
</li>
<li><p>在初始化阶段<code>&lt;clinit&gt;()</code>中赋值的情况： 排除上述的在准备环节赋值的情况之外的情况。</p>
</li>
</ul>
<h4 id="最终结论："><a href="#最终结论：" class="headerlink" title="最终结论："></a><strong>最终结论</strong>：</h4><p><strong>使用 static+final 修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类到或 String 类型的显式财值，是在链接阶段的准备环节进行。</strong> </p>
<h3 id="lt-clinit-gt-的线程安全性"><a href="#lt-clinit-gt-的线程安全性" class="headerlink" title="&lt;clinit&gt;()的线程安全性"></a><strong><code>&lt;clinit&gt;()</code>的线程安全性</strong></h3><p>对于<code>&lt;clinit&gt;()</code>方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性。</p>
<p>虚拟机会保证一个类的()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。</p>
<p>正是因为函数(<code>&lt;clinit&gt;()</code>)带锁线程安全，因此，如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。</p>
<p>如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行<code>&lt;clinit&gt;()</code>方法了。那么，当需要使用这个类时，虚拟机会直接返回给它已经准备好的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;top.lvxiaoyi.chapter03.code4.StaticB&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;StaticA init OK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;top.lvxiaoyi.chapter03.code4.StaticA&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;StaticB init OK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDeadLockMain</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> flag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticDeadLockMain</span><span class="params">(<span class="keyword">char</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">        <span class="keyword">this</span>.setName(<span class="string">&quot;Thread&quot;</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;top.lvxiaoyi.chapter03.code4.Static&quot;</span> + flag);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticDeadLockMain loadA = <span class="keyword">new</span> StaticDeadLockMain(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        loadA.start();</span><br><span class="line">        StaticDeadLockMain loadB = <span class="keyword">new</span> StaticDeadLockMain(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">        loadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述程序中会发生死锁，两个类在交叉的初始化，相当于循环依赖</p>
<h3 id="类的初始化情况：主动使用-vs-被动使用"><a href="#类的初始化情况：主动使用-vs-被动使用" class="headerlink" title="类的初始化情况：主动使用 vs 被动使用"></a>类的初始化情况：主动使用 vs 被动使用</h3><p>Java 程序对类的使用分为两种：主动使用和被动使用。</p>
<h4 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a><strong>主动使用</strong></h4><p>Class 只有在必须要首次使用的时候才会被装载，Java 虚拟机不会无条件地装载 Class 类型。Java 虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。</p>
<ol>
<li><p>实例化：当创建一个类的实例时，比如使用 new 关键字，或者通过反射、克隆、反序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lvxiaoyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/22 9:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Order类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUse1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ActiveUse1 activeUse1 = <span class="keyword">new</span> ActiveUse1();</span><br><span class="line"><span class="comment">//        activeUse1.test1();</span></span><br><span class="line">        activeUse1.test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列化过程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 序列化</span></span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;order.dat&quot;</span>));</span><br><span class="line">            oos.writeObject(<span class="keyword">new</span> Order());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (oos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oos.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化过程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 序列化</span></span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;order.dat&quot;</span>));</span><br><span class="line">            Order order = (Order) ois.readObject();</span><br><span class="line">            System.out.println(order);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ois != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ois.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>静态方法：当调用类的静态方法时，即当使用了字节码 invokestatic 指令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUse2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ActiveUse2 activeUse2 = <span class="keyword">new</span> ActiveUse2();</span><br><span class="line">        activeUse2.test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Order.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Order类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Order method()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Order类的初始化过程</span><br><span class="line">Order method()...</span><br></pre></td></tr></table></figure></li>
<li><p>静态字段：当使用类、接口的静态字段时（final 修饰特殊考虑），比如，使用 getstatic 或者 putstatic 指令。（对应访问变量、赋值变量操作）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lvxiaoyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/22 9:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUse3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ActiveUse3 activeUse3 = <span class="keyword">new</span> ActiveUse3();</span><br><span class="line">        activeUse3.test1();</span><br><span class="line">        activeUse3.test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(User.num);</span><br><span class="line">        System.out.println(User.num1);</span><br><span class="line">        System.out.println(User.num2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(CompareA.NUM1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread T = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;CompareA&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>反射：当使用 java.lang.reflect 包中的方法反射类的方法时。比如：Class.forName(“com.atguigu.java.Test”)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lvxiaoyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/22 9:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUse4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ActiveUse4 activeUse4 = <span class="keyword">new</span> ActiveUse4();</span><br><span class="line">        activeUse4.test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">&quot;top.lvxiaoyi.chapter03.code4.Order&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>继承：当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
<blockquote>
<p>当 Java 虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。</p>
<ul>
<li>在初始化一个类时，并不会先初始化它所实现的接口</li>
<li>在初始化一个接口时，并不会先初始化它的父接口</li>
<li>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lvxiaoyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/22 9:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUse5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ActiveUse5 activeUse5 = <span class="keyword">new</span> ActiveUse5();</span><br><span class="line">        activeUse5.test1();</span><br><span class="line">        activeUse5.test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Son.num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(CompareC.NUM1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> <span class="keyword">implements</span> <span class="title">CompareB</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread T = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;CompareB&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareC</span> <span class="keyword">extends</span> <span class="title">CompareB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread T = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;CompareC的初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+TraceClassLoading</span><br></pre></td></tr></table></figure>

<p><strong>test1方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[Opened C:\Program Files\Java\jdk1<span class="number">.8</span><span class="number">.0_101</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.Object from C:\Program Files\Java\jdk1<span class="number">.8</span><span class="number">.0_101</span>\jre\lib\rt.jar]<span class="comment">// object类必须先加载</span></span><br><span class="line">....</span><br><span class="line">....    </span><br><span class="line"><span class="comment">// CompareB类的加载</span></span><br><span class="line">[Loaded top.lvxiaoyi.chapter03.code4.CompareB from file:/D:/interview/jvm/target/classes/]</span><br><span class="line"><span class="comment">// Father类的加载</span></span><br><span class="line">[Loaded top.lvxiaoyi.chapter03.code4.Father from file:/D:/interview/jvm/target/classes/]</span><br><span class="line"><span class="comment">// Son类的加载</span></span><br><span class="line">[Loaded top.lvxiaoyi.chapter03.code4.Son from file:/D:/interview/jvm/target/classes/]</span><br><span class="line">[Loaded top.lvxiaoyi.chapter03.code4.CompareB$<span class="number">1</span> from file:/D:/interview/jvm/target/classes/]</span><br><span class="line">Father类的初始化过程</span><br><span class="line">Son类的初始化过程</span><br><span class="line"><span class="number">1</span></span><br><span class="line">[Loaded java.lang.Shutdown from C:\Program Files\Java\jdk1<span class="number">.8</span><span class="number">.0_101</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.Shutdown$Lock from C:\Program Files\Java\jdk1<span class="number">.8</span><span class="number">.0_101</span>\jre\lib\rt.jar]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>test2方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Loaded top.lvxiaoyi.chapter03.code4.CompareB$<span class="number">1</span> from file:/D:/interview/jvm/target/classes/]</span><br><span class="line">[Loaded top.lvxiaoyi.chapter03.code4.CompareC$<span class="number">1</span> from file:/D:/interview/jvm/target/classes/]</span><br><span class="line">CompareC的初始化</span><br><span class="line"><span class="number">1</span></span><br><span class="line">[Loaded java.lang.Shutdown from C:\Program Files\Java\jdk1<span class="number">.8</span><span class="number">.0_101</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.Shutdown$Lock from C:\Program Files\Java\jdk1<span class="number">.8</span><span class="number">.0_101</span>\jre\lib\rt.jar]</span><br></pre></td></tr></table></figure></li>
<li><p>default 方法：如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread T = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;CompareB&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ActiveUse6中使用，在ActiveUse5中请注释下面代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,lvxioayi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUse6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ActiveUse6 activeUse6 = <span class="keyword">new</span> ActiveUse6();</span><br><span class="line">        activeUse6.test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Son.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Father类的初始化过程</span><br><span class="line">CompareB</span><br><span class="line">Son类的初始化过程</span><br><span class="line">1</span><br></pre></td></tr></table></figure></li>
<li><p>main 方法：当虚拟机启动时，用户需要指定一个要执行的主类（包含 main()方法的那个类），虚拟机会先初始化这个主类。</p>
<blockquote>
<p>VM 启动的时候通过引导类加载器加载一个初始类。这个类在调用 public static void main(String[])方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUse7</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ActiveUse7初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,lvxiaoyi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>MethodHandle：当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。（涉及解析 REF getStatic、REF_putStatic、REF invokeStatic 方法句柄对应的类）</p>
</li>
</ol>
<h4 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a><strong>被动使用</strong></h4><p>除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化。</p>
<p>也就是说：<strong>并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。</strong></p>
<ol>
<li><p>静态字段：当通过子类引用父类的静态变量，不会导致子类初始化，<strong>只有真正声明这个字段的类才会被初始化</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lvxiaoyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/22 10:25</span></span><br><span class="line"><span class="comment"> * 类的被动使用，不会调用类的初始化操作</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 说明：没有初始化类，不意味着没有加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassiveUse1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PassiveUse1 passiveUse1 = <span class="keyword">new</span> PassiveUse1();</span><br><span class="line">        passiveUse1.test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Child.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    如果这个变量在子类，子类也会被初始化</span></span><br><span class="line"><span class="comment">//    public static int num = 1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Loaded top.lvxiaoyi.chapter03.code4.Parent from file:/D:/interview/jvm/target/classes/]</span><br><span class="line">[Loaded top.lvxiaoyi.chapter03.code4.Child from file:/D:/interview/jvm/target/classes/]</span><br><span class="line">Parent的初始化过程</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如果把<code>public static int num = 1;</code>定义到Child中，这个时候父类、子类都会被初始化</p>
</li>
<li><p>数组定义：通过数组定义类引用，不会触发此类的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lvxiaoyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/22 10:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassiveUse2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PassiveUse2 passiveUse2 = <span class="keyword">new</span> PassiveUse2();</span><br><span class="line">        passiveUse2.test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这个时候没哟进行初始化</span></span><br><span class="line">        Parent[] parents = <span class="keyword">new</span> Parent[<span class="number">10</span>];</span><br><span class="line">        System.out.println(parents.getClass());</span><br><span class="line">        System.out.println(parents.getClass().getSuperclass());</span><br><span class="line">        <span class="comment">// 只有new对象的时候才会初始化</span></span><br><span class="line">        parents[<span class="number">0</span>] = <span class="keyword">new</span> Parent();</span><br><span class="line">        <span class="comment">// 只会初始化一次</span></span><br><span class="line">        parents[<span class="number">1</span>] = <span class="keyword">new</span> Parent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> [<span class="title">Ltop</span>.<span class="title">lvxiaoyi</span>.<span class="title">chapter03</span>.<span class="title">code4</span>.<span class="title">Parent</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br><span class="line"><span class="class"><span class="title">Parent</span>的初始化过程</span></span><br></pre></td></tr></table></figure></li>
<li><p>引用常量：引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lvxiaoyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/22 10:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassiveUse3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PassiveUse3 passiveUse3 = <span class="keyword">new</span> PassiveUse3();</span><br><span class="line">        passiveUse3.test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Person.NUM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person类的初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在链接过程中的准备阶段都已经赋值了，然后就不需要初始化都能拿到这个值了，那么为什么还需要初始化！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">1</span>;</span><br><span class="line">     <span class="comment">//这样就会导致初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是：</strong></p>
<p>interFace中的变量默认是 public static final ，所以在interFace中直接调用变量不会导致初始化</p>
</li>
<li><p>loadClass 方法：调用 ClassLoader 类的 loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassiveUse4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PassiveUse4 passiveUse4 = <span class="keyword">new</span> PassiveUse4();</span><br><span class="line">        passiveUse4.test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;top.lvxiaoyi.chapter03.code4.Person&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>扩展</strong></p>
<blockquote>
<p>-XX:+TraceClassLoading：追踪打印类的加载信息</p>
</blockquote>
<h2 id="过程四：类的-Using（使用）"><a href="#过程四：类的-Using（使用）" class="headerlink" title="过程四：类的 Using（使用）"></a>过程四：类的 Using（使用）</h2><p>任何一个类型在使用之前都必须经历过完整的加载、链接和初始化 3 个类加载步骤。一旦一个类型成功经历过这 3 个步骤之后，便“厉事俱备只欠东风”，就等着开发者使用了。</p>
<p>开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用 new 关键字为其创建对象实例。</p>
<h2 id="过程五：类的-Unloading（卸载）"><a href="#过程五：类的-Unloading（卸载）" class="headerlink" title="过程五：类的 Unloading（卸载）"></a>过程五：类的 Unloading（卸载）</h2><h3 id="类、类的加载器、类的实例之间的引用关系"><a href="#类、类的加载器、类的实例之间的引用关系" class="headerlink" title="类、类的加载器、类的实例之间的引用关系"></a>类、类的加载器、类的实例之间的引用关系</h3><p>在类加载器的内部实现中，用一个 Java 集合来存放所加载类的引用。另一方面，一个 Class 对象总是会引用它的类加载器，调用 Class 对象的 getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的 Class 实例与其类的加载器之间为双向关联关系。</p>
<p>一个类的实例总是引用代表这个类的 Class 对象。在 Object 类中定义了 getClass()方法，这个方法返回代表对象所属类的 Class 对象的引用。此外，所有的 java 类都有一个静态属性 class，它引用代表这个类的 Class 对象。</p>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>当 Sample 类被加载、链接和初始化后，它的生命周期就开始了。当代表 Sample 类的 Class 对象不再被引用，即不可触及时，Class 对象就会结束生命周期，Sample 类在方法区内的数据也会被卸载，从而结束 Sample 类的生命周期。</p>
<p>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</p>
<h3 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210922135453605.png/lvxiaoyi" alt="image-20210922135453605" style="zoom:67%;" />

<p>loader1 变量和 obj 变量间接应用代表 Sample 类的 Class 对象，而 objClass 变量则直接引用它。</p>
<p>如果程序运行过程中，将上图左侧三个引用变量都置为 null，此时 Sample 对象结束生命周期，MyClassLoader 对象结束生命周期，代表 Sample 类的 Class 对象也结束生命周期，Sample 类在方法区内的二进制数据被卸载。</p>
<p>当再次有需要时，会检查 Sample 类的 Class 对象是否存在，如果存在会直接使用，不再重新加载；如果不存在 Sample 类会被重新加载，在 Java 虚拟机的堆区会生成一个新的代表 Sample 类的 Class 实例（可以通过哈希码查看是否是同一个实例）</p>
<h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><ul>
<li><p>启动类加载器加载的类型在整个运行期间是不可能被卸载的（jvm 和 jls 规范） </p>
</li>
<li><p>被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到 unreachable 的可能性极小。</p>
</li>
<li><p>被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中（比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能），被加载的类型在运行期间也是几乎不太可能被卸载的（至少卸载的时间是不确定的）。</p>
</li>
</ul>
<p>综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。</p>
<h3 id="回顾：方法区的垃圾回收"><a href="#回顾：方法区的垃圾回收" class="headerlink" title="回顾：方法区的垃圾回收"></a>回顾：方法区的垃圾回收</h3><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p>
<p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li>该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例。该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p>
<h1 id="再谈类的加载器"><a href="#再谈类的加载器" class="headerlink" title="再谈类的加载器"></a>再谈类的加载器</h1><h2 id="概述-13"><a href="#概述-13" class="headerlink" title="概述"></a>概述</h2><p>类加载器是JVM执行类加载机制的前提。</p>
<p><strong>ClassLoader的作用：</strong></p>
<p>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。然后交给Java虚拟机进行链接、初始化等操作。因此，ClassLoader在整个装载阶段，只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由Execution Engine（执行引擎 ）决定。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210922141022850.png/lvxiaoyi" alt="image-20210922141022850" style="zoom:67%;" />

<p>类加载器最早出现在Java1.0版本中，那个时候只是单纯地为了满足Java Applet应用而被研发出来。但如今类加载器却在OSGi、字节码加解密领域大放异彩。这主要归功于Java虚拟机的设计者们当初在设计类加载器的时候，并没有考虑将它绑定在VM内部，这样做的好处就是能够更加灵活和动态地执行类加载操作。</p>
<h3 id="大厂面试题-1"><a href="#大厂面试题-1" class="headerlink" title="大厂面试题"></a>大厂面试题</h3><blockquote>
<p>蚂蚁金服：</p>
<p>深入分析ClassLoader，双亲委派机制</p>
<p>类加载器的双亲委派模型是什么？一面：双亲委派机制及使用原因</p>
<p>百度：</p>
<p>都有哪些类加载器，这些类加载器都加载哪些文件？</p>
<p>手写一个类加载器Demo</p>
<p>Class的forName（“java.lang.String”）和Class的getClassLoader（）的Loadclass（“java.lang.String”）有什么区别？</p>
<p>腾讯：</p>
<p>什么是双亲委派模型？</p>
<p>类加载器有哪些？</p>
<p>小米：</p>
<p>双亲委派模型介绍一下</p>
<p>滴滴：</p>
<p>简单说说你了解的类加载器一面：讲一下双亲委派模型，以及其优点</p>
<p>字节跳动：</p>
<p>什么是类加载器，类加载器有哪些？</p>
<p>京东：</p>
<p>类加载器的双亲委派模型是什么？</p>
<p>双亲委派机制可以打破吗？为什么</p>
</blockquote>
<h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><p>类的加载分类：显式加载 vs 隐式加载</p>
<p>class文件的显式加载与隐式加载的方式是指JVM加载class文件到内存的方式。</p>
<h4 id="显式加载"><a href="#显式加载" class="headerlink" title="显式加载"></a>显式加载</h4><p>指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象。</p>
<h4 id="隐式加载"><a href="#隐式加载" class="headerlink" title="隐式加载"></a>隐式加载</h4><p>不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</p>
<p>在日常开发以上两种方式一般会混合使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lvxiaoyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/22 14:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//隐式加载</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//显式加载，并初始化</span></span><br><span class="line">            Class clazz = Class.forName(<span class="string">&quot;top.lvxiaoyi.chapter04.code01.User&quot;</span>);</span><br><span class="line">            <span class="comment">//显式加载，但不初始化</span></span><br><span class="line">            ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;top.lvxiaoyi.chapter04.code01.User&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-3-类加载器的必要性"><a href="#1-3-类加载器的必要性" class="headerlink" title="1.3. 类加载器的必要性"></a>1.3. 类加载器的必要性</h3><p>一般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：</p>
<ul>
<li>避免在开发中遇到java.lang.ClassNotFoundException异常或java.lang.NoClassDefFoundError异常时，手足无措。只有了解类加载器的 加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题</li>
<li>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</li>
<li>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。</li>
</ul>
<h3 id="1-4-命名空间"><a href="#1-4-命名空间" class="headerlink" title="1.4. 命名空间"></a>1.4. 命名空间</h3><p><strong>何为类的唯一性？</strong></p>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。每一个类加载器，都拥有一个独立的类名称空间：比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p>
<p><strong>命名空间</strong></p>
<ul>
<li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成</li>
<li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li>
<li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</li>
</ul>
<p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lvxiaoyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/22 14:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData1(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getClassData1(String className) &#123;</span><br><span class="line">        String path = classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + <span class="string">&quot;\\&quot;</span> + className.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;\\&#x27;</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String rootDir = <span class="string">&quot;D:\\interview\\jvm\\src\\main\\java&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UserClassLoader loader1 = <span class="keyword">new</span> UserClassLoader(rootDir);</span><br><span class="line">            Class clazz1 = loader1.findClass(<span class="string">&quot;top.lvxiaoyi.chapter04.code01.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">            UserClassLoader loader2 = <span class="keyword">new</span> UserClassLoader(rootDir);</span><br><span class="line">            Class clazz2 = loader2.findClass(<span class="string">&quot;top.lvxiaoyi.chapter04.code01.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(clazz1 == clazz2);</span><br><span class="line">            System.out.println(clazz1.getClassLoader());</span><br><span class="line">            System.out.println(clazz2.getClassLoader());</span><br><span class="line">            </span><br><span class="line">            Class clazz3 = ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;top.lvxiaoyi.chapter04.code01.User&quot;</span>);</span><br><span class="line">            System.out.println(clazz3.getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">false</span></span><br><span class="line">top.lvxiaoyi.chapter04.code01.UserClassLoader@4554617c</span><br><span class="line">top.lvxiaoyi.chapter04.code01.UserClassLoader@<span class="number">1540e19d</span></span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>



<h3 id="1-5-类加载机制的基本特征"><a href="#1-5-类加载机制的基本特征" class="headerlink" title="1.5. 类加载机制的基本特征"></a>1.5. 类加载机制的基本特征</h3><p>通常类加载机制有三个基本特征：</p>
<ul>
<li><p>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。 </p>
</li>
<li><p>可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</p>
</li>
<li><p>单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</p>
</li>
</ul>
<h3 id="1-6-类加载器之间的关系"><a href="#1-6-类加载器之间的关系" class="headerlink" title="1.6. 类加载器之间的关系"></a>1.6. 类加载器之间的关系</h3><p>Launcher类核心代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Launcher.ExtClassLoader var1;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;Could not create extension class loader&quot;</span>, var10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;Could not create application class loader&quot;</span>, var9);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread.currentThread().setContextClassLoader(<span class="keyword">this</span>.loader);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ExtClassLoader的Parent类是null</strong></li>
<li><strong>AppClassLoader的Parent类是ExtClassLoader</strong></li>
<li><strong>当前线程的ClassLoader是AppClassLoader</strong></li>
</ul>
<p>注意，这里的Parent类并不是Java语言意义上的继承关系，而是一种包含关系注意，这里的Parent类并不是Java语言意义上的继承关系，而是一种包含关系</p>
<hr>
<h2 id="类的加载器分类"><a href="#类的加载器分类" class="headerlink" title="类的加载器分类"></a>类的加载器分类</h2><p>JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是<strong>Java虚拟机规范</strong>却没有这么定义，而是将<strong>所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</strong>无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/0c43fb4a7da20038c8f56b42a1ddf802.png/lvxiaoyi" alt="image-20210501164413665" style="zoom: 80%;" />

<ul>
<li>除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加戟器。</li>
<li>不同类加载器看似是继承（Inheritance）关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用。</li>
</ul>
<p>父类加载器和子类</p>
<p>加载器的关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    ClassLoader parent;<span class="comment">//父类加载器</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123; <span class="comment">//parent = new ParentClassLoader();</span></span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正是由于子类加载器中包含着父类加载器的引用，所以可以通过子类加载器的方法获取对应的父类加载器</p>
<p><strong>注意：</strong></p>
<p>启动类加载器通过C/C++语言编写，而自定义类加载器都是由Java语言编写的，虽然扩展类加载器和应用程序类加载器是被jdk开发人员使用java语言来编写的，但是也是由java语言编写的，所以也被称为自定义类加载器</p>
<h3 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h3><p>启动类加载器（引导类加载器，Bootstrap ClassLoader）</p>
<ul>
<li><p>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</p>
</li>
<li><p>它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容）。用于提供JVM自身需要的类。</p>
</li>
<li><p>并不继承自java.lang.ClassLoader，没有父加载器。</p>
</li>
<li><p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p>
</li>
<li><p>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/43431a1abff0e5f2bd7bfd20fe91e5f7.png/lvxiaoyi" alt="image-20210501170011811"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/5cd73234cd993408846ec7b4c2cb7238.png/lvxiaoyi" alt="image-20210501170038212"> 使用-XX:+TraceClassLoading参数得到。</p>
</li>
</ul>
<p>启动类加载器使用C++编写的？Yes！</p>
<ul>
<li>C/C++：指针函数&amp;函数指针、C++支持多继承、更加高效</li>
<li>Java：由C++演变而来，（C++）–版，单继承</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Launcher;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;lassLoader&gt; <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*******启动类加载器*******&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取BootstrapclassLoader能够加载的api的路径</span></span><br><span class="line">        URL[] urLs = Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (URL element : urLs) &#123;</span><br><span class="line">            System.out.println(element.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从上面的路径中随意选择一个类，来看看他的类加载器是什么：引导类加载器</span></span><br><span class="line">        ClassLoader classLoader = java.security.Provider.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*******启动类加载器*******</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1.8.0_101/jre/lib/resources.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1.8.0_101/jre/lib/rt.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1.8.0_101/jre/lib/sunrsasign.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1.8.0_101/jre/lib/jsse.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1.8.0_101/jre/lib/jce.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1.8.0_101/jre/lib/charsets.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1.8.0_101/jre/lib/jfr.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1.8.0_101/jre/classes</span><br><span class="line">null</span><br></pre></td></tr></table></figure>



<h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p>扩展类加载器（Extension ClassLoader）</p>
<ul>
<li><p>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</p>
</li>
<li><p>继承于ClassLoader类</p>
</li>
<li><p>父类加载器为启动类加载器</p>
</li>
<li><p>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/ba54af96e744eb99a9248d13e55a7e3c.png/lvxiaoyi" alt="在这里插入图片描述"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.security.ec.CurveDB;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;lassLoader&gt; <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******扩展类加载器*******&quot;</span>);</span><br><span class="line">        String extDirs = System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String path : extDirs.split(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从上面的路径中随意选择一个类，来看看他的类加载器是什么：扩展类加载器</span></span><br><span class="line">        ClassLoader classLoader1 = CurveDB.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1); <span class="comment">//sun.misc.Launcher$ExtClassLoader@4b67cf4d</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*******扩展类加载器*******</span><br><span class="line">C:\Program Files\Java\jdk1.8.0_101\jre\lib\ext</span><br><span class="line">C:\WINDOWS\Sun\Java\lib\ext</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@4b67cf4d</span><br></pre></td></tr></table></figure>



<h3 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h3><p>应用程序类加载器（系统类加载器，AppClassLoader）</p>
<ul>
<li>java语言编写，由sun.misc.Launcher$AppClassLoader实现</li>
<li>继承于ClassLoader类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统属性java.class.path 指定路径下的类库</li>
<li><strong>应用程序中的类加载器默认是系统类加载器</strong>。</li>
<li>它是用户自定义类加载器的默认父加载器</li>
<li>通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/19dd9595afeb6543593ef14161fc1bb8.png/lvxiaoyi" alt="image-20210501171206453"></p>
<h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>用户自定义类加载器</p>
<ul>
<li>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li>
<li>体现Java语言强大生命力和巨大魅力的关键因素之一便是，Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。</li>
<li>通过类加载器可以实现非常绝妙的插件机制通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</li>
<li>同时，自定义加载器能够实现应用隔离自定义加载器能够实现应用隔离，例如Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多，想不修改C/C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。</li>
<li>自定义类加载器通常需要继承于ClassLoader。</li>
</ul>
<hr>
<h2 id="测试不同的类的加载器"><a href="#测试不同的类的加载器" class="headerlink" title="测试不同的类的加载器"></a>测试不同的类的加载器</h2><p>每个Class对象都会包含一个定义它的ClassLoader的一个引用。 <strong>获取ClassLoader的途径</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得当前类的ClassLoader</span></span><br><span class="line">clazz.getClassLoader()</span><br><span class="line"><span class="comment">// 获得当前线程上下文的ClassLoader</span></span><br><span class="line">Thread.currentThread().getContextClassLoader()</span><br><span class="line"><span class="comment">// 获得系统的ClassLoader</span></span><br><span class="line">ClassLoader.getSystemClassLoader()</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加 载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。由于引导类加载 器压根儿就不是一个Java类，因此在Java程序中只能打印出空值。</li>
<li>数组类的Class对象，不是由类加载器去创建的，而是在Java运行期JVM根据需要自动创建的。对于数组类的类加载器 来说，是通过Class.getClassLoader()返回的，与数组当中元素类型的类加载器是一样的；如果数组当中的元素类型 是基本数据类型，数组类是没有类加载器的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行结果：null</span></span><br><span class="line">String[] strArr = <span class="keyword">new</span> String[<span class="number">6</span>];</span><br><span class="line">System.out.println(strArr.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：sun.misc.Launcher$AppCLassLoader@18b4aac2</span></span><br><span class="line">ClassLoaderTest[] test=<span class="keyword">new</span> ClassLoaderTest[<span class="number">1</span>];</span><br><span class="line">System.out.println(test.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：null</span></span><br><span class="line"><span class="keyword">int</span>[]ints =<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">System.out.println(ints.getClass().getClassLoader());</span><br></pre></td></tr></table></figure>

<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取系统该类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//获取扩展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@4554617c</span></span><br><span class="line">        <span class="comment">//试图获取引导类加载器：失败</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//##################################</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader classLoader = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader);</span><br><span class="line">            <span class="comment">//自定义的类默认使用系统类加载器</span></span><br><span class="line">            ClassLoader classLoader1 = Class.forName(<span class="string">&quot;top.lvxiaoyi.chapter04.code03.ClassLoaderTest1&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader1);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//关于数组类型的加载：使用的类的加载器与数组元素的类的加载器相同</span></span><br><span class="line">            String[] arrstr = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arrstr.getClass().getClassLoader());<span class="comment">//null：表示使用的是引导类加载器</span></span><br><span class="line"></span><br><span class="line">            ClassLoaderTest1[] arr1 = <span class="keyword">new</span> ClassLoaderTest1[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arr1.getClass().getClassLoader());<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arr2.getClass().getClassLoader());<span class="comment">//null:</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@4554617c</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>



<h2 id="ClassLoader源码解析"><a href="#ClassLoader源码解析" class="headerlink" title="ClassLoader源码解析"></a>ClassLoader源码解析</h2><p><strong>ClassLoader与现有类加载器的关系：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/00148a792adcf05932114dff408f82b5.png/lvxiaoyi" alt="image-20210501173110637">d</p>
<p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p>
<h3 id="ClassLoader的主要方法"><a href="#ClassLoader的主要方法" class="headerlink" title="ClassLoader的主要方法"></a>ClassLoader的主要方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ClassLoader <span class="title">getParent</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>返回该类加载器的超类加载器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br></pre></td></tr></table></figure>

<p>loadClass剖析：</p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;top.lvxioayi.java.User&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>设计到如下代码的调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resolve：true  加载class的同时进行解析操作</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 同步操作，保证只能加载一次</span></span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            <span class="comment">// 首先，在缓存中检查是否已经加载了同名的类</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取时间</span></span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取当前类加载器的父类</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果存在父类加载器，则调用父类加载器进行类的加载</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 父类为空，说明父类为引导类加载器</span></span><br><span class="line">                        <span class="comment">// 如果缓存中已经记载了同名的类则不加载，否则加载这个类</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line">				</span><br><span class="line">                <span class="comment">// 当前类的父类加载器未加载此类 或者 当前类的加载器未加载此类</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="comment">// 调用当前ClassLoader的findClass方法</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 是否进行解析操作</span></span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回 ClassNotFoundException异常。该方法中的逻辑就是双亲委派模式的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                    <span class="comment">// 路径替换</span></span><br><span class="line">                    String path = name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.class&quot;</span>);</span><br><span class="line">                    Resource res = ucp.getResource(path, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> defineClass(name, res);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, acc);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (ClassNotFoundException) pae.getException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用。</p>
<ul>
<li>在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中，从前面的分析可知，findClass()方法是在loadClass()方法中被调用的，当loadClass()方法中父加载器加载失败后，则会调用自己的findClass()方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。</li>
<li>需要注意的是ClassLoader类中并没有实现findClass()方法的具体代码逻辑，取而代之的是抛出ClassNotFoundException异常，同时应该知道的是findClass方法通常是和defineClass方法一起使用的。一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象。一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; defineClass(String name, Resource res) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">    <span class="keyword">int</span> i = name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    URL url = res.getCodeSourceURL();</span><br><span class="line">    <span class="keyword">if</span> (i != -<span class="number">1</span>) &#123;</span><br><span class="line">        String pkgname = name.substring(<span class="number">0</span>, i);</span><br><span class="line">        <span class="comment">// Check if package already loaded.</span></span><br><span class="line">        Manifest man = res.getManifest();</span><br><span class="line">        definePackageInternal(pkgname, man, url);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Now read the class bytes and define the class</span></span><br><span class="line">    java.nio.ByteBuffer bb = res.getByteBuffer();</span><br><span class="line">    <span class="keyword">if</span> (bb != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Use (direct) ByteBuffer:</span></span><br><span class="line">        CodeSigner[] signers = res.getCodeSigners();</span><br><span class="line">        CodeSource cs = <span class="keyword">new</span> CodeSource(url, signers);</span><br><span class="line">        sun.misc.PerfCounter.getReadClassBytesTime().addElapsedTimeFrom(t0);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, bb, cs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = res.getBytes();</span><br><span class="line">        <span class="comment">// must read certificates AFTER reading bytes.</span></span><br><span class="line">        CodeSigner[] signers = res.getCodeSigners();</span><br><span class="line">        CodeSource cs = <span class="keyword">new</span> CodeSource(url, signers);</span><br><span class="line">        sun.misc.PerfCounter.getReadClassBytesTime().addElapsedTimeFrom(t0);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length, cs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用。</p>
<ul>
<li>defineClass()方法是用来将byte字节流解析成JVM能够识别的Class对象（ClassLoader中已实现该方法逻辑），通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象。</li>
<li>defineClass()方法通常与findClass()方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象defineClass()方法通常与findClass()方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象</li>
</ul>
<p><strong>简单举例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 获取类的字节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] classData =getClassData(name);</span><br><span class="line">    <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//使用defineClass生成class对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name,classData,θ,classData.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span></span></span><br></pre></td></tr></table></figure>

<p>链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name)</span><br></pre></td></tr></table></figure>

<p>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例。这个方法是final方法，无法被修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br></pre></td></tr></table></figure>

<p>它也是一个ClassLoader的实例，这个字段所表示的ClassLoader也称为这个ClassLoader的双亲。在类加载的过程中，ClassLoader可能会将某些请求交予自己的双亲处理。</p>
<h3 id="SecureClassLoader与URLClassLoader"><a href="#SecureClassLoader与URLClassLoader" class="headerlink" title="SecureClassLoader与URLClassLoader"></a>SecureClassLoader与URLClassLoader</h3><p>接着SecureClassLoader扩展了ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对class源码的访问权限）的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联。</p>
<p>前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。<strong>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类</strong>，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/53f634bada23b3400a303bfcc6e11a31.png/lvxiaoyi" alt="image-20210501174730756"></p>
<h3 id="ExtClassLoader与AppClassLoader"><a href="#ExtClassLoader与AppClassLoader" class="headerlink" title="ExtClassLoader与AppClassLoader"></a>ExtClassLoader与AppClassLoader</h3><p>了解完URLClassLoader后接着看看剩余的两个类加载器，即拓展类加载器ExtClassLoader和系统类加载器AppClassLoader，这两个类都继承自URLClassLoader，是sun.misc.Launcher的静态内部类。</p>
<p>sun.misc.Launcher主要被系统用于启动主应用程序，ExtClassLoader和AppClassLoader都是由sun.misc.Launcher创建的，其类主要类结构如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/a77b6bca10308e6b9be35b1b2dfc84bc.png/lvxiaoyi" alt="img"></p>
<p>我们发现ExtClassLoader并没有重写loadClass()方法，这足矣说明其遵循双亲委派模式，而<strong>AppClassLoader重载了loadClass()方法，但最终调用的还是父类loadClass()方法，因此依然遵守双亲委派模式</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Class <span class="title">loadClass</span><span class="params">(String var1, <span class="keyword">boolean</span> var2)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var3 = var1.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">    <span class="keyword">if</span> (var3 != -<span class="number">1</span>) &#123;</span><br><span class="line">        SecurityManager var4 = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (var4 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            var4.checkPackageAccess(var1.substring(<span class="number">0</span>, var3));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类的loadClass</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException var5) &#123;</span><br><span class="line">        <span class="keyword">throw</span> var5;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException var6) &#123;</span><br><span class="line">        <span class="keyword">throw</span> var6;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error var7) &#123;</span><br><span class="line">        <span class="keyword">throw</span> var7;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Class-forName-与ClassLoader-loadClass"><a href="#Class-forName-与ClassLoader-loadClass" class="headerlink" title="Class.forName()与ClassLoader.loadClass()"></a>Class.forName()与ClassLoader.loadClass()</h3><p><strong>Class.forName()</strong></p>
<ul>
<li><p>Class.forName()：是一个静态方法，最常用的是Class.forName(String className);</p>
</li>
<li><p>根据传入的类的全限定名返回一个Class对象。该方法在将Class文件加载到内存的同时，会执行类的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;top.lvxioayi.java.Helloworld&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>ClassLoader.loadClass()</strong></p>
<ul>
<li><p>ClassLoader.loadClass()：这是一个实例方法，需要一个ClassLoader对象来调用该方法。</p>
</li>
<li><p>该方法将Class文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化。该方法因为需要得到一个ClassLoader对象，所以可以根据需要指定使用哪个类加载器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Classloader cl = ......; cl.loadClass(<span class="string">&quot;top.lvxioayi.java.Helloworld&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
</li>
</ul>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="定义与本质"><a href="#定义与本质" class="headerlink" title="定义与本质"></a>定义与本质</h3><p>类加载器用来把类加载到Java虚拟机中。从JDK1.2版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证Java平台的安全。</p>
<p><strong>定义</strong></p>
<p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</p>
<p><strong>本质</strong></p>
<p>规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/41cbfd9ba1da676a7f05dae0dac3abae.png/lvxiaoyi" alt="image-20210501175529542"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/c1526b63e95852b48551b4f136ebbd6f.png/lvxiaoyi" alt="img"></p>
<h3 id="优势与劣势"><a href="#优势与劣势" class="headerlink" title="优势与劣势"></a>优势与劣势</h3><h4 id="双亲委派机制优势"><a href="#双亲委派机制优势" class="headerlink" title="双亲委派机制优势"></a><strong>双亲委派机制优势</strong></h4><ul>
<li><p>避免类的重复加载，确保一个类的全局唯一性</p>
<p><strong>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载</strong>，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();<span class="comment">// object类的加载只能使用引导类加载器进行</span></span><br></pre></td></tr></table></figure></li>
<li><p>保护程序安全，防止核心API被随意篡改</p>
<p>不能定义<code>java.lang.String</code>类，报错Prohibited package name：java.lang</p>
</li>
</ul>
<p><strong>代码支持</strong></p>
<p>双亲委派机制在<code>java.lang.ClassLoader.loadClass(String,boolean)</code>接口中体现。该接口的逻辑如下：</p>
<p>（1）先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</p>
<p>（2）判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name，false)接口进行加载。</p>
<p>（3）反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassorNull(name)接口，让引导类加载器进行加载。</p>
<p>（4）如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。</p>
<p>双亲委派的模型就隐藏在这第2和第3步中。</p>
<p><strong>举例</strong></p>
<p>假设当前加载的是java.lang.Object这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当]VM准备加载javaJang.Object时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从<strong>系统类的缓存中肯定查找不到该类</strong>，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩<strong>展类加载器的缓存中</strong>也一定查找不到该类，因此进入第2步。扩展类的父加载器是null，因此系统调用findClass（String），最终通过引导类加载器进行加载。</p>
<p><strong>思考</strong></p>
<p>如果在自定义的类加载器中重写java.lang.ClassLoader.loadClass(String)或java.lang.ClassLoader.loadclass(String，boolean)方法，抹去其中的双亲委派机制，仅保留上面这4步中的第l步与第4步，那么是不是就能够加载核心类库了呢？</p>
<p>这也不行！因为JDK还为核心类库提供了一层保护机制。<strong>不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都必须调用 java.lang.ClassLoader.defineclass(String，byte[]，int，int，ProtectionDomain)方法</strong>，而该方法会执行preDefineClass()接口，该接口中提供了对JDK核心类库的保护。</p>
<p>在的实现在URLClassLoader中的findclass中，在findclass中调用defineclass，然后最终调用preDefineClass()</p>
<h4 id="双亲委派模式弊端"><a href="#双亲委派模式弊端" class="headerlink" title="双亲委派模式弊端"></a><strong>双亲委派模式弊端</strong></h4><p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类，保护核心不能被修改。</p>
<p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p>
<p><strong>结论</strong></p>
<p><strong>由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型</strong>，只是建议采用这种方式而已。比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法。</p>
<h3 id="破坏双亲委派机制"><a href="#破坏双亲委派机制" class="headerlink" title="破坏双亲委派机制"></a>破坏双亲委派机制</h3><p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p>
<p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p>
<h4 id="第一次破坏双亲委派机制"><a href="#第一次破坏双亲委派机制" class="headerlink" title="第一次破坏双亲委派机制"></a><strong>第一次破坏双亲委派机制</strong></h4><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代。</p>
<p>由于<strong>双亲委派模型在JDK 1.2之后才被引入</strong>，但是<strong>类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在</strong>，面对经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协。</p>
<p><strong>为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性</strong>，只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<h4 id="第二次破坏双亲委派机制：线程上下文类加载器"><a href="#第二次破坏双亲委派机制：线程上下文类加载器" class="headerlink" title="第二次破坏双亲委派机制：线程上下文类加载器"></a><strong>第二次破坏双亲委派机制：线程上下文类加载器</strong></h4><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载越基础的类由越上层的加载器进行加载），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？基础类型又要调用回用户的代码，那该怎么办呢？</p>
<p>这并非是不可能出现的事情，一个典型的例子便是<code>JNDI</code>服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？（SPI：在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI）</p>
<p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（ThreadContextClassLoader）,也就是ApplicationClassLoader（sun.misc.Launcher.class中）。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
<p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器（ApplicationClassLoader）去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，==这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则==，但也是无可奈何的事情。 </p>
<p>例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK6时，JDK提供了java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/814235dcce5471c2a527e82bafcf21c7.png/lvxiaoyi" alt="img"  />

<p>默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p>
<h4 id="第三次破坏双亲委派机制"><a href="#第三次破坏双亲委派机制" class="headerlink" title="第三次破坏双亲委派机制"></a><strong>第三次破坏双亲委派机制</strong></h4><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如：**代码热替换(Hot Swap)、模块热部署(Hot Deployment)**等</p>
<p>IBM公司主导的JSR-291(即OSGiR4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(osGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在oSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p>
<p>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p>
<p>1）将以java.∗开头的类，委派给父类加载器加载。将以java.∗开头的类，委派给父类加载器加载。</p>
<p>2）否则，将委派列表名单内的类，委派给父类加载器加载。否则，将委派列表名单内的类，委派给父类加载器加载。</p>
<p>3）否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</p>
<p>4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</p>
<p>5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</p>
<p>6）否则，查找Dynamic Import列表的Bundle，委派给对应Bund1e的类加载器加载。</p>
<p>7）否则，类查找失败。</p>
<p>说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p>
<p>小结：这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</p>
<p>正如：OSGi中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为<strong>OSGi中对类加载器的运用是值得学习的，完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹。</strong></p>
<h3 id="热替换的实现"><a href="#热替换的实现" class="headerlink" title="热替换的实现"></a>热替换的实现</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的，比如：PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。</p>
<p>但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。</p>
<p>注意：由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同一个类，在虚拟机内部，会认为这2个类是完全不同的。</p>
<p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/9ae876265c85af4e431932647993dab7.png/lvxiaoyi" alt="image-20210501182003439"></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lvxiaoyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/26 21:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">hot</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;old Demo1&quot;</span>);</span><br><span class="line"><span class="comment">//        System.out.println(&quot;old Demo1  -&gt; hello lvxiaoyi , you are success&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lvxiaoyi.chapter04.code05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lvxiaoyi</span></span><br><span class="line"><span class="comment"> * 实战java虚拟机 p355</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/26 21:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopRun</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 自定义类加载器，不同的命名空间是不同的类加载器，如果忘记回顾概述、命名空间</span></span><br><span class="line">                MyClassLoader loader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;D:\\interview\\jvm\\src\\main\\java&quot;</span>);</span><br><span class="line">                <span class="comment">// 加载demo1的class文件</span></span><br><span class="line">                Class clazz = loader.findClass(<span class="string">&quot;top.lvxiaoyi.chapter04.code05.Demo1&quot;</span>);</span><br><span class="line">                <span class="comment">// 根据class文件，创建对象</span></span><br><span class="line">                Object demo = clazz.newInstance();</span><br><span class="line">                <span class="comment">// 调用hot方法，这里是public方法，如果是private方法还需要setAccessible(true)</span></span><br><span class="line">                Method m = clazz.getMethod(<span class="string">&quot;hot&quot;</span>);</span><br><span class="line">                <span class="comment">// 执行方法</span></span><br><span class="line">                m.invoke(demo);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException | InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;not find&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lvxiaoyi.chapter04.code05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Channels;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.WritableByteChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lvxiaoyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/26 21:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) &#123;</span><br><span class="line">        <span class="comment">// 查找已经记载的类，如果类已经加载，则不作重复加载</span></span><br><span class="line">        Class clazz = <span class="keyword">this</span>.findLoadedClass(className);</span><br><span class="line">        <span class="comment">// 通过文件查找（FileInputStream），读取class的二进制数据流然后输出（ByteArrayOutputStream），中间通过channel和buffer读入和写出</span></span><br><span class="line">        <span class="comment">// 这里使用的java NIO，如果没有学习可以参考https://lvxiaoyi.top/30cac350.html</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == clazz) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String classFile = getClassFile(className);</span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(classFile);</span><br><span class="line">                <span class="comment">// 创建file的Channel，nio的channel可以双向读写</span></span><br><span class="line">                FileChannel fileChannel = fis.getChannel();</span><br><span class="line">                <span class="comment">// 创建字节输出流</span></span><br><span class="line">                ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                <span class="comment">// 字节输出流用channel包装</span></span><br><span class="line">                WritableByteChannel outC = Channels.newChannel(baos);</span><br><span class="line">                <span class="comment">// 创建buffer缓存，chanel读取写入是通过buffer的</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">                <span class="comment">// 循环将channerl的内容读入buffer、写入WritableByteChannel中</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = fileChannel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || i == -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 转换读写</span></span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    outC.write(buffer);</span><br><span class="line">                    <span class="comment">// 清空buffer，以便后续写入</span></span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                fis.close();</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">                <span class="comment">// 将二进制数据流定义为Class，返回该对象</span></span><br><span class="line">                clazz = defineClass(className, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getClassFile</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + <span class="string">&quot;\\&quot;</span> + className.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;\\&quot;</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//javac Demo1.java</span></span><br><span class="line">old Demo1</span><br><span class="line">old Demo1</span><br><span class="line">old Demo1</span><br><span class="line">old Demo1</span><br><span class="line">old Demo1</span><br><span class="line">old Demo1</span><br><span class="line">old Demo1</span><br><span class="line">old Demo1</span><br><span class="line">old Demo1</span><br><span class="line">old Demo1</span><br><span class="line">old Demo1</span><br><span class="line"><span class="comment">// 修改demo1文件，然后运行javac Demo1.java</span></span><br><span class="line">old Demo1  -&gt; hello lvxiaoyi , you are success</span><br><span class="line">old Demo1  -&gt; hello lvxiaoyi , you are success</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/s28036503.jpg/lvxiaoyi" alt="实战Java虚拟机"></p>
<p>P355页的案例</p>
<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>沙箱安全机制</p>
<ul>
<li>保证程序安全</li>
<li>保护Java原生的JDK代码</li>
</ul>
<p>Java安全模型的核心就是Java沙箱（<code>sandbox</code>）Java安全模型的核心就是Java沙箱（<code>sandbox</code>）。什么是沙箱？沙箱是一个限制程序运行的环境。</p>
<p>沙箱机制就是将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。</p>
<p>沙箱主要限制系统资源访问，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p>
<p>所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p>
<h3 id="JDK1-0时期"><a href="#JDK1-0时期" class="headerlink" title="JDK1.0时期"></a>JDK1.0时期</h3><p>在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于<strong>沙箱（Sandbox）机制</strong>。如下图所示JDK1.0安全模型</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/71caf905a0ca13866e24419b7faa14ee.png/lvxiaoyi" alt="image-20210501182608205" style="zoom:67%;" />

<h3 id="JDK1-1时期"><a href="#JDK1-1时期" class="headerlink" title="JDK1.1时期"></a>JDK1.1时期</h3><p>JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。</p>
<p>因此在后续的Java1.1版本中，针对安全机制做了改进，增加了<strong>安全策略</strong>。允许用户指定代码对本地资源的访问权限。</p>
<p>如下图所示JDK1.1安全模型</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/b93f0829e8340131a49738f8843307e4.png/lvxiaoyi" alt="image-20210501182626963" style="zoom:67%;" />

<h3 id="JDK1-2时期"><a href="#JDK1-2时期" class="headerlink" title="JDK1.2时期"></a>JDK1.2时期</h3><p>在Java1.2版本中，再次改进了安全机制，增加了<strong>代码签名</strong>。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/81919ed70977f2b57ef5a11481c68abc.png/lvxiaoyi" alt="image-20210501182652378" style="zoom:67%;" />

<h3 id="JDK1-6时期"><a href="#JDK1-6时期" class="headerlink" title="JDK1.6时期"></a>JDK1.6时期</h3><p>当前最新的安全机制实现，则引入了<strong>域（Domain）</strong>的概念。</p>
<p>虚拟机会把所有代码加载到不同的系统域和应用域。系统域部分专门负责与关键资源进行交互系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型（jdk1.6）</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/cf22059daec45f370ae3afb33b870c1f.png/lvxiaoyi" alt="image-20210501182740197" style="zoom:67%;" />

<hr>
<h2 id="自定义类的加载器"><a href="#自定义类的加载器" class="headerlink" title="自定义类的加载器"></a>自定义类的加载器</h2><h3 id="为什么要自定义类加载器？"><a href="#为什么要自定义类加载器？" class="headerlink" title="为什么要自定义类加载器？"></a>为什么要自定义类加载器？</h3><ul>
<li><p>隔离加载类</p>
<p>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如:Tomcat这类Web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。（类的仲裁–&gt;类冲突）</p>
</li>
<li><p>修改类加载的方式修改类加载的方式</p>
<p>类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载</p>
</li>
<li><p>扩展加载源扩展加载源</p>
<p>比如从数据库、网络、甚至是电视机机顶盒进行加载</p>
</li>
<li><p>防止源码泄漏防止源码泄漏</p>
<p>Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</p>
</li>
</ul>
<p><strong>常见的场景</strong></p>
<ul>
<li>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是JavaEE和OSGI、JPMS等框架。</li>
<li>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。</li>
</ul>
<p><strong>注意</strong></p>
<p>在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换，则加载器反而容易产生不美好的事情。在做Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p>
<p>在自定义ClassLoader的子类时候，我们常见的会有两种做法：</p>
<ul>
<li>方式一：重写loadClass()方法</li>
<li>方式二：重写findclass()方法</li>
</ul>
<p><strong>对比</strong></p>
<ul>
<li>这两种方法本质上差不多，毕竟loadClass()也会调用findClass()，但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。</li>
<li>loadclass()这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写loadClass()方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</li>
<li>当编写好自定义类加载器后，便可以在程序中调用loadClass()方法来实现类加载操作。</li>
</ul>
<p><strong>说明</strong></p>
<ul>
<li>其父类加载器是系统类加载器</li>
<li>JVM中的所有类加载都会使用java.lang.ClassLoader.loadClass(String)接口(自定义类加载器并重写java.lang.ClassLoader.loadClass(String)接口的除外)，连JDK的核心类库也不能例外。</li>
</ul>
<hr>
<h2 id="Java9新特性"><a href="#Java9新特性" class="headerlink" title="Java9新特性"></a>Java9新特性</h2><p>为了保证兼容性，JDK9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lvxiaoyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/26 21:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClassLoader loader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;D:\\interview\\jvm\\src\\main\\java&quot;</span>);</span><br><span class="line">        Class clazz = loader.findClass(<span class="string">&quot;top.lvxiaoyi.chapter04.code05.Demo1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;加载此类的加载器为：&quot;</span> + clazz.getClassLoader().getClass().getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;加载当前demo1此类的加载器的父类加载器为：&quot;</span> + clazz.getClassLoader().getParent().getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在java8中</span></span><br><span class="line">加载此类的加载器为：top.lvxiaoyi.chapter04.code05.MyClassLoader</span><br><span class="line">加载当前demo1此类的加载器的父类加载器为：sun.misc.Launcher$AppClassLoader</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 在java9中由AppClassLoader变为了$PlatformClassLoader</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol>
<li><p>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器(platform class loader)。可以通过classLoader的新方法getPlatformClassLoader()来获取。</p>
<p>JDK9时基于模块化进行构建(原来的 <code>rt.jar</code>和·tools.jar·被拆分成数十个<code>JMOD</code>文件)，其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录，此前使用这个目录或者<code>java.ext.dirs</code>系统变量来扩展JDK功能的机制已经没有继续存在的价值了。</p>
</li>
<li><p>平台类加载器和应用程序类加载器都不再继承自java.net.URLClassLoader。</p>
<p>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader。</p>
</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/323cfcda53f98034ed15372c0ea43685.png/lvxiaoyi" alt="img" style="zoom:67%;" />

<p> 如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在JDK9及更高版本的JDK中崩溃。</p>
<ol start="3">
<li><p>在Java9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</p>
</li>
<li><p><strong>启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器</strong>（以前是C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。</p>
</li>
<li><p>类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</p>
</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/cb23791a5fb1bf1a4c8a28d6a3179e84.png/lvxiaoyi" alt="img" style="zoom: 80%;" />



<p>附加:<br>在 Java模块化系统明确规定了三个类加载器负责各自加载的模块：</p>
<ul>
<li>启动类加载器负责加载的模块</li>
</ul>
<table>
<thead>
<tr>
<th>java.bas4</th>
<th>java.security.sasl</th>
</tr>
</thead>
<tbody><tr>
<td>java.datatransfer</td>
<td>java.xml</td>
</tr>
<tr>
<td>java.desktop</td>
<td>jdk.httpserver</td>
</tr>
<tr>
<td>java.instrument</td>
<td>jdk.internal.vm.ci</td>
</tr>
<tr>
<td>java.logging</td>
<td>jdk.management</td>
</tr>
<tr>
<td>java.management</td>
<td>jdk.management.agent</td>
</tr>
<tr>
<td>java.management.rmi</td>
<td>jdk.naming.rmi</td>
</tr>
<tr>
<td>java.naming</td>
<td>jdk.net</td>
</tr>
<tr>
<td>java.prefs</td>
<td>jdk.sctp</td>
</tr>
<tr>
<td>java.rmi</td>
<td>jdk. unsupported</td>
</tr>
</tbody></table>
<ul>
<li>平台类加载器负责加载的模块</li>
</ul>
<table>
<thead>
<tr>
<th>java.activation*</th>
<th>jdk.accessibility</th>
</tr>
</thead>
<tbody><tr>
<td>java.compiler*</td>
<td>jdk.charsets</td>
</tr>
<tr>
<td>java.corba*</td>
<td>jdk.crypto.cryptoki</td>
</tr>
<tr>
<td>java.scripting</td>
<td>jdk.crypto.ec</td>
</tr>
<tr>
<td>java.se</td>
<td>jdk.dynalink</td>
</tr>
<tr>
<td>java.se.ee</td>
<td>jdk.incubator.httpclient</td>
</tr>
<tr>
<td>java.security.jgss</td>
<td>jdk.internal.vm.compiler*</td>
</tr>
<tr>
<td>java.smartcardio</td>
<td>jdk.jsobject</td>
</tr>
<tr>
<td>java.sql</td>
<td>jdk.localedata</td>
</tr>
<tr>
<td>java.sql.rowset</td>
<td>jdk.naming.dns</td>
</tr>
<tr>
<td>java.transaction*</td>
<td>jdk.scripting.nashorn</td>
</tr>
<tr>
<td>java.xml.bind*</td>
<td>jdk.security.auth</td>
</tr>
<tr>
<td>java.xml.crypto</td>
<td>jdk.security.jgss</td>
</tr>
<tr>
<td>java.xml.ws*</td>
<td>jdk.xml .dom</td>
</tr>
<tr>
<td>java.xml.ws.annotation*</td>
<td>jdk.zipfs</td>
</tr>
</tbody></table>
<ul>
<li>应用程序类加载器负责加载的模块</li>
</ul>
<table>
<thead>
<tr>
<th>jdk.aot</th>
<th>jdk.jdeps</th>
</tr>
</thead>
<tbody><tr>
<td>jdk.attach</td>
<td>jdk.jdi</td>
</tr>
<tr>
<td>jdk.compiler</td>
<td>jdk.jdwp.agent</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader());</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getParent());</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getParent().getParent());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">        <span class="comment">//获取平台类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.getPlatformClassLoader());</span><br><span class="line">        <span class="comment">//获取类的加载器的名称</span></span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/60069cd7f346fb566ebba524">https://www.processon.com/view/link/60069cd7f346fb566ebba524</a></p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/u21195183/">https://www.yuque.com/u21195183/</a></p>
<p><a target="_blank" rel="noopener" href="https://youthlql.gitee.io/post/8c954c6.html">https://youthlql.gitee.io/post/8c954c6.html</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://lvxiaoyi.top">lvxiaoyi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lvxiaoyi.top/9f1e208e.html">https://lvxiaoyi.top/9f1e208e.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lvxiaoyi.top" target="_blank">吕小医's BLOG</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/jvm/">jvm</a></div><div class="post_share"><div class="social-share" data-image="https://img.lvxiaoyi.top/typora-img/202111011421399.jpeg/lvxiaoyi" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/6197d47a.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111011421399.jpeg/lvxiaoyi" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">jvm基础3之性能监控与调优篇</div></div></a></div><div class="next-post pull-right"><a href="/539b1196.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111011421399.jpeg/lvxiaoyi" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">jvm基础1之内存与垃圾回收篇</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/127ae04f.html" title="Jvm基础4之案例篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111011421399.jpeg/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">Jvm基础4之案例篇</div></div></a></div><div><a href="/dd88deb1.html" title="前端编译器和后端编译器"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.zhimg.com/v2-9964d2894516902605191817111ec781_r.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">前端编译器和后端编译器</div></div></a></div><div><a href="/561c47f9.html" title="jvm中对象的内存布局"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111011413329.png/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">jvm中对象的内存布局</div></div></a></div><div><a href="/6197d47a.html" title="jvm基础3之性能监控与调优篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111011421399.jpeg/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">jvm基础3之性能监控与调优篇</div></div></a></div><div><a href="/539b1196.html" title="jvm基础1之内存与垃圾回收篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111011421399.jpeg/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">jvm基础1之内存与垃圾回收篇</div></div></a></div><div><a href="/2134a338.html" title="源码级别理解java拆箱装箱过程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20210913142135732.png/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">源码级别理解java拆箱装箱过程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p0.meituan.net/csc/8a1b1d488e6a8ab5108c9c78f36b3a1776955.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lvxiaoyi</div><div class="author-info__description">ISFP到ESFJ</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">205</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">51</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lvxiaoyi"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">冲鸭！内卷起来了兄弟</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#jvm%E5%9F%BA%E7%A1%802"><span class="toc-number">1.</span> <span class="toc-text">jvm基础2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">字节码文件的跨平台性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%EF%BC%9A%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%E8%AF%AD%E8%A8%80%EF%BC%88write-once%EF%BC%8Crun-anywhere"><span class="toc-number">2.1.1.</span> <span class="toc-text">Java语言：跨平台的语言（write once，run anywhere</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9A%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B9%B3%E5%8F%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">Java虚拟机：跨语言的平台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E6%BA%90%E7%A0%81%E5%BF%85%E9%A1%BB%E7%BC%96%E8%AF%91%E4%B8%BA%E7%AC%A6%E5%90%88jvm%E8%A7%84%E8%8C%83%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">2.1.3.</span> <span class="toc-text">java源码必须编译为符合jvm规范的字节码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">前端编译器和后端编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">前端编译器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">后端编译器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%82%E5%AF%9F"><span class="toc-number">2.3.</span> <span class="toc-text">深入字节码观察</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.3.1.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%981"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">面试题1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%982"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">面试题2</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#valueOf-NaN"><span class="toc-number">2.3.1.2.1.</span> <span class="toc-text">valueOf</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#intValue"><span class="toc-number">2.3.1.2.2.</span> <span class="toc-text">intValue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.3.1.2.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text">代码举例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B1"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">举例1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B2"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">举例2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B3"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">举例3</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.3.2.3.1.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9F%BA%E7%9F%B3%EF%BC%9AClass%E6%96%87%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">虚拟机的基石：Class文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.1.</span> <span class="toc-text">字节码文件是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%EF%BC%88byte-code%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">什么是字节码指令（byte code）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E8%AF%BB"><span class="toc-number">3.3.</span> <span class="toc-text">如何解读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9Anotepad"><span class="toc-number">3.3.1.</span> <span class="toc-text">方法一：notepad++</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">下载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">安装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8Binary-Viewer"><span class="toc-number">3.3.2.</span> <span class="toc-text">方法二：使用Binary Viewer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E4%BD%BF%E7%94%A8javap%E6%8C%87%E4%BB%A4"><span class="toc-number">3.3.3.</span> <span class="toc-text">方法三：使用javap指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%9B%9B%EF%BC%9Ajclasslib-bytecode-viewer%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">3.3.4.</span> <span class="toc-text">方法四：jclasslib bytecode viewer（推荐）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Class-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">Class 文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">4.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Class%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">4.1.1.</span> <span class="toc-text">Class类的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.1.2.</span> <span class="toc-text">Class文件格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.1.3.</span> <span class="toc-text">代码示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">原始字节码文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.4.</span> <span class="toc-text">总体文件结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text">Class 字节码文件结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class-%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">Class 文件数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AD%94%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">魔数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-number">4.5.</span> <span class="toc-text">文件版本号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-%E6%96%87%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%B7%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-number">4.5.1.</span> <span class="toc-text">Class 文件版本号对应关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%E9%9B%86%E5%90%88"><span class="toc-number">4.6.</span> <span class="toc-text">常量池集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">4.6.1.</span> <span class="toc-text">常量池计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%A1%A8"><span class="toc-number">4.6.2.</span> <span class="toc-text">常量池表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8"><span class="toc-number">4.6.2.1.</span> <span class="toc-text">字面量和符号引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%BB%93%E6%9E%84"><span class="toc-number">4.6.2.2.</span> <span class="toc-text">常量类型和结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97"><span class="toc-number">4.7.</span> <span class="toc-text">访问标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E6%8E%A5%E5%8F%A3%E7%B4%A2%E5%BC%95"><span class="toc-number">4.8.</span> <span class="toc-text">类索引、父类索引、接口索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this-class%EF%BC%88%E7%B1%BB%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="toc-number">4.8.1.</span> <span class="toc-text">this_class（类索引）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super-class%EF%BC%88%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="toc-number">4.8.2.</span> <span class="toc-text">super_class（父类索引）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interfaces"><span class="toc-number">4.8.3.</span> <span class="toc-text">interfaces</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#interfaces-count%EF%BC%88%E6%8E%A5%E5%8F%A3%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%89"><span class="toc-number">4.8.3.1.</span> <span class="toc-text">interfaces_count（接口计数器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#interfaces-%EF%BC%88%E6%8E%A5%E5%8F%A3%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">4.8.3.2.</span> <span class="toc-text">interfaces[]（接口索引集合）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E8%A1%A8%E9%9B%86%E5%90%88"><span class="toc-number">4.9.</span> <span class="toc-text">字段表集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-1-%E5%AD%97%E6%AE%B5%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">4.9.1.</span> <span class="toc-text">1.8.1. 字段计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-2-%E5%AD%97%E6%AE%B5%E8%A1%A8"><span class="toc-number">4.9.2.</span> <span class="toc-text">1.8.2. 字段表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%85%A0-%E5%AD%97%E6%AE%B5%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%A0%87%E8%AF%86"><span class="toc-number">4.9.2.1.</span> <span class="toc-text">Ⅰ. 字段表访问标识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%85%A1-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%B4%A2%E5%BC%95"><span class="toc-number">4.9.2.2.</span> <span class="toc-text">Ⅱ. 描述符索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%85%A2-%E5%B1%9E%E6%80%A7%E8%A1%A8%E9%9B%86%E5%90%88"><span class="toc-number">4.9.2.3.</span> <span class="toc-text">Ⅲ. 属性表集合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A1%A8%E9%9B%86%E5%90%88"><span class="toc-number">4.10.</span> <span class="toc-text">方法表集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">4.10.1.</span> <span class="toc-text">方法计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A1%A8"><span class="toc-number">4.10.2.</span> <span class="toc-text">方法表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%A1%A8%E9%9B%86%E5%90%88"><span class="toc-number">4.11.</span> <span class="toc-text">属性表集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">4.11.1.</span> <span class="toc-text">属性计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%A1%A8"><span class="toc-number">4.11.2.</span> <span class="toc-text">属性表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#javap%E6%8C%87%E4%BB%A4%E8%A7%A3%E6%9E%90Class%E6%96%87%E4%BB%B6"><span class="toc-number">4.12.</span> <span class="toc-text">javap指令解析Class文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%AD%97%E8%8A%82%E7%A0%81%E4%BD%9C%E7%94%A8"><span class="toc-number">4.12.1.</span> <span class="toc-text">解析字节码作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#javac-g-%E6%93%8D%E4%BD%9C"><span class="toc-number">4.12.2.</span> <span class="toc-text">javac -g 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#javap%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">4.12.3.</span> <span class="toc-text">javap的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="toc-number">4.12.4.</span> <span class="toc-text">使用举例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">4.12.4.1.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">4.12.4.2.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Jclasslib%E5%88%86%E6%9E%90"><span class="toc-number">4.12.4.3.</span> <span class="toc-text">Jclasslib分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">4.12.5.</span> <span class="toc-text">总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">5.</span> <span class="toc-text">字节码指令集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">5.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">执行模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.2.</span> <span class="toc-text">字节码与数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.3.</span> <span class="toc-text">指令的分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">5.2.</span> <span class="toc-text">加载与存储指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">5.2.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">常用指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%A6%82%EF%BC%9A"><span class="toc-number">5.2.1.2.1.</span> <span class="toc-text">例如：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E4%B9%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-number">5.2.2.</span> <span class="toc-text">复习：操作数栈与局部变量表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">操作数栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%EF%BC%88Local-Variables%EF%BC%89"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">局部变量表（Local Variables）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="toc-number">5.2.2.2.1.</span> <span class="toc-text">解析：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%8E%8B%E6%A0%88%E6%8C%87%E4%BB%A4"><span class="toc-number">5.2.3.</span> <span class="toc-text">局部变量压栈指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%8E%8B%E6%A0%88%E6%8C%87%E4%BB%A4-1"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">局部变量压栈指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%8E%8B%E6%A0%88%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">局部变量压栈常用指令集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4"><span class="toc-number">5.2.4.</span> <span class="toc-text">常量入栈指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4%E5%89%96%E6%9E%90"><span class="toc-number">5.2.4.1.</span> <span class="toc-text">常量入栈指令剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4const%E7%B3%BB%E5%88%97%EF%BC%9A"><span class="toc-number">5.2.4.1.1.</span> <span class="toc-text">指令const系列：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4push%E7%B3%BB%E5%88%97%EF%BC%9A"><span class="toc-number">5.2.4.1.2.</span> <span class="toc-text">指令push系列：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4ldc%E7%B3%BB%E5%88%97%EF%BC%9A"><span class="toc-number">5.2.4.1.3.</span> <span class="toc-text">指令ldc系列：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%85%A5%E6%A0%88%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">5.2.4.2.</span> <span class="toc-text">常量入栈常用指令集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BA%E6%A0%88%E8%A3%85%E5%85%A5%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">5.2.5.</span> <span class="toc-text">出栈装入局部变量表指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E6%A0%88%E8%A3%85%E5%85%A5%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E6%8C%87%E4%BB%A4%E5%89%96%E6%9E%90"><span class="toc-number">5.2.5.1.</span> <span class="toc-text">出栈装入局部变量表指令剖析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E6%A0%88%E8%A3%85%E5%85%A5%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">5.2.5.2.</span> <span class="toc-text">出栈装入局部变量表常用指令集</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4"><span class="toc-number">5.3.</span> <span class="toc-text">算术指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="toc-number">5.3.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-1"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#byte%E3%80%81short%E3%80%81char%E5%92%8Cboolean%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">5.3.1.3.</span> <span class="toc-text">byte、short、char和boolean类型说明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%90%E7%AE%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.1.3.1.</span> <span class="toc-text">java虚拟机中的实际类型与运算类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E6%97%B6%E7%9A%84%E6%BA%A2%E5%87%BA"><span class="toc-number">5.3.1.4.</span> <span class="toc-text">运算时的溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.1.5.</span> <span class="toc-text">运算模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NAN%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">5.3.1.6.</span> <span class="toc-text">NAN的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">5.3.2.</span> <span class="toc-text">算术指令集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97"><span class="toc-number">5.4.</span> <span class="toc-text">整数运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="toc-number">5.5.</span> <span class="toc-text">逻辑运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">5.5.1.</span> <span class="toc-text">移位操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97"><span class="toc-number">5.5.2.</span> <span class="toc-text">按位布尔运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97"><span class="toc-number">5.5.3.</span> <span class="toc-text">浮点运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4%E4%B8%BE%E4%BE%8B"><span class="toc-number">5.5.3.1.</span> <span class="toc-text">算术指令举例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B1-1"><span class="toc-number">5.5.3.1.1.</span> <span class="toc-text">举例1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B2-1"><span class="toc-number">5.5.3.1.2.</span> <span class="toc-text">举例2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B3-1"><span class="toc-number">5.5.3.1.3.</span> <span class="toc-text">举例3</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%8D%E4%B8%BE%E4%BE%8B"><span class="toc-number">5.5.3.2.</span> <span class="toc-text">再举例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%BA%8C"><span class="toc-number">5.5.3.2.1.</span> <span class="toc-text">举例二</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%B8%89"><span class="toc-number">5.5.3.2.2.</span> <span class="toc-text">举例三</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E5%9B%9B"><span class="toc-number">5.5.3.2.3.</span> <span class="toc-text">举例四</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%BA%94"><span class="toc-number">5.5.3.2.4.</span> <span class="toc-text">举例五</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E5%85%AD"><span class="toc-number">5.5.3.2.5.</span> <span class="toc-text">举例六</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%B8%83"><span class="toc-number">5.5.3.2.6.</span> <span class="toc-text">举例七</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E5%85%AB"><span class="toc-number">5.5.3.2.7.</span> <span class="toc-text">举例八</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%B9%9D"><span class="toc-number">5.5.3.2.8.</span> <span class="toc-text">举例九</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-number">5.5.4.</span> <span class="toc-text">比较指令的说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4"><span class="toc-number">5.6.</span> <span class="toc-text">类型转换指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-5"><span class="toc-number">5.6.1.</span> <span class="toc-text">概述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%BD%E5%8C%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.7.</span> <span class="toc-text">宽化类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%84%E5%8C%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.8.</span> <span class="toc-text">窄化类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%BD%E5%8C%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%89%96%E6%9E%90"><span class="toc-number">5.8.1.</span> <span class="toc-text">宽化类型转换剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99"><span class="toc-number">5.8.1.1.</span> <span class="toc-text">转换规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%BE%E5%BA%A6%E6%8D%9F%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="toc-number">5.8.1.2.</span> <span class="toc-text">精度损失问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="toc-number">5.8.1.3.</span> <span class="toc-text">补充说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%84%E5%8C%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%89%96%E6%9E%90"><span class="toc-number">5.8.2.</span> <span class="toc-text">窄化类型转换剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99-1"><span class="toc-number">5.8.2.1.</span> <span class="toc-text">转换规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%BE%E5%BA%A6%E6%8D%9F%E5%A4%B1%E9%97%AE%E9%A2%98-1"><span class="toc-number">5.8.2.2.</span> <span class="toc-text">精度损失问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E-1"><span class="toc-number">5.8.2.3.</span> <span class="toc-text">补充说明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BD%93%E5%B0%86%E4%B8%80%E4%B8%AA%E6%B5%AE%E7%82%B9%E5%80%BC%E7%AA%84%E5%8C%96%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8BT-T%E9%99%90%E4%BA%8Eint%E6%88%96long%E7%B1%BB%E5%9E%8B%E4%B9%8B%E4%B8%80-%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%B0%86%E9%81%B5%E5%BE%AA%E4%BB%A5%E4%B8%8B%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-number">5.8.2.3.1.</span> <span class="toc-text">当将一个浮点值窄化转换为整数类型T(T限于int或long类型之一)的时候，将遵循以下转换规则：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BD%93%E5%B0%86%E4%B8%80%E4%B8%AAdouble%E7%B1%BB%E5%9E%8B%E7%AA%84%E5%8C%96%E8%BD%AC%E6%8D%A2%E4%B8%BAfloat%E7%B1%BB%E5%9E%8B%E6%97%B6%EF%BC%8C%E5%B0%86%E9%81%B5%E5%BE%AA%E4%BB%A5%E4%B8%8B%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-number">5.8.2.3.2.</span> <span class="toc-text">当将一个double类型窄化转换为float类型时，将遵循以下转换规则：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4"><span class="toc-number">5.9.</span> <span class="toc-text">对象的创建与访问指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-6"><span class="toc-number">5.9.1.</span> <span class="toc-text">概述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-number">5.10.</span> <span class="toc-text">对象操作指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-number">5.11.</span> <span class="toc-text">数组操作指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%8C%87%E4%BB%A4"><span class="toc-number">5.11.1.</span> <span class="toc-text">创建指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4"><span class="toc-number">5.11.2.</span> <span class="toc-text">字段访问指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4-1"><span class="toc-number">5.11.3.</span> <span class="toc-text">数组操作指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E6%8C%87%E4%BB%A4"><span class="toc-number">5.11.4.</span> <span class="toc-text">类型检查指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%8E%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="toc-number">5.12.</span> <span class="toc-text">方法调用与返回指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">5.13.</span> <span class="toc-text">方法调用指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="toc-number">5.14.</span> <span class="toc-text">方法返回指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4-1"><span class="toc-number">5.14.1.</span> <span class="toc-text">方法调用指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%B8%80"><span class="toc-number">5.14.1.1.</span> <span class="toc-text">举例一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%BA%8C-1"><span class="toc-number">5.14.1.2.</span> <span class="toc-text">举例二</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4-1"><span class="toc-number">5.14.2.</span> <span class="toc-text">方法返回指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E7%AE%A1%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-number">5.15.</span> <span class="toc-text">操作数栈管理指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-7"><span class="toc-number">5.15.1.</span> <span class="toc-text">概述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8-%E6%97%A0%E7%B1%BB%E5%9E%8B%EF%BC%89%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-number">5.16.</span> <span class="toc-text">通用(无类型）栈操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%B8%80-1"><span class="toc-number">5.16.1.</span> <span class="toc-text">举例一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%BA%8C-2"><span class="toc-number">5.16.2.</span> <span class="toc-text">举例二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">5.17.</span> <span class="toc-text">控制转移指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-8"><span class="toc-number">5.17.1.</span> <span class="toc-text">概述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4"><span class="toc-number">5.18.</span> <span class="toc-text">比较指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E6%8C%87%E4%BB%A4"><span class="toc-number">5.19.</span> <span class="toc-text">条件分支指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E6%8C%87%E4%BB%A4"><span class="toc-number">5.20.</span> <span class="toc-text">比较条件分支指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">5.21.</span> <span class="toc-text">多条件分支跳转指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">5.22.</span> <span class="toc-text">无条件跳转指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4-1"><span class="toc-number">5.22.1.</span> <span class="toc-text">比较指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">5.22.2.</span> <span class="toc-text">条件跳转指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%B8%80-2"><span class="toc-number">5.22.2.1.</span> <span class="toc-text">举例一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%BA%8C-3"><span class="toc-number">5.22.2.2.</span> <span class="toc-text">举例二</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">5.22.3.</span> <span class="toc-text">比较条件跳转指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E8%B7%B3%E8%BD%AC"><span class="toc-number">5.22.4.</span> <span class="toc-text">多条件分支跳转</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%B8%80-3"><span class="toc-number">5.22.4.1.</span> <span class="toc-text">举例一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%BA%8C-4"><span class="toc-number">5.22.4.2.</span> <span class="toc-text">举例二</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC"><span class="toc-number">5.22.5.</span> <span class="toc-text">无条件跳转</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%B8%80-4"><span class="toc-number">5.22.5.1.</span> <span class="toc-text">举例一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%BA%8C-5"><span class="toc-number">5.22.5.2.</span> <span class="toc-text">举例二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%B8%89-1"><span class="toc-number">5.22.5.3.</span> <span class="toc-text">举例三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E5%9B%9B-1"><span class="toc-number">5.22.5.4.</span> <span class="toc-text">举例四</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%BA%94-1"><span class="toc-number">5.22.5.5.</span> <span class="toc-text">举例五</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-number">5.23.</span> <span class="toc-text">异常处理指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-9"><span class="toc-number">5.23.1.</span> <span class="toc-text">概述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4-1"><span class="toc-number">5.24.</span> <span class="toc-text">异常处理指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E6%8C%87%E4%BB%A4"><span class="toc-number">5.24.1.</span> <span class="toc-text">抛出异常指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%B8%80-5"><span class="toc-number">5.24.1.1.</span> <span class="toc-text">举例一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%BA%8C-6"><span class="toc-number">5.24.1.2.</span> <span class="toc-text">举例二</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E5%BC%82%E5%B8%B8%E8%A1%A8"><span class="toc-number">5.24.2.</span> <span class="toc-text">异常处理与异常表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%B8%80-6"><span class="toc-number">5.24.2.1.</span> <span class="toc-text">举例一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%BA%8C-7"><span class="toc-number">5.24.2.2.</span> <span class="toc-text">举例二</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-number">5.24.2.2.1.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E8%A1%A8%EF%BC%9A"><span class="toc-number">5.24.2.2.2.</span> <span class="toc-text">异常表：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">5.24.2.2.3.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%B8%89-2"><span class="toc-number">5.24.2.3.</span> <span class="toc-text">举例三</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-number">5.25.</span> <span class="toc-text">同步控制指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">5.25.1.</span> <span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-10"><span class="toc-number">5.25.2.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%BA%A7%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">5.25.3.</span> <span class="toc-text">方法级的同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%86%85%E6%8C%87%E4%BB%A4%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">5.25.4.</span> <span class="toc-text">方法内指令指令序列的同步</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89%E8%AF%A6%E8%A7%A3"><span class="toc-number">6.</span> <span class="toc-text">类的加载过程（类的生命周期）详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-11"><span class="toc-number">6.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">6.1.1.</span> <span class="toc-text">大厂面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E4%B8%80%EF%BC%9ALoading%EF%BC%88%E5%8A%A0%E8%BD%BD%EF%BC%89%E9%98%B6%E6%AE%B5"><span class="toc-number">6.2.</span> <span class="toc-text">过程一：Loading（加载）阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">6.2.1.</span> <span class="toc-text">加载完成的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%81%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="toc-number">6.2.2.</span> <span class="toc-text">二进制流的获取方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%B8%8E-Class-%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">6.2.3.</span> <span class="toc-text">类模型与 Class 实例的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">6.2.4.</span> <span class="toc-text">数组类的加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E4%BA%8C%EF%BC%9ALinking%EF%BC%88%E9%93%BE%E6%8E%A5%EF%BC%89%E9%98%B6%E6%AE%B5"><span class="toc-number">6.3.</span> <span class="toc-text">过程二：Linking（链接）阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E8%8A%82-1%EF%BC%9A%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5%E4%B9%8B-Verification%EF%BC%88%E9%AA%8C%E8%AF%81%EF%BC%89"><span class="toc-number">6.3.1.</span> <span class="toc-text">环节 1：链接阶段之 Verification（验证）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%8E%AF%E8%8A%82-2%EF%BC%9A%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5%E4%B9%8B-Preparation%EF%BC%88%E5%87%86%E5%A4%87%EF%BC%89"><span class="toc-number">6.3.2.</span> <span class="toc-text">3.2. 环节 2：链接阶段之 Preparation（准备）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%8E%AF%E8%8A%82-3%EF%BC%9A%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5%E4%B9%8B-Resolution%EF%BC%88%E8%A7%A3%E6%9E%90%EF%BC%89"><span class="toc-number">6.3.3.</span> <span class="toc-text">3.3. 环节 3：链接阶段之 Resolution（解析）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%8F%8F%E8%BF%B0%EF%BC%9A"><span class="toc-number">6.3.3.1.</span> <span class="toc-text">具体描述：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%B8%80-7"><span class="toc-number">6.3.3.1.1.</span> <span class="toc-text">举例一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%BA%8C%EF%BC%9A"><span class="toc-number">6.3.3.1.2.</span> <span class="toc-text">举例二：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">6.3.3.2.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%8D%E4%B9%A0"><span class="toc-number">6.3.3.3.</span> <span class="toc-text">字符串复习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E4%B8%89%EF%BC%9AInitialization%EF%BC%88%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%89%E9%98%B6%E6%AE%B5"><span class="toc-number">6.4.</span> <span class="toc-text">过程三：Initialization（初始化）阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-12"><span class="toc-number">6.4.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%8F%8F%E8%BF%B0"><span class="toc-number">6.4.1.1.</span> <span class="toc-text">具体描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-number">6.4.1.2.</span> <span class="toc-text">说明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%B8%80-8"><span class="toc-number">6.4.1.2.1.</span> <span class="toc-text">举例一</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-%E4%B8%8E-final-%E7%9A%84%E6%90%AD%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-number">6.4.2.</span> <span class="toc-text">static 与 final 的搭配问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">6.4.2.1.</span> <span class="toc-text">说明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%B8%80-9"><span class="toc-number">6.4.2.2.</span> <span class="toc-text">举例一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%BA%8C-8"><span class="toc-number">6.4.2.3.</span> <span class="toc-text">举例二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E7%BB%93%E8%AE%BA%EF%BC%9A"><span class="toc-number">6.4.2.4.</span> <span class="toc-text">最终结论：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lt-clinit-gt-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">6.4.3.</span> <span class="toc-text">&lt;clinit&gt;()的线程安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%83%85%E5%86%B5%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8-vs-%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">6.4.4.</span> <span class="toc-text">类的初始化情况：主动使用 vs 被动使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">6.4.4.1.</span> <span class="toc-text">主动使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">6.4.4.2.</span> <span class="toc-text">被动使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E5%9B%9B%EF%BC%9A%E7%B1%BB%E7%9A%84-Using%EF%BC%88%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">6.5.</span> <span class="toc-text">过程四：类的 Using（使用）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E4%BA%94%EF%BC%9A%E7%B1%BB%E7%9A%84-Unloading%EF%BC%88%E5%8D%B8%E8%BD%BD%EF%BC%89"><span class="toc-number">6.6.</span> <span class="toc-text">过程五：类的 Unloading（卸载）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E3%80%81%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E3%80%81%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">6.6.1.</span> <span class="toc-text">类、类的加载器、类的实例之间的引用关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">6.6.2.</span> <span class="toc-text">类的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E4%BE%8B%E5%AD%90"><span class="toc-number">6.6.3.</span> <span class="toc-text">具体例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8D%B8%E8%BD%BD"><span class="toc-number">6.6.4.</span> <span class="toc-text">类的卸载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE%EF%BC%9A%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">6.6.5.</span> <span class="toc-text">回顾：方法区的垃圾回收</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">再谈类的加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-13"><span class="toc-number">7.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98-1"><span class="toc-number">7.1.1.</span> <span class="toc-text">大厂面试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">7.1.2.</span> <span class="toc-text">类加载器的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%8A%A0%E8%BD%BD"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">显式加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E5%8A%A0%E8%BD%BD"><span class="toc-number">7.1.2.2.</span> <span class="toc-text">隐式加载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">7.1.3.</span> <span class="toc-text">1.3. 类加载器的必要性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">7.1.4.</span> <span class="toc-text">1.4. 命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">7.1.5.</span> <span class="toc-text">1.5. 类加载机制的基本特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.1.6.</span> <span class="toc-text">1.6. 类加载器之间的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">7.2.</span> <span class="toc-text">类的加载器分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.2.1.</span> <span class="toc-text">引导类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.2.2.</span> <span class="toc-text">扩展类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.2.3.</span> <span class="toc-text">系统类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.2.4.</span> <span class="toc-text">用户自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E4%B8%8D%E5%90%8C%E7%9A%84%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.3.</span> <span class="toc-text">测试不同的类的加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ClassLoader%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">7.4.</span> <span class="toc-text">ClassLoader源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ClassLoader%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-number">7.4.1.</span> <span class="toc-text">ClassLoader的主要方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SecureClassLoader%E4%B8%8EURLClassLoader"><span class="toc-number">7.4.2.</span> <span class="toc-text">SecureClassLoader与URLClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ExtClassLoader%E4%B8%8EAppClassLoader"><span class="toc-number">7.4.3.</span> <span class="toc-text">ExtClassLoader与AppClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-forName-%E4%B8%8EClassLoader-loadClass"><span class="toc-number">7.4.4.</span> <span class="toc-text">Class.forName()与ClassLoader.loadClass()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.5.</span> <span class="toc-text">双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%9C%AC%E8%B4%A8"><span class="toc-number">7.5.1.</span> <span class="toc-text">定义与本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF"><span class="toc-number">7.5.2.</span> <span class="toc-text">优势与劣势</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8A%BF"><span class="toc-number">7.5.2.1.</span> <span class="toc-text">双亲委派机制优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F%E5%BC%8A%E7%AB%AF"><span class="toc-number">7.5.2.2.</span> <span class="toc-text">双亲委派模式弊端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">7.5.3.</span> <span class="toc-text">破坏双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">7.5.3.1.</span> <span class="toc-text">第一次破坏双亲委派机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9A%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.5.3.2.</span> <span class="toc-text">第二次破坏双亲委派机制：线程上下文类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">7.5.3.3.</span> <span class="toc-text">第三次破坏双亲委派机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%AD%E6%9B%BF%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.5.4.</span> <span class="toc-text">热替换的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">7.5.4.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.5.4.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">7.6.</span> <span class="toc-text">沙箱安全机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-0%E6%97%B6%E6%9C%9F"><span class="toc-number">7.6.1.</span> <span class="toc-text">JDK1.0时期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-1%E6%97%B6%E6%9C%9F"><span class="toc-number">7.6.2.</span> <span class="toc-text">JDK1.1时期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-2%E6%97%B6%E6%9C%9F"><span class="toc-number">7.6.3.</span> <span class="toc-text">JDK1.2时期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-6%E6%97%B6%E6%9C%9F"><span class="toc-number">7.6.4.</span> <span class="toc-text">JDK1.6时期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.7.</span> <span class="toc-text">自定义类的加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F"><span class="toc-number">7.7.1.</span> <span class="toc-text">为什么要自定义类加载器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">7.7.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java9%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">7.8.</span> <span class="toc-text">Java9新特性</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/560e8e48.html" title="博客美化"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.zhimg.com/v2-9964d2894516902605191817111ec781_r.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="博客美化"/></a><div class="content"><a class="title" href="/560e8e48.html" title="博客美化">博客美化</a><time datetime="2023-12-29T14:58:12.257Z" title="发表于 2023-12-29 22:58:12">2023-12-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7ef7bbd4.html" title="LeetCode 118. 杨辉三角"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111011355394.png/lvxiaoyi" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode 118. 杨辉三角"/></a><div class="content"><a class="title" href="/7ef7bbd4.html" title="LeetCode 118. 杨辉三角">LeetCode 118. 杨辉三角</a><time datetime="2023-03-19T14:25:59.394Z" title="发表于 2023-03-19 22:25:59">2023-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/82c8cab7.html" title="shell基础"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.zhimg.com/v2-9964d2894516902605191817111ec781_r.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="shell基础"/></a><div class="content"><a class="title" href="/82c8cab7.html" title="shell基础">shell基础</a><time datetime="2022-10-12T16:07:18.841Z" title="发表于 2022-10-13 00:07:18">2022-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f1601c3e.html" title="单例模式"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/1002892-20180912131026735-781767905.png/lvxiaoyi" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="单例模式"/></a><div class="content"><a class="title" href="/f1601c3e.html" title="单例模式">单例模式</a><time datetime="2022-09-12T07:22:48.777Z" title="发表于 2022-09-12 15:22:48">2022-09-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/b15f0f1b.html" title="设计模式基础-1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20211012093705433.png/lvxiaoyi" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式基础-1"/></a><div class="content"><a class="title" href="/b15f0f1b.html" title="设计模式基础-1">设计模式基础-1</a><time datetime="2022-09-12T07:22:48.777Z" title="发表于 2022-09-12 15:22:48">2022-09-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://img.lvxiaoyi.top/typora-img/202111011421399.jpeg/lvxiaoyi')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By lvxiaoyi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/lvxiaoyi.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>