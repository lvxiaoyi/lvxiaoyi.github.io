<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Spark基础-3SparkStreaming | 吕小医's BLOG</title><meta name="keywords" content="大数据"><meta name="author" content="lvxiaoyi"><meta name="copyright" content="lvxiaoyi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spark基础-3SparkStreamingSparkStreaming 概述Spark Streaming 是什么 Spark 流使得构建可扩展的容错流应用程序变得更加容易。 Spark Streaming 用于流式数据的处理。Spark Streaming 支持的数据输入源很多，例如：Kafka、Flume、Twitter、ZeroMQ 和简单的 TCP 套接字等等。数据输入后可以用 Spa">
<meta property="og:type" content="article">
<meta property="og:title" content="Spark基础-3SparkStreaming">
<meta property="og:url" content="https://lvxiaoyi.top/e1884286.html">
<meta property="og:site_name" content="吕小医&#39;s BLOG">
<meta property="og:description" content="Spark基础-3SparkStreamingSparkStreaming 概述Spark Streaming 是什么 Spark 流使得构建可扩展的容错流应用程序变得更加容易。 Spark Streaming 用于流式数据的处理。Spark Streaming 支持的数据输入源很多，例如：Kafka、Flume、Twitter、ZeroMQ 和简单的 TCP 套接字等等。数据输入后可以用 Spa">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.lvxiaoyi.top/typora-img/202111091530306.png/lvxiaoyi">
<meta property="article:published_time" content="2022-09-12T07:22:48.769Z">
<meta property="article:modified_time" content="2022-09-12T07:22:48.769Z">
<meta property="article:author" content="lvxiaoyi">
<meta property="article:tag" content="大数据">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.lvxiaoyi.top/typora-img/202111091530306.png/lvxiaoyi"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lvxiaoyi.top/e1884286"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spark基础-3SparkStreaming',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-12 15:22:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://p0.meituan.net/csc/8a1b1d488e6a8ab5108c9c78f36b3a1776955.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">204</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">50</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 小医</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img.lvxiaoyi.top/typora-img/202111091530306.png/lvxiaoyi')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">吕小医's BLOG</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 小医</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spark基础-3SparkStreaming</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-12T07:22:48.769Z" title="发表于 2022-09-12 15:22:48">2022-09-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-12T07:22:48.769Z" title="更新于 2022-09-12 15:22:48">2022-09-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/">Spark</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spark基础-3SparkStreaming"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Spark基础-3SparkStreaming"><a href="#Spark基础-3SparkStreaming" class="headerlink" title="Spark基础-3SparkStreaming"></a>Spark基础-3SparkStreaming</h1><h1 id="SparkStreaming-概述"><a href="#SparkStreaming-概述" class="headerlink" title="SparkStreaming 概述"></a>SparkStreaming 概述</h1><h2 id="Spark-Streaming-是什么"><a href="#Spark-Streaming-是什么" class="headerlink" title="Spark Streaming 是什么"></a>Spark Streaming 是什么</h2><p><img src="https://img.lvxiaoyi.top/typora-img/202111091530306.png/lvxiaoyi" alt="image-20211109153043234"></p>
<p>Spark 流使得构建可扩展的容错流应用程序变得更加容易。</p>
<p>Spark Streaming 用于流式数据的处理。Spark Streaming 支持的数据输入源很多，例如：Kafka、Flume、Twitter、ZeroMQ 和简单的 TCP 套接字等等。数据输入后可以用 Spark 的高度抽象原语如：map、reduce、join、window 等进行运算。而结果也能保存在很多地方，如 HDFS，数据库等。</p>
<p><img src="https://img.lvxiaoyi.top/typora-img/202111091531082.png/lvxiaoyi" alt="image-20211109153104989"></p>
<p>和 Spark 基于 RDD 的概念很相似，Spark Streaming 使用离散化流(discretized stream)作为抽象表示，叫作DStream。DStream 是随时间推移而收到的数据的序列。在内部，每个时间区间收到的数据都作为 RDD 存在，而 DStream 是由这些RDD 所组成的序列(因此得名“离散化”)。所以简单来将，DStream 就是对 RDD 在实时数据处理场景的一种封装。</p>
<h2 id="Spark-Streaming-的特点"><a href="#Spark-Streaming-的特点" class="headerlink" title="Spark Streaming 的特点"></a>Spark Streaming 的特点</h2><ul>
<li>易用</li>
<li>容错</li>
<li>易整合到 Spark 体系</li>
</ul>
<h2 id="Spark-Streaming-架构"><a href="#Spark-Streaming-架构" class="headerlink" title="Spark Streaming 架构"></a>Spark Streaming 架构</h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><ul>
<li><p>整体架构图</p>
<p><img src="https://img.lvxiaoyi.top/typora-img/202111091532418.png/lvxiaoyi" alt="image-20211109153237355"></p>
</li>
<li><p>SparkStreaming 架构图</p>
<p><img src="https://img.lvxiaoyi.top/typora-img/202111091533756.png/lvxiaoyi" alt="image-20211109153302683"></p>
</li>
</ul>
<h3 id="背压机制"><a href="#背压机制" class="headerlink" title="背压机制"></a>背压机制</h3><p>Spark 1.5 以前版本，用户如果要限制 Receiver 的数据接收速率，可以通过设置静态配制参数“spark.streaming.receiver.maxRate”的值来实现，此举虽然可以通过限制接收速率，来适配当前的处理能力，防止内存溢出，但也会引入其它问题。比如：producer 数据生产高于 maxRate，当前集群处理能力也高于 maxRate，这就会造成资源利用率下降等问题。</p>
<p>为了更好的协调数据接收速率与资源处理能力，1.5 版本开始 Spark Streaming 可以动态控制数据接收速率来适配集群数据处理能力。背压机制（即 Spark Streaming Backpressure）: 根据JobScheduler 反馈作业的执行信息来动态调整Receiver 数据接收率。</p>
<p>通过属性“spark.streaming.backpressure.enabled”来控制是否启用 backpressure 机制，默认值false，即不启用。</p>
<h1 id="Dstream-入门"><a href="#Dstream-入门" class="headerlink" title="Dstream 入门"></a>Dstream 入门</h1><h2 id="WordCount-案例实操"><a href="#WordCount-案例实操" class="headerlink" title="WordCount 案例实操"></a>WordCount 案例实操</h2><p>需求：使用 netcat 工具向 9999 端口不断的发送数据，通过 SparkStreaming 读取端口数据并统计不同单词出现的次数</p>
<ol>
<li><p>添加依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;spark-streaming_2.12&lt;/artifactId&gt;</span><br><span class="line"> &lt;version&gt;3.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>编写代码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StreamWordCount</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"> <span class="comment">//1.初始化 Spark 配置信息</span></span><br><span class="line"> <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;StreamWordCount&quot;</span>)</span><br><span class="line"> <span class="comment">//2.初始化 SparkStreamingContext，第一个参数为环境配置，第二个参数为批量处理的周期</span></span><br><span class="line"> <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sparkConf, <span class="type">Seconds</span>(<span class="number">3</span>))</span><br><span class="line"> <span class="comment">//3.通过监控端口创建 DStream，读进来的数据为一行行</span></span><br><span class="line"> <span class="keyword">val</span> lineStreams = ssc.socketTextStream(<span class="string">&quot;linux1&quot;</span>, <span class="number">9999</span>)</span><br><span class="line"> <span class="comment">//将每一行数据做切分，形成一个个单词</span></span><br><span class="line"> <span class="keyword">val</span> wordStreams = lineStreams.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"> <span class="comment">//将单词映射成元组（word,1）</span></span><br><span class="line"> <span class="keyword">val</span> wordAndOneStreams = wordStreams.map((_, <span class="number">1</span>))</span><br><span class="line"> <span class="comment">//将相同的单词次数做统计</span></span><br><span class="line"> <span class="keyword">val</span> wordAndCountStreams = wordAndOneStreams.reduceByKey(_+_)</span><br><span class="line"> <span class="comment">//打印</span></span><br><span class="line"> wordAndCountStreams.print()</span><br><span class="line"> <span class="comment">//启动 SparkStreamingContext</span></span><br><span class="line"> ssc.start()</span><br><span class="line"> ssc.awaitTermination()</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动程序并通过 netcat 发送数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -lk 9999</span><br><span class="line">hello spark</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="WordCount-解析"><a href="#WordCount-解析" class="headerlink" title="WordCount 解析"></a>WordCount 解析</h2><p>Discretized Stream 是 Spark Streaming 的基础抽象，代表持续性的数据流和经过各种 Spark 原语操作后的结果数据流。在内部实现上，DStream 是一系列连续的 RDD 来表示。每个 RDD 含有一段时间间隔内的数据。</p>
<p><img src="https://img.lvxiaoyi.top/typora-img/202111091536780.png/lvxiaoyi" alt="image-20211109153604736"></p>
<p>对数据的操作也是按照 RDD 为单位来进行的</p>
<p><img src="https://img.lvxiaoyi.top/typora-img/202111091536218.png/lvxiaoyi" alt="image-20211109153611177"></p>
<p>计算过程由 Spark Engine 来完成</p>
<p><img src="https://img.lvxiaoyi.top/typora-img/202111091536170.png/lvxiaoyi" alt="image-20211109153657135"></p>
<h2 id="DStream-创建"><a href="#DStream-创建" class="headerlink" title="DStream 创建"></a>DStream 创建</h2><h2 id="RDD-队列"><a href="#RDD-队列" class="headerlink" title="RDD 队列"></a>RDD 队列</h2><h3 id="用法及说明"><a href="#用法及说明" class="headerlink" title="用法及说明"></a>用法及说明</h3><p>测试过程中，可以通过使用 ssc.queueStream(queueOfRDDs)来创建 DStream，每一个推送到这个队列中的 RDD，都会作为一个 DStream 处理。</p>
<p>案例实操</p>
<p>需求：循环创建几个 RDD，将 RDD 放入队列。通过 SparkStream 创建 Dstream，计算WordCount</p>
<p>编写代码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RDDStream</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line"> <span class="comment">//1.初始化 Spark 配置信息</span></span><br><span class="line"> <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;RDDStream&quot;</span>)</span><br><span class="line"> <span class="comment">//2.初始化 SparkStreamingContext</span></span><br><span class="line"> <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Seconds</span>(<span class="number">4</span>))</span><br><span class="line"> <span class="comment">//3.创建 RDD 队列</span></span><br><span class="line"> <span class="keyword">val</span> rddQueue = <span class="keyword">new</span> mutable.<span class="type">Queue</span>[<span class="type">RDD</span>[<span class="type">Int</span>]]()</span><br><span class="line"> <span class="comment">//4.创建 QueueInputDStream</span></span><br><span class="line"> <span class="keyword">val</span> inputStream = ssc.queueStream(rddQueue,oneAtATime = <span class="literal">false</span>)</span><br><span class="line"> <span class="comment">//5.处理队列中的 RDD 数据</span></span><br><span class="line"> <span class="keyword">val</span> mappedStream = inputStream.map((_,<span class="number">1</span>))</span><br><span class="line"> <span class="keyword">val</span> reducedStream = mappedStream.reduceByKey(_ + _)</span><br><span class="line"> <span class="comment">//6.打印结果</span></span><br><span class="line"> reducedStream.print()</span><br><span class="line"> <span class="comment">//7.启动任务</span></span><br><span class="line"> ssc.start()</span><br><span class="line"><span class="comment">//8.循环创建并向 RDD 队列中放入 RDD</span></span><br><span class="line"> <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">5</span>) &#123;</span><br><span class="line"> rddQueue += ssc.sparkContext.makeRDD(<span class="number">1</span> to <span class="number">300</span>, <span class="number">10</span>)</span><br><span class="line"> <span class="type">Thread</span>.sleep(<span class="number">2000</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> ssc.awaitTermination()</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>结果展示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------</span><br><span class="line">Time: 1539075280000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(4,60)</span><br><span class="line">(0,60)</span><br><span class="line">(6,60)</span><br><span class="line">(8,60)</span><br><span class="line">(2,60)</span><br><span class="line">(1,60)</span><br><span class="line">(3,60)</span><br><span class="line">(7,60)</span><br><span class="line">(9,60)</span><br><span class="line">(5,60)</span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1539075284000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(4,60)</span><br><span class="line">(0,60)</span><br><span class="line">(6,60)</span><br><span class="line">(8,60)</span><br><span class="line">(2,60)</span><br><span class="line">(1,60)</span><br><span class="line">(3,60)</span><br><span class="line">(7,60)</span><br><span class="line">(9,60)</span><br><span class="line">(5,60)</span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1539075288000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(4,30)</span><br><span class="line">(0,30)</span><br><span class="line">(6,30)</span><br><span class="line">(8,30)</span><br><span class="line">(2,30)</span><br><span class="line">(1,30)</span><br><span class="line">(3,30)</span><br><span class="line">(7,30)</span><br><span class="line">(9,30)</span><br><span class="line">(5,30)</span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1539075292000 ms</span><br><span class="line">-------------------------------------------</span><br></pre></td></tr></table></figure>

<h2 id="自定义数据源"><a href="#自定义数据源" class="headerlink" title="自定义数据源"></a>自定义数据源</h2><h3 id="用法及说明-1"><a href="#用法及说明-1" class="headerlink" title="用法及说明"></a>用法及说明</h3><p>需要继承 Receiver，并实现 onStart、onStop 方法来自定义数据源采集。</p>
<p>案例实操</p>
<p>需求：自定义数据源，实现监控某个端口号，获取该端口号内容。</p>
<ol>
<li>自定义数据源</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerReceiver</span>(<span class="params">host: <span class="type">String</span>, port: <span class="type">Int</span></span>) <span class="keyword">extends</span></span></span><br><span class="line">  <span class="type">Receiver</span>[<span class="type">String</span>](<span class="type">StorageLevel</span>.<span class="type">MEMORY_ONLY</span>) &#123;</span><br><span class="line">  <span class="comment">//最初启动的时候，调用该方法，作用为：读数据并将数据发送给 Spark</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onStart</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Thread</span>(<span class="string">&quot;Socket Receiver&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() &#123;</span><br><span class="line">        receive()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读数据并将数据发送给 Spark</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//创建一个 Socket</span></span><br><span class="line">    <span class="keyword">var</span> socket: <span class="type">Socket</span> = <span class="keyword">new</span> <span class="type">Socket</span>(host, port)</span><br><span class="line">    <span class="comment">//定义一个变量，用来接收端口传过来的数据</span></span><br><span class="line">    <span class="keyword">var</span> input: <span class="type">String</span> = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//创建一个 BufferedReader 用于读取端口传来的数据</span></span><br><span class="line">    <span class="keyword">val</span> reader = <span class="keyword">new</span> <span class="type">BufferedReader</span>(<span class="keyword">new</span> <span class="type">InputStreamReader</span>(socket.getInputStream, <span class="type">StandardCharsets</span>.<span class="type">UTF_8</span>))</span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line">    input = reader.readLine()</span><br><span class="line">    <span class="comment">//当 receiver 没有关闭并且输入数据不为空，则循环发送数据给 Spark</span></span><br><span class="line">    <span class="keyword">while</span> (!isStopped() &amp;&amp; input != <span class="literal">null</span>) &#123;</span><br><span class="line">      store(input)</span><br><span class="line">      input = reader.readLine()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跳出循环则关闭资源</span></span><br><span class="line">    reader.close()</span><br><span class="line">    socket.close()</span><br><span class="line">    <span class="comment">//重启任务</span></span><br><span class="line">    restart(<span class="string">&quot;restart&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onStop</span></span>(): <span class="type">Unit</span> = &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>使用自定义的数据源采集数据</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FileStream</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1.初始化 Spark 配置信息</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;StreamWordCount&quot;</span>)</span><br><span class="line">    <span class="comment">//2.初始化 SparkStreamingContext</span></span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sparkConf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line">    <span class="comment">//3.创建自定义 receiver 的 Streaming</span></span><br><span class="line">    <span class="keyword">val</span> lineStream = ssc.receiverStream(<span class="keyword">new</span> <span class="type">CustomerReceiver</span>(<span class="string">&quot;hadoop102&quot;</span>, <span class="number">9999</span>))</span><br><span class="line">    <span class="comment">//4.将每一行数据做切分，形成一个个单词</span></span><br><span class="line">    <span class="keyword">val</span> wordStream = lineStream.flatMap(_.split(<span class="string">&quot;\t&quot;</span>))</span><br><span class="line">    <span class="comment">//5.将单词映射成元组（word,1）</span></span><br><span class="line">    <span class="keyword">val</span> wordAndOneStream = wordStream.map((_, <span class="number">1</span>))</span><br><span class="line">    <span class="comment">//6.将相同的单词次数做统计</span></span><br><span class="line">    <span class="keyword">val</span> wordAndCountStream = wordAndOneStream.reduceByKey(_ + _)</span><br><span class="line">    <span class="comment">//7.打印</span></span><br><span class="line">    wordAndCountStream.print()</span><br><span class="line">    <span class="comment">//8.启动 SparkStreamingContext</span></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Kafka-数据源（面试、开发重点）"><a href="#Kafka-数据源（面试、开发重点）" class="headerlink" title="Kafka 数据源（面试、开发重点）"></a>Kafka 数据源（面试、开发重点）</h2><h3 id="版本选型"><a href="#版本选型" class="headerlink" title="版本选型"></a>版本选型</h3><p>ReceiverAPI：需要一个专门的 Executor 去接收数据，然后发送给其他的 Executor 做计算。存在的问题，接收数据的 Executor 和计算的 Executor 速度会有所不同，特别在接收数据的 Executor速度大于计算的 Executor 速度，会导致计算数据的节点内存溢出。早期版本中提供此方式，当前版本不适用</p>
<p>DirectAPI：是由计算的 Executor 来主动消费 Kafka 的数据，速度由自身控制。</p>
<h3 id="Kafka-0-8-Receiver-模式（当前版本不适用）"><a href="#Kafka-0-8-Receiver-模式（当前版本不适用）" class="headerlink" title="Kafka 0-8 Receiver 模式（当前版本不适用）"></a>Kafka 0-8 Receiver 模式（当前版本不适用）</h3><ol>
<li><p>需求：通过 SparkStreaming 从 Kafka 读取数据，并将读取过来的数据做简单计算，最终打印到控制台。</p>
</li>
<li><p>导入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;spark-streaming-kafka-0-8_2.11&lt;/artifactId&gt;</span><br><span class="line"> &lt;version&gt;2.4.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>编写代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.kafka</span><br><span class="line">import org.apache.spark.SparkConf</span><br><span class="line">import org.apache.spark.streaming.dstream.ReceiverInputDStream</span><br><span class="line">import org.apache.spark.streaming.kafka.KafkaUtils</span><br><span class="line">import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;</span><br><span class="line">object ReceiverAPI &#123;</span><br><span class="line"> def main(args: Array[String]): Unit = &#123;</span><br><span class="line"> //1.创建 SparkConf</span><br><span class="line"> val sparkConf: SparkConf = new </span><br><span class="line">SparkConf().setAppName(&quot;ReceiverWordCount&quot;).setMaster(&quot;local[*]&quot;)</span><br><span class="line"> //2.创建 StreamingContext</span><br><span class="line">  val ssc = new StreamingContext(sparkConf, Seconds(3))</span><br><span class="line"> //3.读取 Kafka 数据创建 DStream(基于 Receive 方式)</span><br><span class="line"> val kafkaDStream: ReceiverInputDStream[(String, String)] = </span><br><span class="line">KafkaUtils.createStream(ssc,</span><br><span class="line"> &quot;linux1:2181,linux2:2181,linux3:2181&quot;,</span><br><span class="line"> &quot;atguigu&quot;,</span><br><span class="line"> Map[String, Int](&quot;atguigu&quot; -&gt; 1))</span><br><span class="line"> //4.计算 WordCount</span><br><span class="line"> kafkaDStream.map &#123; case (_, value) =&gt;</span><br><span class="line"> (value, 1)</span><br><span class="line"> &#125;.reduceByKey(_ + _)</span><br><span class="line"> .print()</span><br><span class="line"> //5.开启任务</span><br><span class="line"> ssc.start()</span><br><span class="line"> ssc.awaitTermination()</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Kafka-0-8-Direct-模式（当前版本不适用）"><a href="#Kafka-0-8-Direct-模式（当前版本不适用）" class="headerlink" title="Kafka 0-8 Direct 模式（当前版本不适用）"></a>Kafka 0-8 Direct 模式（当前版本不适用）</h3><ol>
<li><p>需求：通过 SparkStreaming 从 Kafka 读取数据，并将读取过来的数据做简单计算，最终打印到控制台。</p>
</li>
<li><p>导入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;spark-streaming-kafka-0-8_2.11&lt;/artifactId&gt;</span><br><span class="line"> &lt;version&gt;2.4.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>编写代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.kafka</span><br><span class="line">import org.apache.spark.SparkConf</span><br><span class="line">import org.apache.spark.streaming.dstream.ReceiverInputDStream</span><br><span class="line">import org.apache.spark.streaming.kafka.KafkaUtils</span><br><span class="line">import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;</span><br><span class="line">object ReceiverAPI &#123;</span><br><span class="line"> def main(args: Array[String]): Unit = &#123;</span><br><span class="line"> //1.创建 SparkConf</span><br><span class="line"> val sparkConf: SparkConf = new </span><br><span class="line">SparkConf().setAppName(&quot;ReceiverWordCount&quot;).setMaster(&quot;local[*]&quot;)</span><br><span class="line"> //2.创建 StreamingContext</span><br><span class="line">  val ssc = new StreamingContext(sparkConf, Seconds(3))</span><br><span class="line"> //3.读取 Kafka 数据创建 DStream(基于 Receive 方式)</span><br><span class="line"> val kafkaDStream: ReceiverInputDStream[(String, String)] = </span><br><span class="line">KafkaUtils.createStream(ssc,</span><br><span class="line"> &quot;linux1:2181,linux2:2181,linux3:2181&quot;,</span><br><span class="line"> &quot;atguigu&quot;,</span><br><span class="line"> Map[String, Int](&quot;atguigu&quot; -&gt; 1))</span><br><span class="line"> //4.计算 WordCount</span><br><span class="line"> kafkaDStream.map &#123; case (_, value) =&gt;</span><br><span class="line"> (value, 1)</span><br><span class="line"> &#125;.reduceByKey(_ + _)</span><br><span class="line"> .print()</span><br><span class="line"> //5.开启任务</span><br><span class="line"> ssc.start()</span><br><span class="line"> ssc.awaitTermination()</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Kafka-0-8-Direct-模式（当前版本不适用）-1"><a href="#Kafka-0-8-Direct-模式（当前版本不适用）-1" class="headerlink" title="Kafka 0-8 Direct 模式（当前版本不适用）"></a>Kafka 0-8 Direct 模式（当前版本不适用）</h3><ol>
<li><p>需求：通过 SparkStreaming 从 Kafka 读取数据，并将读取过来的数据做简单计算，最终打印到控制台。</p>
</li>
<li><p>导入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;spark-streaming-kafka-0-8_2.11&lt;/artifactId&gt;</span><br><span class="line"> &lt;version&gt;2.4.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>编写代码（自动维护 offset）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import kafka.serializer.StringDecoder</span><br><span class="line">import org.apache.kafka.clients.consumer.ConsumerConfig</span><br><span class="line">import org.apache.spark.SparkConf</span><br><span class="line">import org.apache.spark.streaming.dstream.InputDStream</span><br><span class="line">import org.apache.spark.streaming.kafka.KafkaUtils</span><br><span class="line">import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;</span><br><span class="line">object DirectAPIAuto02 &#123;</span><br><span class="line"> val getSSC1: () =&gt; StreamingContext = () =&gt; &#123;</span><br><span class="line"> val sparkConf: SparkConf = new </span><br><span class="line">SparkConf().setAppName(&quot;ReceiverWordCount&quot;).setMaster(&quot;local[*]&quot;)</span><br><span class="line"> val ssc = new StreamingContext(sparkConf, Seconds(3))</span><br><span class="line"> ssc</span><br><span class="line"> &#125;</span><br><span class="line"> def getSSC: StreamingContext = &#123;</span><br><span class="line"> //1.创建 SparkConf</span><br><span class="line"> val sparkConf: SparkConf = new </span><br><span class="line">SparkConf().setAppName(&quot;ReceiverWordCount&quot;).setMaster(&quot;local[*]&quot;)</span><br><span class="line"> //2.创建 StreamingContext</span><br><span class="line"> val ssc = new StreamingContext(sparkConf, Seconds(3))</span><br><span class="line">  //设置 CK</span><br><span class="line"> ssc.checkpoint(&quot;./ck2&quot;)</span><br><span class="line"> //3.定义 Kafka 参数</span><br><span class="line"> val kafkaPara: Map[String, String] = Map[String, String](</span><br><span class="line"> ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG -&gt; </span><br><span class="line">&quot;linux1:9092,linux2:9092,linux3:9092&quot;,</span><br><span class="line"> ConsumerConfig.GROUP_ID_CONFIG -&gt; &quot;atguigu&quot;</span><br><span class="line"> )</span><br><span class="line"> //4.读取 Kafka 数据</span><br><span class="line"> val kafkaDStream: InputDStream[(String, String)] = </span><br><span class="line">KafkaUtils.createDirectStream[String, String, StringDecoder, StringDecoder](ssc,</span><br><span class="line"> kafkaPara,</span><br><span class="line"> Set(&quot;atguigu&quot;))</span><br><span class="line"> //5.计算 WordCount</span><br><span class="line"> kafkaDStream.map(_._2)</span><br><span class="line"> .flatMap(_.split(&quot; &quot;))</span><br><span class="line"> .map((_, 1))</span><br><span class="line"> .reduceByKey(_ + _)</span><br><span class="line"> .print()</span><br><span class="line"> //6.返回数据</span><br><span class="line"> ssc</span><br><span class="line"> &#125;</span><br><span class="line"> def main(args: Array[String]): Unit = &#123;</span><br><span class="line"> //获取 SSC</span><br><span class="line"> val ssc: StreamingContext = StreamingContext.getActiveOrCreate(&quot;./ck2&quot;, () =&gt; </span><br><span class="line">getSSC)</span><br><span class="line"> //开启任务</span><br><span class="line"> ssc.start()</span><br><span class="line"> ssc.awaitTermination()</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写代码（手动维护 offset）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import kafka.common.TopicAndPartition</span><br><span class="line">import kafka.message.MessageAndMetadata</span><br><span class="line">import kafka.serializer.StringDecoder</span><br><span class="line">import org.apache.kafka.clients.consumer.ConsumerConfig</span><br><span class="line">import org.apache.spark.SparkConf</span><br><span class="line">import org.apache.spark.streaming.dstream.&#123;DStream, InputDStream&#125;</span><br><span class="line">import org.apache.spark.streaming.kafka.&#123;HasOffsetRanges, KafkaUtils,</span><br><span class="line">OffsetRange&#125;</span><br><span class="line">import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;</span><br><span class="line">object DirectAPIHandler &#123;</span><br><span class="line"> def main(args: Array[String]): Unit = &#123;</span><br><span class="line"> //1.创建 SparkConf</span><br><span class="line"> val sparkConf: SparkConf = new </span><br><span class="line">SparkConf().setAppName(&quot;ReceiverWordCount&quot;).setMaster(&quot;local[*]&quot;)</span><br><span class="line"> //2.创建 StreamingContext</span><br><span class="line"> val ssc = new StreamingContext(sparkConf, Seconds(3))</span><br><span class="line">  //3.Kafka 参数</span><br><span class="line"> val kafkaPara: Map[String, String] = Map[String, String](</span><br><span class="line"> ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG -&gt; </span><br><span class="line">&quot;hadoop102:9092,hadoop103:9092,hadoop104:9092&quot;,</span><br><span class="line"> ConsumerConfig.GROUP_ID_CONFIG -&gt; &quot;atguigu&quot;</span><br><span class="line"> )</span><br><span class="line"> //4.获取上一次启动最后保留的 Offset=&gt;getOffset(MySQL)</span><br><span class="line"> val fromOffsets: Map[TopicAndPartition, Long] = Map[TopicAndPartition, </span><br><span class="line">Long](TopicAndPartition(&quot;atguigu&quot;, 0) -&gt; 20)</span><br><span class="line"> //5.读取 Kafka 数据创建 DStream</span><br><span class="line"> val kafkaDStream: InputDStream[String] = KafkaUtils.createDirectStream[String, </span><br><span class="line">String, StringDecoder, StringDecoder, String](ssc,</span><br><span class="line"> kafkaPara,</span><br><span class="line"> fromOffsets,</span><br><span class="line"> (m: MessageAndMetadata[String, String]) =&gt; m.message())</span><br><span class="line"> //6.创建一个数组用于存放当前消费数据的 offset 信息</span><br><span class="line"> var offsetRanges = Array.empty[OffsetRange]</span><br><span class="line"> //7.获取当前消费数据的 offset 信息</span><br><span class="line"> val wordToCountDStream: DStream[(String, Int)] = kafkaDStream.transform &#123; rdd </span><br><span class="line">=&gt;</span><br><span class="line"> offsetRanges = rdd.asInstanceOf[HasOffsetRanges].offsetRanges</span><br><span class="line"> rdd</span><br><span class="line"> &#125;.flatMap(_.split(&quot; &quot;))</span><br><span class="line"> .map((_, 1))</span><br><span class="line"> .reduceByKey(_ + _)</span><br><span class="line"> //8.打印 Offset 信息</span><br><span class="line"> wordToCountDStream.foreachRDD(rdd =&gt; &#123;</span><br><span class="line"> for (o &lt;- offsetRanges) &#123;</span><br><span class="line"> println(s&quot;$&#123;o.topic&#125;:$&#123;o.partition&#125;:$&#123;o.fromOffset&#125;:$&#123;o.untilOffset&#125;&quot;)</span><br><span class="line"> &#125;</span><br><span class="line"> rdd.foreach(println)</span><br><span class="line"> &#125;)</span><br><span class="line"> //9.开启任务</span><br><span class="line"> ssc.start()</span><br><span class="line"> ssc.awaitTermination()</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="Kafka-0-10-Direct-模式"><a href="#Kafka-0-10-Direct-模式" class="headerlink" title="Kafka 0-10 Direct 模式"></a>Kafka 0-10 Direct 模式</h3><ol>
<li><p>需求：通过 SparkStreaming 从 Kafka 读取数据，并将读取过来的数据做简单计算，最终打印到控制台。</p>
</li>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-streaming-kafka-0-10_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.kafka.clients.consumer.&#123;ConsumerConfig, ConsumerRecord&#125;</span><br><span class="line">import org.apache.spark.SparkConf</span><br><span class="line">import org.apache.spark.streaming.dstream.&#123;DStream, InputDStream&#125;</span><br><span class="line">import org.apache.spark.streaming.kafka010.&#123;ConsumerStrategies, KafkaUtils, </span><br><span class="line">LocationStrategies&#125;</span><br><span class="line">import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;</span><br><span class="line">object DirectAPI &#123;</span><br><span class="line"> def main(args: Array[String]): Unit = &#123;</span><br><span class="line"> //1.创建 SparkConf</span><br><span class="line"> val sparkConf: SparkConf = new </span><br><span class="line">SparkConf().setAppName(&quot;ReceiverWordCount&quot;).setMaster(&quot;local[*]&quot;)</span><br><span class="line"> //2.创建 StreamingContext</span><br><span class="line"> val ssc = new StreamingContext(sparkConf, Seconds(3))</span><br><span class="line"> //3.定义 Kafka 参数</span><br><span class="line"> val kafkaPara: Map[String, Object] = Map[String, Object](</span><br><span class="line"> ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG -&gt; </span><br><span class="line">&quot;linux1:9092,linux2:9092,linux3:9092&quot;,</span><br><span class="line"> ConsumerConfig.GROUP_ID_CONFIG -&gt; &quot;atguigu&quot;,</span><br><span class="line"> &quot;key.deserializer&quot; -&gt; </span><br><span class="line">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;,</span><br><span class="line"> &quot;value.deserializer&quot; -&gt; </span><br><span class="line">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span><br><span class="line"> )</span><br><span class="line"> //4.读取 Kafka 数据创建 DStream</span><br><span class="line"> val kafkaDStream: InputDStream[ConsumerRecord[String, String]] = </span><br><span class="line">KafkaUtils.createDirectStream[String, String](ssc,</span><br><span class="line"> LocationStrategies.PreferConsistent,</span><br><span class="line"> ConsumerStrategies.Subscribe[String, String](Set(&quot;atguigu&quot;), kafkaPara))</span><br><span class="line"> //5.将每条消息的 KV 取出</span><br><span class="line"> val valueDStream: DStream[String] = kafkaDStream.map(record =&gt; record.value())</span><br><span class="line"> //6.计算 WordCount</span><br><span class="line"> valueDStream.flatMap(_.split(&quot; &quot;))</span><br><span class="line"> .map((_, 1))</span><br><span class="line"> .reduceByKey(_ + _)</span><br><span class="line"> .print()</span><br><span class="line"> //7.开启任务</span><br><span class="line"> ssc.start()</span><br><span class="line"> ssc.awaitTermination()</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>查看 Kafka 消费进度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-consumer-groups.sh --describe --bootstrap-server linux1:9092 --group </span><br><span class="line">atguigu</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="DStream-转换"><a href="#DStream-转换" class="headerlink" title="DStream 转换"></a>DStream 转换</h1><p>DStream 上的操作与 RDD 的类似，分为 Transformations（转换）和 Output Operations（输出）两种，此外转换操作中还有一些比较特殊的原语，如：updateStateByKey()、transform()以及各种 Window 相关的原语。</p>
<h2 id="无状态转化操作"><a href="#无状态转化操作" class="headerlink" title="无状态转化操作"></a>无状态转化操作</h2><p>无状态转化操作就是把简单的 RDD 转化操作应用到每个批次上，也就是转化 DStream 中的每一个 RDD。部分无状态转化操作列在了下表中。注意，针对键值对的 DStream 转化操作(比如reduceByKey())要添加 import StreamingContext._才能在 Scala 中使用。</p>
<p><img src="https://img.lvxiaoyi.top/typora-img/202111091553041.png/lvxiaoyi" alt="image-20211109155333945"></p>
<p>需要记住的是，尽管这些函数看起来像作用在整个流上一样，但事实上每个 DStream 在内部是由许多 RDD（批次）组成，且无状态转化操作是分别应用到每个 RDD 上的。</p>
<p>例如：reduceByKey()会归约每个时间区间中的数据，但不会归约不同区间之间的数据。</p>
<h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><p>Transform 允许 DStream 上执行任意的 RDD-to-RDD 函数。即使这些函数并没有在 DStream的 API 中暴露出来，通过该函数可以方便的扩展 Spark API。该函数每一批次调度一次。其实也就是对 DStream 中的 RDD 应用转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">object Transform &#123;</span><br><span class="line"> def main(args: Array[String]): Unit = &#123;</span><br><span class="line"> //创建 SparkConf</span><br><span class="line">  val sparkConf: SparkConf = new </span><br><span class="line">SparkConf().setMaster(&quot;local[*]&quot;).setAppName(&quot;WordCount&quot;)</span><br><span class="line"> //创建 StreamingContext</span><br><span class="line"> val ssc = new StreamingContext(sparkConf, Seconds(3))</span><br><span class="line"> //创建 DStream</span><br><span class="line"> val lineDStream: ReceiverInputDStream[String] = ssc.socketTextStream(&quot;linux1&quot;, </span><br><span class="line">9999)</span><br><span class="line"> //转换为 RDD 操作</span><br><span class="line"> val wordAndCountDStream: DStream[(String, Int)] = lineDStream.transform(rdd =&gt; </span><br><span class="line">&#123;</span><br><span class="line"> val words: RDD[String] = rdd.flatMap(_.split(&quot; &quot;))</span><br><span class="line"> val wordAndOne: RDD[(String, Int)] = words.map((_, 1))</span><br><span class="line"> val value: RDD[(String, Int)] = wordAndOne.reduceByKey(_ + _)</span><br><span class="line"> value</span><br><span class="line"> &#125;)</span><br><span class="line"> //打印</span><br><span class="line"> wordAndCountDStream.print</span><br><span class="line"> //启动</span><br><span class="line"> ssc.start()</span><br><span class="line"> ssc.awaitTermination()</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>两个流之间的 join 需要两个流的批次大小一致，这样才能做到同时触发计算。计算过程就是对当前批次的两个流中各自的 RDD 进行 join，与两个 RDD 的 join 效果相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.spark.SparkConf</span><br><span class="line">import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;</span><br><span class="line">import org.apache.spark.streaming.dstream.&#123;DStream, ReceiverInputDStream&#125;</span><br><span class="line">object JoinTest &#123;</span><br><span class="line"> def main(args: Array[String]): Unit = &#123;</span><br><span class="line"> //1.创建 SparkConf</span><br><span class="line"> val sparkConf: SparkConf = new </span><br><span class="line">SparkConf().setMaster(&quot;local[*]&quot;).setAppName(&quot;JoinTest&quot;)</span><br><span class="line"> //2.创建 StreamingContext</span><br><span class="line"> val ssc = new StreamingContext(sparkConf, Seconds(5))</span><br><span class="line"> //3.从端口获取数据创建流</span><br><span class="line"> val lineDStream1: ReceiverInputDStream[String] = </span><br><span class="line">ssc.socketTextStream(&quot;linux1&quot;, 9999)</span><br><span class="line"> val lineDStream2: ReceiverInputDStream[String] = </span><br><span class="line">ssc.socketTextStream(&quot;linux2&quot;, 8888)</span><br><span class="line"> //4.将两个流转换为 KV 类型</span><br><span class="line"> val wordToOneDStream: DStream[(String, Int)] = lineDStream1.flatMap(_.split(&quot;</span><br><span class="line"> &quot;)).map((_, 1))</span><br><span class="line"> val wordToADStream: DStream[(String, String)] = lineDStream2.flatMap(_.split(&quot; </span><br><span class="line">&quot;)).map((_, &quot;a&quot;))</span><br><span class="line"> //5.流的 JOIN</span><br><span class="line"> val joinDStream: DStream[(String, (Int, String))] = </span><br><span class="line">wordToOneDStream.join(wordToADStream)</span><br><span class="line"> //6.打印</span><br><span class="line"> joinDStream.print()</span><br><span class="line"> //7.启动任务</span><br><span class="line"> ssc.start()</span><br><span class="line"> ssc.awaitTermination()</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="有状态转化操作"><a href="#有状态转化操作" class="headerlink" title="有状态转化操作"></a>有状态转化操作</h2><h3 id="UpdateStateByKey"><a href="#UpdateStateByKey" class="headerlink" title="UpdateStateByKey"></a>UpdateStateByKey</h3><p>UpdateStateByKey 原语用于记录历史记录，有时，我们需要在 DStream 中跨批次维护状态(例如流计算中累加 wordcount)。针对这种情况，updateStateByKey()为我们提供了对一个状态变量的访问，用于键值对形式的 DStream。给定一个由(键，事件)对构成的 DStream，并传递一个指<br>定如何根据新的事件更新每个键对应状态的函数，它可以构建出一个新的 DStream，其内部数据为(键，状态) 对。</p>
<p>updateStateByKey() 的结果会是一个新的 DStream，其内部的 RDD 序列是由每个时间区间对应的(键，状态)对组成的。</p>
<p>updateStateByKey 操作使得我们可以在用新信息进行更新时保持任意的状态。为使用这个功能，需要做下面两步：</p>
<ol>
<li><p> 定义状态，状态可以是一个任意的数据类型。</p>
</li>
<li><p> 定义状态更新函数，用此函数阐明如何使用之前的状态和来自输入流的新值对状态进行更新。</p>
</li>
</ol>
<p>   使用 updateStateByKey 需要对检查点目录进行配置，会使用检查点来保存状态。</p>
<p>   更新版的 wordcount</p>
<ol start="2">
<li><p>编写代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">object WorldCount &#123;</span><br><span class="line"> def main(args: Array[String]) &#123;</span><br><span class="line"> // 定义更新状态方法，参数 values 为当前批次单词频度，state 为以往批次单词频度</span><br><span class="line"> val updateFunc = (values: Seq[Int], state: Option[Int]) =&gt; &#123;</span><br><span class="line"> val currentCount = values.foldLeft(0)(_ + _)</span><br><span class="line">  val previousCount = state.getOrElse(0)</span><br><span class="line"> Some(currentCount + previousCount)</span><br><span class="line"> &#125;</span><br><span class="line"> val conf = new </span><br><span class="line">SparkConf().setMaster(&quot;local[*]&quot;).setAppName(&quot;NetworkWordCount&quot;)</span><br><span class="line"> val ssc = new StreamingContext(conf, Seconds(3))</span><br><span class="line"> ssc.checkpoint(&quot;./ck&quot;)</span><br><span class="line"> // Create a DStream that will connect to hostname:port, like hadoop102:9999</span><br><span class="line"> val lines = ssc.socketTextStream(&quot;linux1&quot;, 9999)</span><br><span class="line"> // Split each line into words</span><br><span class="line"> val words = lines.flatMap(_.split(&quot; &quot;))</span><br><span class="line"> //import org.apache.spark.streaming.StreamingContext._ // not necessary since </span><br><span class="line">Spark 1.3</span><br><span class="line"> // Count each word in each batch</span><br><span class="line"> val pairs = words.map(word =&gt; (word, 1))</span><br><span class="line"> // 使用 updateStateByKey 来更新状态，统计从运行开始以来单词总的次数</span><br><span class="line"> val stateDstream = pairs.updateStateByKey[Int](updateFunc)</span><br><span class="line"> stateDstream.print()</span><br><span class="line"> ssc.start() // Start the computation</span><br><span class="line"> ssc.awaitTermination() // Wait for the computation to terminate</span><br><span class="line"> //ssc.stop()</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动程序并向 9999 端口发送数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc -lk 9999</span><br><span class="line">Hello World</span><br><span class="line">Hello Scala</span><br></pre></td></tr></table></figure></li>
<li><p>结果展示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------</span><br><span class="line">Time: 1504685175000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1504685181000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(shi,1)</span><br><span class="line">(shui,1)</span><br><span class="line">(ni,1)</span><br><span class="line">-------------------------------------------</span><br><span class="line">Time: 1504685187000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(shi,1)</span><br><span class="line">(ma,1)</span><br><span class="line">(hao,1)</span><br><span class="line">(shui,1)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="WindowOperations"><a href="#WindowOperations" class="headerlink" title="WindowOperations"></a>WindowOperations</h3><p>Window Operations 可以设置窗口的大小和滑动窗口的间隔来动态的获取当前 Steaming 的允许状态。所有基于窗口的操作都需要两个参数，分别为窗口时长以及滑动步长。</p>
<ul>
<li>窗口时长：计算内容的时间范围；</li>
<li>滑动步长：隔多久触发一次计算。</li>
</ul>
<p>注意：这两者都必须为采集周期大小的整数倍。</p>
<p>WordCount 第三版：3 秒一个批次，窗口 12 秒，滑步 6 秒。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">object WorldCount &#123;</span><br><span class="line"> def main(args: Array[String]) &#123;</span><br><span class="line"> val conf = new </span><br><span class="line">SparkConf().setMaster(&quot;local[2]&quot;).setAppName(&quot;NetworkWordCount&quot;)</span><br><span class="line"> val ssc = new StreamingContext(conf, Seconds(3))</span><br><span class="line"> ssc.checkpoint(&quot;./ck&quot;)</span><br><span class="line"> // Create a DStream that will connect to hostname:port, like localhost:9999</span><br><span class="line"> val lines = ssc.socketTextStream(&quot;linux1&quot;, 9999)</span><br><span class="line"> // Split each line into words</span><br><span class="line"> val words = lines.flatMap(_.split(&quot; &quot;))</span><br><span class="line">// Count each word in each batch</span><br><span class="line"> val pairs = words.map(word =&gt; (word, 1))</span><br><span class="line"> val wordCounts = pairs.reduceByKeyAndWindow((a:Int,b:Int) =&gt; (a + </span><br><span class="line">b),Seconds(12), Seconds(6))</span><br><span class="line"> // Print the first ten elements of each RDD generated in this DStream to the </span><br><span class="line">console</span><br><span class="line"> wordCounts.print()</span><br><span class="line"> ssc.start() // Start the computation</span><br><span class="line"> ssc.awaitTermination() // Wait for the computation to terminate</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>关于 Window 的操作还有如下方法：</p>
<ol>
<li><p>window(windowLength, slideInterval): 基于对源 DStream 窗化的批次进行计算返回一个新的 Dstream； </p>
</li>
<li><p>countByWindow(windowLength, slideInterval): 返回一个滑动窗口计数流中的元素个数；</p>
</li>
<li><p>reduceByWindow(func, windowLength, slideInterval): 通过使用自定义函数整合滑动区间流元素来创建一个新的单元素流；</p>
</li>
<li><p>reduceByKeyAndWindow(func, windowLength, slideInterval, [numTasks]): 当在一个(K,V)对的 DStream 上调用此函数，会返回一个新(K,V)对的 DStream，此处通过对滑动窗口中批次数据使用 reduce 函数来整合每个 key 的 value 值。</p>
</li>
<li><p>reduceByKeyAndWindow(func, invFunc, windowLength, slideInterval, [numTasks]): 这个函数是上述函数的变化版本，每个窗口的 reduce 值都是通过用前一个窗的 reduce 值来递增计算。通过 reduce 进入到滑动窗口数据并”反向 reduce”离开窗口的旧数据来实现这个操作。一个例子是随着窗口滑动对 keys 的“加”“减”计数。通过前边介绍可以想到，这个函数只适用于”可逆的 reduce 函数”，也就是这些 reduce 函数有相应的”反 reduce”函数(以参数 invFunc 形式传入)。如前述函数，reduce 任务的数量通过可选参数来配置。</p>
</li>
</ol>
<p><img src="https://img.lvxiaoyi.top/typora-img/202111091601653.png/lvxiaoyi" alt="image-20211109160140565"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val ipDStream = accessLogsDStream.map(logEntry =&gt; (logEntry.getIpAddress(), 1))</span><br><span class="line">val ipCountDStream = ipDStream.reduceByKeyAndWindow(</span><br><span class="line"> &#123;(x, y) =&gt; x + y&#125;,</span><br><span class="line"> &#123;(x, y) =&gt; x - y&#125;,</span><br><span class="line"> Seconds(30),</span><br><span class="line"> Seconds(10))</span><br><span class="line"> //加上新进入窗口的批次中的元素 //移除离开窗口的老批次中的元素 //窗口时长// 滑动步长</span><br></pre></td></tr></table></figure>

<p>countByWindow()和 countByValueAndWindow()作为对数据进行计数操作的简写。<br>countByWindow()返回一个表示每个窗口中元素个数的 DStream，而 countByValueAndWindow()返回的 DStream 则包含窗口中每个值的个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val ipDStream = accessLogsDStream.map&#123;entry =&gt; entry.getIpAddress()&#125;</span><br><span class="line">val ipAddressRequestCount = ipDStream.countByValueAndWindow(Seconds(30), </span><br><span class="line">Seconds(10)) </span><br><span class="line">val requestCount = accessLogsDStream.countByWindow(Seconds(30), Seconds(10))</span><br></pre></td></tr></table></figure>

<h1 id="DStream-输出"><a href="#DStream-输出" class="headerlink" title="DStream 输出"></a>DStream 输出</h1><p>输出操作指定了对流数据经转化操作得到的数据所要执行的操作(例如把结果推入外部数据库或输出到屏幕上)。与 RDD 中的惰性求值类似，如果一个 DStream 及其派生出的 DStream 都没有被执行输出操作，那么这些 DStream 就都不会被求值。如果 StreamingContext 中没有设定输出操作，整个 context 就都不会启动。</p>
<p>输出操作如下：</p>
<ul>
<li>print()：在运行流程序的驱动结点上打印 DStream 中每一批次数据的最开始 10 个元素。这用于开发和调试。在 Python API 中，同样的操作叫 print()。</li>
<li>saveAsTextFiles(prefix, [suffix])：以 text 文件形式存储这个 DStream 的内容。每一批次的存储文件名基于参数中的 prefix 和 suffix。”prefix-Time_IN_MS[.suffix]”。</li>
<li>saveAsObjectFiles(prefix, [suffix])：以 Java 对象序列化的方式将 Stream 中的数据保存为SequenceFiles . 每一批次的存储文件名基于参数中的为”prefix-TIME_IN_MS[.suffix]”. Python中目前不可用。</li>
<li>saveAsHadoopFiles(prefix, [suffix])：将 Stream 中的数据保存为 Hadoop files. 每一批次的存储文件名基于参数中的为”prefix-TIME_IN_MS[.suffix]”。Python API 中目前不可用。</li>
<li> foreachRDD(func)：这是最通用的输出操作，即将函数 func 用于产生于 stream 的每一个RDD。其中参数传入的函数 func 应该实现将每一个 RDD 中数据推送到外部系统，如将RDD 存入文件或者通过网络将其写入数据库。</li>
</ul>
<p>通用的输出操作 foreachRDD()，它用来对 DStream 中的 RDD 运行任意计算。这和 transform() 有些类似，都可以让我们访问任意 RDD。在 foreachRDD()中，可以重用我们在 Spark 中实现的所有行动操作。比如，常见的用例之一是把数据写到诸如 MySQL 的外部数据库中。</p>
<p>注意：</p>
<ol>
<li><p>连接不能写在 driver 层面（序列化）</p>
</li>
<li><p>如果写在 foreach 则每个 RDD 中的每一条数据都创建，得不偿失；</p>
</li>
<li><p>增加 foreachPartition，在分区创建（获取）。</p>
</li>
</ol>
<h1 id="优雅关闭"><a href="#优雅关闭" class="headerlink" title="优雅关闭"></a>优雅关闭</h1><p>流式任务需要 7*24 小时执行，但是有时涉及到升级代码需要主动停止程序，但是分布式程序，没办法做到一个个进程去杀死，所有配置优雅的关闭就显得至关重要了。使用外部文件系统来控制内部程序关闭。</p>
<ul>
<li><p>MonitorStop</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.net.URI</span><br><span class="line">import org.apache.hadoop.conf.Configuration</span><br><span class="line">import org.apache.hadoop.fs.&#123;FileSystem, Path&#125;</span><br><span class="line">import org.apache.spark.streaming.&#123;StreamingContext, StreamingContextState&#125;</span><br><span class="line">class MonitorStop(ssc: StreamingContext) extends Runnable &#123;</span><br><span class="line"> override def run(): Unit = &#123;</span><br><span class="line"> val fs: FileSystem = FileSystem.get(new URI(&quot;hdfs://linux1:9000&quot;), new </span><br><span class="line">Configuration(), &quot;atguigu&quot;)</span><br><span class="line"> while (true) &#123;</span><br><span class="line"> try</span><br><span class="line"> Thread.sleep(5000)</span><br><span class="line"> catch &#123;</span><br><span class="line"> case e: InterruptedException =&gt;</span><br><span class="line"> e.printStackTrace()</span><br><span class="line"> &#125;</span><br><span class="line"> val state: StreamingContextState = ssc.getState</span><br><span class="line"> val bool: Boolean = fs.exists(new Path(&quot;hdfs://linux1:9000/stopSpark&quot;))</span><br><span class="line"> if (bool) &#123;</span><br><span class="line"> if (state == StreamingContextState.ACTIVE) &#123;</span><br><span class="line"> ssc.stop(stopSparkContext = true, stopGracefully = true)</span><br><span class="line"> System.exit(0)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>SparkTest</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.spark.SparkConf</span><br><span class="line">import org.apache.spark.streaming.dstream.&#123;DStream, ReceiverInputDStream&#125;</span><br><span class="line">import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;</span><br><span class="line">object SparkTest &#123;</span><br><span class="line"> def createSSC(): _root_.org.apache.spark.streaming.StreamingContext = &#123;</span><br><span class="line"> val update: (Seq[Int], Option[Int]) =&gt; Some[Int] = (values: Seq[Int], status: </span><br><span class="line">Option[Int]) =&gt; &#123;</span><br><span class="line"> //当前批次内容的计算</span><br><span class="line"> val sum: Int = values.sum</span><br><span class="line"> //取出状态信息中上一次状态</span><br><span class="line">  val lastStatu: Int = status.getOrElse(0)</span><br><span class="line"> Some(sum + lastStatu)</span><br><span class="line"> &#125;</span><br><span class="line"> val sparkConf: SparkConf = new </span><br><span class="line">SparkConf().setMaster(&quot;local[4]&quot;).setAppName(&quot;SparkTest&quot;)</span><br><span class="line"> //设置优雅的关闭</span><br><span class="line"> sparkConf.set(&quot;spark.streaming.stopGracefullyOnShutdown&quot;, &quot;true&quot;)</span><br><span class="line"> val ssc = new StreamingContext(sparkConf, Seconds(5))</span><br><span class="line"> ssc.checkpoint(&quot;./ck&quot;)</span><br><span class="line"> val line: ReceiverInputDStream[String] = ssc.socketTextStream(&quot;linux1&quot;, 9999)</span><br><span class="line"> val word: DStream[String] = line.flatMap(_.split(&quot; &quot;))</span><br><span class="line"> val wordAndOne: DStream[(String, Int)] = word.map((_, 1))</span><br><span class="line"> val wordAndCount: DStream[(String, Int)] = wordAndOne.updateStateByKey(update)</span><br><span class="line"> wordAndCount.print()</span><br><span class="line"> ssc</span><br><span class="line"> &#125;</span><br><span class="line"> def main(args: Array[String]): Unit = &#123;</span><br><span class="line"> val ssc: StreamingContext = StreamingContext.getActiveOrCreate(&quot;./ck&quot;, () =&gt; </span><br><span class="line">createSSC())</span><br><span class="line"> new Thread(new MonitorStop(ssc)).start()</span><br><span class="line"> ssc.start()</span><br><span class="line"> ssc.awaitTermination()</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="SparkStreaming-案例实操"><a href="#SparkStreaming-案例实操" class="headerlink" title="SparkStreaming 案例实操"></a>SparkStreaming 案例实操</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="pom-文件"><a href="#pom-文件" class="headerlink" title="pom 文件"></a>pom 文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;spark-core_2.12&lt;/artifactId&gt;</span><br><span class="line"> &lt;version&gt;3.0.0&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;spark-streaming_2.12&lt;/artifactId&gt;</span><br><span class="line"> &lt;version&gt;3.0.0&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;spark-streaming-kafka-0-10_2.12&lt;/artifactId&gt;</span><br><span class="line"> &lt;version&gt;3.0.0&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line"> &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line"> &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line"> &lt;version&gt;5.1.27&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line"> &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;</span><br><span class="line"> &lt;version&gt;2.10.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul>
<li><p>PropertiesUtil</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.io.InputStreamReader</span><br><span class="line">import java.util.Properties</span><br><span class="line">object PropertiesUtil &#123;</span><br><span class="line"> def load(propertiesName:String): Properties =&#123;</span><br><span class="line"> val prop=new Properties()</span><br><span class="line"> prop.load(new </span><br><span class="line">InputStreamReader(Thread.currentThread().getContextClassLoader.getResourceAsStrea</span><br><span class="line">m(propertiesName) , &quot;UTF-8&quot;))</span><br><span class="line"> prop</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="实时数据生成模块"><a href="#实时数据生成模块" class="headerlink" title="实时数据生成模块"></a>实时数据生成模块</h2><ul>
<li><p>config.properties</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#jdbc 配置</span><br><span class="line">jdbc.datasource.size=10</span><br><span class="line">jdbc.url=jdbc:mysql://linux1:3306/spark2020?useUnicode=true&amp;characterEncoding=utf</span><br><span class="line">8&amp;rewriteBatchedStatements=true</span><br><span class="line">jdbc.user=root</span><br><span class="line">jdbc.password=000000</span><br><span class="line"># Kafka 配置</span><br><span class="line">kafka.broker.list=linux1:9092,linux2:9092,linux3:9092</span><br></pre></td></tr></table></figure></li>
<li><p>CityInfo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * 城市信息表</span><br><span class="line"> *</span><br><span class="line"> * @param city_id 城市 id</span><br><span class="line"> * @param city_name 城市名称</span><br><span class="line"> * @param area 城市所在大区</span><br><span class="line"> */</span><br><span class="line">case class CityInfo (city_id:Long,</span><br><span class="line"> city_name:String,</span><br><span class="line"> area:String)</span><br></pre></td></tr></table></figure></li>
<li><p>RandomOptions</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import scala.collection.mutable.ListBuffer</span><br><span class="line">import scala.util.Random</span><br><span class="line">case class RanOpt[T](value: T, weight: Int)</span><br><span class="line">object RandomOptions &#123;</span><br><span class="line"> def apply[T](opts: RanOpt[T]*): RandomOptions[T] = &#123;</span><br><span class="line"> val randomOptions = new RandomOptions[T]()</span><br><span class="line"> for (opt &lt;- opts) &#123;</span><br><span class="line"> randomOptions.totalWeight += opt.weight</span><br><span class="line"> for (i &lt;- 1 to opt.weight) &#123;</span><br><span class="line"> randomOptions.optsBuffer += opt.value</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> randomOptions</span><br><span class="line"> &#125; &#125;</span><br><span class="line">class RandomOptions[T](opts: RanOpt[T]*) &#123;</span><br><span class="line"> var totalWeight = 0</span><br><span class="line"> var optsBuffer = new ListBuffer[T]</span><br><span class="line"> def getRandomOpt: T = &#123;</span><br><span class="line"> val randomNum: Int = new Random().nextInt(totalWeight)</span><br><span class="line"> optsBuffer(randomNum)</span><br><span class="line">  &#125; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>MockerRealTime</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import java.util.&#123;Properties, Random&#125;</span><br><span class="line">import com.atguigu.bean.CityInfo</span><br><span class="line">import com.atguigu.utils.&#123;PropertiesUtil, RanOpt, RandomOptions&#125;</span><br><span class="line">import org.apache.kafka.clients.producer.&#123;KafkaProducer, ProducerConfig, </span><br><span class="line">ProducerRecord&#125;</span><br><span class="line">import scala.collection.mutable.ArrayBuffer</span><br><span class="line">object MockerRealTime &#123;</span><br><span class="line"> /**</span><br><span class="line"> * 模拟的数据</span><br><span class="line"> *</span><br><span class="line"> * 格式 ：timestamp area city userid adid</span><br><span class="line"> * 某个时间点 某个地区 某个城市 某个用户 某个广告</span><br><span class="line"> */</span><br><span class="line"> def generateMockData(): Array[String] = &#123;</span><br><span class="line"> val array: ArrayBuffer[String] = ArrayBuffer[String]()</span><br><span class="line"> val CityRandomOpt = RandomOptions(RanOpt(CityInfo(1, &quot;北京&quot;, &quot;华北&quot;), 30),</span><br><span class="line"> RanOpt(CityInfo(2, &quot;上海&quot;, &quot;华东&quot;), 30),</span><br><span class="line"> RanOpt(CityInfo(3, &quot;广州&quot;, &quot;华南&quot;), 10),</span><br><span class="line"> RanOpt(CityInfo(4, &quot;深圳&quot;, &quot;华南&quot;), 20),</span><br><span class="line"> RanOpt(CityInfo(5, &quot;天津&quot;, &quot;华北&quot;), 10))</span><br><span class="line"> val random = new Random()</span><br><span class="line"> // 模拟实时数据：</span><br><span class="line"> // timestamp province city userid adid</span><br><span class="line"> for (i &lt;- 0 to 50) &#123;</span><br><span class="line"> val timestamp: Long = System.currentTimeMillis()</span><br><span class="line"> val cityInfo: CityInfo = CityRandomOpt.getRandomOpt</span><br><span class="line"> val city: String = cityInfo.city_name</span><br><span class="line"> val area: String = cityInfo.area</span><br><span class="line"> val adid: Int = 1 + random.nextInt(6)</span><br><span class="line"> val userid: Int = 1 + random.nextInt(6)</span><br><span class="line"> // 拼接实时数据</span><br><span class="line"> array += timestamp + &quot; &quot; + area + &quot; &quot; + city + &quot; &quot; + userid + &quot; &quot; + adid</span><br><span class="line"> &#125;</span><br><span class="line"> array.toArray</span><br><span class="line"> &#125;</span><br><span class="line"> def createKafkaProducer(broker: String): KafkaProducer[String, String] = &#123;</span><br><span class="line"> // 创建配置对象</span><br><span class="line"> val prop = new Properties()</span><br><span class="line"> // 添加配置</span><br><span class="line"> prop.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, broker)</span><br><span class="line"> prop.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, </span><br><span class="line">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;)</span><br><span class="line"> prop.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, </span><br><span class="line">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;)</span><br><span class="line"> // 根据配置创建 Kafka 生产者</span><br><span class="line"> new KafkaProducer[String, String](prop)</span><br><span class="line"> &#125;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"> // 获取配置文件 config.properties 中的 Kafka 配置参数</span><br><span class="line"> val config: Properties = PropertiesUtil.load(&quot;config.properties&quot;)</span><br><span class="line"> val broker: String = config.getProperty(&quot;kafka.broker.list&quot;)</span><br><span class="line"> val topic = &quot;test&quot;</span><br><span class="line"> // 创建 Kafka 消费者</span><br><span class="line"> val kafkaProducer: KafkaProducer[String, String] = createKafkaProducer(broker)</span><br><span class="line"> while (true) &#123;</span><br><span class="line"> // 随机产生实时数据并通过 Kafka 生产者发送到 Kafka 集群中</span><br><span class="line"> for (line &lt;- generateMockData()) &#123;</span><br><span class="line"> kafkaProducer.send(new ProducerRecord[String, String](topic, line))</span><br><span class="line"> println(line)</span><br><span class="line"> &#125;</span><br><span class="line"> Thread.sleep(2000)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="需求一：广告黑名单"><a href="#需求一：广告黑名单" class="headerlink" title="需求一：广告黑名单"></a>需求一：广告黑名单</h2><p>实现实时的动态黑名单机制：将每天对某个广告点击超过 100 次的用户拉黑。<br>注：黑名单保存到 MySQL 中</p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><ol>
<li>读取 Kafka 数据之后，并对 MySQL 中存储的黑名单数据做校验；</li>
<li>校验通过则对给用户点击广告次数累加一并存入 MySQL；</li>
<li>在存入 MySQL 之后对数据做校验，如果单日超过 100 次则将该用户加入黑名单。</li>
</ol>
<h3 id="MySQL-建表"><a href="#MySQL-建表" class="headerlink" title="MySQL 建表"></a>MySQL 建表</h3><p>创建库 spark2020</p>
<ol>
<li><p>存放黑名单用户的表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE black_list (userid CHAR(1) PRIMARY KEY);</span><br></pre></td></tr></table></figure></li>
<li><p>存放单日各用户点击每个广告的次数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user_ad_count (</span><br><span class="line">dt varchar(255),</span><br><span class="line">userid CHAR (1),</span><br><span class="line">adid CHAR (1),</span><br><span class="line">count BIGINT,</span><br><span class="line">PRIMARY KEY (dt, userid, adid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h3><p>接下来开始实时需求的分析，需要用到 SparkStreaming 来做实时数据的处理，在生产环境中，绝大部分时候都是对接的 Kafka 数据源，创建一个 SparkStreaming 读取 Kafka 数据的工具类。</p>
<ul>
<li><p>MyKafkaUtil</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Properties</span><br><span class="line">import org.apache.kafka.clients.consumer.ConsumerRecord</span><br><span class="line">import org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">import org.apache.spark.streaming.StreamingContext</span><br><span class="line">import org.apache.spark.streaming.dstream.InputDStream</span><br><span class="line">import org.apache.spark.streaming.kafka010.&#123;ConsumerStrategies, KafkaUtils, </span><br><span class="line">LocationStrategies&#125;</span><br><span class="line">object MyKafkaUtil &#123;</span><br><span class="line"> //1.创建配置信息对象</span><br><span class="line"> private val properties: Properties = PropertiesUtil.load(&quot;config.properties&quot;)</span><br><span class="line"> //2.用于初始化链接到集群的地址</span><br><span class="line"> val broker_list: String = properties.getProperty(&quot;kafka.broker.list&quot;)</span><br><span class="line"> //3.kafka 消费者配置</span><br><span class="line"> val kafkaParam = Map(</span><br><span class="line"> &quot;bootstrap.servers&quot; -&gt; broker_list,</span><br><span class="line"> &quot;key.deserializer&quot; -&gt; classOf[StringDeserializer],</span><br><span class="line"> &quot;value.deserializer&quot; -&gt; classOf[StringDeserializer],</span><br><span class="line"> //消费者组</span><br><span class="line"> &quot;group.id&quot; -&gt; &quot;commerce-consumer-group&quot;,</span><br><span class="line"> //如果没有初始化偏移量或者当前的偏移量不存在任何服务器上，可以使用这个配置属性</span><br><span class="line"> //可以使用这个配置，latest 自动重置偏移量为最新的偏移量</span><br><span class="line"> &quot;auto.offset.reset&quot; -&gt; &quot;latest&quot;,</span><br><span class="line"> //如果是 true，则这个消费者的偏移量会在后台自动提交,但是 kafka 宕机容易丢失数据</span><br><span class="line"> //如果是 false，会需要手动维护 kafka 偏移量</span><br><span class="line"> &quot;enable.auto.commit&quot; -&gt; (true: java.lang.Boolean)</span><br><span class="line"> )</span><br><span class="line"> // 创建 DStream，返回接收到的输入数据</span><br><span class="line"> // LocationStrategies：根据给定的主题和集群地址创建 consumer</span><br><span class="line"> // LocationStrategies.PreferConsistent：持续的在所有 Executor 之间分配分区</span><br><span class="line"> // ConsumerStrategies：选择如何在 Driver 和 Executor 上创建和配置 Kafka Consumer</span><br><span class="line"> // ConsumerStrategies.Subscribe：订阅一系列主题</span><br><span class="line"> def getKafkaStream(topic: String, ssc: StreamingContext): </span><br><span class="line">InputDStream[ConsumerRecord[String, String]] = &#123;</span><br><span class="line"> val dStream: InputDStream[ConsumerRecord[String, String]] = </span><br><span class="line">KafkaUtils.createDirectStream[String, String](ssc, </span><br><span class="line">LocationStrategies.PreferConsistent, ConsumerStrategies.Subscribe[String, </span><br><span class="line">String](Array(topic), kafkaParam))</span><br><span class="line"> dStream</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>JdbcUtil</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">import java.sql.&#123;Connection, PreparedStatement, ResultSet&#125;</span><br><span class="line">import java.util.Properties</span><br><span class="line">import javax.sql.DataSource</span><br><span class="line">import com.alibaba.druid.pool.DruidDataSourceFactory</span><br><span class="line">object JdbcUtil &#123;</span><br><span class="line"> //初始化连接池</span><br><span class="line"> var dataSource: DataSource = init()</span><br><span class="line"> //初始化连接池方法</span><br><span class="line"> def init(): DataSource = &#123;</span><br><span class="line"> val properties = new Properties()</span><br><span class="line"> val config: Properties = PropertiesUtil.load(&quot;config.properties&quot;)</span><br><span class="line"> properties.setProperty(&quot;driverClassName&quot;, &quot;com.mysql.jdbc.Driver&quot;)</span><br><span class="line"> properties.setProperty(&quot;url&quot;, config.getProperty(&quot;jdbc.url&quot;))</span><br><span class="line"> properties.setProperty(&quot;username&quot;, config.getProperty(&quot;jdbc.user&quot;))</span><br><span class="line"> properties.setProperty(&quot;password&quot;, config.getProperty(&quot;jdbc.password&quot;))</span><br><span class="line"> properties.setProperty(&quot;maxActive&quot;, </span><br><span class="line">config.getProperty(&quot;jdbc.datasource.size&quot;))</span><br><span class="line"> DruidDataSourceFactory.createDataSource(properties)</span><br><span class="line"> &#125;</span><br><span class="line"> //获取 MySQL 连接</span><br><span class="line"> def getConnection: Connection = &#123;</span><br><span class="line"> dataSource.getConnection</span><br><span class="line"> &#125;</span><br><span class="line"> //执行 SQL 语句,单条数据插入</span><br><span class="line"> def executeUpdate(connection: Connection, sql: String, params: Array[Any]): Int </span><br><span class="line">= &#123;</span><br><span class="line"> var rtn = 0</span><br><span class="line"> var pstmt: PreparedStatement = null</span><br><span class="line"> try &#123;</span><br><span class="line"> connection.setAutoCommit(false)</span><br><span class="line"> pstmt = connection.prepareStatement(sql)</span><br><span class="line"> if (params != null &amp;&amp; params.length &gt; 0) &#123;</span><br><span class="line"> for (i &lt;- params.indices) &#123;</span><br><span class="line"> pstmt.setObject(i + 1, params(i))</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> rtn = pstmt.executeUpdate()</span><br><span class="line"> connection.commit()</span><br><span class="line"> pstmt.close()</span><br><span class="line"> &#125; catch &#123;</span><br><span class="line"> case e: Exception =&gt; e.printStackTrace()</span><br><span class="line"> &#125;</span><br><span class="line"> rtn</span><br><span class="line"> &#125;</span><br><span class="line"> //执行 SQL 语句,批量数据插入</span><br><span class="line"> def executeBatchUpdate(connection: Connection, sql: String, paramsList: </span><br><span class="line">Iterable[Array[Any]]): Array[Int] = &#123;</span><br><span class="line"> var rtn: Array[Int] = null</span><br><span class="line"> var pstmt: PreparedStatement = null</span><br><span class="line"> try &#123;</span><br><span class="line"> connection.setAutoCommit(false)</span><br><span class="line"> pstmt = connection.prepareStatement(sql)</span><br><span class="line"> for (params &lt;- paramsList) &#123;</span><br><span class="line"> if (params != null &amp;&amp; params.length &gt; 0) &#123;</span><br><span class="line"> for (i &lt;- params.indices) &#123;</span><br><span class="line"> pstmt.setObject(i + 1, params(i))</span><br><span class="line"> &#125;</span><br><span class="line"> pstmt.addBatch()</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; rtn = pstmt.executeBatch()</span><br><span class="line"> connection.commit()</span><br><span class="line"> pstmt.close()</span><br><span class="line"> &#125; catch &#123;</span><br><span class="line"> case e: Exception =&gt; e.printStackTrace()</span><br><span class="line"> &#125;</span><br><span class="line"> rtn</span><br><span class="line"> &#125;</span><br><span class="line"> //判断一条数据是否存在</span><br><span class="line"> def isExist(connection: Connection, sql: String, params: Array[Any]): Boolean = </span><br><span class="line">&#123;</span><br><span class="line"> var flag: Boolean = false</span><br><span class="line"> var pstmt: PreparedStatement = null</span><br><span class="line"> try &#123;</span><br><span class="line"> pstmt = connection.prepareStatement(sql)</span><br><span class="line"> for (i &lt;- params.indices) &#123;</span><br><span class="line"> pstmt.setObject(i + 1, params(i))</span><br><span class="line"> &#125;</span><br><span class="line"> flag = pstmt.executeQuery().next()</span><br><span class="line"> pstmt.close()</span><br><span class="line"> &#125; catch &#123;</span><br><span class="line"> case e: Exception =&gt; e.printStackTrace()</span><br><span class="line"> &#125;</span><br><span class="line"> flag</span><br><span class="line"> &#125;</span><br><span class="line"> //获取 MySQL 的一条数据</span><br><span class="line"> def getDataFromMysql(connection: Connection, sql: String, params: Array[Any]): </span><br><span class="line">Long = &#123;</span><br><span class="line"> var result: Long = 0L</span><br><span class="line"> var pstmt: PreparedStatement = null</span><br><span class="line"> try &#123;</span><br><span class="line"> pstmt = connection.prepareStatement(sql)</span><br><span class="line"> for (i &lt;- params.indices) &#123;</span><br><span class="line"> pstmt.setObject(i + 1, params(i))</span><br><span class="line"> &#125;</span><br><span class="line"> val resultSet: ResultSet = pstmt.executeQuery()</span><br><span class="line"> while (resultSet.next()) &#123;</span><br><span class="line"> result = resultSet.getLong(1)</span><br><span class="line"> &#125;</span><br><span class="line"> resultSet.close()</span><br><span class="line"> pstmt.close()</span><br><span class="line"> &#125; catch &#123;</span><br><span class="line"> case e: Exception =&gt; e.printStackTrace()</span><br><span class="line"> &#125;</span><br><span class="line"> result</span><br><span class="line"> &#125;</span><br><span class="line"> //主方法,用于测试上述方法</span><br><span class="line"> def main(args: Array[String]): Unit = &#123;</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li>Ads_log</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case class Ads_log(timestamp: Long,</span><br><span class="line"> area: String,</span><br><span class="line">  city: String,</span><br><span class="line"> userid: String,</span><br><span class="line"> adid: String)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>BlackListHandler</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import java.sql.Connection</span><br><span class="line">import java.text.SimpleDateFormat</span><br><span class="line">import java.util.Date</span><br><span class="line">import com.atguigu.bean.Ads_log</span><br><span class="line">import com.atguigu.utils.JdbcUtil</span><br><span class="line">import org.apache.spark.streaming.dstream.DStream</span><br><span class="line">object BlackListHandler &#123;</span><br><span class="line"> //时间格式化对象</span><br><span class="line"> private val sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;)</span><br><span class="line"> def addBlackList(filterAdsLogDSteam: DStream[Ads_log]): Unit = &#123;</span><br><span class="line"> //统计当前批次中单日每个用户点击每个广告的总次数</span><br><span class="line"> //1.将数据接转换结构 ads_log=&gt;((date,user,adid),1)</span><br><span class="line"> val dateUserAdToOne: DStream[((String, String, String), Long)] = </span><br><span class="line">filterAdsLogDSteam.map(adsLog =&gt; &#123;</span><br><span class="line"> //a.将时间戳转换为日期字符串</span><br><span class="line"> val date: String = sdf.format(new Date(adsLog.timestamp))</span><br><span class="line"> //b.返回值</span><br><span class="line"> ((date, adsLog.userid, adsLog.adid), 1L)</span><br><span class="line"> &#125;)</span><br><span class="line"> //2.统计单日每个用户点击每个广告的总次数</span><br><span class="line">((date,user,adid),1)=&gt;((date,user,adid),count)</span><br><span class="line"> val dateUserAdToCount: DStream[((String, String, String), Long)] = </span><br><span class="line">dateUserAdToOne.reduceByKey(_ + _)</span><br><span class="line"> dateUserAdToCount.foreachRDD(rdd =&gt; &#123;</span><br><span class="line"> rdd.foreachPartition(iter =&gt; &#123;</span><br><span class="line"> val connection: Connection = JdbcUtil.getConnection</span><br><span class="line"> iter.foreach &#123; case ((dt, user, ad), count) =&gt;</span><br><span class="line"> JdbcUtil.executeUpdate(connection,</span><br><span class="line"> &quot;&quot;&quot;</span><br><span class="line"> |INSERT INTO user_ad_count (dt,userid,adid,count)</span><br><span class="line"> |VALUES (?,?,?,?)</span><br><span class="line"> |ON DUPLICATE KEY</span><br><span class="line"> |UPDATE count=count+?</span><br><span class="line"> &quot;&quot;&quot;.stripMargin, Array(dt, user, ad, count, count))</span><br><span class="line"> val ct: Long = JdbcUtil.getDataFromMysql(connection, &quot;select count from </span><br><span class="line">user_ad_count where dt=? and userid=? and adid =?&quot;, Array(dt, user, ad))</span><br><span class="line"> if (ct &gt;= 30) &#123;</span><br><span class="line"> JdbcUtil.executeUpdate(connection, &quot;INSERT INTO black_list (userid) </span><br><span class="line">VALUES (?) ON DUPLICATE KEY update userid=?&quot;, Array(user, user))</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> connection.close()</span><br><span class="line"> &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"> def filterByBlackList(adsLogDStream: DStream[Ads_log]): DStream[Ads_log] = &#123;</span><br><span class="line"> adsLogDStream.transform(rdd =&gt; &#123;</span><br><span class="line"> rdd.filter(adsLog =&gt; &#123;</span><br><span class="line">  val connection: Connection = JdbcUtil.getConnection</span><br><span class="line"> val bool: Boolean = JdbcUtil.isExist(connection, &quot;select * from black_list </span><br><span class="line">where userid=?&quot;, Array(adsLog.userid))</span><br><span class="line"> connection.close()</span><br><span class="line"> !bool</span><br><span class="line"> &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>RealtimeApp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import com.atguigu.bean.Ads_log</span><br><span class="line">import com.atguigu.handler.BlackListHandler</span><br><span class="line">import com.atguigu.utils.MyKafkaUtil</span><br><span class="line">import org.apache.kafka.clients.consumer.ConsumerRecord</span><br><span class="line">import org.apache.spark.SparkConf</span><br><span class="line">import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;</span><br><span class="line">import org.apache.spark.streaming.dstream.&#123;DStream, InputDStream&#125;</span><br><span class="line">object RealTimeApp &#123;</span><br><span class="line"> def main(args: Array[String]): Unit = &#123;</span><br><span class="line"> //1.创建 SparkConf</span><br><span class="line"> val sparkConf: SparkConf = new SparkConf().setAppName(&quot;RealTimeApp </span><br><span class="line">&quot;).setMaster(&quot;local[*]&quot;)</span><br><span class="line"> //2.创建 StreamingContext</span><br><span class="line"> val ssc = new StreamingContext(sparkConf, Seconds(3))</span><br><span class="line"> //3.读取数据</span><br><span class="line"> val kafkaDStream: InputDStream[ConsumerRecord[String, String]] = </span><br><span class="line">MyKafkaUtil.getKafkaStream(&quot;ads_log&quot;, ssc)</span><br><span class="line"> //4.将从 Kafka 读出的数据转换为样例类对象</span><br><span class="line"> val adsLogDStream: DStream[Ads_log] = kafkaDStream.map(record =&gt; &#123;</span><br><span class="line"> val value: String = record.value()</span><br><span class="line"> val arr: Array[String] = value.split(&quot; &quot;)</span><br><span class="line"> Ads_log(arr(0).toLong, arr(1), arr(2), arr(3), arr(4))</span><br><span class="line"> &#125;)</span><br><span class="line"> //5.需求一：根据 MySQL 中的黑名单过滤当前数据集</span><br><span class="line"> val filterAdsLogDStream: DStream[Ads_log] = </span><br><span class="line">BlackListHandler2.filterByBlackList(adsLogDStream)</span><br><span class="line"> //6.需求一：将满足要求的用户写入黑名单</span><br><span class="line"> BlackListHandler2.addBlackList(filterAdsLogDStream)</span><br><span class="line"> //测试打印</span><br><span class="line"> filterAdsLogDStream.cache()</span><br><span class="line"> filterAdsLogDStream.count().print()</span><br><span class="line"> //启动任务</span><br><span class="line"> ssc.start()</span><br><span class="line"> ssc.awaitTermination()</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="需求二：广告点击量实时统计"><a href="#需求二：广告点击量实时统计" class="headerlink" title="需求二：广告点击量实时统计"></a>需求二：广告点击量实时统计</h2><p>描述：实时统计每天各地区各城市各广告的点击总流量，并将其存入 MySQL。</p>
<h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><ol>
<li>单个批次内对数据进行按照天维度的聚合统计; </li>
<li>结合 MySQL 数据跟当前批次数据更新原有的数据。</li>
</ol>
<h3 id="MySQL-建表-1"><a href="#MySQL-建表-1" class="headerlink" title="MySQL 建表"></a>MySQL 建表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE area_city_ad_count (</span><br><span class="line">dt VARCHAR(255),</span><br><span class="line">area VARCHAR(255),</span><br><span class="line">city VARCHAR(255),</span><br><span class="line">adid VARCHAR(255),</span><br><span class="line"> count BIGINT,</span><br><span class="line">PRIMARY KEY (dt,area,city,adid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li><p>DateAreaCityAdCountHandler</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import java.sql.Connection</span><br><span class="line">import java.text.SimpleDateFormat</span><br><span class="line">import java.util.Date</span><br><span class="line">import com.atguigu.bean.Ads_log</span><br><span class="line">import com.atguigu.utils.JdbcUtil</span><br><span class="line">import org.apache.spark.streaming.dstream.DStream</span><br><span class="line">object DateAreaCityAdCountHandler &#123;</span><br><span class="line"> //时间格式化对象</span><br><span class="line"> private val sdf: SimpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;)</span><br><span class="line"> /**</span><br><span class="line"> * 统计每天各大区各个城市广告点击总数并保存至 MySQL 中</span><br><span class="line"> *</span><br><span class="line"> * @param filterAdsLogDStream 根据黑名单过滤后的数据集</span><br><span class="line"> */</span><br><span class="line"> def saveDateAreaCityAdCountToMysql(filterAdsLogDStream: DStream[Ads_log]): Unit </span><br><span class="line">= &#123;</span><br><span class="line"> //1.统计每天各大区各个城市广告点击总数</span><br><span class="line"> val dateAreaCityAdToCount: DStream[((String, String, String, String), Long)] = </span><br><span class="line">filterAdsLogDStream.map(ads_log =&gt; &#123;</span><br><span class="line"> //a.取出时间戳</span><br><span class="line"> val timestamp: Long = ads_log.timestamp</span><br><span class="line"> //b.格式化为日期字符串</span><br><span class="line"> val dt: String = sdf.format(new Date(timestamp))</span><br><span class="line"> //c.组合,返回</span><br><span class="line"> ((dt, ads_log.area, ads_log.city, ads_log.adid), 1L)</span><br><span class="line"> &#125;).reduceByKey(_ + _)</span><br><span class="line"> //2.将单个批次统计之后的数据集合 MySQL 数据对原有的数据更新</span><br><span class="line">  dateAreaCityAdToCount.foreachRDD(rdd =&gt; &#123;</span><br><span class="line"> //对每个分区单独处理</span><br><span class="line"> rdd.foreachPartition(iter =&gt; &#123;</span><br><span class="line"> //a.获取连接</span><br><span class="line"> val connection: Connection = JdbcUtil.getConnection</span><br><span class="line"> //b.写库</span><br><span class="line"> iter.foreach &#123; case ((dt, area, city, adid), count) =&gt;</span><br><span class="line"> JdbcUtil.executeUpdate(connection,</span><br><span class="line"> &quot;&quot;&quot;</span><br><span class="line"> |INSERT INTO area_city_ad_count (dt,area,city,adid,count)</span><br><span class="line"> |VALUES(?,?,?,?,?)</span><br><span class="line"> |ON DUPLICATE KEY</span><br><span class="line"> |UPDATE count=count+?;</span><br><span class="line"> &quot;&quot;&quot;.stripMargin,</span><br><span class="line"> Array(dt, area, city, adid, count, count))</span><br><span class="line"> &#125;</span><br><span class="line"> //c.释放连接</span><br><span class="line"> connection.close()</span><br><span class="line"> &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>RealTimeApp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import java.sql.Connection</span><br><span class="line">import com.atguigu.bean.Ads_log</span><br><span class="line">import com.atguigu.handler.&#123;BlackListHandler, DateAreaCityAdCountHandler, </span><br><span class="line">LastHourAdCountHandler&#125;</span><br><span class="line">import com.atguigu.utils.&#123;JdbcUtil, MyKafkaUtil, PropertiesUtil&#125;</span><br><span class="line">import org.apache.kafka.clients.consumer.ConsumerRecord</span><br><span class="line">import org.apache.spark.SparkConf</span><br><span class="line">import org.apache.spark.streaming.dstream.&#123;DStream, InputDStream&#125;</span><br><span class="line">import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;</span><br><span class="line">object RealTimeApp &#123;</span><br><span class="line"> def main(args: Array[String]): Unit = &#123;</span><br><span class="line"> //1.创建 SparkConf</span><br><span class="line"> val sparkConf: SparkConf = new </span><br><span class="line">SparkConf().setMaster(&quot;local[*]&quot;).setAppName(&quot;RealTimeApp&quot;)</span><br><span class="line"> //2.创建 StreamingContext</span><br><span class="line"> val ssc = new StreamingContext(sparkConf, Seconds(3))</span><br><span class="line"> //3.读取 Kafka 数据 1583288137305 华南 深圳 4 3</span><br><span class="line"> val topic: String = </span><br><span class="line">PropertiesUtil.load(&quot;config.properties&quot;).getProperty(&quot;kafka.topic&quot;)</span><br><span class="line"> val kafkaDStream: InputDStream[ConsumerRecord[String, String]] = </span><br><span class="line">MyKafkaUtil.getKafkaStream(topic, ssc)</span><br><span class="line"> //4.将每一行数据转换为样例类对象</span><br><span class="line"> val adsLogDStream: DStream[Ads_log] = kafkaDStream.map(record =&gt; &#123;</span><br><span class="line"> //a.取出 value 并按照&quot; &quot;切分</span><br><span class="line"> val arr: Array[String] = record.value().split(&quot; &quot;)</span><br><span class="line"> //b.封装为样例类对象</span><br><span class="line">  Ads_log(arr(0).toLong, arr(1), arr(2), arr(3), arr(4))</span><br><span class="line"> &#125;)</span><br><span class="line"> //5.根据 MySQL 中的黑名单表进行数据过滤</span><br><span class="line"> val filterAdsLogDStream: DStream[Ads_log] = adsLogDStream.filter(adsLog =&gt; &#123;</span><br><span class="line"> //查询 MySQL,查看当前用户是否存在。</span><br><span class="line"> val connection: Connection = JdbcUtil.getConnection</span><br><span class="line"> val bool: Boolean = JdbcUtil.isExist(connection, &quot;select * from black_list </span><br><span class="line">where userid=?&quot;, Array(adsLog.userid))</span><br><span class="line"> connection.close()</span><br><span class="line"> !bool</span><br><span class="line"> &#125;)</span><br><span class="line"> filterAdsLogDStream.cache()</span><br><span class="line"> //6.对没有被加入黑名单的用户统计当前批次单日各个用户对各个广告点击的总次数,</span><br><span class="line"> // 并更新至 MySQL</span><br><span class="line"> // 之后查询更新之后的数据,判断是否超过 100 次。</span><br><span class="line"> // 如果超过则将给用户加入黑名单</span><br><span class="line"> BlackListHandler.saveBlackListToMysql(filterAdsLogDStream)</span><br><span class="line"> //7.统计每天各大区各个城市广告点击总数并保存至 MySQL 中</span><br><span class="line">dateAreaCityAdCountHandler.saveDateAreaCityAdCountToMysql(filterAdsLogDStream)</span><br><span class="line"> //10.开启任务</span><br><span class="line"> ssc.start()</span><br><span class="line"> ssc.awaitTermination()</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="需求三：最近一小时广告点击量"><a href="#需求三：最近一小时广告点击量" class="headerlink" title="需求三：最近一小时广告点击量"></a>需求三：最近一小时广告点击量</h3><p>结果展示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：List [15:50-&gt;10,15:51-&gt;25,15:52-&gt;30]</span><br><span class="line">2：List [15:50-&gt;10,15:51-&gt;25,15:52-&gt;30]</span><br><span class="line">3：List [15:50-&gt;10,15:51-&gt;25,15:52-&gt;30]</span><br></pre></td></tr></table></figure>

<h3 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h3><ol>
<li><p>开窗确定时间范围；</p>
</li>
<li><p>在窗口内将数据转换数据结构为((adid,hm),count);</p>
</li>
<li><p>按照广告 id 进行分组处理，组内按照时分排序。</p>
</li>
</ol>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li><p>LastHourAdCountHandler</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.text.SimpleDateFormat</span><br><span class="line">import java.util.Date</span><br><span class="line">import com.atguigu.bean.Ads_log</span><br><span class="line">import org.apache.spark.streaming.Minutes</span><br><span class="line">import org.apache.spark.streaming.dstream.DStream</span><br><span class="line">object LastHourAdCountHandler &#123;</span><br><span class="line"> //时间格式化对象</span><br><span class="line"> private val sdf: SimpleDateFormat = new SimpleDateFormat(&quot;HH:mm&quot;)</span><br><span class="line"> /**</span><br><span class="line"> * 统计最近一小时(2 分钟)广告分时点击总数</span><br><span class="line"> *</span><br><span class="line"> * @param filterAdsLogDStream 过滤后的数据集</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line"> def getAdHourMintToCount(filterAdsLogDStream: DStream[Ads_log]): </span><br><span class="line">DStream[(String, List[(String, Long)])] = &#123;</span><br><span class="line"> //1.开窗 =&gt; 时间间隔为 1 个小时 window()</span><br><span class="line"> val windowAdsLogDStream: DStream[Ads_log] = </span><br><span class="line">filterAdsLogDStream.window(Minutes(2))</span><br><span class="line"> //2.转换数据结构 ads_log =&gt;((adid,hm),1L) map()</span><br><span class="line"> val adHmToOneDStream: DStream[((String, String), Long)] = </span><br><span class="line">windowAdsLogDStream.map(adsLog =&gt; &#123;</span><br><span class="line"> val timestamp: Long = adsLog.timestamp</span><br><span class="line"> val hm: String = sdf.format(new Date(timestamp))</span><br><span class="line"> ((adsLog.adid, hm), 1L)</span><br><span class="line"> &#125;)</span><br><span class="line"> //3.统计总数 ((adid,hm),1L)=&gt;((adid,hm),sum) reduceBykey(_+_)</span><br><span class="line"> val adHmToCountDStream: DStream[((String, String), Long)] = </span><br><span class="line">adHmToOneDStream.reduceByKey(_ + _)</span><br><span class="line"> //4.转换数据结构 ((adid,hm),sum)=&gt;(adid,(hm,sum)) map()</span><br><span class="line"> val adToHmCountDStream: DStream[(String, (String, Long))] = </span><br><span class="line">adHmToCountDStream.map &#123; case ((adid, hm), count) =&gt;</span><br><span class="line"> (adid, (hm, count))</span><br><span class="line"> &#125;</span><br><span class="line"> //5.按照 adid 分组 (adid,(hm,sum))=&gt;(adid,Iter[(hm,sum),...]) groupByKey</span><br><span class="line"> adToHmCountDStream.groupByKey()</span><br><span class="line"> .mapValues(iter =&gt;</span><br><span class="line"> iter.toList.sortWith(_._1 &lt; _._1)</span><br><span class="line"> )</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>RealTimeApp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import java.sql.Connection</span><br><span class="line">import com.atguigu.bean.Ads_log</span><br><span class="line">import com.atguigu.handler.&#123;BlackListHandler, DateAreaCityAdCountHandler, </span><br><span class="line">LastHourAdCountHandler&#125;</span><br><span class="line">import com.atguigu.utils.&#123;JdbcUtil, MyKafkaUtil, PropertiesUtil&#125;</span><br><span class="line">import org.apache.kafka.clients.consumer.ConsumerRecord</span><br><span class="line">import org.apache.spark.SparkConf</span><br><span class="line">import org.apache.spark.streaming.dstream.&#123;DStream, InputDStream&#125;</span><br><span class="line">import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;</span><br><span class="line">object RealTimeApp &#123;</span><br><span class="line"> def main(args: Array[String]): Unit = &#123;</span><br><span class="line">  //1.创建 SparkConf</span><br><span class="line"> val sparkConf: SparkConf = new </span><br><span class="line">SparkConf().setMaster(&quot;local[*]&quot;).setAppName(&quot;RealTimeApp&quot;)</span><br><span class="line"> //2.创建 StreamingContext</span><br><span class="line"> val ssc = new StreamingContext(sparkConf, Seconds(3))</span><br><span class="line"> //3.读取 Kafka 数据 1583288137305 华南 深圳 4 3</span><br><span class="line"> val topic: String = </span><br><span class="line">PropertiesUtil.load(&quot;config.properties&quot;).getProperty(&quot;kafka.topic&quot;)</span><br><span class="line"> val kafkaDStream: InputDStream[ConsumerRecord[String, String]] = </span><br><span class="line">MyKafkaUtil.getKafkaStream(topic, ssc)</span><br><span class="line"> //4.将每一行数据转换为样例类对象</span><br><span class="line"> val adsLogDStream: DStream[Ads_log] = kafkaDStream.map(record =&gt; &#123;</span><br><span class="line"> //a.取出 value 并按照&quot; &quot;切分</span><br><span class="line"> val arr: Array[String] = record.value().split(&quot; &quot;)</span><br><span class="line"> //b.封装为样例类对象</span><br><span class="line"> Ads_log(arr(0).toLong, arr(1), arr(2), arr(3), arr(4))</span><br><span class="line"> &#125;)</span><br><span class="line"> //5.根据 MySQL 中的黑名单表进行数据过滤</span><br><span class="line"> val filterAdsLogDStream: DStream[Ads_log] = adsLogDStream.filter(adsLog =&gt; &#123;</span><br><span class="line"> //查询 MySQL,查看当前用户是否存在。</span><br><span class="line"> val connection: Connection = JdbcUtil.getConnection</span><br><span class="line"> val bool: Boolean = JdbcUtil.isExist(connection, &quot;select * from black_list </span><br><span class="line">where userid=?&quot;, Array(adsLog.userid))</span><br><span class="line"> connection.close()</span><br><span class="line"> !bool</span><br><span class="line"> &#125;)</span><br><span class="line"> filterAdsLogDStream.cache()</span><br><span class="line"> //6.对没有被加入黑名单的用户统计当前批次单日各个用户对各个广告点击的总次数,</span><br><span class="line"> // 并更新至 MySQL</span><br><span class="line"> // 之后查询更新之后的数据,判断是否超过 100 次。</span><br><span class="line"> // 如果超过则将给用户加入黑名单</span><br><span class="line"> BlackListHandler.saveBlackListToMysql(filterAdsLogDStream)</span><br><span class="line"> //7.统计每天各大区各个城市广告点击总数并保存至 MySQL 中</span><br><span class="line"> DateAreaCityAdCountHandler.saveDateAreaCityAdCountToMysql(filterAdsLogDStream)</span><br><span class="line"> //8.统计最近一小时(2 分钟)广告分时点击总数</span><br><span class="line"> val adToHmCountListDStream: DStream[(String, List[(String, Long)])] = </span><br><span class="line">LastHourAdCountHandler.getAdHourMintToCount(filterAdsLogDStream)</span><br><span class="line"> //9.打印</span><br><span class="line"> adToHmCountListDStream.print()</span><br><span class="line"> //10.开启任务</span><br><span class="line"> ssc.start()</span><br><span class="line"> ssc.awaitTermination()</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://lvxiaoyi.top">lvxiaoyi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lvxiaoyi.top/e1884286.html">https://lvxiaoyi.top/e1884286.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lvxiaoyi.top" target="_blank">吕小医's BLOG</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></div><div class="post_share"><div class="social-share" data-image="https://img.lvxiaoyi.top/typora-img/202111091530306.png/lvxiaoyi" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/b0191bc6.html"><img class="prev-cover" src="https://img.lvxiaoyi.top/typora-img/image-20211028174657424.png/lvxiaoyi" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">hadoop基础-2MapReduce</div></div></a></div><div class="next-post pull-right"><a href="/4443ccc7.html"><img class="next-cover" src="https://img.lvxiaoyi.top/typora-img/202111081621419.png/lvxiaoyi" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spark基础-4Spark核心</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/5eb2dc8b.html" title="hadoop基础-3Yarn"><img class="cover" src="https://img.lvxiaoyi.top/typora-img/image-20211028174657424.png/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">hadoop基础-3Yarn</div></div></a></div><div><a href="/bc13a2ae.html" title="HBase基础"><img class="cover" src="https://img.lvxiaoyi.top/typora-img/image-20211028174657424.png/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">HBase基础</div></div></a></div><div><a href="/9cbb2d93.html" title="hive基础-2"><img class="cover" src="https://img.lvxiaoyi.top/typora-img/image-20211028174657424.png/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">hive基础-2</div></div></a></div><div><a href="/1d83a7d1.html" title="Hive基础-1"><img class="cover" src="https://img.lvxiaoyi.top/typora-img/image-20211028174657424.png/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">Hive基础-1</div></div></a></div><div><a href="/6362a21d.html" title="Scala基础-1"><img class="cover" src="https://img.lvxiaoyi.top/typora-img/202111082146936.png/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">Scala基础-1</div></div></a></div><div><a href="/fa6bf3a7.html" title="Scala基础-2"><img class="cover" src="https://img.lvxiaoyi.top/typora-img/202111082146936.png/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">Scala基础-2</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://p0.meituan.net/csc/8a1b1d488e6a8ab5108c9c78f36b3a1776955.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lvxiaoyi</div><div class="author-info__description">ISFP到ESFJ</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">204</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">50</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spark%E5%9F%BA%E7%A1%80-3SparkStreaming"><span class="toc-number">1.</span> <span class="toc-text">Spark基础-3SparkStreaming</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SparkStreaming-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">SparkStreaming 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spark-Streaming-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.</span> <span class="toc-text">Spark Streaming 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spark-Streaming-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.2.</span> <span class="toc-text">Spark Streaming 的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spark-Streaming-%E6%9E%B6%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">Spark Streaming 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">2.3.1.</span> <span class="toc-text">架构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E5%8E%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.2.</span> <span class="toc-text">背压机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dstream-%E5%85%A5%E9%97%A8"><span class="toc-number">3.</span> <span class="toc-text">Dstream 入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#WordCount-%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%93%8D"><span class="toc-number">3.1.</span> <span class="toc-text">WordCount 案例实操</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WordCount-%E8%A7%A3%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text">WordCount 解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DStream-%E5%88%9B%E5%BB%BA"><span class="toc-number">3.3.</span> <span class="toc-text">DStream 创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RDD-%E9%98%9F%E5%88%97"><span class="toc-number">3.4.</span> <span class="toc-text">RDD 队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95%E5%8F%8A%E8%AF%B4%E6%98%8E"><span class="toc-number">3.4.1.</span> <span class="toc-text">用法及说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">3.5.</span> <span class="toc-text">自定义数据源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95%E5%8F%8A%E8%AF%B4%E6%98%8E-1"><span class="toc-number">3.5.1.</span> <span class="toc-text">用法及说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kafka-%E6%95%B0%E6%8D%AE%E6%BA%90%EF%BC%88%E9%9D%A2%E8%AF%95%E3%80%81%E5%BC%80%E5%8F%91%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">Kafka 数据源（面试、开发重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E9%80%89%E5%9E%8B"><span class="toc-number">3.6.1.</span> <span class="toc-text">版本选型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kafka-0-8-Receiver-%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%BD%93%E5%89%8D%E7%89%88%E6%9C%AC%E4%B8%8D%E9%80%82%E7%94%A8%EF%BC%89"><span class="toc-number">3.6.2.</span> <span class="toc-text">Kafka 0-8 Receiver 模式（当前版本不适用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kafka-0-8-Direct-%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%BD%93%E5%89%8D%E7%89%88%E6%9C%AC%E4%B8%8D%E9%80%82%E7%94%A8%EF%BC%89"><span class="toc-number">3.6.3.</span> <span class="toc-text">Kafka 0-8 Direct 模式（当前版本不适用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kafka-0-8-Direct-%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%BD%93%E5%89%8D%E7%89%88%E6%9C%AC%E4%B8%8D%E9%80%82%E7%94%A8%EF%BC%89-1"><span class="toc-number">3.6.4.</span> <span class="toc-text">Kafka 0-8 Direct 模式（当前版本不适用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kafka-0-10-Direct-%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.6.5.</span> <span class="toc-text">Kafka 0-10 Direct 模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DStream-%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.</span> <span class="toc-text">DStream 转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.</span> <span class="toc-text">无状态转化操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Transform"><span class="toc-number">4.1.1.</span> <span class="toc-text">Transform</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-number">4.1.2.</span> <span class="toc-text">join</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.</span> <span class="toc-text">有状态转化操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UpdateStateByKey"><span class="toc-number">4.2.1.</span> <span class="toc-text">UpdateStateByKey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WindowOperations"><span class="toc-number">4.2.2.</span> <span class="toc-text">WindowOperations</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DStream-%E8%BE%93%E5%87%BA"><span class="toc-number">5.</span> <span class="toc-text">DStream 输出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E9%9B%85%E5%85%B3%E9%97%AD"><span class="toc-number">6.</span> <span class="toc-text">优雅关闭</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SparkStreaming-%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%93%8D"><span class="toc-number">7.</span> <span class="toc-text">SparkStreaming 案例实操</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">7.1.</span> <span class="toc-text">环境准备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pom-%E6%96%87%E4%BB%B6"><span class="toc-number">7.1.1.</span> <span class="toc-text">pom 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">7.1.2.</span> <span class="toc-text">工具类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E6%A8%A1%E5%9D%97"><span class="toc-number">7.2.</span> <span class="toc-text">实时数据生成模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E4%B8%80%EF%BC%9A%E5%B9%BF%E5%91%8A%E9%BB%91%E5%90%8D%E5%8D%95"><span class="toc-number">7.3.</span> <span class="toc-text">需求一：广告黑名单</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="toc-number">7.3.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E5%BB%BA%E8%A1%A8"><span class="toc-number">7.3.2.</span> <span class="toc-text">MySQL 建表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-1"><span class="toc-number">7.3.3.</span> <span class="toc-text">环境准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.3.4.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E4%BA%8C%EF%BC%9A%E5%B9%BF%E5%91%8A%E7%82%B9%E5%87%BB%E9%87%8F%E5%AE%9E%E6%97%B6%E7%BB%9F%E8%AE%A1"><span class="toc-number">7.4.</span> <span class="toc-text">需求二：广告点击量实时统计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-1"><span class="toc-number">7.4.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E5%BB%BA%E8%A1%A8-1"><span class="toc-number">7.4.2.</span> <span class="toc-text">MySQL 建表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">7.4.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E4%B8%89%EF%BC%9A%E6%9C%80%E8%BF%91%E4%B8%80%E5%B0%8F%E6%97%B6%E5%B9%BF%E5%91%8A%E7%82%B9%E5%87%BB%E9%87%8F"><span class="toc-number">7.4.4.</span> <span class="toc-text">需求三：最近一小时广告点击量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-2"><span class="toc-number">7.4.5.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">7.4.6.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/7ef7bbd4.html" title="LeetCode 118. 杨辉三角"><img src="https://img.lvxiaoyi.top/typora-img/202111011355394.png/lvxiaoyi" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode 118. 杨辉三角"/></a><div class="content"><a class="title" href="/7ef7bbd4.html" title="LeetCode 118. 杨辉三角">LeetCode 118. 杨辉三角</a><time datetime="2023-03-19T14:25:59.394Z" title="发表于 2023-03-19 22:25:59">2023-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/82c8cab7.html" title="shell基础"><img src="https://pic2.zhimg.com/v2-9964d2894516902605191817111ec781_r.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="shell基础"/></a><div class="content"><a class="title" href="/82c8cab7.html" title="shell基础">shell基础</a><time datetime="2022-10-12T16:07:18.841Z" title="发表于 2022-10-13 00:07:18">2022-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f1601c3e.html" title="单例模式"><img src="https://img.lvxiaoyi.top/typora-img/1002892-20180912131026735-781767905.png/lvxiaoyi" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="单例模式"/></a><div class="content"><a class="title" href="/f1601c3e.html" title="单例模式">单例模式</a><time datetime="2022-09-12T07:22:48.777Z" title="发表于 2022-09-12 15:22:48">2022-09-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/b15f0f1b.html" title="设计模式基础-1"><img src="https://img.lvxiaoyi.top/typora-img/image-20211012093705433.png/lvxiaoyi" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式基础-1"/></a><div class="content"><a class="title" href="/b15f0f1b.html" title="设计模式基础-1">设计模式基础-1</a><time datetime="2022-09-12T07:22:48.777Z" title="发表于 2022-09-12 15:22:48">2022-09-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2109f677.html" title="计算机网络常见面试题"><img src="https://img.lvxiaoyi.top/typora-img/java-interview/1.png/lvxiaoyi" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络常见面试题"/></a><div class="content"><a class="title" href="/2109f677.html" title="计算机网络常见面试题">计算机网络常见面试题</a><time datetime="2022-09-12T07:22:48.777Z" title="发表于 2022-09-12 15:22:48">2022-09-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://img.lvxiaoyi.top/typora-img/202111091530306.png/lvxiaoyi')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By lvxiaoyi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/lvxiaoyi.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>