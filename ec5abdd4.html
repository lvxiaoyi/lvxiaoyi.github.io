<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>吕小医's BLOG | 吕小医's BLOG</title><meta name="keywords" content="大数据"><meta name="author" content="lvxiaoyi"><meta name="copyright" content="lvxiaoyi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spark基础-1SparkCoreSpark 概述Spark 是什么 Spark 是一种基于内存的快速、通用、可扩展的大数据分析计算引擎。 Spark and Hadoop在之前的学习中，Hadoop 的 MapReduce 是大家广为熟知的计算框架，那为什么咱们还要学习新的计算框架 Spark 呢，这里就不得不提到Spark 和Hadoop 的关系。 首先从时间节点上来看:  Hadoop">
<meta property="og:type" content="article">
<meta property="og:title" content="吕小医&#39;s BLOG">
<meta property="og:url" content="https://lvxiaoyi.top/ec5abdd4.html">
<meta property="og:site_name" content="吕小医&#39;s BLOG">
<meta property="og:description" content="Spark基础-1SparkCoreSpark 概述Spark 是什么 Spark 是一种基于内存的快速、通用、可扩展的大数据分析计算引擎。 Spark and Hadoop在之前的学习中，Hadoop 的 MapReduce 是大家广为熟知的计算框架，那为什么咱们还要学习新的计算框架 Spark 呢，这里就不得不提到Spark 和Hadoop 的关系。 首先从时间节点上来看:  Hadoop">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.lvxiaoyi.top/typora-img/202111081621419.png/lvxiaoyi">
<meta property="article:published_time" content="2022-09-12T07:22:48.773Z">
<meta property="article:modified_time" content="2022-09-12T07:22:48.773Z">
<meta property="article:author" content="lvxiaoyi">
<meta property="article:tag" content="大数据">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.lvxiaoyi.top/typora-img/202111081621419.png/lvxiaoyi"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lvxiaoyi.top/ec5abdd4"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '吕小医\'s BLOG',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-12 15:22:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p0.meituan.net/csc/8a1b1d488e6a8ab5108c9c78f36b3a1776955.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">205</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">51</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 小医</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img.lvxiaoyi.top/typora-img/202111081621419.png/lvxiaoyi')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">吕小医's BLOG</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 小医</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-12T07:22:48.773Z" title="发表于 2022-09-12 15:22:48">2022-09-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-12T07:22:48.773Z" title="更新于 2022-09-12 15:22:48">2022-09-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/">Spark</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Spark基础-1SparkCore"><a href="#Spark基础-1SparkCore" class="headerlink" title="Spark基础-1SparkCore"></a>Spark基础-1SparkCore</h1><h1 id="Spark-概述"><a href="#Spark-概述" class="headerlink" title="Spark 概述"></a>Spark 概述</h1><h2 id="Spark-是什么"><a href="#Spark-是什么" class="headerlink" title="Spark 是什么"></a>Spark 是什么</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111081621419.png/lvxiaoyi" alt="spark"></p>
<p>Spark 是一种基于内存的快速、通用、可扩展的大数据分析计算引擎。</p>
<h2 id="Spark-and-Hadoop"><a href="#Spark-and-Hadoop" class="headerlink" title="Spark and Hadoop"></a>Spark and Hadoop</h2><p>在之前的学习中，Hadoop 的 MapReduce 是大家广为熟知的计算框架，那为什么咱们还要学习新的计算框架 Spark 呢，这里就不得不提到Spark 和Hadoop 的关系。</p>
<p>首先从时间节点上来看:</p>
<ul>
<li><p>Hadoop</p>
<ul>
<li><p>2006 年 1 月，Doug Cutting 加入Yahoo，领导Hadoop 的开发</p>
</li>
<li><p>2008 年 1 月，Hadoop 成为 Apache 顶级项目</p>
</li>
<li><p>2011 年 1.0 正式发布</p>
</li>
<li><p>2012 年 3 月稳定版发布</p>
</li>
<li><p>2013 年 10 月发布 2.X (Yarn)版本</p>
</li>
</ul>
</li>
<li><p>Spark</p>
<ul>
<li>2009 年，Spark 诞生于伯克利大学的AMPLab 实验室</li>
<li>2010 年，伯克利大学正式开源了 Spark 项目</li>
<li>2013 年 6 月，Spark 成为了 Apache 基金会下的项目</li>
<li>2014 年 2 月，Spark 以飞快的速度成为了 Apache 的顶级项目</li>
<li>2015 年至今，Spark 变得愈发火爆，大量的国内公司开始重点部署或者使用 Spark</li>
</ul>
</li>
</ul>
<p>然后我们再从功能上来看:</p>
<ul>
<li>Hadoop<ul>
<li>Hadoop 是由 java 语言编写的，在分布式服务器集群上存储海量数据并运行分布式分析应用的开源框架</li>
<li>作为 Hadoop 分布式文件系统，HDFS 处于 Hadoop 生态圈的最下层，存储着所有的数据， 支持着 Hadoop 的所有服务。 它的理论基础源于 Google 的TheGoogleFileSystem 这篇论文，它是GFS 的开源实现。</li>
<li>MapReduce 是一种编程模型，Hadoop 根据 Google 的 MapReduce 论文将其实现， 作为 Hadoop 的分布式计算模型，是 Hadoop 的核心。基于这个框架，分布式并行程序的编写变得异常简单。综合了 HDFS 的分布式存储和 MapReduce 的分布式计算，Hadoop 在处理海量数据时，性能横向扩展变得非常容易。</li>
<li>HBase 是对 Google 的 Bigtable 的开源实现，但又和 Bigtable 存在许多不同之处。HBase 是一个基于HDFS 的分布式数据库，擅长实时地随机读/写超大规模数据集。它也是 Hadoop 非常重要的组件。</li>
</ul>
</li>
<li>Spark<ul>
<li>Spark 是一种由 Scala 语言开发的快速、通用、可扩展的大数据分析引擎</li>
<li>Spark Core 中提供了 Spark 最基础与最核心的功能</li>
<li>Spark SQL 是Spark 用来操作结构化数据的组件。通过 Spark SQL，用户可以使用SQL 或者 Apache Hive 版本的 SQL 方言（HQL）来查询数据。</li>
<li>Spark Streaming 是 Spark 平台上针对实时数据进行流式计算的组件，提供了丰富的处理数据流的API。</li>
</ul>
</li>
</ul>
<p>由上面的信息可以获知，Spark 出现的时间相对较晚，并且主要功能主要是用于数据计算， 所以其实 Spark 一直被认为是Hadoop 框架的升级版。</p>
<h2 id="Spark-or-Hadoop"><a href="#Spark-or-Hadoop" class="headerlink" title="Spark or Hadoop"></a>Spark or Hadoop</h2><p>Hadoop 的 MR 框架和Spark 框架都是数据处理框架，那么我们在使用时如何选择呢？</p>
<ul>
<li>Hadoop MapReduce 由于其设计初衷并不是为了满足循环迭代式数据流处理，因此在多并行运行的数据可复用场景（如：机器学习、图挖掘算法、交互式数据挖掘算法）中存在诸多计算效率等问题。所以 Spark 应运而生，Spark 就是在传统的MapReduce 计算框架的基础上，利用其计算过程的优化，从而大大加快了数据分析、挖掘的运行和读写速度，并将计算单元缩小到更适合并行计算和重复使用的RDD 计算模型。</li>
<li>机器学习中 ALS、凸优化梯度下降等。这些都需要基于数据集或者数据集的衍生数据反复查询反复操作。MR 这种模式不太合适，即使多 MR 串行处理，性能和时间也是一个问题。数据的共享依赖于磁盘。另外一种是交互式数据挖掘，MR 显然不擅长。而Spark 所基于的 scala 语言恰恰擅长函数的处理。</li>
<li>Spark 是一个分布式数据快速分析项目。它的核心技术是弹性分布式数据集（Resilient Distributed Datasets），提供了比MapReduce 丰富的模型，可以快速在内存中对数据集进行多次迭代，来支持复杂的数据挖掘算法和图形计算算法。</li>
<li>Spark 和Hadoop 的根本差异是多个作业之间的数据通信问题 : Spark 多个作业之间数据通信是基于内存，而 Hadoop 是基于磁盘。</li>
<li>Spark Task 的启动时间快。Spark 采用 fork 线程的方式，而 Hadoop 采用创建新的进程的方式。</li>
<li>Spark 只有在 shuffle 的时候将数据写入磁盘，而 Hadoop 中多个 MR 作业之间的数据交互都要依赖于磁盘交互</li>
</ul>
<p>经过上面的比较，我们可以看出在绝大多数的数据计算场景中，Spark 确实会比 MapReduce 更有优势。但是Spark 是基于内存的，所以在实际的生产环境中，由于内存的限制，可能会由于内存资源不够导致 Job 执行失败，此时，MapReduce 其实是一个更好的选择，所以 Spark 并不能完全替代 MR。</p>
<h2 id="Spark-核心模块"><a href="#Spark-核心模块" class="headerlink" title="Spark 核心模块"></a>Spark 核心模块</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111081645429.png/lvxiaoyi" alt="image-20211108164552332" style="zoom:50%;" />

<ul>
<li><p>Spark Core</p>
<p>Spark Core 中提供了 Spark 最基础与最核心的功能，Spark 其他的功能如：Spark SQL， Spark Streaming，GraphX, MLlib 都是在 Spark Core 的基础上进行扩展的</p>
</li>
<li><p>Spark SQL</p>
<p>Spark SQL 是Spark 用来操作结构化数据的组件。通过 Spark SQL，用户可以使用 SQL或者Apache Hive 版本的 SQL 方言（HQL）来查询数据。</p>
</li>
<li><p>Spark Streaming</p>
<p>Spark Streaming 是 Spark 平台上针对实时数据进行流式计算的组件，提供了丰富的处理数据流的API。</p>
</li>
<li><p>Spark MLlib</p>
<p>MLlib 是 Spark 提供的一个机器学习算法库。MLlib 不仅提供了模型评估、数据导入等额外的功能，还提供了一些更底层的机器学习原语。</p>
</li>
<li><p>Spark GraphX</p>
<p>GraphX 是 Spark 面向图计算提供的框架与算法库。</p>
</li>
</ul>
<h2 id="Spark-快速上手"><a href="#Spark-快速上手" class="headerlink" title="Spark 快速上手"></a>Spark 快速上手</h2><p>在大数据早期的课程中我们已经学习了 MapReduce 框架的原理及基本使用，并了解了其底层数据处理的实现方式。接下来，就让咱们走进 Spark 的世界，了解一下它是如何带领我们完成数据处理的。</p>
<h2 id="创建-Maven-项目"><a href="#创建-Maven-项目" class="headerlink" title="创建 Maven 项目"></a>创建 Maven 项目</h2><h3 id="增加-Scala-插件"><a href="#增加-Scala-插件" class="headerlink" title="增加 Scala 插件"></a>增加 Scala 插件</h3><p>Spark 由 Scala 语言开发的，所以本课件接下来的开发所使用的语言也为 Scala，咱们当前使用的 Spark 版本为 3.0.0，默认采用的 Scala 编译版本为 2.12，所以后续开发时。我们依然采用这个版本。开发前请保证 IDEA 开发工具中含有 Scala 开发插件</p>
<h3 id="增加依赖关系"><a href="#增加依赖关系" class="headerlink" title="增加依赖关系"></a>增加依赖关系</h3><p>修改 Maven 项目中的POM 文件，增加 Spark 框架的依赖关系。本课件基于 Spark3.0 版本，使用时请注意对应版本。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-core_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 该插件用于将 Scala 代码编译成 class 文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.alchim31.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 声明绑定到 maven 的 compile 阶段 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>testCompile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="WordCount"><a href="#WordCount" class="headerlink" title="WordCount"></a>WordCount</h3><p>为了能直观地感受 Spark 框架的效果，接下来我们实现一个大数据学科中最常见的教学案例WordCount</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Spark 运行配置对象</span></span><br><span class="line"><span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Spark 上下文环境对象（连接对象）</span></span><br><span class="line"><span class="keyword">val</span> sc : <span class="type">SparkContext</span> = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件数据</span></span><br><span class="line"><span class="keyword">val</span> fileRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">&quot;input/word.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件中的数据进行分词</span></span><br><span class="line"><span class="keyword">val</span> wordRDD: <span class="type">RDD</span>[<span class="type">String</span>] = fileRDD.flatMap( _.split(<span class="string">&quot; &quot;</span>) )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换数据结构 word =&gt; (word, 1)</span></span><br><span class="line"><span class="keyword">val</span> word2OneRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordRDD.map((_,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将转换结构后的数据按照相同的单词进行分组聚合</span></span><br><span class="line"><span class="keyword">val</span> word2CountRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = word2OneRDD.reduceByKey(_+_)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据聚合结果采集到内存中</span></span><br><span class="line"><span class="keyword">val</span> word2Count: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = word2CountRDD.collect()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">word2Count.foreach(println)</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭 Spark 连接</span></span><br><span class="line">sc.stop()</span><br></pre></td></tr></table></figure>

<p>执行过程中，会产生大量的执行日志，如果为了能够更好的查看程序的执行结果，可以在项</p>
<p>目的 resources 目录中创建log4j.properties 文件，并添加日志配置信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootCategory=ERROR, console</span><br><span class="line">log4j.appender.console=org.apache.log4j.ConsoleAppender log4j.appender.console.target=System.err log4j.appender.console.layout=org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=%d&#123;yy/MM/dd HH:mm:ss&#125; %p %c&#123;1&#125;: %m%n</span><br><span class="line"></span><br><span class="line"># Set the default spark-shell log level to ERROR. When running the spark-shell, the</span><br><span class="line"># log level for this class is used to overwrite the root logger&#x27;s log level, so that</span><br><span class="line"># the user can have different defaults for the shell and regular Spark apps. log4j.logger.org.apache.spark.repl.Main=ERROR</span><br><span class="line"></span><br><span class="line"># Settings to quiet third party logs that are too verbose log4j.logger.org.spark_project.jetty=ERROR log4j.logger.org.spark_project.jetty.util.component.AbstractLifeCycle=ERROR log4j.logger.org.apache.spark.repl.SparkIMain$exprTyper=ERROR log4j.logger.org.apache.spark.repl.SparkILoop$SparkILoopInterpreter=ERROR log4j.logger.org.apache.parquet=ERROR</span><br><span class="line">log4j.logger.parquet=ERROR</span><br><span class="line"></span><br><span class="line"># SPARK-9183: Settings to avoid annoying messages when looking up nonexistent UDFs in SparkSQL with Hive support log4j.logger.org.apache.hadoop.hive.metastore.RetryingHMSHandler=FATAL log4j.logger.org.apache.hadoop.hive.ql.exec.FunctionRegistry=ERROR</span><br></pre></td></tr></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>如果本机操作系统是 Windows，在程序中使用了 Hadoop 相关的东西，比如写入文件到HDFS，则会遇到如下异常：</p>
<p>出现这个问题的原因，并不是程序的错误，而是 windows 系统用到了 hadoop 相关的服</p>
<p>务，解决办法是通过配置关联到 windows 的系统依赖就可以了</p>
<p>在 IDEA 中配置 Run Configuration，添加 HADOOP_HOME 变量</p>
<h1 id="Spark-运行环境"><a href="#Spark-运行环境" class="headerlink" title="Spark 运行环境"></a>Spark 运行环境</h1><p>Spark 作为一个数据处理框架和计算引擎，被设计在所有常见的集群环境中运行, 在国内工作中主流的环境为 Yarn，不过逐渐容器式环境也慢慢流行起来。接下来，我们就分别看看不同环境下 Spark 的运行</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111081651113.png/lvxiaoyi" alt="image-20211108165142918" style="zoom:50%;" />

<h2 id="Local-模式"><a href="#Local-模式" class="headerlink" title="Local 模式"></a>Local 模式</h2><p>想啥呢，你之前一直在使用的模式可不是 Local 模式哟。所谓的 Local 模式，就是不需要其他任何节点资源就可以在本地执行 Spark 代码的环境，一般用于教学，调试，演示等，之前在 IDEA 中运行代码的环境我们称之为开发环境，不太一样。</p>
<h3 id="解压缩文件"><a href="#解压缩文件" class="headerlink" title="解压缩文件"></a>解压缩文件</h3><p>将 spark-3.0.0-bin-hadoop3.2.tgz 文件上传到 Linux 并解压缩，放置在指定位置，路径中不要包含中文或空格，课件后续如果涉及到解压缩操作，不再强调</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf spark-3.0.0-bin-hadoop3.2.tgz -C /opt/module</span><br><span class="line">cd /opt/module </span><br><span class="line">mv spark-3.0.0-bin-hadoop3.2 spark-local</span><br></pre></td></tr></table></figure>

<h3 id="启动-Local-环境"><a href="#启动-Local-环境" class="headerlink" title="启动 Local 环境"></a>启动 Local 环境</h3><ol>
<li><p>进入解压缩后的路径，执行如下指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-shell</span><br></pre></td></tr></table></figure></li>
<li><p>启动成功后，可以输入网址进行 Web UI 监控页面访问</p>
<p>http://虚拟机地址:4040</p>
</li>
</ol>
<h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h3><p>在解压缩文件夹下的 data 目录中，添加 word.txt 文件。在命令行工具中执行如下代码指令（和 IDEA 中代码简化版一致）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc.textFile(&quot;data/word.txt&quot;).flatMap(_.split(&quot;</span><br><span class="line">&quot;)).map((_,1)).reduceByKey(_+_).collect</span><br></pre></td></tr></table></figure>

<h3 id="退出本地模式"><a href="#退出本地模式" class="headerlink" title="退出本地模式"></a>退出本地模式</h3><p>按键 Ctrl+C 或输入 Scala 指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:quit</span><br></pre></td></tr></table></figure>

<h3 id="提交应用"><a href="#提交应用" class="headerlink" title="提交应用"></a>提交应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master local[2] \</span><br><span class="line">./examples/jars/spark-examples_2.12-3.0.0.jar \</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<ol>
<li><p>–class 表示要执行程序的主类，此处可以更换为咱们自己写的应用程序</p>
</li>
<li><p>–master local[2] 部署模式，默认为本地模式，数字表示分配的虚拟 CPU 核数量</p>
</li>
<li><p>spark-examples_2.12-3.0.0.jar 运行的应用类所在的 jar 包，实际使用时，可以设定为咱们自己打的 jar 包</p>
</li>
<li><p>数字 10 表示程序的入口参数，用于设定当前应用的任务数量</p>
</li>
</ol>
<h2 id="Standalone-模式"><a href="#Standalone-模式" class="headerlink" title="Standalone 模式"></a>Standalone 模式</h2><p>local 本地模式毕竟只是用来进行练习演示的，真实工作中还是要将应用提交到对应的集群中去执行，这里我们来看看只使用 Spark 自身节点运行的集群模式，也就是我们所谓的独立部署（Standalone）模式。Spark 的 Standalone 模式体现了经典的 master-slave 模式。</p>
<p>集群规划:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">机器		Linux1 				Linux2 		  Linux3</span><br><span class="line">Spark 	Worker Master 		  Worker 		Worker</span><br></pre></td></tr></table></figure>

<h3 id="解压缩文件-1"><a href="#解压缩文件-1" class="headerlink" title="解压缩文件"></a>解压缩文件</h3><p>将 spark-3.0.0-bin-hadoop3.2.tgz 文件上传到 Linux 并解压缩在指定位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf spark-3.0.0-bin-hadoop3.2.tgz -C /opt/module</span><br><span class="line">cd /opt/module </span><br><span class="line">mv spark-3.0.0-bin-hadoop3.2 spark-standalone</span><br></pre></td></tr></table></figure>

<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><ol>
<li><p>进入解压缩后路径的 conf 目录，修改 slaves.template 文件名为 slaves</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv slaves.template slaves</span><br></pre></td></tr></table></figure></li>
<li><p>修改 slaves 文件，添加 work 节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux1</span><br><span class="line">linux2</span><br><span class="line">linux3</span><br></pre></td></tr></table></figure></li>
<li><p>修改 spark-env.sh.template 文件名为 spark-env.sh</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv spark-env.sh.template spark-env.sh</span><br></pre></td></tr></table></figure></li>
<li><p>修改 spark-env.sh 文件，添加 JAVA_HOME 环境变量和集群对应的 master 节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_144</span><br><span class="line">SPARK_MASTER_HOST=linux1</span><br><span class="line">SPARK_MASTER_PORT=7077</span><br></pre></td></tr></table></figure>

<p>注意：7077 端口，相当于 hadoop3 内部通信的 8020 端口，此处的端口需要确认自己的 Hadoop配置</p>
</li>
<li><p>分发 spark-standalone 目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xsync spark-standalone</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h3><ol>
<li><p>执行脚本命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-all.sh</span><br></pre></td></tr></table></figure></li>
<li><p>查看三台服务器运行进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">================linux1================</span><br><span class="line">3330 Jps</span><br><span class="line">3238 Worker</span><br><span class="line">3163 Master</span><br><span class="line">================linux2================</span><br><span class="line">2966 Jps</span><br><span class="line">2908 Worker</span><br><span class="line">================linux3================</span><br><span class="line">2978 Worker</span><br><span class="line">3036 Jps</span><br></pre></td></tr></table></figure></li>
<li><p>查看 Master 资源监控 Web UI 界面: <a target="_blank" rel="noopener" href="http://linux1:8080/">http://linux1:8080</a></p>
</li>
</ol>
<h3 id="提交应用-1"><a href="#提交应用-1" class="headerlink" title="提交应用"></a>提交应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master spark://linux1:7077 \</span><br><span class="line">./examples/jars/spark-examples_2.12-3.0.0.jar \</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<ol>
<li><p>–class 表示要执行程序的主类</p>
</li>
<li><p>–master spark://linux1:7077 独立部署模式，连接到 Spark 集群</p>
</li>
<li><p>spark-examples_2.12-3.0.0.jar 运行类所在的 jar 包</p>
</li>
<li><p>数字 10 表示程序的入口参数，用于设定当前应用的任务数量</p>
</li>
</ol>
<p>执行任务时，会产生多个 Java 进程</p>
<p>执行任务时，默认采用服务器集群节点的总核数，每个节点内存 1024M。</p>
<h3 id="提交参数说明"><a href="#提交参数说明" class="headerlink" title="提交参数说明"></a>提交参数说明</h3><p>在提交应用中，一般会同时一些提交参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class &lt;main-class&gt;</span><br><span class="line">--master &lt;master-url&gt; \</span><br><span class="line">... # other options</span><br><span class="line">&lt;application-jar&gt; \</span><br><span class="line">[application-arguments]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数         解释</th>
<th></th>
<th>可选值举例</th>
</tr>
</thead>
<tbody><tr>
<td>–class</td>
<td>Spark 程序中包含主函数的类</td>
<td></td>
</tr>
<tr>
<td>–master</td>
<td>Spark 程序运行的模式(环境)</td>
<td>模式：local[*]、spark://linux1:7077、Yarn</td>
</tr>
<tr>
<td>–executor-memory 1G</td>
<td>指定每个 executor 可用内存为 1G</td>
<td>符合集群内存配置即可，具体情况具体分析。</td>
</tr>
<tr>
<td>–total-executor-cores 2</td>
<td>指定所有executor使用的cpu核数为 2 个</td>
<td></td>
</tr>
<tr>
<td>–executor-cores</td>
<td>指定每个executor使用的cpu核数</td>
<td></td>
</tr>
<tr>
<td>application-jar</td>
<td>打包好的应用 jar，包含依赖。这个 URL 在集群中全局可见。 比 如 hdfs:// 共享存储系统，如果是file:// path，那么所有的节点的path 都包含同样的 jar</td>
<td></td>
</tr>
<tr>
<td>application-arguments</td>
<td>传给 main()方法的参数</td>
<td></td>
</tr>
</tbody></table>
<h3 id="配置历史服务"><a href="#配置历史服务" class="headerlink" title="配置历史服务"></a>配置历史服务</h3><p>由于 spark-shell 停止掉后，集群监控 linux1:4040 页面就看不到历史任务的运行情况，所以开发时都配置历史服务器记录任务运行情况。</p>
<ol>
<li><p>修改 spark-defaults.conf.template 文件名为 spark-defaults.conf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv spark-defaults.conf.template spark-defaults.conf</span><br></pre></td></tr></table></figure></li>
<li><p>修改 spark-default.conf 文件，配置日志存储路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spark.eventLog.enabled true</span><br><span class="line">spark.eventLog.dir hdfs://linux1:8020/directory</span><br></pre></td></tr></table></figure>

<p>注意：需要启动 hadoop 集群，HDFS 上的 directory 目录需要提前存在。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-dfs.sh</span><br><span class="line">hadoop fs -mkdir /directory</span><br></pre></td></tr></table></figure></li>
<li><p>修改 spark-env.sh 文件, 添加日志配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_HISTORY_OPTS=&quot;</span><br><span class="line">-Dspark.history.ui.port=18080 </span><br><span class="line">-Dspark.history.fs.logDirectory=hdfs://linux1:8020/directory </span><br><span class="line">-Dspark.history.retainedApplications=30&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数 1 含义：WEB UI 访问的端口号为 18080</p>
</li>
<li><p>参数 2 含义：指定历史服务器日志存储路径</p>
</li>
<li><p>参数 3 含义：指定保存 Application 历史记录的个数，如果超过这个值，旧的应用程序信息将被删除，这个是内存中的应用数，而不是页面上显示的应用数。</p>
</li>
</ul>
</li>
<li><p>分发配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xsync conf</span><br></pre></td></tr></table></figure></li>
<li><p>重新启动集群和历史服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-all.sh</span><br><span class="line">sbin/start-history-server.sh</span><br></pre></td></tr></table></figure></li>
<li><p>重新执行任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master spark://linux1:7077 \</span><br><span class="line">./examples/jars/spark-examples_2.12-3.0.0.jar \</span><br><span class="line">10</span><br></pre></td></tr></table></figure></li>
<li><p>查看历史服务：<a target="_blank" rel="noopener" href="http://linux1:18080/">http://linux1:18080</a></p>
</li>
</ol>
<h3 id="配置高可用（HA）"><a href="#配置高可用（HA）" class="headerlink" title="配置高可用（HA）"></a>配置高可用（HA）</h3><p>所谓的高可用是因为当前集群中的 Master 节点只有一个，所以会存在单点故障问题。所以为了解决单点故障问题，需要在集群中配置多个 Master 节点，一旦处于活动状态的 Master发生故障时，由备用 Master 提供服务，保证作业可以继续执行。这里的高可用一般采用Zookeeper 设置</p>
<p><strong>集群规划</strong>:</p>
<table>
<thead>
<tr>
<th></th>
<th>Linux1</th>
<th>Linux2</th>
<th>Linux3</th>
</tr>
</thead>
<tbody><tr>
<td>Spark</td>
<td>Master<br />Zookeeper<br />Worker</td>
<td>Master<br />Zookeeper<br />Worker</td>
<td>Zookeeper<br />Worker</td>
</tr>
</tbody></table>
<ol>
<li><p>停止集群</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbin/stop-all.sh</span><br></pre></td></tr></table></figure></li>
<li><p>启动 Zookeeper</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xstart zk</span><br></pre></td></tr></table></figure></li>
<li><p>修改 spark-env.sh 文件添加如下配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">注释如下内容：</span><br><span class="line">#SPARK_MASTER_HOST=linux1</span><br><span class="line">#SPARK_MASTER_PORT=7077</span><br><span class="line">添加如下内容:</span><br><span class="line">#Master 监控页面默认访问端口为 8080，但是可能会和 Zookeeper 冲突，所以改成 8989，也可以自</span><br><span class="line">定义，访问 UI 监控页面时请注意</span><br><span class="line">SPARK_MASTER_WEBUI_PORT=8989</span><br><span class="line">export SPARK_DAEMON_JAVA_OPTS=&quot;</span><br><span class="line">-Dspark.deploy.recoveryMode=ZOOKEEPER </span><br><span class="line">-Dspark.deploy.zookeeper.url=linux1,linux2,linux3</span><br><span class="line">-Dspark.deploy.zookeeper.dir=/spark&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>分发配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xsync conf/</span><br></pre></td></tr></table></figure></li>
<li><p>启动集群</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-all.sh</span><br></pre></td></tr></table></figure></li>
<li><p>启动 linux2 的单独 Master 节点，此时 linux2 节点 Master 状态处于备用状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linux2 spark-standalone]# sbin/start-master.sh</span><br></pre></td></tr></table></figure></li>
<li><p>提交应用到高可用集群</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master spark://linux1:7077,linux2:7077 \</span><br><span class="line">./examples/jars/spark-examples_2.12-3.0.0.jar \</span><br><span class="line">10</span><br></pre></td></tr></table></figure></li>
<li><p>停止 linux1 的 Master 资源监控进程</p>
</li>
<li><p>查看 linux2 的 Master 资源监控 Web UI，稍等一段时间后，linux2 节点的 Master 状态提升为活动状态</p>
</li>
</ol>
<h2 id="Yarn-模式"><a href="#Yarn-模式" class="headerlink" title="Yarn 模式"></a>Yarn 模式</h2><p>独立部署（Standalone）模式由 Spark 自身提供计算资源，无需其他框架提供资源。这种方式降低了和其他第三方资源框架的耦合性，独立性非常强。但是你也要记住，Spark 主要是计算框架，而不是资源调度框架，所以本身提供的资源调度并不是它的强项，所以还是和其他专业的资源调度框架集成会更靠谱一些。所以接下来我们来学习在强大的 Yarn 环境下 Spark 是如何工作的（其实是因为在国内工作中，Yarn 使用的非常多）。</p>
<h3 id="解压缩文件-2"><a href="#解压缩文件-2" class="headerlink" title="解压缩文件"></a>解压缩文件</h3><p>将 spark-3.0.0-bin-hadoop3.2.tgz 文件上传到 linux 并解压缩，放置在指定位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf spark-3.0.0-bin-hadoop3.2.tgz -C /opt/module</span><br><span class="line">cd /opt/module </span><br><span class="line">mv spark-3.0.0-bin-hadoop3.2 spark-yarn</span><br></pre></td></tr></table></figure>

<h3 id="修改配置文件-1"><a href="#修改配置文件-1" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><ol>
<li><p>修改 hadoop 配置文件/opt/module/hadoop/etc/hadoop/yarn-site.xml, 并分发</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--是否启动一个线程检查每个任务正使用的物理内存量，如果任务超出分配值，则直接将其杀掉，默认是 true --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line"> &lt;name&gt;yarn.nodemanager.pmem-check-enabled&lt;/name&gt;</span><br><span class="line"> &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!--是否启动一个线程检查每个任务正使用的虚拟内存量，如果任务超出分配值，则直接将其杀掉，默认是 true --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line"> &lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt;</span><br><span class="line"> &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>修改 conf/spark-env.sh，添加 JAVA_HOME 和 YARN_CONF_DIR 配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mv spark-env.sh.template spark-env.sh</span><br><span class="line">...</span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_144</span><br><span class="line">YARN_CONF_DIR=/opt/module/hadoop/etc/hadoop</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="启动-HDFS-以及-YARN-集群"><a href="#启动-HDFS-以及-YARN-集群" class="headerlink" title="启动 HDFS 以及 YARN 集群"></a><strong>启动 HDFS 以及 YARN 集群</strong></h3><h3 id="提交应用-2"><a href="#提交应用-2" class="headerlink" title="提交应用"></a>提交应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master yarn \</span><br><span class="line">--deploy-mode cluster \</span><br><span class="line">./examples/jars/spark-examples_2.12-3.0.0.jar \</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>查看 <a target="_blank" rel="noopener" href="http://linux2:8088/">http://linux2:8088</a> 页面，点击 History，查看历史页面</p>
<h3 id="配置历史服务器"><a href="#配置历史服务器" class="headerlink" title="配置历史服务器"></a>配置历史服务器</h3><ol>
<li><p>修改 spark-defaults.conf.template 文件名为 spark-defaults.conf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv spark-defaults.conf.template spark-defaults.conf</span><br></pre></td></tr></table></figure></li>
<li><p>修改 spark-default.conf 文件，配置日志存储路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spark.eventLog.enabled true</span><br><span class="line">spark.eventLog.dir hdfs://linux1:8020/directory</span><br></pre></td></tr></table></figure>

<p>注意：需要启动 hadoop 集群，HDFS 上的目录需要提前存在。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linux1 hadoop]# sbin/start-dfs.sh</span><br><span class="line">[root@linux1 hadoop]# hadoop fs -mkdir /directory</span><br></pre></td></tr></table></figure></li>
<li><p>修改 spark-env.sh 文件, 添加日志配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_HISTORY_OPTS=&quot;</span><br><span class="line">-Dspark.history.ui.port=18080 </span><br><span class="line">-Dspark.history.fs.logDirectory=hdfs://linux1:8020/directory </span><br><span class="line">-Dspark.history.retainedApplications=30&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数 1 含义：WEB UI 访问的端口号为 18080</p>
</li>
<li><p>参数 2 含义：指定历史服务器日志存储路径</p>
</li>
<li><p>参数 3 含义：指定保存 Application 历史记录的个数，如果超过这个值，旧的应用程序信息将被删除，这个是内存中的应用数，而不是页面上显示的应用数。</p>
</li>
</ul>
</li>
<li><p>修改 spark-defaults.conf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spark.yarn.historyServer.address=linux1:18080</span><br><span class="line">spark.history.ui.port=18080</span><br></pre></td></tr></table></figure></li>
<li><p>启动历史服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-history-server.sh</span><br></pre></td></tr></table></figure></li>
<li><p>重新提交应用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master yarn \</span><br><span class="line">--deploy-mode client \</span><br><span class="line">./examples/jars/spark-examples_2.12-3.0.0.jar \</span><br><span class="line">10</span><br></pre></td></tr></table></figure></li>
<li><p>Web 页面查看日志：<a target="_blank" rel="noopener" href="http://linux2:8088/">http://linux2:8088</a></p>
</li>
</ol>
<h2 id="K8S-amp-Mesos-模式"><a href="#K8S-amp-Mesos-模式" class="headerlink" title="K8S &amp; Mesos 模式"></a>K8S &amp; Mesos 模式</h2><p>Mesos 是 Apache 下的开源分布式资源管理框架，它被称为是分布式系统的内核,在Twitter 得到广泛使用,管理着 Twitter 超过 30,0000 台服务器上的应用部署，但是在国内，依然使用着传统的 Hadoop 大数据框架，所以国内使用 Mesos 框架的并不多，但是原理其实都差不多，这里我们就不做过多讲解了。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111081717358.png/lvxiaoyi" style="zoom:50%;" />

<p>容器化部署是目前业界很流行的一项技术，基于 Docker 镜像运行能够让用户更加方便地对应用进行管理和运维。容器管理工具中最为流行的就是 Kubernetes（k8s），而 Spark也在最近的版本中支持了 k8s 部署模式。这里我们也不做过多的讲解。给个链接大家自己感受一下：<a target="_blank" rel="noopener" href="https://spark.apache.org/docs/latest/running-on-kubernetes.html">https://spark.apache.org/docs/latest/running-on-kubernetes.html</a></p>
<h2 id="Windows-模式"><a href="#Windows-模式" class="headerlink" title="Windows 模式"></a>Windows 模式</h2><p>在同学们自己学习时，每次都需要启动虚拟机，启动集群，这是一个比较繁琐的过程，并且会占大量的系统资源，导致系统执行变慢，不仅仅影响学习效果，也影响学习进度，Spark 非常暖心地提供了可以在 windows 系统下启动本地集群的方式，这样，在不使用虚拟机的情况下，也能学习 Spark 的基本使用</p>
<p>在后续的教学中，为了能够给同学们更加流畅的教学效果和教学体验，我们一般情况下都会采用 windows 系统的集群来学习 Spark。</p>
<h3 id="解压缩文件-3"><a href="#解压缩文件-3" class="headerlink" title="解压缩文件"></a>解压缩文件</h3><p>将文件 spark-3.0.0-bin-hadoop3.2.tgz 解压缩到无中文无空格的路径中</p>
<h3 id="启动本地环境"><a href="#启动本地环境" class="headerlink" title="启动本地环境"></a>启动本地环境</h3><ol>
<li>执行解压缩文件路径下 bin 目录中的 spark-shell.cmd 文件，启动 Spark 本地环境</li>
<li>在 bin 目录中创建 input 目录，并添加 word.txt 文件, 在命令行中输入脚本代码</li>
</ol>
<h3 id="命令行提交应用"><a href="#命令行提交应用" class="headerlink" title="命令行提交应用"></a>命令行提交应用</h3><p>在 DOS 命令行窗口中执行提交指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spark-submit --class org.apache.spark.examples.SparkPi --master </span><br><span class="line">local[2] ../examples/jars/spark-examples_2.12-3.0.0.jar 10</span><br></pre></td></tr></table></figure>

<h2 id="部署模式对比"><a href="#部署模式对比" class="headerlink" title="部署模式对比"></a>部署模式对比</h2><table>
<thead>
<tr>
<th>模式</th>
<th>Spark 安装机器数</th>
<th>需启动的进程</th>
<th>所属者</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Local</td>
<td>1</td>
<td>无</td>
<td>Spark</td>
<td>测试</td>
</tr>
<tr>
<td>Standalone</td>
<td>3</td>
<td>Master 及 Worker</td>
<td>Spark</td>
<td>单独部署</td>
</tr>
<tr>
<td>Yarn</td>
<td>1</td>
<td>Yarn 及 HDFS</td>
<td>Hadoop</td>
<td>混合部署</td>
</tr>
</tbody></table>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><ul>
<li><p>Spark 查看当前 Spark-shell 运行任务情况端口号：4040（计算） </p>
</li>
<li><p>Spark Master 内部通信服务端口号：7077</p>
</li>
<li><p>Standalone 模式下，Spark Master Web 端口号：8080（资源）</p>
</li>
<li><p>Spark 历史服务器端口号：18080</p>
</li>
<li><p>Hadoop YARN 任务运行情况查看端口号：8088</p>
</li>
</ul>
<h1 id="Spark-运行架构"><a href="#Spark-运行架构" class="headerlink" title="Spark 运行架构"></a>Spark 运行架构</h1><h2 id="运行架构"><a href="#运行架构" class="headerlink" title="运行架构"></a>运行架构</h2><p>Spark 框架的核心是一个计算引擎，整体来说，它采用了标准 master-slave 的结构。 </p>
<p>如下图所示，它展示了一个 Spark 执行时的基本结构。图形中的 Driver 表示 master，负责管理整个集群中的作业任务调度。图形中的 Executor 则是 slave，负责实际执行任务。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111081724579.png/lvxiaoyi" alt="image-20211108172446353" style="zoom: 33%;" />

<h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p>由上图可以看出，对于 Spark 框架有两个核心组件：</p>
<h3 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h3><p>Spark 驱动器节点，用于执行 Spark 任务中的 main 方法，负责实际代码的执行工作。Driver 在 Spark 作业执行时主要负责：</p>
<ul>
<li><p>将用户程序转化为作业（job） </p>
</li>
<li><p>在 Executor 之间调度任务(task)</p>
</li>
<li><p>跟踪 Executor 的执行情况</p>
</li>
<li><p>通过 UI 展示查询运行情况</p>
</li>
</ul>
<p>实际上，我们无法准确地描述 Driver 的定义，因为在整个的编程过程中没有看到任何有关Driver 的字眼。所以简单理解，所谓的 Driver 就是驱使整个应用运行起来的程序，也称之为Driver 类</p>
<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>Spark Executor 是集群中工作节点（Worker）中的一个 JVM 进程，负责在 Spark 作业中运行具体任务（Task），任务彼此之间相互独立。Spark 应用启动时，Executor 节点被同时启动，并且始终伴随着整个 Spark 应用的生命周期而存在。如果有 Executor 节点发生了故障或崩溃，Spark 应用也可以继续执行，会将出错节点上的任务调度到其他 Executor 节点上继续运行。</p>
<p>Executor 有两个核心功能：</p>
<ul>
<li><p>负责运行组成 Spark 应用的任务，并将结果返回给驱动器进程</p>
</li>
<li><p>它们通过自身的块管理器（Block Manager）为用户程序中要求缓存的 RDD 提供内存式存储。RDD 是直接缓存在 Executor 进程内的，因此任务可以在运行时充分利用缓存数据加速运算。</p>
</li>
</ul>
<h3 id="Master-amp-Worker"><a href="#Master-amp-Worker" class="headerlink" title="Master &amp; Worker"></a>Master &amp; Worker</h3><p>Spark 集群的独立部署环境中，不需要依赖其他的资源调度框架，自身就实现了资源调度的功能，所以环境中还有其他两个核心组件：Master 和 Worker，这里的 Master 是一个进程，主要负责资源的调度和分配，并进行集群的监控等职责，类似于 Yarn 环境中的 RM, 而Worker 呢，也是进程，一个 Worker 运行在集群中的一台服务器上，由 Master 分配资源对数据进行并行的处理和计算，类似于 Yarn 环境中 NM。 </p>
<h3 id="ApplicationMaster"><a href="#ApplicationMaster" class="headerlink" title="ApplicationMaster"></a>ApplicationMaster</h3><p>Hadoop 用户向 YARN 集群提交应用程序时,提交程序中应该包含 ApplicationMaster，用于向资源调度器申请执行任务的资源容器 Container，运行用户自己的程序任务 job，监控整个任务的执行，跟踪整个任务的状态，处理任务失败等异常情况。</p>
<p>说的简单点就是，ResourceManager（资源）和 Driver（计算）之间的解耦合靠的就是ApplicationMaster。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="Executor-与-Core"><a href="#Executor-与-Core" class="headerlink" title="Executor 与 Core"></a>Executor 与 Core</h3><p>Spark Executor 是集群中运行在工作节点（Worker）中的一个 JVM 进程，是整个集群中的专门用于计算的节点。在提交应用中，可以提供参数指定计算节点的个数，以及对应的资源。这里的资源一般指的是工作节点 Executor 的内存大小和使用的虚拟 CPU 核（Core）数量。</p>
<p>应用程序相关启动参数如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>–num-executors</td>
<td>配置 Executor 的数量</td>
</tr>
<tr>
<td>–executor-memory</td>
<td>配置每个 Executor 的内存大小</td>
</tr>
<tr>
<td>–executor-cores</td>
<td>配置每个 Executor 的虚拟 CPU core 数量</td>
</tr>
</tbody></table>
<h3 id="并行度（Parallelism）"><a href="#并行度（Parallelism）" class="headerlink" title="并行度（Parallelism）"></a>并行度（Parallelism）</h3><p>在分布式计算框架中一般都是多个任务同时执行，由于任务分布在不同的计算节点进行计算，所以能够真正地实现多任务并行执行，记住，这里是并行，而不是并发。这里我们将整个集群并行执行任务的数量称之为并行度。那么一个作业到底并行度是多少呢？这个取决于框架的默认配置。应用程序也可以在运行过程中动态修改。</p>
<h3 id="有向无环图（DAG）"><a href="#有向无环图（DAG）" class="headerlink" title="有向无环图（DAG）"></a>有向无环图（DAG）</h3><p>大数据计算引擎框架我们根据使用方式的不同一般会分为四类，其中第一类就是Hadoop 所承载的 MapReduce,它将计算分为两个阶段，分别为 Map 阶段 和 Reduce 阶段。对于上层应用来说，就不得不想方设法去拆分算法，甚至于不得不在上层应用实现多个 Job 的串联，以完成一个完整的算法，例如迭代计算。 由于这样的弊端，催生了支持 DAG 框架的产生。因此，支持 DAG 的框架被划分为第二代计算引擎。如 Tez 以及更上层的Oozie。这里我们不去细究各种 DAG 实现之间的区别，不过对于当时的 Tez 和 Oozie 来说，大多还是批处理的任务。接下来就是以 Spark 为代表的第三代的计算引擎。第三代计算引擎的特点主要是 Job 内部的 DAG 支持（不跨越 Job），以及实时计算。</p>
<p>这里所谓的有向无环图，并不是真正意义的图形，而是由 Spark 程序直接映射成的数据流的高级抽象模型。简单理解就是将整个程序计算的执行过程用图形表示出来,这样更直观，更便于理解，可以用于表示程序的拓扑结构。</p>
<p>DAG（Directed Acyclic Graph）有向无环图是由点和线组成的拓扑图形，该图形具有方向，不会闭环。</p>
<h2 id="提交流程"><a href="#提交流程" class="headerlink" title="提交流程"></a>提交流程</h2><p>所谓的提交流程，其实就是我们开发人员根据需求写的应用程序通过 Spark 客户端提交给 Spark 运行环境执行计算的流程。在不同的部署环境中，这个提交过程基本相同，但是又有细微的区别，我们这里不进行详细的比较，但是因为国内工作中，将 Spark 引用部署到Yarn 环境中会更多一些，所以本课程中的提交流程是基于 Yarn 环境的。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111081732926.png/lvxiaoyi" alt="dag" style="zoom:50%;" />

<p>Spark 应用程序提交到 Yarn 环境中执行的时候，一般会有两种部署执行的方式：Client 和 Cluster。两种模式主要区别在于：Driver 程序的运行节点位置。</p>
<h3 id="4-2-1Yarn-Client-模式"><a href="#4-2-1Yarn-Client-模式" class="headerlink" title="4.2.1Yarn Client 模式"></a>4.2.1Yarn Client 模式</h3><p>Client 模式将用于监控和调度的Driver 模块在客户端执行，而不是在 Yarn 中，所以一般用于测试。</p>
<ul>
<li><p>Driver 在任务提交的本地机器上运行</p>
</li>
<li><p>Driver 启动后会和ResourceManager 通讯申请启动ApplicationMaster</p>
</li>
<li><p>ResourceManager 分配 container，在合适的NodeManager 上启动ApplicationMaster，负责向ResourceManager 申请 Executor 内存</p>
</li>
<li><p>ResourceManager 接到 ApplicationMaster 的资源申请后会分配 container，然后ApplicationMaster 在资源分配指定的NodeManager 上启动 Executor 进程</p>
</li>
<li><p>Executor 进程启动后会向Driver 反向注册，Executor 全部注册完成后Driver 开始执行main 函数</p>
</li>
<li><p>之后执行到 Action 算子时，触发一个 Job，并根据宽依赖开始划分 stage，每个stage 生成对应的TaskSet，之后将 task 分发到各个Executor 上执行。</p>
</li>
</ul>
<h3 id="Yarn-Cluster-模式"><a href="#Yarn-Cluster-模式" class="headerlink" title="Yarn Cluster 模式"></a>Yarn Cluster 模式</h3><p>Cluster 模式将用于监控和调度的 Driver 模块启动在Yarn 集群资源中执行。一般应用于实际生产环境。</p>
<ul>
<li><p>在 YARN Cluster 模式下，任务提交后会和ResourceManager 通讯申请启动ApplicationMaster，</p>
</li>
<li><p>随后ResourceManager 分配 container，在合适的 NodeManager 上启动 ApplicationMaster，此时的 ApplicationMaster 就是Driver。</p>
</li>
<li><p>Driver 启动后向 ResourceManager 申请Executor 内存，ResourceManager 接到ApplicationMaster 的资源申请后会分配container，然后在合适的NodeManager 上启动Executor 进程</p>
</li>
<li><p>Executor 进程启动后会向Driver 反向注册，Executor 全部注册完成后Driver 开始执行main 函数，</p>
</li>
<li><p>之后执行到 Action 算子时，触发一个 Job，并根据宽依赖开始划分 stage，每个stage 生成对应的TaskSet，之后将 task 分发到各个Executor 上执行。</p>
</li>
</ul>
<h1 id="Spark-核心编程"><a href="#Spark-核心编程" class="headerlink" title="Spark 核心编程"></a>Spark 核心编程</h1><p>Spark 计算框架为了能够进行高并发和高吞吐的数据处理，封装了三大数据结构，用于处理不同的应用场景。三大数据结构分别是：</p>
<ul>
<li><p> RDD : 弹性分布式数据集</p>
</li>
<li><p> 累加器：分布式共享只写变量</p>
</li>
<li><p> 广播变量：分布式共享只读变量</p>
</li>
</ul>
<p>接下来我们一起看看这三大数据结构是如何在数据处理中使用的。</p>
<h2 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h2><h3 id="什么是-RDD"><a href="#什么是-RDD" class="headerlink" title="什么是 RDD"></a>什么是 RDD</h3><p>RDD（Resilient Distributed Dataset）叫做弹性分布式数据集，是 Spark 中最基本的数据处理模型。代码中是一个抽象类，它代表一个弹性的、不可变、可分区、里面的元素可并行计算的集合。</p>
<ul>
<li><p>弹性</p>
<ul>
<li>存储的弹性：内存与磁盘的自动切换；</li>
<li>容错的弹性：数据丢失可以自动恢复；</li>
<li>计算的弹性：计算出错重试机制；</li>
<li>分片的弹性：可根据需要重新分片。</li>
</ul>
</li>
<li><p>分布式：数据存储在大数据集群不同节点上</p>
</li>
<li><p>数据集：RDD 封装了计算逻辑，并不保存数据</p>
</li>
<li><p>数据抽象：RDD 是一个抽象类，需要子类具体实现</p>
</li>
<li><p>不可变：RDD 封装了计算逻辑，是不可以改变的，想要改变，只能产生新的 RDD，在新的 RDD 里面封装计算逻辑</p>
</li>
<li><p>可分区、并行计算</p>
</li>
</ul>
<h3 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h3><ul>
<li><p>分区列表</p>
<p>RDD 数据结构中存在分区列表，用于执行任务时并行计算，是实现分布式计算的重要属性。</p>
</li>
<li><p>分区计算函数</p>
<p>Spark 在计算时，是使用分区函数对每一个分区进行计算</p>
</li>
<li><p>RDD 之间的依赖关系</p>
<p>RDD 是计算模型的封装，当需求中需要将多个计算模型进行组合时，就需要将多个 RDD 建立依赖关系</p>
</li>
<li><p>分区器（可选）</p>
<p>当数据为 KV 类型数据时，可以通过设定分区器自定义数据的分区</p>
</li>
<li><p>首选位置（可选）</p>
<p>计算数据时，可以根据计算节点的状态选择不同的节点位置进行计算</p>
</li>
</ul>
<h3 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h3><p>从计算的角度来讲，数据处理过程中需要计算资源（内存 &amp; CPU）和计算模型（逻辑）。执行时，需要将计算资源和计算模型进行协调和整合。</p>
<p>Spark 框架在执行时，先申请资源，然后将应用程序的数据处理逻辑分解成一个一个的计算任务。然后将任务发到已经分配资源的计算节点上, 按照指定的计算模型进行数据计算。最后得到计算结果。</p>
<p>RDD 是 Spark 框架中用于数据处理的核心模型，接下来我们看看，在 Yarn 环境中，RDD的工作原理:</p>
<ol>
<li><p>启动 Yarn 集群环境</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111081743690.png/lvxiaoyi" alt="图片1" style="zoom: 50%;" /></li>
<li><p>Spark 通过申请资源创建调度节点和计算节点</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111081743259.png/lvxiaoyi" alt="图片2" style="zoom:50%;" /></li>
<li><p>Spark 框架根据需求将计算逻辑根据分区划分成不同的任务</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111081743493.png/lvxiaoyi" alt="图片3" style="zoom: 67%;" /></li>
<li><p>调度节点将任务根据计算节点状态发送到对应的计算节点进行计算</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111081743739.png/lvxiaoyi" alt="图片4" style="zoom: 67%;" /></li>
</ol>
<p>从以上流程可以看出 RDD 在整个流程中主要用于将逻辑进行封装，并生成 Task 发送给Executor 节点执行计算，接下来我们就一起看看 Spark 框架中 RDD 是具体是如何进行数据处理的。</p>
<h3 id="基础编程"><a href="#基础编程" class="headerlink" title="基础编程"></a>基础编程</h3><h4 id="RDD-创建"><a href="#RDD-创建" class="headerlink" title="RDD 创建"></a>RDD 创建</h4><p>在 Spark 中创建 RDD 的创建方式可以分为四种：</p>
<h5 id="从集合（内存）中创建-RDD"><a href="#从集合（内存）中创建-RDD" class="headerlink" title="从集合（内存）中创建 RDD"></a>从集合（内存）中创建 RDD</h5><p>从集合中创建 RDD，Spark 主要提供了两个方法：parallelize 和 makeRDD</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">val sparkConf =</span><br><span class="line"> new SparkConf().setMaster(&quot;local[*]&quot;).setAppName(&quot;spark&quot;)</span><br><span class="line">val sparkContext = new SparkContext(sparkConf)</span><br><span class="line">val rdd1 = sparkContext.parallelize(</span><br><span class="line"> List(1,2,3,4)</span><br><span class="line">)</span><br><span class="line">val rdd2 = sparkContext.makeRDD(</span><br><span class="line"> List(1,2,3,4)</span><br><span class="line">)</span><br><span class="line">rdd1.collect().foreach(println)</span><br><span class="line">rdd2.collect().foreach(println)</span><br><span class="line">sparkContext.stop()</span><br></pre></td></tr></table></figure>

<p>从底层代码实现来讲，makeRDD 方法其实就是 parallelize 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def makeRDD[T: ClassTag](</span><br><span class="line"> seq: Seq[T],</span><br><span class="line"> numSlices: Int = defaultParallelism): RDD[T] = withScope &#123;</span><br><span class="line"> parallelize(seq, numSlices)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="从外部存储（文件）创建-RDD"><a href="#从外部存储（文件）创建-RDD" class="headerlink" title="从外部存储（文件）创建 RDD"></a>从外部存储（文件）创建 RDD</h5><p>由外部存储系统的数据集创建 RDD 包括：本地的文件系统，所有 Hadoop 支持的数据集，比如 HDFS、HBase 等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val sparkConf =</span><br><span class="line"> new SparkConf().setMaster(&quot;local[*]&quot;).setAppName(&quot;spark&quot;)</span><br><span class="line">val sparkContext = new SparkContext(sparkConf)</span><br><span class="line">val fileRDD: RDD[String] = sparkContext.textFile(&quot;input&quot;)</span><br><span class="line">fileRDD.collect().foreach(println)</span><br><span class="line">sparkContext.stop()</span><br></pre></td></tr></table></figure>

<h5 id="从其他-RDD-创建"><a href="#从其他-RDD-创建" class="headerlink" title="从其他 RDD 创建"></a>从其他 RDD 创建</h5><p>主要是通过一个 RDD 运算完后，再产生新的 RDD。详情请参考后续章节</p>
<h5 id="直接创建-RDD（new）"><a href="#直接创建-RDD（new）" class="headerlink" title="直接创建 RDD（new）"></a>直接创建 RDD（new）</h5><p>使用 new 的方式直接构造 RDD，一般由 Spark 框架自身使用。</p>
<h4 id="RDD-并行度与分区"><a href="#RDD-并行度与分区" class="headerlink" title="RDD 并行度与分区"></a>RDD 并行度与分区</h4><p>默认情况下，Spark 可以将一个作业切分多个任务后，发送给 Executor 节点并行计算，而能 够并行计算的任务数量我们称之为并行度。这个数量可以在构建 RDD 时指定。记住，这里的并行执行的任务数量，并不是指的切分任务的数量，不要混淆了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val sparkConf =</span><br><span class="line"> new SparkConf().setMaster(&quot;local[*]&quot;).setAppName(&quot;spark&quot;)</span><br><span class="line">val sparkContext = new SparkContext(sparkConf)</span><br><span class="line">val dataRDD: RDD[Int] =</span><br><span class="line"> sparkContext.makeRDD(</span><br><span class="line"> List(1,2,3,4),</span><br><span class="line"> 4)</span><br><span class="line">val fileRDD: RDD[String] =</span><br><span class="line"> sparkContext.textFile(</span><br><span class="line"> &quot;input&quot;,</span><br><span class="line"> 2)</span><br><span class="line">fileRDD.collect().foreach(println)</span><br><span class="line">sparkContext.stop()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>读取内存数据时，数据可以按照并行度的设定进行数据的分区操作，数据分区规则的</p>
<p>Spark 核心源码如下：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def positions(length: Long, numSlices: Int): Iterator[(Int, Int)] = &#123;</span><br><span class="line"> (0 until numSlices).iterator.map &#123; i =&gt;</span><br><span class="line"> val start = ((i * length) / numSlices).toInt</span><br><span class="line"> val end = (((i + 1) * length) / numSlices).toInt</span><br><span class="line"> (start, end)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>读取文件数据时，数据是按照 Hadoop 文件读取的规则进行切片分区，而切片规则和数据读取的规则有些差异，具体 Spark 核心源码如下</p>
<p>分区内容是按照字节来计算的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public InputSplit[] getSplits(JobConf job, int numSplits)</span><br><span class="line"> throws IOException &#123;</span><br><span class="line"> long totalSize = 0; // compute total size</span><br><span class="line"> for (FileStatus file: files) &#123; // check we have valid files</span><br><span class="line"> if (file.isDirectory()) &#123;</span><br><span class="line"> throw new IOException(&quot;Not a file: &quot;+ file.getPath());</span><br><span class="line"> &#125;</span><br><span class="line"> totalSize += file.getLen();</span><br><span class="line"> &#125;</span><br><span class="line"> long goalSize = totalSize / (numSplits == 0 ? 1 : numSplits);</span><br><span class="line"> long minSize = Math.max(job.getLong(org.apache.hadoop.mapreduce.lib.input.</span><br><span class="line"> FileInputFormat.SPLIT_MINSIZE, 1), minSplitSize);</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line"> for (FileStatus file: files) &#123;</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line"> if (isSplitable(fs, path)) &#123;</span><br><span class="line"> long blockSize = file.getBlockSize();</span><br><span class="line"> long splitSize = computeSplitSize(goalSize, minSize, blockSize);</span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br><span class="line"> protected long computeSplitSize(long goalSize, long minSize,</span><br><span class="line"> long blockSize) &#123;</span><br><span class="line"> return Math.max(minSize, Math.min(goalSize, blockSize));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="RDD-转换算子"><a href="#RDD-转换算子" class="headerlink" title="RDD 转换算子"></a>RDD 转换算子</h4><p>RDD 根据数据处理方式的不同将算子整体上分为 Value 类型、双 Value 类型和 Key-Value类型</p>
<h5 id="Value-类型"><a href="#Value-类型" class="headerlink" title="Value 类型"></a>Value 类型</h5><ol>
<li><p>map</p>
<p>函数签名：def map[U: ClassTag](f: T =&gt; U): RDD[U] </p>
<p>函数说明：将处理的数据逐条进行映射转换，这里的转换可以是类型的转换，也可以是值的转换。</p>
<p>Map同一个分区内的线程是有序的，但是不同分区是无序的</p>
</li>
<li><p>mapPartitions</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def mapPartitions[U: ClassTag](</span><br><span class="line"> f: Iterator[T] =&gt; Iterator[U],</span><br><span class="line"> preservesPartitioning: Boolean = false): RDD[U]</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>将待处理的数据以分区为单位发送到计算节点进行处理，这里的处理是指可以进行任意的处理，哪怕是过滤数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD1: RDD[Int] = dataRDD.mapPartitions(</span><br><span class="line"> datas =&gt; &#123;</span><br><span class="line"> 	datas.filter(_==2)</span><br><span class="line"> &#125; )</span><br></pre></td></tr></table></figure>

<p>小功能：获取每个数据分区的最大值</p>
<p>map 和 mapPartitions 的区别</p>
<ul>
<li><p>数据处理角度</p>
<p>Map 算子是分区内一个数据一个数据的执行，类似于串行操作。而 <strong>mapPartitions 算子是以分区为单位进行批处理操作</strong>。</p>
</li>
<li><p>功能的角度</p>
<p>Map 算子主要目的将数据源中的数据进行转换和改变。但是不会减少或增多数据。MapPartitions 算子需要传递一个迭代器，返回一个迭代器，没有要求的元素的个数保持不变，所以可以增加或减少数据</p>
</li>
<li><p>性能的角度</p>
<p>Map 算子因为类似于串行操作，所以性能比较低，而是 mapPartitions 算子类似于批处理，所以性能较高。但是 mapPartitions 算子会长时间占用内存，那么这样会导致内存可能不够用，出现内存溢出的错误。所以在内存有限的情况下，不推荐使用。使用 map 操作。</p>
</li>
</ul>
</li>
<li><p>mapPartitionsWithIndex</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def mapPartitionsWithIndex[U: ClassTag](</span><br><span class="line"> f: (Int, Iterator[T]) =&gt; Iterator[U],</span><br><span class="line"> preservesPartitioning: Boolean = false): RDD[U]</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>将待处理的数据以分区为单位发送到计算节点进行处理，这里的处理是指可以进行任意的处理，哪怕是过滤数据，在处理时同时可以获取当前分区索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD1 = dataRDD.mapPartitionsWithIndex(</span><br><span class="line"> (index, datas) =&gt; &#123;</span><br><span class="line"> datas.map(index, _)</span><br><span class="line"> &#125; )</span><br></pre></td></tr></table></figure>

<p>小功能：获取第二个数据分区的数据</p>
</li>
<li><p>flatMap</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def flatMap[U: ClassTag](f: T =&gt; TraversableOnce[U]): RDD[U]</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>将处理的数据进行扁平化后再进行映射处理，所以算子也称之为扁平映射</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD = sparkContext.makeRDD(List(</span><br><span class="line"> List(1,2),List(3,4)</span><br><span class="line">),1)</span><br><span class="line">val dataRDD1 = dataRDD.flatMap(</span><br><span class="line"> list =&gt; list</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>小功能：将 List(List(1,2),3,List(4,5))进行扁平化操作</p>
</li>
<li><p>glom</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def glom(): RDD[Array[T]]</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>将同一个分区的数据直接转换为相同类型的内存数组进行处理，分区不变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD = sparkContext.makeRDD(List(</span><br><span class="line"> 1,2,3,4</span><br><span class="line">),1)</span><br><span class="line">val dataRDD1:RDD[Array[Int]] = dataRDD.glom()</span><br></pre></td></tr></table></figure>

<p>小功能：计算所有分区最大值求和（分区内取最大值，分区间最大值求和）</p>
</li>
<li><p>groupBy</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def groupBy[K](f: T =&gt; K)(implicit kt: ClassTag[K]): RDD[(K, Iterable[T])]</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>将数据根据指定的规则进行分组, 分区默认不变，但是数据会被打乱重新组合，我们将这样的操作称之为 shuffle。极限情况下，数据可能被分在同一个分区中一个组的数据在一个分区中，但是并不是说一个分区中只有一个组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD = sparkContext.makeRDD(List(1,2,3,4),1)</span><br><span class="line">val dataRDD1 = dataRDD.groupBy(</span><br><span class="line"> _%2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>小功能：将 List(“Hello”, “hive”, “hbase”, “Hadoop”)根据单词首写字母进行分组。</li>
<li>小功能：从服务器日志数据 apache.log 中获取每个时间段访问量。</li>
<li>小功能：WordCount。</li>
</ul>
</li>
<li><p>filter</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def filter(f: T =&gt; Boolean): RDD[T]</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>将数据根据指定的规则进行筛选过滤，符合规则的数据保留，不符合规则的数据丢弃。当数据进行筛选过滤后，分区不变，但是分区内的数据可能不均衡，生产环境下，可能会出现数据倾斜</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD = sparkContext.makeRDD(List(</span><br><span class="line"> 1,2,3,4</span><br><span class="line">),1)</span><br><span class="line">val dataRDD1 = dataRDD.filter(_%2 == 0)</span><br></pre></td></tr></table></figure>

<p>小功能：从服务器日志数据 apache.log 中获取 2015 年 5 月 17 日的请求路径</p>
</li>
<li><p>sample</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def sample(</span><br><span class="line"> withReplacement: Boolean,</span><br><span class="line"> fraction: Double,</span><br><span class="line"> seed: Long = Utils.random.nextLong): RDD[T]</span><br></pre></td></tr></table></figure>

<p>函数说明</p>
<p>根据指定的规则从数据集中抽取数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD = sparkContext.makeRDD(List(</span><br><span class="line"> 1,2,3,4</span><br><span class="line">),1)</span><br><span class="line">// 抽取数据不放回（伯努利算法）</span><br><span class="line">// 伯努利算法：又叫 0、1 分布。例如扔硬币，要么正面，要么反面。</span><br><span class="line">// 具体实现：根据种子和随机算法算出一个数和第二个参数设置几率比较，小于第二个参数要，大于不</span><br><span class="line">要</span><br><span class="line">// 第一个参数：抽取的数据是否放回，false：不放回</span><br><span class="line">// 第二个参数：抽取的几率，范围在[0,1]之间,0：全不取；1：全取；</span><br><span class="line">// 第三个参数：随机数种子，默认是当前系统的时间</span><br><span class="line">val dataRDD1 = dataRDD.sample(false, 0.5)</span><br><span class="line">// 抽取数据放回（泊松算法）</span><br><span class="line">// 第一个参数：抽取的数据是否放回，true：放回；false：不放回</span><br><span class="line">// 第二个参数：重复数据的几率，范围大于等于 0.表示每一个元素被期望抽取到的次数</span><br><span class="line">// 第三个参数：随机数种子</span><br><span class="line">val dataRDD2 = dataRDD.sample(true, 2)</span><br></pre></td></tr></table></figure>

<p>在数据倾斜（shuffle）的时候，使用这种</p>
</li>
<li><p>distinct</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def distinct()(implicit ord: Ordering[T] = null): RDD[T]</span><br><span class="line">def distinct(numPartitions: Int)(implicit ord: Ordering[T] = null): RDD[T]</span><br></pre></td></tr></table></figure>

<p>函数说明</p>
<p>将数据集中重复的数据去重</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD = sparkContext.makeRDD(List(</span><br><span class="line"> 1,2,3,4,1,2</span><br><span class="line">),1)</span><br><span class="line">val dataRDD1 = dataRDD.distinct()</span><br><span class="line">val dataRDD2 = dataRDD.distinct(2)</span><br></pre></td></tr></table></figure>

<p>如果不用该算子，你有什么办法实现数据去重？</p>
</li>
<li><p>coalesce</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def coalesce(numPartitions: Int, shuffle: Boolean = false,</span><br><span class="line"> partitionCoalescer: Option[PartitionCoalescer] = Option.empty)</span><br><span class="line"> (implicit ord: Ordering[T] = null)</span><br><span class="line"> : RDD[T]</span><br></pre></td></tr></table></figure>

<p>函数说明</p>
<p>根据数据量缩减分区，用于大数据集过滤后，提高小数据集的执行效率当 spark 程序中，存在过多的小任务的时候，可以通过 coalesce 方法，收缩合并分区，减少分区的个数，减小任务调度成本</p>
<p>这种情况下的缩减分区有可能导致数据不均衡，我们可以使用shuffle来让数据重新组合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD = sparkContext.makeRDD(List(</span><br><span class="line"> 1,2,3,4,1,2</span><br><span class="line">),6)</span><br><span class="line">// 第二个参数为boolean，可以选择是否shuffle</span><br><span class="line">val dataRDD1 = dataRDD.coalesce(2)</span><br></pre></td></tr></table></figure>

<p>我想要扩大分区，怎么办</p>
<p>需要使用shuffle操作，dataRDD.coalesce(3，true)</p>
</li>
<li><p>repartition</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def repartition(numPartitions: Int)(implicit ord: Ordering[T] = null): RDD[T]</span><br></pre></td></tr></table></figure>

<p>函数说明</p>
<p>该操作内部其实执行的是 coalesce 操作，参数 shuffle 的默认值为 true。无论是将分区数多的RDD 转换为分区数少的 RDD，还是将分区数少的 RDD 转换为分区数多的 RDD，repartition操作都可以完成，因为无论如何都会经 shuffle 过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD = sparkContext.makeRDD(List(</span><br><span class="line"> 1,2,3,4,1,2</span><br><span class="line">),2)</span><br><span class="line">val dataRDD1 = dataRDD.repartition(4)</span><br></pre></td></tr></table></figure>

<p>coalesce 和 repartition 区别？</p>
<p>总结：缩减分区使用coalesce，如果有数据倾斜使用shuffle，扩大分区使用repartition（底层还是使用的coalesce ）</p>
</li>
<li><p>sortBy</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def sortBy[K](</span><br><span class="line"> f: (T) =&gt; K,</span><br><span class="line"> ascending: Boolean = true,</span><br><span class="line"> numPartitions: Int = this.partitions.length)</span><br><span class="line"> (implicit ord: Ordering[K], ctag: ClassTag[K]): RDD[T]</span><br></pre></td></tr></table></figure>

<p>函数说明</p>
<p>该操作用于排序数据。在排序之前，可以将数据通过 f 函数进行处理，之后按照 f 函数处理的结果进行排序，默认为升序排列。排序后新产生的 RDD 的分区数与原 RDD 的分区数一致。中间存在 shuffle 的过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD = sparkContext.makeRDD(List(</span><br><span class="line"> 1,2,3,4,1,2</span><br><span class="line">),2)</span><br><span class="line">// 默认为升序，第二个参数改变分区升序规则false为降序</span><br><span class="line">val dataRDD1 = dataRDD.sortBy(num=&gt;num, false, 4)</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="双-Value-类型"><a href="#双-Value-类型" class="headerlink" title="双 Value 类型"></a>双 Value 类型</h5><ol start="13">
<li><p>intersection</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def intersection(other: RDD[T]): RDD[T]</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>对源 RDD 和参数 RDD 求交集后返回一个新的 RDD</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD1 = sparkContext.makeRDD(List(1,2,3,4))</span><br><span class="line">val dataRDD2 = sparkContext.makeRDD(List(3,4,5,6))</span><br><span class="line">val dataRDD = dataRDD1.intersection(dataRDD2)</span><br></pre></td></tr></table></figure>

<p>如果两个 RDD 数据类型不一致怎么办？</p>
<p>编译不通过</p>
</li>
<li><p>union</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def union(other: RDD[T]): RDD[T]</span><br></pre></td></tr></table></figure>

<p>对源 RDD 和参数 RDD 求并集后返回一个新的 RDD</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD1 = sparkContext.makeRDD(List(1,2,3,4))</span><br><span class="line">val dataRDD2 = sparkContext.makeRDD(List(3,4,5,6))</span><br><span class="line">val dataRDD = dataRDD1.union(dataRDD2)</span><br></pre></td></tr></table></figure>

<p>如果两个 RDD 数据类型不一致怎么办？</p>
<p>编译不通过</p>
</li>
<li><p>subtract</p>
<p>函数签名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def subtract(other: RDD[T]): RDD[T]</span><br></pre></td></tr></table></figure>

<p>函数说明</p>
<p>以一个 RDD 元素为主，去除两个 RDD 中重复元素，将其他元素保留下来。求差集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD1 = sparkContext.makeRDD(List(1,2,3,4))</span><br><span class="line">val dataRDD2 = sparkContext.makeRDD(List(3,4,5,6))</span><br><span class="line">val dataRDD = dataRDD1.subtract(dataRDD2)</span><br></pre></td></tr></table></figure>

<p>如果两个 RDD 数据类型不一致怎么办？</p>
<p>编译不通过</p>
</li>
<li><p>zip（拉链）</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def zip[U: ClassTag](other: RDD[U]): RDD[(T, U)]</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>将两个 RDD 中的元素，以键值对的形式进行合并。其中，键值对中的 Key 为第 1 个 RDD中的元素，Value 为第 2 个 RDD 中的相同位置的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD1 = sparkContext.makeRDD(List(1,2,3,4))</span><br><span class="line">val dataRDD2 = sparkContext.makeRDD(List(3,4,5,6))</span><br><span class="line">val dataRDD = dataRDD1.zip(dataRDD2)</span><br></pre></td></tr></table></figure>

<p>如果两个 RDD 数据类型不一致怎么办？</p>
<p>可以不一致</p>
<p>如果两个 RDD 数据分区不一致怎么办？如果两个 RDD 分区数据数量不一致怎么办？</p>
<p>报错</p>
</li>
</ol>
<h5 id="Key-Value-类型"><a href="#Key-Value-类型" class="headerlink" title="Key - Value 类型"></a>Key - Value 类型</h5><ol start="17">
<li><p>partitionBy</p>
<p>函数签名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def partitionBy(partitioner: Partitioner): RDD[(K, V)]</span><br></pre></td></tr></table></figure>

<p>函数说明</p>
<p>将数据按照指定 Partitioner 重新进行分区。Spark 默认的分区器是 HashPartitioner</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val rdd: RDD[(Int, String)] =</span><br><span class="line"> sc.makeRDD(Array((1,&quot;aaa&quot;),(2,&quot;bbb&quot;),(3,&quot;ccc&quot;)),3)</span><br><span class="line"> </span><br><span class="line">import org.apache.spark.HashPartitioner</span><br><span class="line">val rdd2: RDD[(Int, String)] =</span><br><span class="line"> rdd.partitionBy(new HashPartitioner(2))</span><br></pre></td></tr></table></figure>

<p>如果重分区的分区器和当前 RDD 的分区器一样怎么办？</p>
<p>​    如果分区器的类型和数量都是一样的，那么第二次分区不会执行，返回第一次结果</p>
<p>Spark 还有其他分区器吗？</p>
<p>HashPartitioner</p>
<p>RangePartitioner（一般在排序中使用）</p>
<p>PythonPartitioner（只能在特定的包）</p>
<p>如果想按照自己的方法进行数据分区怎么办？</p>
<p>自己继承Partitioner，写一个分区器 </p>
</li>
<li><p>reduceByKey</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def reduceByKey(func: (V, V) =&gt; V): RDD[(K, V)]</span><br><span class="line">def reduceByKey(func: (V, V) =&gt; V, numPartitions: Int): RDD[(K, V)]</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>可以将数据按照相同的 Key 对 Value 进行聚合，如果key的数据只有一个是不会参与运算的（直接拿到结果）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD1 = sparkContext.makeRDD(List((&quot;a&quot;,1),(&quot;b&quot;,2),(&quot;c&quot;,3)))</span><br><span class="line">val dataRDD2 = dataRDD1.reduceByKey(_+_)</span><br><span class="line">val dataRDD3 = dataRDD1.reduceByKey(_+_, 2)</span><br></pre></td></tr></table></figure>

<p>小功能：WordCount</p>
</li>
<li><p>groupByKey</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def groupByKey(): RDD[(K, Iterable[V])]</span><br><span class="line">def groupByKey(numPartitions: Int): RDD[(K, Iterable[V])]</span><br><span class="line">def groupByKey(partitioner: Partitioner): RDD[(K, Iterable[V])]</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>将数据源的数据根据 key 对 value 进行分组，相同的key放在一个分组中，形成一个对偶元祖，第一个元祖为key，第二个元祖为对应可以的value的集合，分区的数据会被打断重新组合（shuffle）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD1 =</span><br><span class="line"> sparkContext.makeRDD(List((&quot;a&quot;,1),(&quot;b&quot;,2),(&quot;c&quot;,3)))</span><br><span class="line">val dataRDD2 = dataRDD1.groupByKey()</span><br><span class="line">val dataRDD3 = dataRDD1.groupByKey(2)</span><br><span class="line">val dataRDD4 = dataRDD1.groupByKey(new HashPartitioner(2))</span><br></pre></td></tr></table></figure>

<p>reduceByKey 和 groupByKey 的区别？</p>
<p>shuffle会有一个文件缓冲区，所有的组合文件都要罗盘到一个磁盘文件中而不是全部在内存中（因为是异步的，需要等待另一个文件的数据，但是不知道这个文件数据什么时候过来）</p>
<p><strong>从</strong> <strong>shuffle</strong> <strong>的角度</strong>：reduceByKey 和 groupByKey 都存在 shuffle 的操作，但是 reduceByKey可以在 shuffle 前对分区内相同 key 的数据进行预聚合（combine）功能，这样会减少落盘的数据量，而 groupByKey 只是进行分组，不存在数据量减少的问题，reduceByKey 性能比较高。</p>
<p><strong>从功能的角度</strong>：reduceByKey 其实包含分组和聚合的功能。GroupByKey 只能分组，不能聚合，所以在分组聚合的场合下，推荐使用 reduceByKey，如果仅仅是分组而不需要聚合。那么还是只能使用 groupByKey</p>
<p>小功能：WordCount</p>
</li>
<li><p>aggregateByKey</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def aggregateByKey[U: ClassTag](zeroValue: U)(seqOp: (U, V) =&gt; U,</span><br><span class="line"> combOp: (U, U) =&gt; U): RDD[(K, U)]</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>将数据根据不同的规则进行<strong>分区内计算和分区间计算</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD1 = sparkContext.makeRDD(List((&quot;a&quot;,1),(&quot;b&quot;,2),(&quot;c&quot;,3)))</span><br><span class="line">val dataRDD2 = dataRDD1.aggregateByKey(0)(_+_,_+_)</span><br></pre></td></tr></table></figure>

<p>取出每个分区内相同 key 的最大值然后分区间相加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// TODO : 取出每个分区内相同 key 的最大值然后分区间相加</span><br><span class="line">// aggregateByKey 算子是函数柯里化，存在两个参数列表</span><br><span class="line">// 1. 第一个参数列表中的参数表示初始值</span><br><span class="line">// 2. 第二个参数列表中含有两个参数</span><br><span class="line">// 2.1 第一个参数表示分区内的计算规则</span><br><span class="line">// 2.2 第二个参数表示分区间的计算规则</span><br><span class="line">val rdd =</span><br><span class="line"> sc.makeRDD(List(</span><br><span class="line"> (&quot;a&quot;,1),(&quot;a&quot;,2),(&quot;c&quot;,3),</span><br><span class="line"> (&quot;b&quot;,4),(&quot;c&quot;,5),(&quot;c&quot;,6)</span><br><span class="line"> ),2)</span><br><span class="line">// 0:(&quot;a&quot;,1),(&quot;a&quot;,2),(&quot;c&quot;,3) =&gt; (a,10)(c,10)</span><br><span class="line">// =&gt; (a,10)(b,10)(c,20)</span><br><span class="line">// 1:(&quot;b&quot;,4),(&quot;c&quot;,5),(&quot;c&quot;,6) =&gt; (b,10)(c,10)</span><br><span class="line">val resultRDD =</span><br><span class="line"> rdd.aggregateByKey(10)(</span><br><span class="line"> (x, y) =&gt; math.max(x,y),</span><br><span class="line"> (x, y) =&gt; x + y</span><br><span class="line"> )</span><br><span class="line">resultRDD.collect().foreach(println)</span><br></pre></td></tr></table></figure>

<p>分区内计算规则和分区间计算规则相同怎么办？（WordCount）</p>
<p>可以使用至简原则（_）</p>
</li>
<li><p>foldByKey</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def foldByKey(zeroValue: V)(func: (V, V) =&gt; V): RDD[(K, V)]</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>当分区内计算规则和分区间计算规则相同时，aggregateByKey 就可以简化为 foldByKey</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD1 = sparkContext.makeRDD(List((&quot;a&quot;,1),(&quot;b&quot;,2),(&quot;c&quot;,3)))</span><br><span class="line">val dataRDD2 = dataRDD1.foldByKey(0)(_+_)</span><br></pre></td></tr></table></figure></li>
<li><p>combineByKey</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def combineByKey[C](</span><br><span class="line"> createCombiner: V =&gt; C,</span><br><span class="line"> mergeValue: (C, V) =&gt; C,</span><br><span class="line"> mergeCombiners: (C, C) =&gt; C): RDD[(K, C)]</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>最通用的对 key-value 型 rdd 进行聚集操作的聚集函数（aggregation function）。类似于aggregate()，combineByKey()允许用户返回值的类型与输入不一致。</p>
<p>小练习：将数据 List((“a”, 88), (“b”, 95), (“a”, 91), (“b”, 93), (“a”, 95), (“b”, 98))求每个 key 的平均值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val list: List[(String, Int)] = List((&quot;a&quot;, 88), (&quot;b&quot;, 95), (&quot;a&quot;, 91), (&quot;b&quot;, 93), </span><br><span class="line">(&quot;a&quot;, 95), (&quot;b&quot;, 98))</span><br><span class="line">val input: RDD[(String, Int)] = sc.makeRDD(list, 2)</span><br><span class="line">val combineRdd: RDD[(String, (Int, Int))] = input.combineByKey(</span><br><span class="line"> (_, 1),</span><br><span class="line"> (acc: (Int, Int), v) =&gt; (acc._1 + v, acc._2 + 1),</span><br><span class="line"> (acc1: (Int, Int), acc2: (Int, Int)) =&gt; (acc1._1 + acc2._1, acc1._2 + acc2._2)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>思考一个问题：reduceByKey、foldByKey、aggregateByKey、combineByKey 的区别？</p>
<p>这些底层都是调用的CombineByKey</p>
<p>reduceByKey: 相同 key 的第一个数据不进行任何计算，分区内和分区间计算规则相同</p>
<p>FoldByKey: 相同 key 的第一个数据和初始值进行分区内计算，分区内和分区间计算规则相同</p>
<p>AggregateByKey：相同 key 的第一个数据和初始值进行分区内计算，分区内和分区间计算规则可以不相同</p>
<p>CombineByKey:当计算时，发现数据结构不满足要求时，可以让第一个数据转换结构。分区内和分区间计算规则不相同。</p>
</li>
<li><p>sortByKey</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def sortByKey(ascending: Boolean = true, numPartitions: Int = self.partitions.length)</span><br><span class="line"> : RDD[(K, V)]</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>在一个(K,V)的 RDD 上调用，K 必须实现 Ordered 接口(特质)，返回一个按照 key 进行排序的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD1 = sparkContext.makeRDD(List((&quot;a&quot;,1),(&quot;b&quot;,2),(&quot;c&quot;,3)))</span><br><span class="line">val sortRDD1: RDD[(String, Int)] = dataRDD1.sortByKey(true)</span><br><span class="line">val sortRDD1: RDD[(String, Int)] = dataRDD1.sortByKey(false)</span><br></pre></td></tr></table></figure>

<p>小功能：设置 key 为自定义类 User</p>
</li>
<li><p>join</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def join[W](other: RDD[(K, W)]): RDD[(K, (V, W))]</span><br></pre></td></tr></table></figure>

<p>函数说明</p>
<p>在类型为(K,V)和(K,W)的 RDD 上调用，返回一个相同 key 对应的所有元素连接在一起的(K,(V,W))的 RDD</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val rdd: RDD[(Int, String)] = sc.makeRDD(Array((1, &quot;a&quot;), (2, &quot;b&quot;), (3, &quot;c&quot;)))</span><br><span class="line">val rdd1: RDD[(Int, Int)] = sc.makeRDD(Array((1, 4), (2, 5), (3, 6)))</span><br><span class="line">rdd.join(rdd1).collect().foreach(println)</span><br></pre></td></tr></table></figure>

<p>如果 key 存在不相等呢？</p>
<p>数据不会出现在结果上</p>
<p>如果key存在多个相同的</p>
<p>会出现类似于笛卡尔积的感觉数据量会几何增长，每一个相同的key都会出现</p>
</li>
<li><p>leftOuterJoin</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def leftOuterJoin[W](other: RDD[(K, W)]): RDD[(K, (V, Option[W]))]</span><br></pre></td></tr></table></figure>

<p>函数说明</p>
<p>类似于 SQL 语句的左外连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD1 = sparkContext.makeRDD(List((&quot;a&quot;,1),(&quot;b&quot;,2),(&quot;c&quot;,3)))</span><br><span class="line">val dataRDD2 = sparkContext.makeRDD(List((&quot;a&quot;,1),(&quot;b&quot;,2),(&quot;c&quot;,3)))</span><br><span class="line">val rdd: RDD[(String, (Int, Option[Int]))] = dataRDD1.leftOuterJoin(dataRDD2)</span><br></pre></td></tr></table></figure></li>
<li><p>cogroup</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def cogroup[W](other: RDD[(K, W)]): RDD[(K, (Iterable[V], Iterable[W]))]</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>在类型为(K,V)和(K,W)的 RDD 上调用，返回一个(K,(Iterable<V>,Iterable<W>))类型的 RDD</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val dataRDD1 = sparkContext.makeRDD(List((&quot;a&quot;,1),(&quot;a&quot;,2),(&quot;c&quot;,3)))</span><br><span class="line">val dataRDD2 = sparkContext.makeRDD(List((&quot;a&quot;,1),(&quot;c&quot;,2),(&quot;c&quot;,3)))</span><br><span class="line">val value: RDD[(String, (Iterable[Int], Iterable[Int]))] = </span><br><span class="line">dataRDD1.cogroup(dataRDD2)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="案例实操"><a href="#案例实操" class="headerlink" title="案例实操"></a>案例实操</h4><ol>
<li><p>数据准备</p>
<p>agent.log：时间戳，省份，城市，用户，广告，中间字段使用空格分隔。</p>
</li>
<li><p>需求描述</p>
<p>统计出每一个省份<strong>每个广告被点击数量</strong>排行的 Top3</p>
</li>
<li><p>需求分析</p>
</li>
<li><p>功能实现</p>
</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark24_RDD_Req</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;RDD&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// 案例实操</span></span><br><span class="line">    <span class="comment">// 1.获取原始数据 时间戳，省份，城市，用户，广告</span></span><br><span class="line">    <span class="keyword">val</span> dataRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">&quot;datas/agent.log&quot;</span>)</span><br><span class="line">    <span class="comment">// 2.将原始数据进行结构的转换，方便统计</span></span><br><span class="line">    <span class="comment">// 时间戳，省份，城市，用户，广告 =&gt;</span></span><br><span class="line">    <span class="comment">// ((省份，广告),1)</span></span><br><span class="line">    <span class="keyword">val</span> mapRDD: <span class="type">RDD</span>[((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>)] = dataRDD.map(line =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> datas: <span class="type">Array</span>[<span class="type">String</span>] = line.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">      ((datas(<span class="number">1</span>), datas(<span class="number">4</span>)), <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 3.将转换结构后的数据进行分组聚合</span></span><br><span class="line">    <span class="comment">// ((省份，广告),1) =&gt; ((省份，广告),sum)</span></span><br><span class="line">    <span class="keyword">val</span> reduceRDD: <span class="type">RDD</span>[((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>)] = mapRDD.reduceByKey(_ + _)</span><br><span class="line">    <span class="comment">// 4.将聚合的结果进行结构的转换</span></span><br><span class="line">    <span class="comment">// ((省份，广告),sum) =&gt; (省份，(广告,sum))</span></span><br><span class="line">    <span class="keyword">val</span> newMapRDD: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">String</span>, <span class="type">Int</span>))] = reduceRDD.map &#123;</span><br><span class="line">      <span class="keyword">case</span> ((prv, ad), sum) =&gt; &#123;</span><br><span class="line">        (prv, (ad, sum))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.将转换结构后的数据根据省份进行分组</span></span><br><span class="line">    <span class="comment">// (省份，[(广告A,sum),(广告B,sum)])</span></span><br><span class="line">    <span class="keyword">val</span> groupRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[(<span class="type">String</span>, <span class="type">Int</span>)])] = newMapRDD.groupByKey()</span><br><span class="line">    <span class="comment">// 6.将分组后的数据组内排序(降序),取前3名</span></span><br><span class="line">    <span class="keyword">val</span> resultRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)])] = groupRDD.mapValues(iter =&gt; &#123;</span><br><span class="line">      iter.toList.sortBy(_._2)(<span class="type">Ordering</span>.<span class="type">Int</span>.reverse).take(<span class="number">3</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 7.采集数据打印在控制台</span></span><br><span class="line">    resultRDD.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="RDD-行动算子"><a href="#RDD-行动算子" class="headerlink" title="RDD 行动算子"></a>RDD 行动算子</h4><p> 触发作业执行的方法</p>
<ol>
<li><p>reduce</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def reduce(f: (T, T) =&gt; T): T</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>聚集 RDD 中的所有元素，先聚合分区内数据，再聚合分区间数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val rdd: RDD[Int] = sc.makeRDD(List(1,2,3,4))</span><br><span class="line">// 聚合数据</span><br><span class="line">val reduceResult: Int = rdd.reduce(_+_)</span><br></pre></td></tr></table></figure></li>
<li><p>collect</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def collect(): Array[T]</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>在驱动程序中，以数组 Array 的形式返回数据集的所有元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val rdd: RDD[Int] = sc.makeRDD(List(1,2,3,4))</span><br><span class="line">// 收集数据到 Driver</span><br><span class="line">rdd.collect().foreach(println)</span><br></pre></td></tr></table></figure></li>
<li><p>count</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def count(): Long</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>返回 RDD 中元素的个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val rdd: RDD[Int] = sc.makeRDD(List(1,2,3,4))</span><br><span class="line">// 返回 RDD 中元素的个数</span><br><span class="line">val countResult: Long = rdd.count()</span><br></pre></td></tr></table></figure></li>
<li><p>first</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def first(): T</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>返回 RDD 中的第一个元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val rdd: RDD[Int] = sc.makeRDD(List(1,2,3,4))</span><br><span class="line">// 返回 RDD 中元素的个数</span><br><span class="line">val firstResult: Int = rdd.first()</span><br><span class="line">println(firstResult)</span><br></pre></td></tr></table></figure></li>
<li><p>take</p>
<p>函数签名：def take(num: Int): Array[T]</p>
<p>函数说明：返回一个由 RDD 的前 n 个元素组成的数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vval rdd: RDD[Int] = sc.makeRDD(List(1,2,3,4))</span><br><span class="line">// 返回 RDD 中元素的个数</span><br><span class="line">val takeResult: Array[Int] = rdd.take(2)</span><br><span class="line">println(takeResult.mkString(&quot;,&quot;))</span><br></pre></td></tr></table></figure></li>
<li><p>takeOrdered</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def takeOrdered(num: Int)(implicit ord: Ordering[T]): Array[T]</span><br></pre></td></tr></table></figure>

<p>函数说明：返回该 RDD 排序后的前 n 个元素组成的数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val rdd: RDD[Int] = sc.makeRDD(List(1,3,2,4))</span><br><span class="line">// 返回 RDD 中元素的个数</span><br><span class="line">val result: Array[Int] = rdd.takeOrdered(2)</span><br></pre></td></tr></table></figure></li>
<li><p>aggregate</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def aggregate[U: ClassTag](zeroValue: U)(seqOp: (U, T) =&gt; U, combOp: (U, U) =&gt; U): U</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>分区的数据通过初始值和分区内的数据进行聚合，然后再和初始值进行分区间的数据聚合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val rdd: RDD[Int] = sc.makeRDD(List(1, 2, 3, 4), 8)</span><br><span class="line">// 将该 RDD 所有元素相加得到结果</span><br><span class="line">//val result: Int = rdd.aggregate(0)(_ + _, _ + _)</span><br><span class="line">val result: Int = rdd.aggregate(10)(_ + _, _ + _)</span><br></pre></td></tr></table></figure></li>
<li><p>fold</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def fold(zeroValue: T)(op: (T, T) =&gt; T): T</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>折叠操作，aggregate 的简化版操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val rdd: RDD[Int] = sc.makeRDD(List(1, 2, 3, 4))</span><br><span class="line">val foldResult: Int = rdd.fold(0)(_+_)</span><br></pre></td></tr></table></figure></li>
<li><p>countByKey</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def countByKey(): Map[K, Long]</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>统计每种 key 的个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val rdd: RDD[(Int, String)] = sc.makeRDD(List((1, &quot;a&quot;), (1, &quot;a&quot;), (1, &quot;a&quot;), (2, </span><br><span class="line">&quot;b&quot;), (3, &quot;c&quot;), (3, &quot;c&quot;)))</span><br><span class="line">// 统计每种 key 的个数</span><br><span class="line">val result: collection.Map[Int, Long] = rdd.countByKey()</span><br></pre></td></tr></table></figure></li>
<li><p>save 相关算子</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def saveAsTextFile(path: String): Unit</span><br><span class="line">def saveAsObjectFile(path: String): Unit</span><br><span class="line">def saveAsSequenceFile(</span><br><span class="line"> path: String,</span><br><span class="line"> codec: Option[Class[_ &lt;: CompressionCodec]] = None): Unit</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>将数据保存到不同格式的文件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 保存成 Text 文件</span><br><span class="line">rdd.saveAsTextFile(&quot;output&quot;)</span><br><span class="line">// 序列化成对象保存到文件</span><br><span class="line">rdd.saveAsObjectFile(&quot;output1&quot;)</span><br><span class="line">// 保存成 Sequencefile 文件，要求数据的格式必须为k-v类型</span><br><span class="line">rdd.map((_,1)).saveAsSequenceFile(&quot;output2&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p>foreach</p>
<p>函数签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def foreach(f: T =&gt; Unit): Unit = withScope &#123;</span><br><span class="line"> val cleanF = sc.clean(f)</span><br><span class="line"> sc.runJob(this, (iter: Iterator[T]) =&gt; iter.foreach(cleanF))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<p>分布式遍历 RDD 中的每一个元素，调用指定函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val rdd: RDD[Int] = sc.makeRDD(List(1,2,3,4))</span><br><span class="line">// 收集后打印</span><br><span class="line">// 是在Driver端内存集合的循环遍历方法</span><br><span class="line">rdd.map(num=&gt;num).collect().foreach(println)</span><br><span class="line">println(&quot;****************&quot;)</span><br><span class="line">// 分布式打印</span><br><span class="line">// foreach 其实是在Excotor端内存数据打印</span><br><span class="line">rdd.foreach(println)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>算子：Operator操作</p>
<p>RDD的方法和Scalal集合对象的方法不一样，集合对象的方法都是在同一个节点的内存中完成的。RDD的方法可以将计算逻辑发送到Excutor端（分布式节点）执行，为了区分不同的处理效果，所以将RDD的方法称为算子。</p>
<p>RDD的方法的外部操作都是在Driver端执行的，而方法内部的逻辑代码是在Excutor端执行的</p>
<h4 id="实现wordCount的几种方式"><a href="#实现wordCount的几种方式" class="headerlink" title="实现wordCount的几种方式"></a>实现wordCount的几种方式</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换算子</span></span><br><span class="line"><span class="comment">// groupBy</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordcount1</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;Hello Scala&quot;</span>, <span class="string">&quot;Hello Spark&quot;</span>))</span><br><span class="line">    .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    .groupBy(word =&gt; word)</span><br><span class="line">    .mapValues(iter =&gt; iter.size)</span><br><span class="line">    .collect()</span><br><span class="line">    .foreach(println)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// groupByKey</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordcount2</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;Hello Scala&quot;</span>, <span class="string">&quot;Hello Spark&quot;</span>))</span><br><span class="line">    .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    .map(_ -&gt; <span class="number">1</span>)</span><br><span class="line">    .groupByKey()</span><br><span class="line">    .mapValues(iter =&gt; iter.size)</span><br><span class="line">    .collect()</span><br><span class="line">    .foreach(println)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduceByKey</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordcount3</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;Hello Scala&quot;</span>, <span class="string">&quot;Hello Spark&quot;</span>))</span><br><span class="line">    .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    .map(_ -&gt; <span class="number">1</span>)</span><br><span class="line">    .reduceByKey(_ + _)</span><br><span class="line">    .collect()</span><br><span class="line">    .foreach(println)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// aggregateByKey</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordcount4</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;Hello Scala&quot;</span>, <span class="string">&quot;Hello Spark&quot;</span>))</span><br><span class="line">    .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    .map(_ -&gt; <span class="number">1</span>)</span><br><span class="line">    .aggregateByKey(<span class="number">0</span>)(_ + _, _ + _)</span><br><span class="line">    .collect()</span><br><span class="line">    .foreach(println)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foldByKey</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordcount5</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;Hello Scala&quot;</span>, <span class="string">&quot;Hello Spark&quot;</span>))</span><br><span class="line">    .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    .map(_ -&gt; <span class="number">1</span>)</span><br><span class="line">    .foldByKey(<span class="number">0</span>)(_ + _)</span><br><span class="line">    .collect()</span><br><span class="line">    .foreach(println)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// combineByKey</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordcount6</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;Hello Scala&quot;</span>, <span class="string">&quot;Hello Spark&quot;</span>))</span><br><span class="line">    .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    .map(_ -&gt; <span class="number">1</span>)</span><br><span class="line">    .combineByKey(</span><br><span class="line">        x =&gt; x,</span><br><span class="line">        (x: <span class="type">Int</span>, y) =&gt; x + y,</span><br><span class="line">        (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x + y</span><br><span class="line">    )</span><br><span class="line">    .collect()</span><br><span class="line">    .foreach(println)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行动算子</span></span><br><span class="line"><span class="comment">// countByKey</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordcount7</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> rdd: collection.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;Hello Scala&quot;</span>, <span class="string">&quot;Hello Spark&quot;</span>))</span><br><span class="line">    .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    .map(_ -&gt; <span class="number">1</span>)</span><br><span class="line">    .countByKey()</span><br><span class="line"></span><br><span class="line">    println(rdd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// countByValue</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordcount8</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> rdd: collection.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;Hello Scala&quot;</span>, <span class="string">&quot;Hello Spark&quot;</span>))</span><br><span class="line">    .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    .countByValue()</span><br><span class="line"></span><br><span class="line">    println(rdd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordcount9</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> rdd: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;Hello Scala&quot;</span>, <span class="string">&quot;Hello Spark&quot;</span>))</span><br><span class="line">    .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    .map(word =&gt; &#123;</span><br><span class="line">        mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]((word, <span class="number">1</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    .reduce((map1, map2) =&gt; &#123;</span><br><span class="line">        map2.foreach &#123;</span><br><span class="line">            <span class="keyword">case</span> (word, count) =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> newCount = map1.getOrElse(word, <span class="number">0</span>L) + count</span><br><span class="line">                map1.update(word, newCount)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map1</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    println(rdd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// aggregate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordcount10</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> rdd: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;Hello Scala&quot;</span>, <span class="string">&quot;Hello Spark&quot;</span>))</span><br><span class="line">    .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    .map(word =&gt; &#123;</span><br><span class="line">        <span class="type">Map</span>((word, <span class="number">1</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    .aggregate(mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]())(</span><br><span class="line">        (map1, map2) =&gt; &#123;</span><br><span class="line">            map2.foreach &#123;</span><br><span class="line">                <span class="keyword">case</span> (word, count) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">val</span> newCount = map1.getOrElse(word, <span class="number">0</span>L) + count</span><br><span class="line">                    map1.update(word, newCount)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map1</span><br><span class="line">        &#125;,</span><br><span class="line">        (map1, map2) =&gt; &#123;</span><br><span class="line">            map2.foreach &#123;</span><br><span class="line">                <span class="keyword">case</span> (word, count) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">val</span> newCount = map1.getOrElse(word, <span class="number">0</span>L) + count</span><br><span class="line">                    map1.update(word, newCount)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map1</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    println(rdd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// fold</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordcount11</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> rdd: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;Hello Scala&quot;</span>, <span class="string">&quot;Hello Spark&quot;</span>))</span><br><span class="line">    .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    .map(word =&gt; &#123;</span><br><span class="line">        mutable.<span class="type">Map</span>((word, <span class="number">1</span>L))</span><br><span class="line">    &#125;)</span><br><span class="line">    .fold(mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]())(</span><br><span class="line">        (map1, map2) =&gt; &#123;</span><br><span class="line">            map2.foreach &#123;</span><br><span class="line">                <span class="keyword">case</span> (word, count) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">val</span> newCount: <span class="type">Long</span> = map1.getOrElse(word, <span class="number">0</span>L) + count</span><br><span class="line">                    map1.update(word, newCount)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map1</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    println(rdd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="RDD-序列化"><a href="#RDD-序列化" class="headerlink" title="RDD 序列化"></a>RDD 序列化</h4><ol>
<li><p>闭包检查</p>
<p>从计算的角度, 算子以外的代码都是在 Driver 端执行, 算子里面的代码都是在 Executor端执行。那么在 scala 的函数式编程中，就会导致算子内经常会用到算子外的数据，这样就形成了闭包的效果，如果使用的算子外的数据无法序列化，就意味着无法传值给 Executor端执行，就会发生错误，所以需要在执行任务计算前，检测闭包内的对象是否可以进行序列化，这个操作我们称之为闭包检测。Scala2.12 版本后闭包编译方式发生了改变</p>
</li>
<li><p>序列化方法和属性</p>
<p>从计算的角度, 算子以外的代码都是在 Driver 端执行, 算子里面的代码都是在 Executor端执行，看如下代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">serializable02_function</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"> <span class="comment">//1.创建 SparkConf 并设置 App 名称</span></span><br><span class="line"> <span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> </span><br><span class="line"><span class="type">SparkConf</span>().setAppName(<span class="string">&quot;SparkCoreTest&quot;</span>).setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line"> <span class="comment">//2.创建 SparkContext，该对象是提交 Spark App 的入口</span></span><br><span class="line"> <span class="keyword">val</span> sc: <span class="type">SparkContext</span> = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"> <span class="comment">//3.创建一个 RDD</span></span><br><span class="line"> <span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">String</span>] = sc.makeRDD(<span class="type">Array</span>(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;hello spark&quot;</span>, </span><br><span class="line"><span class="string">&quot;hive&quot;</span>, <span class="string">&quot;atguigu&quot;</span>))</span><br><span class="line"> <span class="comment">//3.1 创建一个 Search 对象</span></span><br><span class="line"> <span class="keyword">val</span> search = <span class="keyword">new</span> <span class="type">Search</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"> <span class="comment">//3.2 函数传递，打印：ERROR Task not serializable</span></span><br><span class="line"> search.getMatch1(rdd).collect().foreach(println)</span><br><span class="line"> <span class="comment">//3.3 属性传递，打印：ERROR Task not serializable</span></span><br><span class="line"> search.getMatch2(rdd).collect().foreach(println)</span><br><span class="line"> <span class="comment">//4.关闭连接</span></span><br><span class="line"> sc.stop()</span><br><span class="line"> &#125; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Search</span>(<span class="params">query:<span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span></span>(s: <span class="type">String</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line"> s.contains(query)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 函数序列化案例</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">getMatch1</span> </span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]): <span class="type">RDD</span>[<span class="type">String</span>] = &#123;</span><br><span class="line"> <span class="comment">//rdd.filter(this.isMatch)</span></span><br><span class="line"> rdd.filter(isMatch)</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 属性序列化案例</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">getMatch2</span></span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]): <span class="type">RDD</span>[<span class="type">String</span>] = &#123;</span><br><span class="line"> <span class="comment">//rdd.filter(x =&gt; x.contains(this.query))</span></span><br><span class="line"> rdd.filter(x =&gt; x.contains(query))</span><br><span class="line"> <span class="comment">//val q = query</span></span><br><span class="line"> <span class="comment">//rdd.filter(x =&gt; x.contains(q))</span></span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Kryo 序列化框架</p>
<p>参考地址: <a target="_blank" rel="noopener" href="https://github.com/EsotericSoftware/kryo">https://github.com/EsotericSoftware/kryo</a></p>
<p>Java 的序列化能够序列化任何的类。但是比较重（字节多），序列化后，对象的提交也比较大。Spark 出于性能的考虑，Spark2.0 开始支持另外一种 Kryo 序列化机制。Kryo 速度是 Serializable 的 10 倍。当 RDD 在 Shuffle 数据的时候，简单数据类型、数组和字符串类型已经在 Spark 内部使用 Kryo 来序列化。</p>
<p>注意：即使使用 Kryo 序列化，也要继承 Serializable 接口。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">serializable_Kryo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"> <span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line"> .setAppName(<span class="string">&quot;SerDemo&quot;</span>)</span><br><span class="line"> .setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line"> <span class="comment">// 替换默认的序列化机制</span></span><br><span class="line"> .set(<span class="string">&quot;spark.serializer&quot;</span>, </span><br><span class="line"><span class="string">&quot;org.apache.spark.serializer.KryoSerializer&quot;</span>)</span><br><span class="line"> <span class="comment">// 注册需要使用 kryo 序列化的自定义类</span></span><br><span class="line"> .registerKryoClasses(<span class="type">Array</span>(classOf[<span class="type">Searcher</span>]))</span><br><span class="line"> <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"> <span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">String</span>] = sc.makeRDD(<span class="type">Array</span>(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;hello atguigu&quot;</span>, </span><br><span class="line"><span class="string">&quot;atguigu&quot;</span>, <span class="string">&quot;hahah&quot;</span>), <span class="number">2</span>)</span><br><span class="line"> <span class="keyword">val</span> searcher = <span class="keyword">new</span> <span class="type">Searcher</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"> <span class="keyword">val</span> result: <span class="type">RDD</span>[<span class="type">String</span>] = searcher.getMatchedRDD1(rdd)</span><br><span class="line"> result.collect.foreach(println)</span><br><span class="line"> &#125; &#125;</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Searcher</span>(<span class="params">val query: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span></span>(s: <span class="type">String</span>) = &#123;</span><br><span class="line"> s.contains(query)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">getMatchedRDD1</span></span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]) = &#123;</span><br><span class="line"> rdd.filter(isMatch) </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">getMatchedRDD2</span></span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]) = &#123;</span><br><span class="line"> <span class="keyword">val</span> q = query</span><br><span class="line"> rdd.filter(_.contains(q))</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="RDD-依赖关系"><a href="#RDD-依赖关系" class="headerlink" title="RDD 依赖关系"></a>RDD 依赖关系</h4><ol>
<li><p>RDD 血缘关系</p>
<p>RDD 只支持粗粒度转换，即在大量记录上执行的单个操作。将创建 RDD 的一系列 Lineage（血统）记录下来，以便恢复丢失的分区。RDD 的 Lineage 会记录 RDD 的元数据信息和转换行为，当该 RDD 的部分分区数据丢失时，它可以根据这些信息来重新运算和恢复丢失的数据分区。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> fileRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">&quot;input/1.txt&quot;</span>)</span><br><span class="line">println(fileRDD.toDebugString)</span><br><span class="line">println(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> wordRDD: <span class="type">RDD</span>[<span class="type">String</span>] = fileRDD.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">println(wordRDD.toDebugString)</span><br><span class="line">println(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> mapRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordRDD.map((_,<span class="number">1</span>))</span><br><span class="line">println(mapRDD.toDebugString)</span><br><span class="line">println(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> resultRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = mapRDD.reduceByKey(_+_)</span><br><span class="line">println(resultRDD.toDebugString)</span><br><span class="line">resultRDD.collect()</span><br></pre></td></tr></table></figure></li>
<li><p>RDD 依赖关系</p>
<p>这里所谓的依赖关系，其实就是两个相邻 RDD 之间的关系</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sc: <span class="type">SparkContext</span> = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"><span class="keyword">val</span> fileRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">&quot;input/1.txt&quot;</span>)</span><br><span class="line">println(fileRDD.dependencies)</span><br><span class="line">println(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> wordRDD: <span class="type">RDD</span>[<span class="type">String</span>] = fileRDD.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">println(wordRDD.dependencies)</span><br><span class="line">println(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> mapRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordRDD.map((_, <span class="number">1</span>))</span><br><span class="line">println(mapRDD.dependencies)</span><br><span class="line">println(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> resultRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = mapRDD.reduceByKey(_ + _)</span><br><span class="line">println(resultRDD.dependencies)</span><br><span class="line">resultRDD.collect()</span><br></pre></td></tr></table></figure></li>
<li><p>RDD 窄依赖</p>
<p>窄依赖表示每一个父(上游)RDD 的 Partition 最多被子（下游）RDD 的一个 Partition 使用，窄依赖我们形象的比喻为独生子女。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class OneToOneDependency[T](rdd: RDD[T]) extends NarrowDependency[T](rdd)</span><br></pre></td></tr></table></figure></li>
<li><p>RDD 宽依赖</p>
<p>宽依赖表示同一个父（上游）RDD 的 Partition 被多个子（下游）RDD 的 Partition 依赖，会引起 Shuffle，总结：宽依赖我们形象的比喻为多生。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class ShuffleDependency[K: ClassTag, V: ClassTag, C: ClassTag](</span><br><span class="line">@transient private val _rdd: RDD[_ &lt;: Product2[K, V]],</span><br><span class="line">val partitioner: Partitioner,</span><br><span class="line">val serializer: Serializer = SparkEnv.get.serializer,</span><br><span class="line">val keyOrdering: Option[Ordering[K]] = None,</span><br><span class="line">val aggregator: Option[Aggregator[K, V, C]] = None,</span><br><span class="line">val mapSideCombine: Boolean = false) extends Dependency[Product2[K, V]]</span><br></pre></td></tr></table></figure></li>
<li><p>RDD 阶段划分</p>
<p>DAG（Directed Acyclic Graph）有向无环图是由点和线组成的拓扑图形，该图形具有方向，不会闭环。例如，DAG 记录了 RDD 的转换过程和任务的阶段。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111082027008.png/lvxiaoyi" style="zoom: 50%;" /></li>
<li><p>RDD 阶段划分源码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// New stage creation may throw an exception if, for example, jobs are run on</span></span><br><span class="line">    a</span><br><span class="line">    <span class="comment">// HadoopRDD whose underlying HDFS files have been deleted.</span></span><br><span class="line">    finalStage = createResultStage(finalRDD, func, partitions, jobId, callSite)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt;</span><br><span class="line">    logWarning(<span class="string">&quot;Creating new stage failed due to exception - job: &quot;</span> + jobId, e) listener.jobFailed(e)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">createResultStage</span></span>(rdd: <span class="type">RDD</span>[_],</span><br><span class="line">                              func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[_]) =&gt; _, partitions: <span class="type">Array</span>[<span class="type">Int</span>],</span><br><span class="line">                              jobId: <span class="type">Int</span>,</span><br><span class="line">                              callSite: <span class="type">CallSite</span>): <span class="type">ResultStage</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> parents = getOrCreateParentStages(rdd, jobId)</span><br><span class="line">    <span class="keyword">val</span> id = nextStageId.getAndIncrement()</span><br><span class="line">    <span class="keyword">val</span> stage = <span class="keyword">new</span> <span class="type">ResultStage</span>(id, rdd, func, partitions, parents, jobId, callSite) stageIdToStage (id) = stage</span><br><span class="line">    updateJobIdStageIdMaps(jobId, stage) stage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">getOrCreateParentStages</span></span>(rdd: <span class="type">RDD</span>[_], firstJobId: <span class="type">Int</span>): <span class="type">List</span>[<span class="type">Stage</span>]</span><br><span class="line">= &#123;</span><br><span class="line">    getShuffleDependencies(rdd).map &#123; shuffleDep =&gt; getOrCreateShuffleMapStage(shuffleDep, firstJobId)</span><br><span class="line">                                    &#125;.toList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>[scheduler] <span class="function"><span class="keyword">def</span> <span class="title">getShuffleDependencies</span></span>(</span><br><span class="line">    rdd: <span class="type">RDD</span>[_]): <span class="type">HashSet</span>[<span class="type">ShuffleDependency</span>[_, _, _]] = &#123;</span><br><span class="line">    <span class="keyword">val</span> parents = <span class="keyword">new</span> <span class="type">HashSet</span>[<span class="type">ShuffleDependency</span>[_, _, _]]</span><br><span class="line">    <span class="keyword">val</span> visited = <span class="keyword">new</span> <span class="type">HashSet</span>[<span class="type">RDD</span>[_]]</span><br><span class="line">    <span class="keyword">val</span> waitingForVisit = <span class="keyword">new</span> <span class="type">Stack</span>[<span class="type">RDD</span>[_]] waitingForVisit</span><br><span class="line">    .push(rdd)</span><br><span class="line">    <span class="keyword">while</span> (waitingForVisit.nonEmpty) &#123;</span><br><span class="line">        <span class="keyword">val</span> toVisit = waitingForVisit.pop()</span><br><span class="line">        <span class="keyword">if</span> (!visited(toVisit)) &#123;</span><br><span class="line">            visited += toVisit toVisit</span><br><span class="line">            .dependencies.foreach &#123;</span><br><span class="line">                <span class="keyword">case</span> shuffleDep: <span class="type">ShuffleDependency</span>[_, _, _] =&gt; parents += shuffleDep</span><br><span class="line">                <span class="keyword">case</span> dependency =&gt; waitingForVisit.push(dependency.rdd)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parents</span><br></pre></td></tr></table></figure></li>
<li><p>RDD 任务划分</p>
<p>RDD 任务切分中间分为：Application、Job、Stage 和 Task</p>
<ul>
<li>Application：初始化一个 SparkContext 即生成一个 Application；</li>
<li>Job：一个 Action 算子就会生成一个 Job；</li>
<li>Stage：Stage 等于宽依赖(ShuffleDependency)的个数加 1；</li>
<li>Task：一个 Stage 阶段中，最后一个 RDD 的分区个数就是 Task 的个数。</li>
</ul>
<p>Application-&gt;job-stage-&gt;Task每一层都是1对n的关系</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202112011603285.png/lvxiaoyi" alt="image-20211201160344883"></p>
</li>
<li><p>RDD 任务划分源码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tasks: <span class="type">Seq</span>[<span class="type">Task</span>[_]] = <span class="keyword">try</span> &#123;</span><br><span class="line">    stage <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> stage: <span class="type">ShuffleMapStage</span> =&gt;</span><br><span class="line">        partitionsToCompute.map &#123; id =&gt;</span><br><span class="line">            <span class="keyword">val</span> locs = taskIdToLocations(id)</span><br><span class="line">            <span class="keyword">val</span> part = stage.rdd.partitions(id)</span><br><span class="line">            <span class="keyword">new</span> <span class="type">ShuffleMapTask</span>(stage.id, stage.latestInfo.attemptId,</span><br><span class="line">                               taskBinary, part, locs, stage.latestInfo.taskMetrics, properties,</span><br><span class="line">                               <span class="type">Option</span>(jobId),</span><br><span class="line">                               <span class="type">Option</span>(sc.applicationId), sc.applicationAttemptId)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> stage: <span class="type">ResultStage</span> =&gt;</span><br><span class="line">        partitionsToCompute.map &#123; id =&gt;</span><br><span class="line">            <span class="keyword">val</span> p: <span class="type">Int</span> = stage.partitions(id)</span><br><span class="line">            <span class="keyword">val</span> part = stage.rdd.partitions(p)</span><br><span class="line">            <span class="keyword">val</span> locs = taskIdToLocations(id)</span><br><span class="line">            <span class="keyword">new</span> <span class="type">ResultTask</span>(stage.id, stage.latestInfo.attemptId,</span><br><span class="line">                           taskBinary, part, locs, id, properties, stage.latestInfo.taskMetrics,</span><br><span class="line">                           <span class="type">Option</span>(jobId), <span class="type">Option</span>(sc.applicationId), sc.applicationAttemptId)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">val</span> partitionsToCompute: <span class="type">Seq</span>[<span class="type">Int</span>] = stage.findMissingPartitions()</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">findMissingPartitions</span></span>(): <span class="type">Seq</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">        mapOutputTrackerMaster</span><br><span class="line">        .findMissingPartitions(shuffleDep.shuffleId)</span><br><span class="line">        .getOrElse(<span class="number">0</span> until numPartitions)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="RDD-持久化"><a href="#RDD-持久化" class="headerlink" title="RDD 持久化"></a>RDD 持久化</h4><ol>
<li><p>RDD Cache 缓存</p>
<p>RDD 通过 Cache 或者 Persist 方法将前面的计算结果缓存，默认情况下会把数据以缓存在 JVM 的堆内存中。但是并不是这两个方法被调用时立即缓存，而是触发后面的 action 算 子时，该 RDD 将会被缓存在计算节点的内存中，并供后面重用（或者数据比较重要，我们也可以把数据缓存下来）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// cache 操作会增加血缘关系，不改变原有的血缘关系</span><br><span class="line">println(wordToOneRdd.toDebugString)</span><br><span class="line">// 数据缓存。</span><br><span class="line">wordToOneRdd.cache()</span><br><span class="line">// 可以更改存储级别</span><br><span class="line">//mapRdd.persist(StorageLevel.MEMORY_AND_DISK_2)</span><br></pre></td></tr></table></figure>

<p>存储级别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">object StorageLevel &#123;</span><br><span class="line"> val NONE = new StorageLevel(false, false, false, false)</span><br><span class="line"> val DISK_ONLY = new StorageLevel(true, false, false, false)</span><br><span class="line"> val DISK_ONLY_2 = new StorageLevel(true, false, false, false, 2)</span><br><span class="line"> val MEMORY_ONLY = new StorageLevel(false, true, false, true)</span><br><span class="line"> val MEMORY_ONLY_2 = new StorageLevel(false, true, false, true, 2)</span><br><span class="line"> val MEMORY_ONLY_SER = new StorageLevel(false, true, false, false)</span><br><span class="line"> val MEMORY_ONLY_SER_2 = new StorageLevel(false, true, false, false, 2)</span><br><span class="line"> val MEMORY_AND_DISK = new StorageLevel(true, true, false, true)</span><br><span class="line"> val MEMORY_AND_DISK_2 = new StorageLevel(true, true, false, true, 2)</span><br><span class="line"> val MEMORY_AND_DISK_SER = new StorageLevel(true, true, false, false)</span><br><span class="line"> val MEMORY_AND_DISK_SER_2 = new StorageLevel(true, true, false, false, 2)</span><br><span class="line"> val OFF_HEAP = new StorageLevel(true, true, true, false, 1)</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111082032177.png/lvxiaoyi" alt="图片5" style="zoom:67%;" />

<p>缓存有可能丢失，或者存储于内存的数据由于内存不足而被删除，RDD 的缓存容错机制保证了即使缓存丢失也能保证计算的正确执行。通过基于 RDD 的一系列转换，丢失的数据会被重算，由于 RDD 的各个 Partition 是相对独立的，因此只需要计算丢失的部分即可，并不需要重算全部 Partition。</p>
<p>Spark 会自动对一些 Shuffle 操作的中间数据做持久化操作(比如：reduceByKey)。这样做的目的是为了当一个节点 Shuffle 失败了避免重新计算整个输入。但是，<strong>在实际使用的时候，如果想重用数据，仍然建议调用 persist 或 cache。</strong></p>
</li>
<li><p>RDD CheckPoint 检查点</p>
<p>所谓的检查点其实就是通过将 RDD 中间结果写入磁盘由于血缘依赖过长会造成容错成本过高，这样就不如在中间阶段做检查点容错，如果检查点</p>
<p>之后有节点出现问题，可以从检查点开始重做血缘，减少了开销。对 RDD 进行 checkpoint 操作并不会马上被执行，必须执行 Action 操作才能触发。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置检查点路径</span></span><br><span class="line">sc.setCheckpointDir(<span class="string">&quot;./checkpoint1&quot;</span>)</span><br><span class="line"><span class="comment">// 创建一个 RDD，读取指定位置文件:hello atguigu atguigu</span></span><br><span class="line"><span class="keyword">val</span> lineRdd: <span class="type">RDD</span>[<span class="type">String</span>]</span><br><span class="line">= sc.textFile(<span class="string">&quot;input/1.txt&quot;</span>)</span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line"><span class="keyword">val</span> wordRdd: <span class="type">RDD</span>[<span class="type">String</span>] = lineRdd.flatMap(line =&gt; line.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"><span class="keyword">val</span> wordToOneRdd: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Long</span>)] = wordRdd.map &#123; word =&gt; &#123;</span><br><span class="line">    (word, <span class="type">System</span>.currentTimeMillis())</span><br><span class="line">&#125;</span><br><span class="line">                                                    &#125;</span><br><span class="line"><span class="comment">// 增加缓存,避免再重新跑一个 job 做checkpoint</span></span><br><span class="line">wordToOneRdd.cache()</span><br><span class="line"><span class="comment">// 数据检查点：针对 wordToOneRdd 做检查点计算</span></span><br><span class="line">wordToOneRdd.checkpoint()</span><br><span class="line"><span class="comment">// 触发执行逻辑</span></span><br><span class="line">wordToOneRdd.collect().foreach(println)</span><br></pre></td></tr></table></figure></li>
<li><p>缓存和检查点区别</p>
<ol>
<li><p>Cache 缓存只是将数据保存起来，不切断血缘依赖。Checkpoint 检查点切断血缘依赖。</p>
</li>
<li><p>Cache 缓存的数据通常存储在磁盘、内存等地方，可靠性低。Checkpoint 的数据通常存储在 HDFS 等容错、高可用的文件系统，可靠性高。</p>
</li>
<li><p>建议对 checkpoint()的 RDD 使用 Cache 缓存，这样 checkpoint 的 job 只需从 Cache 缓存中读取数据即可，否则需要再从头计算一次 RDD。在执行过程中，会切断血源关系，重新建立新的血源关系 checkpoint等同于改变数据源</p>
</li>
</ol>
</li>
</ol>
<h4 id="RDD-分区器"><a href="#RDD-分区器" class="headerlink" title="RDD 分区器"></a>RDD 分区器</h4><p>Spark 目前支持 Hash 分区和 Range 分区，和用户自定义分区。Hash 分区为当前的默认分区。分区器直接决定了 RDD 中分区的个数、RDD 中每条数据经过 Shuffle 后进入哪个分区，进而决定了 Reduce 的个数。</p>
<ul>
<li><p>只有 Key-Value 类型的 RDD 才有分区器，非 Key-Value 类型的 RDD 分区的值是 None</p>
</li>
<li><p>每个 RDD 的分区 ID 范围：0 ~ (numPartitions - 1)，决定这个值是属于那个分区的。</p>
</li>
</ul>
<ol>
<li><p>Hash 分区：对于给定的 key，计算其 hashCode,并除以分区个数取余</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashPartitioner</span>(<span class="params">partitions: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">  require(partitions &gt;= <span class="number">0</span>, <span class="string">s&quot;Number of partitions (<span class="subst">$partitions</span>) cannot be negative.&quot;</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = key <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">null</span> =&gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="type">Utils</span>.nonNegativeMod(key.hashCode, numPartitions)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span>= partitions</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">equals</span></span>(other: <span class="type">Any</span>): <span class="type">Boolean</span> = other <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> h: <span class="type">HashPartitioner</span> =&gt; h.numPartitions == numPartitions</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">hashCode</span></span>: <span class="type">Int</span> = numPartitions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Range 分区：将一定范围内的数据映射到一个分区中，尽量保证每个分区数据均匀，而且分区间有序</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangePartitioner</span>[<span class="type">K</span>: <span class="type">Ordering</span> : <span class="type">ClassTag</span>, <span class="type">V</span>](<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">                                                   partitions: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                                                   rdd: <span class="type">RDD</span>[_ &lt;: <span class="type">Product2</span>[<span class="type">K</span>, <span class="type">V</span>]],</span></span></span><br><span class="line"><span class="params"><span class="class">                                                   private var ascending: <span class="type">Boolean</span> = true</span>)</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">Partitioner</span> &#123;</span><br><span class="line">  <span class="comment">// We allow partitions = 0, which happens when sorting an empty RDD under thedefault settings.</span></span><br><span class="line">  require(partitions &gt;= <span class="number">0</span>, <span class="string">s&quot;Number of partitions cannot be negative but found <span class="subst">$partitions</span>.&quot;</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> ordering = implicitly[<span class="type">Ordering</span>[<span class="type">K</span>]]</span><br><span class="line">  <span class="comment">// An array of upper bounds for the first (partitions - 1) partitions</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> rangeBounds: <span class="type">Array</span>[<span class="type">K</span>] = &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> binarySearch: ((<span class="type">Array</span>[<span class="type">K</span>], <span class="type">K</span>) =&gt; <span class="type">Int</span>) = <span class="type">CollectionsUtils</span>.makeBinarySearch[<span class="type">K</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span> = rangeBounds.length + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> k = key.asInstanceOf[<span class="type">K</span>]</span><br><span class="line">    <span class="keyword">var</span> partition = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (rangeBounds.length &lt;= <span class="number">128</span>) &#123;</span><br><span class="line">      <span class="comment">// If we have less than 128 partitions naive search</span></span><br><span class="line">      <span class="keyword">while</span> (partition &lt; rangeBounds.length &amp;&amp; ordering.gt(k,</span><br><span class="line">        rangeBounds(partition))) &#123;</span><br><span class="line">        partition += <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Determine which binary search method to use only once.</span></span><br><span class="line">      partition = binarySearch(rangeBounds, k)</span><br><span class="line">      <span class="comment">// binarySearch either returns the match location or -[insertion point]-1</span></span><br><span class="line">      <span class="keyword">if</span> (partition &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        partition = -partition - <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (partition &gt; rangeBounds.length) &#123;</span><br><span class="line">        partition = rangeBounds.length</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ascending) &#123;</span><br><span class="line">      partition</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      rangeBounds.length - partition</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">equals</span></span>(other: <span class="type">Any</span>): <span class="type">Boolean</span> = other <span class="keyword">match</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">hashCode</span></span>(): <span class="type">Int</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@throws</span>(classOf[<span class="type">IOException</span>])</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">writeObject</span></span>(out: <span class="type">ObjectOutputStream</span>): <span class="type">Unit</span> =</span><br><span class="line">    <span class="type">Utils</span>.tryOrIOException &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@throws</span>(classOf[<span class="type">IOException</span>])</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">readObject</span></span>(in: <span class="type">ObjectInputStream</span>): <span class="type">Unit</span> = <span class="type">Utils</span>.tryOrIOException &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>自定义分区</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPartitioner</span> <span class="keyword">extends</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分区数量</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据数据的key值返回数据所在的分区索引（从0开始)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">        key <span class="keyword">match</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;nba&quot;</span> =&gt; <span class="number">0</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;wnba&quot;</span> =&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">case</span> _ =&gt; <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="RDD-文件读取与保存"><a href="#RDD-文件读取与保存" class="headerlink" title="RDD 文件读取与保存"></a>RDD 文件读取与保存</h4><p>Spark 的数据读取及数据保存可以从两个维度来作区分：文件格式以及文件系统。文件格式分为：text 文件、csv 文件、sequence 文件以及 Object 文件；文件系统分为：本地文件系统、HDFS、HBASE 以及数据库。</p>
<p>text 文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 读取输入文件</span><br><span class="line">val inputRDD: RDD[String] = sc.textFile(&quot;input/1.txt&quot;)</span><br><span class="line">// 保存数据</span><br><span class="line">inputRDD.saveAsTextFile(&quot;output&quot;)</span><br></pre></td></tr></table></figure>

<p>sequence 文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 保存数据为 SequenceFile</span><br><span class="line">dataRDD.saveAsSequenceFile(&quot;output&quot;)</span><br><span class="line">// 读取 SequenceFile 文件</span><br><span class="line">sc.sequenceFile[Int,Int](&quot;output&quot;).collect().foreach(println)</span><br></pre></td></tr></table></figure>

<p>object 对象文件</p>
<p>对象文件是将对象序列化后保存的文件，采用 Java 的序列化机制。可以通过 <code>objectFile[T: ClassTag](path)</code>函数接收一个路径，读取对象文件，返回对应的 RDD，也可以通过调用saveAsObjectFile()实现对对象文件的输出。因为是序列化所以要指定类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 保存数据</span><br><span class="line">dataRDD.saveAsObjectFile(&quot;output&quot;)</span><br><span class="line">// 读取数据</span><br><span class="line">sc.objectFile[Int](&quot;output&quot;).collect().foreach(println)</span><br></pre></td></tr></table></figure>

<h2 id="累加器"><a href="#累加器" class="headerlink" title="累加器"></a>累加器</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>累加器用来把 Executor 端变量信息聚合到 Driver 端。在 Driver 程序中定义的变量，在Executor 端的每个 Task 都会得到这个变量的一份新的副本，每个 task 更新这些副本的值后，传回 Driver 端进行 merge。</p>
<p>累加器我们一般使用在行动算子中，因为可能造成数据的多加和少加</p>
<h3 id="基础编程-1"><a href="#基础编程-1" class="headerlink" title="基础编程"></a>基础编程</h3><h4 id="系统累加器"><a href="#系统累加器" class="headerlink" title="系统累加器"></a>系统累加器</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line"><span class="comment">// 声明累加器，这里也有doubleAccumulator等类型的累加器</span></span><br><span class="line"><span class="keyword">var</span> sum = sc.longAccumulator(<span class="string">&quot;sum&quot;</span>);</span><br><span class="line">rdd.foreach(</span><br><span class="line">    num =&gt; &#123;</span><br><span class="line">        <span class="comment">// 使用累加器</span></span><br><span class="line">        sum.add(num)</span><br><span class="line">    &#125; )</span><br><span class="line"><span class="comment">// 获取累加器的值</span></span><br><span class="line">println(<span class="string">&quot;sum = &quot;</span> + sum.value)</span><br></pre></td></tr></table></figure>

<h4 id="自定义累加器"><a href="#自定义累加器" class="headerlink" title="自定义累加器"></a>自定义累加器</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义累加器</span></span><br><span class="line"><span class="comment">// 1. 继承 ，并设定泛型</span></span><br><span class="line"><span class="comment">// 2. 重写累加器的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordCountAccumulator</span> <span class="keyword">extends</span> <span class="title">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]]</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> map : mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = mutable.<span class="type">Map</span>()</span><br><span class="line">    <span class="comment">// 累加器是否为初始状态</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isZero</span></span>: <span class="type">Boolean</span> = &#123;</span><br><span class="line">        map.isEmpty</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制累加器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">copy</span></span>(): <span class="type">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]] = &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">WordCountAccumulator</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置累加器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">        map.clear()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向累加器中增加数据 (In)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(word: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 查询 map 中是否存在相同的单词</span></span><br><span class="line">        <span class="comment">// 如果有相同的单词，那么单词的数量加 1</span></span><br><span class="line">        <span class="comment">// 如果没有相同的单词，那么在 map 中增加这个单词</span></span><br><span class="line">        map(word) = map.getOrElse(word, <span class="number">0</span>L) + <span class="number">1</span>L</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并累加器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(other: <span class="type">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> map1 = map</span><br><span class="line">        <span class="keyword">val</span> map2 = other.value</span><br><span class="line">        <span class="comment">// 两个 Map 的合并</span></span><br><span class="line">        map = map1.foldLeft(map2)(</span><br><span class="line">            ( innerMap, kv ) =&gt; &#123;</span><br><span class="line">                innerMap(kv._1) = innerMap.getOrElse(kv._1, <span class="number">0</span>L) + kv._2</span><br><span class="line">                innerMap</span><br><span class="line">            &#125;</span><br><span class="line">        ) &#125;</span><br><span class="line">    <span class="comment">// 返回累加器的结果 （Out）</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="广播变量"><a href="#广播变量" class="headerlink" title="广播变量"></a>广播变量</h2><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>广播变量用来高效分发较大的对象。向所有工作节点发送一个较大的只读值，以供一个或多个 Spark 操作使用。比如，如果你的应用需要向所有节点发送一个较大的只读查询表，广播变量用起来都很顺手。在多个并行操作中使用同一个变量，但是 Spark 会为每个任务分别发送。</p>
<h3 id="基础编程-2"><a href="#基础编程-2" class="headerlink" title="基础编程"></a>基础编程</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">List</span>((<span class="string">&quot;a&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">3</span>), (<span class="string">&quot;d&quot;</span>, <span class="number">4</span>)), <span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>((<span class="string">&quot;a&quot;</span>, <span class="number">4</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">5</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">6</span>), (<span class="string">&quot;d&quot;</span>, <span class="number">7</span>))</span><br><span class="line"><span class="comment">// 声明广播变量</span></span><br><span class="line"><span class="keyword">val</span> broadcast: <span class="type">Broadcast</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = sc.broadcast(list)</span><br><span class="line"><span class="keyword">val</span> resultRDD: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Int</span>))] = rdd1.map &#123;</span><br><span class="line">    <span class="keyword">case</span> (key, num) =&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> num2 = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 使用广播变量</span></span><br><span class="line">        <span class="keyword">for</span> ((k, v) &lt;- broadcast.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                num2 = v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        (key, (num, num2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Spark-案例实操"><a href="#Spark-案例实操" class="headerlink" title="Spark 案例实操"></a>Spark 案例实操</h1><p>在之前的学习中，我们已经学习了 Spark 的基础编程方式，接下来，我们看看在实际的工作中如何使用这些 API 实现具体的需求。这些需求是电商网站的真实需求，所以在实现功能前，咱们必须先将数据准备好。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/94c1f573fd7a5ff30447fbdd446c5b15.png" alt="img"></p>
<p>上面的数据图是从数据文件中截取的一部分内容，表示为电商网站的用户行为数据，主要包含用户的 4 种行为：搜索，点击，下单，支付。数据规则如下：</p>
<ul>
<li><p>数据文件中每行数据采用下划线分隔数据</p>
</li>
<li><p>每一行数据表示用户的一次行为，这个行为只能是 4 种行为的一种</p>
</li>
<li><p>如果搜索关键字为 null,表示数据不是搜索数据</p>
</li>
<li><p>如果点击的品类 ID 和产品 ID 为-1，表示数据不是点击数据</p>
</li>
<li><p>针对于下单行为，一次可以下单多个商品，所以品类 ID 和产品 ID 可以是多个，id 之间采用逗号分隔，如果本次不是下单行为，则数据采用 null 表示</p>
</li>
</ul>
<p>支付行为和下单行为类似</p>
<p>详细字段说明：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>字段名称</th>
<th>字段类型</th>
<th>字段含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>date</td>
<td>String</td>
<td>用户点击行为的日期</td>
</tr>
<tr>
<td>2</td>
<td>user_id</td>
<td>Long</td>
<td>用户的 ID</td>
</tr>
<tr>
<td>3</td>
<td>session_id</td>
<td>String</td>
<td>Session 的 ID</td>
</tr>
<tr>
<td>4</td>
<td>page_id</td>
<td>Long</td>
<td>某个页面的 ID</td>
</tr>
<tr>
<td>5</td>
<td>action_time</td>
<td>String</td>
<td>动作的时间点</td>
</tr>
<tr>
<td>6</td>
<td>search_keyword</td>
<td>String</td>
<td>用户搜索的关键词</td>
</tr>
<tr>
<td>7</td>
<td>click_category_id</td>
<td>Long</td>
<td>某一个商品品类的 ID</td>
</tr>
<tr>
<td>8</td>
<td>click_product_id</td>
<td>Long</td>
<td>某一个商品的 ID</td>
</tr>
<tr>
<td>9</td>
<td>order_category_ids</td>
<td>String</td>
<td>一次订单中所有品类的 ID 集合</td>
</tr>
<tr>
<td>10</td>
<td>order_product_ids</td>
<td>String</td>
<td>一次订单中所有商品的 ID 集合</td>
</tr>
<tr>
<td>11</td>
<td>pay_category_ids</td>
<td>String</td>
<td>一次支付中所有品类的 ID 集合</td>
</tr>
<tr>
<td>12</td>
<td>pay_product_ids</td>
<td>String</td>
<td>一次支付中所有商品的 ID 集合</td>
</tr>
<tr>
<td>13</td>
<td>city_id</td>
<td>Long</td>
<td>城市 id</td>
</tr>
</tbody></table>
<p>样例类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//用户访问动作表</span><br><span class="line">case class UserVisitAction(</span><br><span class="line"> date: String,//用户点击行为的日期</span><br><span class="line"> user_id: Long,//用户的 ID</span><br><span class="line"> session_id: String,//Session 的 ID</span><br><span class="line"> page_id: Long,//某个页面的 ID</span><br><span class="line"> action_time: String,//动作的时间点</span><br><span class="line"> search_keyword: String,//用户搜索的关键词</span><br><span class="line"> click_category_id: Long,//某一个商品品类的 ID</span><br><span class="line"> click_product_id: Long,//某一个商品的 ID</span><br><span class="line"> order_category_ids: String,//一次订单中所有品类的 ID 集合</span><br><span class="line"> order_product_ids: String,//一次订单中所有商品的 ID 集合</span><br><span class="line"> pay_category_ids: String,//一次支付中所有品类的 ID 集合</span><br><span class="line"> pay_product_ids: String,//一次支付中所有商品的 ID 集合</span><br><span class="line"> city_id: Long</span><br><span class="line">)//城市 id</span><br></pre></td></tr></table></figure>

<h2 id="需求-1：Top10-热门品类"><a href="#需求-1：Top10-热门品类" class="headerlink" title="需求 1：Top10 热门品类"></a>需求 1：Top10 热门品类</h2><h3 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h3><p>品类是指产品的分类，大型电商网站品类分多级，咱们的项目中品类只有一级，不同的</p>
<p>公司可能对热门的定义不一样。我们按照每个品类的点击、下单、支付的量来统计热门品类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">鞋 	点击数 下单数 支付数</span><br><span class="line">衣服 点击数 下单数 支付数</span><br><span class="line">电脑 点击数 下单数 支付数</span><br></pre></td></tr></table></figure>

<p>例如，综合排名 = 点击数<em>20%+下单数</em>30%+支付数*50%</p>
<p>本项目需求优化为：先按照点击数排名，靠前的就排名高；如果点击数相同，再比较下单数；下单数再相同，就比较支付数。</p>
<h3 id="实现方案一"><a href="#实现方案一" class="headerlink" title="实现方案一"></a>实现方案一</h3><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>分别统计每个品类点击的次数，下单的次数和支付的次数：（品类，点击总数）（品类，下单总数）（品类，支付总数）</p>
<h4 id="需求实现"><a href="#需求实现" class="headerlink" title="需求实现"></a>需求实现</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.req</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_Req1_HotCategoryTop10Analysis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO : Top10热门品类</span></span><br><span class="line">        <span class="keyword">val</span> sparConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;HotCategoryTop10Analysis&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparConf)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 读取原始日志数据</span></span><br><span class="line">        <span class="keyword">val</span> actionRDD = sc.textFile(<span class="string">&quot;datas/user_visit_action.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 统计品类的点击数量：（品类ID，点击数量）</span></span><br><span class="line">        <span class="keyword">val</span> clickActionRDD = actionRDD.filter(</span><br><span class="line">            action =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = action.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                datas(<span class="number">6</span>) != <span class="string">&quot;-1&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> clickCountRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = clickActionRDD.map(</span><br><span class="line">            action =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = action.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                (datas(<span class="number">6</span>), <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        ).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 统计品类的下单数量：（品类ID，下单数量）</span></span><br><span class="line">        <span class="keyword">val</span> orderActionRDD = actionRDD.filter(</span><br><span class="line">            action =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = action.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                datas(<span class="number">8</span>) != <span class="string">&quot;null&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// orderid =&gt; 1,2,3</span></span><br><span class="line">        <span class="comment">// 【(1,1)，(2,1)，(3,1)】</span></span><br><span class="line">        <span class="keyword">val</span> orderCountRDD = orderActionRDD.flatMap(</span><br><span class="line">            action =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = action.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                <span class="keyword">val</span> cid = datas(<span class="number">8</span>)</span><br><span class="line">                <span class="keyword">val</span> cids = cid.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">                cids.map(id=&gt;(id, <span class="number">1</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        ).reduceByKey(_+_)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 统计品类的支付数量：（品类ID，支付数量）</span></span><br><span class="line">        <span class="keyword">val</span> payActionRDD = actionRDD.filter(</span><br><span class="line">            action =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = action.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                datas(<span class="number">10</span>) != <span class="string">&quot;null&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// orderid =&gt; 1,2,3</span></span><br><span class="line">        <span class="comment">// 【(1,1)，(2,1)，(3,1)】</span></span><br><span class="line">        <span class="keyword">val</span> payCountRDD = payActionRDD.flatMap(</span><br><span class="line">            action =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = action.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                <span class="keyword">val</span> cid = datas(<span class="number">10</span>)</span><br><span class="line">                <span class="keyword">val</span> cids = cid.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">                cids.map(id=&gt;(id, <span class="number">1</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        ).reduceByKey(_+_)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 将品类进行排序，并且取前10名</span></span><br><span class="line">        <span class="comment">//    点击数量排序，下单数量排序，支付数量排序</span></span><br><span class="line">        <span class="comment">//    元组排序：先比较第一个，再比较第二个，再比较第三个，依此类推</span></span><br><span class="line">        <span class="comment">//    ( 品类ID, ( 点击数量, 下单数量, 支付数量 ) )</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//  cogroup = connect + group</span></span><br><span class="line">        <span class="keyword">val</span> cogroupRDD: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Iterable</span>[<span class="type">Int</span>], <span class="type">Iterable</span>[<span class="type">Int</span>], <span class="type">Iterable</span>[<span class="type">Int</span>]))] =</span><br><span class="line">            clickCountRDD.cogroup(orderCountRDD, payCountRDD)</span><br><span class="line">        <span class="keyword">val</span> analysisRDD = cogroupRDD.mapValues&#123;</span><br><span class="line">            <span class="keyword">case</span> ( clickIter, orderIter, payIter ) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> clickCnt = <span class="number">0</span></span><br><span class="line">                <span class="keyword">val</span> iter1 = clickIter.iterator</span><br><span class="line">                <span class="keyword">if</span> ( iter1.hasNext ) &#123;</span><br><span class="line">                    clickCnt = iter1.next()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> orderCnt = <span class="number">0</span></span><br><span class="line">                <span class="keyword">val</span> iter2 = orderIter.iterator</span><br><span class="line">                <span class="keyword">if</span> ( iter2.hasNext ) &#123;</span><br><span class="line">                    orderCnt = iter2.next()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> payCnt = <span class="number">0</span></span><br><span class="line">                <span class="keyword">val</span> iter3 = payIter.iterator</span><br><span class="line">                <span class="keyword">if</span> ( iter3.hasNext ) &#123;</span><br><span class="line">                    payCnt = iter3.next()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ( clickCnt, orderCnt, payCnt )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> resultRDD = analysisRDD.sortBy(_._2, <span class="literal">false</span>).take(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 将结果采集到控制台打印出来</span></span><br><span class="line">        resultRDD.foreach(println)</span><br><span class="line"></span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.req</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark02_Req1_HotCategoryTop10Analysis1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO : Top10热门品类</span></span><br><span class="line">        <span class="keyword">val</span> sparConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;HotCategoryTop10Analysis&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparConf)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Q : actionRDD重复使用</span></span><br><span class="line">        <span class="comment">// Q : cogroup性能可能较低</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 读取原始日志数据</span></span><br><span class="line">        <span class="keyword">val</span> actionRDD = sc.textFile(<span class="string">&quot;datas/user_visit_action.txt&quot;</span>)</span><br><span class="line">        actionRDD.cache()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 统计品类的点击数量：（品类ID，点击数量）</span></span><br><span class="line">        <span class="keyword">val</span> clickActionRDD = actionRDD.filter(</span><br><span class="line">            action =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = action.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                datas(<span class="number">6</span>) != <span class="string">&quot;-1&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> clickCountRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = clickActionRDD.map(</span><br><span class="line">            action =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = action.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                (datas(<span class="number">6</span>), <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        ).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 统计品类的下单数量：（品类ID，下单数量）</span></span><br><span class="line">        <span class="keyword">val</span> orderActionRDD = actionRDD.filter(</span><br><span class="line">            action =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = action.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                datas(<span class="number">8</span>) != <span class="string">&quot;null&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// orderid =&gt; 1,2,3</span></span><br><span class="line">        <span class="comment">// 【(1,1)，(2,1)，(3,1)】</span></span><br><span class="line">        <span class="keyword">val</span> orderCountRDD = orderActionRDD.flatMap(</span><br><span class="line">            action =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = action.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                <span class="keyword">val</span> cid = datas(<span class="number">8</span>)</span><br><span class="line">                <span class="keyword">val</span> cids = cid.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">                cids.map(id=&gt;(id, <span class="number">1</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        ).reduceByKey(_+_)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 统计品类的支付数量：（品类ID，支付数量）</span></span><br><span class="line">        <span class="keyword">val</span> payActionRDD = actionRDD.filter(</span><br><span class="line">            action =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = action.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                datas(<span class="number">10</span>) != <span class="string">&quot;null&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// orderid =&gt; 1,2,3</span></span><br><span class="line">        <span class="comment">// 【(1,1)，(2,1)，(3,1)】</span></span><br><span class="line">        <span class="keyword">val</span> payCountRDD = payActionRDD.flatMap(</span><br><span class="line">            action =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = action.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                <span class="keyword">val</span> cid = datas(<span class="number">10</span>)</span><br><span class="line">                <span class="keyword">val</span> cids = cid.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">                cids.map(id=&gt;(id, <span class="number">1</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        ).reduceByKey(_+_)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (品类ID, 点击数量) =&gt; (品类ID, (点击数量, 0, 0))</span></span><br><span class="line">        <span class="comment">// (品类ID, 下单数量) =&gt; (品类ID, (0, 下单数量, 0))</span></span><br><span class="line">        <span class="comment">//                    =&gt; (品类ID, (点击数量, 下单数量, 0))</span></span><br><span class="line">        <span class="comment">// (品类ID, 支付数量) =&gt; (品类ID, (0, 0, 支付数量))</span></span><br><span class="line">        <span class="comment">//                    =&gt; (品类ID, (点击数量, 下单数量, 支付数量))</span></span><br><span class="line">        <span class="comment">// ( 品类ID, ( 点击数量, 下单数量, 支付数量 ) )</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 将品类进行排序，并且取前10名</span></span><br><span class="line">        <span class="comment">//    点击数量排序，下单数量排序，支付数量排序</span></span><br><span class="line">        <span class="comment">//    元组排序：先比较第一个，再比较第二个，再比较第三个，依此类推</span></span><br><span class="line">        <span class="comment">//    ( 品类ID, ( 点击数量, 下单数量, 支付数量 ) )</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">val</span> rdd1 = clickCountRDD.map&#123;</span><br><span class="line">            <span class="keyword">case</span> ( cid, cnt ) =&gt; &#123;</span><br><span class="line">                (cid, (cnt, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> rdd2 = orderCountRDD.map&#123;</span><br><span class="line">            <span class="keyword">case</span> ( cid, cnt ) =&gt; &#123;</span><br><span class="line">                (cid, (<span class="number">0</span>, cnt, <span class="number">0</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> rdd3 = payCountRDD.map&#123;</span><br><span class="line">            <span class="keyword">case</span> ( cid, cnt ) =&gt; &#123;</span><br><span class="line">                (cid, (<span class="number">0</span>, <span class="number">0</span>, cnt))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将三个数据源合并在一起，统一进行聚合计算</span></span><br><span class="line">        <span class="keyword">val</span> soruceRDD: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>))] = rdd1.union(rdd2).union(rdd3)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> analysisRDD = soruceRDD.reduceByKey(</span><br><span class="line">            ( t1, t2 ) =&gt; &#123;</span><br><span class="line">                ( t1._1+t2._1, t1._2 + t2._2, t1._3 + t2._3 )</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> resultRDD = analysisRDD.sortBy(_._2, <span class="literal">false</span>).take(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 将结果采集到控制台打印出来</span></span><br><span class="line">        resultRDD.foreach(println)</span><br><span class="line"></span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="实现方案二"><a href="#实现方案二" class="headerlink" title="实现方案二"></a>实现方案二</h3><h4 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h4><p>一次性统计每个品类点击的次数，下单的次数和支付的次数：（品类，（点击总数，下单总数，支付总数）） </p>
<h4 id="需求实现-1"><a href="#需求实现-1" class="headerlink" title="需求实现"></a>需求实现</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.req</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark03_Req1_HotCategoryTop10Analysis2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO : Top10热门品类</span></span><br><span class="line">        <span class="keyword">val</span> sparConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;HotCategoryTop10Analysis&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparConf)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Q : 存在大量的shuffle操作（reduceByKey）</span></span><br><span class="line">        <span class="comment">// reduceByKey 聚合算子，spark会提供优化，缓存</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 读取原始日志数据</span></span><br><span class="line">        <span class="keyword">val</span> actionRDD = sc.textFile(<span class="string">&quot;datas/user_visit_action.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将数据转换结构</span></span><br><span class="line">        <span class="comment">//    点击的场合 : ( 品类ID，( 1, 0, 0 ) )</span></span><br><span class="line">        <span class="comment">//    下单的场合 : ( 品类ID，( 0, 1, 0 ) )</span></span><br><span class="line">        <span class="comment">//    支付的场合 : ( 品类ID，( 0, 0, 1 ) )</span></span><br><span class="line">        <span class="keyword">val</span> flatRDD: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>))] = actionRDD.flatMap(</span><br><span class="line">            action =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = action.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> (datas(<span class="number">6</span>) != <span class="string">&quot;-1&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 点击的场合</span></span><br><span class="line">                    <span class="type">List</span>((datas(<span class="number">6</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)))</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (datas(<span class="number">8</span>) != <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 下单的场合</span></span><br><span class="line">                    <span class="keyword">val</span> ids = datas(<span class="number">8</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">                    ids.map(id =&gt; (id, (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)))</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (datas(<span class="number">10</span>) != <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 支付的场合</span></span><br><span class="line">                    <span class="keyword">val</span> ids = datas(<span class="number">10</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">                    ids.map(id =&gt; (id, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">Nil</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将相同的品类ID的数据进行分组聚合</span></span><br><span class="line">        <span class="comment">//    ( 品类ID，( 点击数量, 下单数量, 支付数量 ) )</span></span><br><span class="line">        <span class="keyword">val</span> analysisRDD = flatRDD.reduceByKey(</span><br><span class="line">            (t1, t2) =&gt; &#123;</span><br><span class="line">                ( t1._1+t2._1, t1._2 + t2._2, t1._3 + t2._3 )</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将统计结果根据数量进行降序处理，取前10名</span></span><br><span class="line">        <span class="keyword">val</span> resultRDD = analysisRDD.sortBy(_._2, <span class="literal">false</span>).take(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 将结果采集到控制台打印出来</span></span><br><span class="line">        resultRDD.foreach(println)</span><br><span class="line"></span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="实现方案二-1"><a href="#实现方案二-1" class="headerlink" title="实现方案二"></a>实现方案二</h3><h4 id="需求分析-2"><a href="#需求分析-2" class="headerlink" title="需求分析"></a>需求分析</h4><p>使用累加器的方式聚合数据</p>
<h4 id="需求实现-2"><a href="#需求实现-2" class="headerlink" title="需求实现"></a>需求实现</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.req</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.util.<span class="type">AccumulatorV2</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark04_Req1_HotCategoryTop10Analysis3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO : Top10热门品类</span></span><br><span class="line">        <span class="keyword">val</span> sparConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;HotCategoryTop10Analysis&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparConf)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 读取原始日志数据</span></span><br><span class="line">        <span class="keyword">val</span> actionRDD = sc.textFile(<span class="string">&quot;datas/user_visit_action.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> acc = <span class="keyword">new</span> <span class="type">HotCategoryAccumulator</span></span><br><span class="line">        sc.register(acc, <span class="string">&quot;hotCategory&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将数据转换结构</span></span><br><span class="line">        actionRDD.foreach(</span><br><span class="line">            action =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = action.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> (datas(<span class="number">6</span>) != <span class="string">&quot;-1&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 点击的场合</span></span><br><span class="line">                    acc.add((datas(<span class="number">6</span>), <span class="string">&quot;click&quot;</span>))</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (datas(<span class="number">8</span>) != <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 下单的场合</span></span><br><span class="line">                    <span class="keyword">val</span> ids = datas(<span class="number">8</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">                    ids.foreach(</span><br><span class="line">                        id =&gt; &#123;</span><br><span class="line">                            acc.add( (id, <span class="string">&quot;order&quot;</span>) )</span><br><span class="line">                        &#125;</span><br><span class="line">                    )</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (datas(<span class="number">10</span>) != <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 支付的场合</span></span><br><span class="line">                    <span class="keyword">val</span> ids = datas(<span class="number">10</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">                    ids.foreach(</span><br><span class="line">                        id =&gt; &#123;</span><br><span class="line">                            acc.add( (id, <span class="string">&quot;pay&quot;</span>) )</span><br><span class="line">                        &#125;</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> accVal: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">HotCategory</span>] = acc.value</span><br><span class="line">        <span class="keyword">val</span> categories: mutable.<span class="type">Iterable</span>[<span class="type">HotCategory</span>] = accVal.map(_._2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> sort = categories.toList.sortWith(</span><br><span class="line">            (left, right) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> ( left.clickCnt &gt; right.clickCnt ) &#123;</span><br><span class="line">                    <span class="literal">true</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left.clickCnt == right.clickCnt) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( left.orderCnt &gt; right.orderCnt ) &#123;</span><br><span class="line">                        <span class="literal">true</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left.orderCnt == right.orderCnt) &#123;</span><br><span class="line">                        left.payCnt &gt; right.payCnt</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 将结果采集到控制台打印出来</span></span><br><span class="line">        sort.take(<span class="number">10</span>).foreach(println)</span><br><span class="line"></span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">HotCategory</span>(<span class="params"> cid:<span class="type">String</span>, var clickCnt : <span class="type">Int</span>, var orderCnt : <span class="type">Int</span>, var payCnt : <span class="type">Int</span> </span>)</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 自定义累加器</span></span><br><span class="line"><span class="comment">      * 1. 继承AccumulatorV2，定义泛型</span></span><br><span class="line"><span class="comment">      *    IN : ( 品类ID, 行为类型 )</span></span><br><span class="line"><span class="comment">      *    OUT : mutable.Map[String, HotCategory]</span></span><br><span class="line"><span class="comment">      * 2. 重写方法（6）</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HotCategoryAccumulator</span> <span class="keyword">extends</span> <span class="title">AccumulatorV2</span>[(<span class="type">String</span>, <span class="type">String</span>), mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">HotCategory</span>]]</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> hcMap = mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">HotCategory</span>]()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isZero</span></span>: <span class="type">Boolean</span> = &#123;</span><br><span class="line">            hcMap.isEmpty</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">copy</span></span>(): <span class="type">AccumulatorV2</span>[(<span class="type">String</span>, <span class="type">String</span>), mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">HotCategory</span>]] = &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="type">HotCategoryAccumulator</span>()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">            hcMap.clear()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(v: (<span class="type">String</span>, <span class="type">String</span>)): <span class="type">Unit</span> = &#123;</span><br><span class="line">            <span class="keyword">val</span> cid = v._1</span><br><span class="line">            <span class="keyword">val</span> actionType = v._2</span><br><span class="line">            <span class="keyword">val</span> category: <span class="type">HotCategory</span> = hcMap.getOrElse(cid, <span class="type">HotCategory</span>(cid, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">if</span> ( actionType == <span class="string">&quot;click&quot;</span> ) &#123;</span><br><span class="line">                category.clickCnt += <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == <span class="string">&quot;order&quot;</span>) &#123;</span><br><span class="line">                category.orderCnt += <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == <span class="string">&quot;pay&quot;</span>) &#123;</span><br><span class="line">                category.payCnt += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            hcMap.update(cid, category)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(other: <span class="type">AccumulatorV2</span>[(<span class="type">String</span>, <span class="type">String</span>), mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">HotCategory</span>]]): <span class="type">Unit</span> = &#123;</span><br><span class="line">            <span class="keyword">val</span> map1 = <span class="keyword">this</span>.hcMap</span><br><span class="line">            <span class="keyword">val</span> map2 = other.value</span><br><span class="line"></span><br><span class="line">            map2.foreach&#123;</span><br><span class="line">                <span class="keyword">case</span> ( cid, hc ) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">val</span> category: <span class="type">HotCategory</span> = map1.getOrElse(cid, <span class="type">HotCategory</span>(cid, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">                    category.clickCnt += hc.clickCnt</span><br><span class="line">                    category.orderCnt += hc.orderCnt</span><br><span class="line">                    category.payCnt += hc.payCnt</span><br><span class="line">                    map1.update(cid, category)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">HotCategory</span>] = hcMap</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="需求-2：Top10-热门品类中每个品类的-Top10-活跃-Session-统计"><a href="#需求-2：Top10-热门品类中每个品类的-Top10-活跃-Session-统计" class="headerlink" title="需求 2：Top10 热门品类中每个品类的 Top10 活跃 Session 统计"></a>需求 2：Top10 热门品类中每个品类的 Top10 活跃 Session 统计</h2><h3 id="需求说明-1"><a href="#需求说明-1" class="headerlink" title="需求说明"></a>需求说明</h3><p>在需求一的基础上，增加每个品类用户 session 的点击统计</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.req</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark05_Req2_HotCategoryTop10SessionAnalysis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO : Top10热门品类</span></span><br><span class="line">        <span class="keyword">val</span> sparConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;HotCategoryTop10Analysis&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparConf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> actionRDD = sc.textFile(<span class="string">&quot;datas/user_visit_action.txt&quot;</span>)</span><br><span class="line">        actionRDD.cache()</span><br><span class="line">        <span class="keyword">val</span> top10Ids: <span class="type">Array</span>[<span class="type">String</span>] = top10Category(actionRDD)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 过滤原始数据,保留点击和前10品类ID</span></span><br><span class="line">        <span class="keyword">val</span> filterActionRDD = actionRDD.filter(</span><br><span class="line">            action =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = action.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> ( datas(<span class="number">6</span>) != <span class="string">&quot;-1&quot;</span> ) &#123;</span><br><span class="line">                    top10Ids.contains(datas(<span class="number">6</span>))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 根据品类ID和sessionid进行点击量的统计</span></span><br><span class="line">        <span class="keyword">val</span> reduceRDD: <span class="type">RDD</span>[((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>)] = filterActionRDD.map(</span><br><span class="line">            action =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = action.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                ((datas(<span class="number">6</span>), datas(<span class="number">2</span>)), <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        ).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将统计的结果进行结构的转换</span></span><br><span class="line">        <span class="comment">//  (（ 品类ID，sessionId ）,sum) =&gt; ( 品类ID，（sessionId, sum） )</span></span><br><span class="line">        <span class="keyword">val</span> mapRDD = reduceRDD.map&#123;</span><br><span class="line">            <span class="keyword">case</span> ( (cid, sid), sum ) =&gt; &#123;</span><br><span class="line">                ( cid, (sid, sum) )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 相同的品类进行分组</span></span><br><span class="line">        <span class="keyword">val</span> groupRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[(<span class="type">String</span>, <span class="type">Int</span>)])] = mapRDD.groupByKey()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 将分组后的数据进行点击量的排序，取前10名</span></span><br><span class="line">        <span class="keyword">val</span> resultRDD = groupRDD.mapValues(</span><br><span class="line">            iter =&gt; &#123;</span><br><span class="line">                iter.toList.sortBy(_._2)(<span class="type">Ordering</span>.<span class="type">Int</span>.reverse).take(<span class="number">10</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        resultRDD.collect().foreach(println)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top10Category</span></span>(actionRDD:<span class="type">RDD</span>[<span class="type">String</span>]) = &#123;</span><br><span class="line">        <span class="keyword">val</span> flatRDD: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>))] = actionRDD.flatMap(</span><br><span class="line">            action =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = action.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> (datas(<span class="number">6</span>) != <span class="string">&quot;-1&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 点击的场合</span></span><br><span class="line">                    <span class="type">List</span>((datas(<span class="number">6</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)))</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (datas(<span class="number">8</span>) != <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 下单的场合</span></span><br><span class="line">                    <span class="keyword">val</span> ids = datas(<span class="number">8</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">                    ids.map(id =&gt; (id, (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)))</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (datas(<span class="number">10</span>) != <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 支付的场合</span></span><br><span class="line">                    <span class="keyword">val</span> ids = datas(<span class="number">10</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">                    ids.map(id =&gt; (id, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">Nil</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> analysisRDD = flatRDD.reduceByKey(</span><br><span class="line">            (t1, t2) =&gt; &#123;</span><br><span class="line">                ( t1._1+t2._1, t1._2 + t2._2, t1._3 + t2._3 )</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        analysisRDD.sortBy(_._2, <span class="literal">false</span>).take(<span class="number">10</span>).map(_._1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="需求-3：页面单跳转换率统计"><a href="#需求-3：页面单跳转换率统计" class="headerlink" title="需求 3：页面单跳转换率统计"></a>需求 3：页面单跳转换率统计</h2><h3 id="需求说明-2"><a href="#需求说明-2" class="headerlink" title="需求说明"></a>需求说明</h3><ol>
<li><p>页面单跳转化率</p>
<p>计算页面单跳转化率，什么是页面单跳转换率，比如一个用户在一次 Session 过程中访问的页面路径 3,5,7,9,10,21，那么页面 3 跳到页面 5 叫一次单跳，7-9 也叫一次单跳，那么单跳转化率就是要统计页面点击的概率。</p>
<p>比如：计算 3-5 的单跳转化率，先获取符合条件的 Session 对于页面 3 的访问次数（PV） 为 A，然后获取符合条件的 Session 中访问了页面 3 又紧接着访问了页面 5 的次数为 B，那么 B/A 就是 3-5 的页面单跳转化率</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111082046473.png/lvxiaoyi" alt="图片7"></p>
</li>
<li><p>统计页面单跳转化率意义</p>
<p>产品经理和运营总监，可以根据这个指标，去尝试分析，整个网站，产品，各个页面的表现怎么样，是不是需要去优化产品的布局；吸引用户最终可以进入最后的支付页面。</p>
<p>数据分析师，可以此数据做更深一步的计算和分析。</p>
<p>企业管理层，可以看到整个公司的网站，各个页面的之间的跳转的表现如何，可以适当调整公司的经营战略或策略。</p>
</li>
</ol>
<ul>
<li>读取原始数据</li>
<li>将原始数据映射为样例类</li>
<li> 将原始数据根据session进行分组</li>
<li>将分组后的数据根据时间进行排序（升序）</li>
<li> 将排序后的数据进行结构的转换(pageId,1)</li>
<li> 计算分母-将相同的页面id进行聚合统计(pageId,sum)</li>
<li> 计算分子-将页面id进行拉链，形成连续的拉链效果，转换结构(pageId-pageId2,1)</li>
<li> 将转换结构后的数据进行聚合统计(pageId-pageId2,sum)</li>
<li> 计算页面单跳转换率</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.req</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark06_Req3_PageflowAnalysis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO : Top10热门品类</span></span><br><span class="line">        <span class="keyword">val</span> sparConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;HotCategoryTop10Analysis&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparConf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> actionRDD = sc.textFile(<span class="string">&quot;datas/user_visit_action.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> actionDataRDD = actionRDD.map(</span><br><span class="line">            action =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = action.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                <span class="type">UserVisitAction</span>(</span><br><span class="line">                    datas(<span class="number">0</span>),</span><br><span class="line">                    datas(<span class="number">1</span>).toLong,</span><br><span class="line">                    datas(<span class="number">2</span>),</span><br><span class="line">                    datas(<span class="number">3</span>).toLong,</span><br><span class="line">                    datas(<span class="number">4</span>),</span><br><span class="line">                    datas(<span class="number">5</span>),</span><br><span class="line">                    datas(<span class="number">6</span>).toLong,</span><br><span class="line">                    datas(<span class="number">7</span>).toLong,</span><br><span class="line">                    datas(<span class="number">8</span>),</span><br><span class="line">                    datas(<span class="number">9</span>),</span><br><span class="line">                    datas(<span class="number">10</span>),</span><br><span class="line">                    datas(<span class="number">11</span>),</span><br><span class="line">                    datas(<span class="number">12</span>).toLong</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        actionDataRDD.cache()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 对指定的页面连续跳转进行统计</span></span><br><span class="line">        <span class="comment">// 1-2,2-3,3-4,4-5,5-6,6-7</span></span><br><span class="line">        <span class="keyword">val</span> ids = <span class="type">List</span>[<span class="type">Long</span>](<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">        <span class="keyword">val</span> okflowIds: <span class="type">List</span>[(<span class="type">Long</span>, <span class="type">Long</span>)] = ids.zip(ids.tail)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 计算分母</span></span><br><span class="line">        <span class="keyword">val</span> pageidToCountMap: <span class="type">Map</span>[<span class="type">Long</span>, <span class="type">Long</span>] = actionDataRDD.filter(</span><br><span class="line">            action =&gt; &#123;</span><br><span class="line">                ids.init.contains(action.page_id)</span><br><span class="line">            &#125;</span><br><span class="line">        ).map(</span><br><span class="line">            action =&gt; &#123;</span><br><span class="line">                (action.page_id, <span class="number">1</span>L)</span><br><span class="line">            &#125;</span><br><span class="line">        ).reduceByKey(_ + _).collect().toMap</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 计算分子</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据session进行分组</span></span><br><span class="line">        <span class="keyword">val</span> sessionRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[<span class="type">UserVisitAction</span>])] = actionDataRDD.groupBy(_.session_id)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分组后，根据访问时间进行排序（升序）</span></span><br><span class="line">        <span class="keyword">val</span> mvRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">List</span>[((<span class="type">Long</span>, <span class="type">Long</span>), <span class="type">Int</span>)])] = sessionRDD.mapValues(</span><br><span class="line">            iter =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> sortList: <span class="type">List</span>[<span class="type">UserVisitAction</span>] = iter.toList.sortBy(_.action_time)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 【1，2，3，4】</span></span><br><span class="line">                <span class="comment">// 【1，2】，【2，3】，【3，4】</span></span><br><span class="line">                <span class="comment">// 【1-2，2-3，3-4】</span></span><br><span class="line">                <span class="comment">// Sliding : 滑窗</span></span><br><span class="line">                <span class="comment">// 【1，2，3，4】</span></span><br><span class="line">                <span class="comment">// 【2，3，4】</span></span><br><span class="line">                <span class="comment">// zip : 拉链</span></span><br><span class="line">                <span class="keyword">val</span> flowIds: <span class="type">List</span>[<span class="type">Long</span>] = sortList.map(_.page_id)</span><br><span class="line">                <span class="keyword">val</span> pageflowIds: <span class="type">List</span>[(<span class="type">Long</span>, <span class="type">Long</span>)] = flowIds.zip(flowIds.tail)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将不合法的页面跳转进行过滤</span></span><br><span class="line">                pageflowIds.filter(</span><br><span class="line">                    t =&gt; &#123;</span><br><span class="line">                        okflowIds.contains(t)</span><br><span class="line">                    &#125;</span><br><span class="line">                ).map(</span><br><span class="line">                    t =&gt; &#123;</span><br><span class="line">                        (t, <span class="number">1</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// ((1,2),1)</span></span><br><span class="line">        <span class="keyword">val</span> flatRDD: <span class="type">RDD</span>[((<span class="type">Long</span>, <span class="type">Long</span>), <span class="type">Int</span>)] = mvRDD.map(_._2).flatMap(list=&gt;list)</span><br><span class="line">        <span class="comment">// ((1,2),1) =&gt; ((1,2),sum)</span></span><br><span class="line">        <span class="keyword">val</span> dataRDD = flatRDD.reduceByKey(_+_)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 计算单跳转换率</span></span><br><span class="line">        <span class="comment">// 分子除以分母</span></span><br><span class="line">        dataRDD.foreach&#123;</span><br><span class="line">            <span class="keyword">case</span> ( (pageid1, pageid2), sum ) =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> lon: <span class="type">Long</span> = pageidToCountMap.getOrElse(pageid1, <span class="number">0</span>L)</span><br><span class="line"></span><br><span class="line">                println(<span class="string">s&quot;页面<span class="subst">$&#123;pageid1&#125;</span>跳转到页面<span class="subst">$&#123;pageid2&#125;</span>单跳转换率为:&quot;</span> + ( sum.toDouble/lon ))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户访问动作表</span></span><br><span class="line">    <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">UserVisitAction</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">              date: <span class="type">String</span>,//用户点击行为的日期</span></span></span><br><span class="line"><span class="params"><span class="class">              user_id: <span class="type">Long</span>,//用户的<span class="type">ID</span></span></span></span><br><span class="line"><span class="params"><span class="class">              session_id: <span class="type">String</span>,//<span class="type">Session</span>的<span class="type">ID</span></span></span></span><br><span class="line"><span class="params"><span class="class">              page_id: <span class="type">Long</span>,//某个页面的<span class="type">ID</span></span></span></span><br><span class="line"><span class="params"><span class="class">              action_time: <span class="type">String</span>,//动作的时间点</span></span></span><br><span class="line"><span class="params"><span class="class">              search_keyword: <span class="type">String</span>,//用户搜索的关键词</span></span></span><br><span class="line"><span class="params"><span class="class">              click_category_id: <span class="type">Long</span>,//某一个商品品类的<span class="type">ID</span></span></span></span><br><span class="line"><span class="params"><span class="class">              click_product_id: <span class="type">Long</span>,//某一个商品的<span class="type">ID</span></span></span></span><br><span class="line"><span class="params"><span class="class">              order_category_ids: <span class="type">String</span>,//一次订单中所有品类的<span class="type">ID</span>集合</span></span></span><br><span class="line"><span class="params"><span class="class">              order_product_ids: <span class="type">String</span>,//一次订单中所有商品的<span class="type">ID</span>集合</span></span></span><br><span class="line"><span class="params"><span class="class">              pay_category_ids: <span class="type">String</span>,//一次支付中所有品类的<span class="type">ID</span>集合</span></span></span><br><span class="line"><span class="params"><span class="class">              pay_product_ids: <span class="type">String</span>,//一次支付中所有商品的<span class="type">ID</span>集合</span></span></span><br><span class="line"><span class="params"><span class="class">              city_id: <span class="type">Long</span></span></span></span><br><span class="line"><span class="params"><span class="class">      </span>)<span class="comment">//城市 id</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="application"><a href="#application" class="headerlink" title="application"></a>application</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.bigdata.spark.core.framework.application</span><br><span class="line"></span><br><span class="line">import com.atguigu.bigdata.spark.core.framework.common.TApplication</span><br><span class="line">import com.atguigu.bigdata.spark.core.framework.controller.WordCountController</span><br><span class="line"></span><br><span class="line">object WordCountApplication extends App with TApplication&#123;</span><br><span class="line"></span><br><span class="line">    // 启动应用程序</span><br><span class="line">    start()&#123;</span><br><span class="line">        val controller = new WordCountController()</span><br><span class="line">        controller.dispatch()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h2><h2 id="common"><a href="#common" class="headerlink" title="common"></a>common</h2><p>共用</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.framework.common</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bigdata.spark.core.framework.controller.<span class="type">WordCountController</span></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bigdata.spark.core.framework.util.<span class="type">EnvUtil</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>(master:<span class="type">String</span> =<span class="string">&quot;local[*]&quot;</span>, app:<span class="type">String</span> = <span class="string">&quot;Application&quot;</span>)( op : =&gt; <span class="type">Unit</span> ): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> sparConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(master).setAppName(app)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparConf)</span><br><span class="line">        <span class="type">EnvUtil</span>.put(sc)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            op</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ex =&gt; println(ex.getMessage)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 关闭连接</span></span><br><span class="line">        sc.stop()</span><br><span class="line">        <span class="type">EnvUtil</span>.clear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.framework.common</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span></span>(): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.framework.common</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bigdata.spark.core.framework.util.<span class="type">EnvUtil</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readFile</span></span>(path:<span class="type">String</span>) = &#123;</span><br><span class="line">        <span class="type">EnvUtil</span>.take().textFile(path)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.framework.common</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dataAnalysis</span></span>():<span class="type">Any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.framework.controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bigdata.spark.core.framework.common.<span class="type">TController</span></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bigdata.spark.core.framework.service.<span class="type">WordCountService</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 控制层</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordCountController</span> <span class="keyword">extends</span> <span class="title">TController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> wordCountService = <span class="keyword">new</span> <span class="type">WordCountService</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// TODO 执行业务操作</span></span><br><span class="line">        <span class="keyword">val</span> array = wordCountService.dataAnalysis()</span><br><span class="line">        array.foreach(println)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="dao"><a href="#dao" class="headerlink" title="dao"></a>dao</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.framework.dao</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bigdata.spark.core.framework.common.<span class="type">TDao</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 持久层</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordCountDao</span> <span class="keyword">extends</span> <span class="title">TDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.framework.service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bigdata.spark.core.framework.common.<span class="type">TService</span></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bigdata.spark.core.framework.dao.<span class="type">WordCountDao</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 服务层</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordCountService</span> <span class="keyword">extends</span> <span class="title">TService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> wordCountDao = <span class="keyword">new</span> <span class="type">WordCountDao</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据分析</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dataAnalysis</span></span>() = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> lines = wordCountDao.readFile(<span class="string">&quot;datas/word.txt&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> words: <span class="type">RDD</span>[<span class="type">String</span>] = lines.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">        <span class="keyword">val</span> wordToOne = words.map(word=&gt;(word,<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">val</span> wordToSum: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordToOne.reduceByKey(_+_)</span><br><span class="line">        <span class="keyword">val</span> array: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordToSum.collect()</span><br><span class="line">        array</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="util"><a href="#util" class="headerlink" title="util"></a>util</h2><p>工具类</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.framework.util</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkContext</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">EnvUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> scLocal = <span class="keyword">new</span> <span class="type">ThreadLocal</span>[<span class="type">SparkContext</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span></span>( sc : <span class="type">SparkContext</span> ): <span class="type">Unit</span> = &#123;</span><br><span class="line">        scLocal.set(sc)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">take</span></span>(): <span class="type">SparkContext</span> = &#123;</span><br><span class="line">        scLocal.get()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">        scLocal.remove()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://lvxiaoyi.top">lvxiaoyi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lvxiaoyi.top/ec5abdd4.html">https://lvxiaoyi.top/ec5abdd4.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lvxiaoyi.top" target="_blank">吕小医's BLOG</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></div><div class="post_share"><div class="social-share" data-image="https://img.lvxiaoyi.top/typora-img/202111081621419.png/lvxiaoyi" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/c4e34d40.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/OIP.jpg/lvxiaoyi" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统常见面试题</div></div></a></div><div class="next-post pull-right"><a href="/5eb2dc8b#.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20211028174657424.png/lvxiaoyi" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">hadoop高级-2源码分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/5eb2dc8b.html" title="hadoop基础-3Yarn"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20211028174657424.png/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">hadoop基础-3Yarn</div></div></a></div><div><a href="/bc13a2ae.html" title="HBase基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20211028174657424.png/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">HBase基础</div></div></a></div><div><a href="/1d83a7d1.html" title="Hive基础-1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20211028174657424.png/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">Hive基础-1</div></div></a></div><div><a href="/beeb1f38.html" title="Kafka基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.zhimg.com/v2-9964d2894516902605191817111ec781_r.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">Kafka基础</div></div></a></div><div><a href="/9cbb2d93.html" title="hive基础-2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20211028174657424.png/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">hive基础-2</div></div></a></div><div><a href="/6362a21d.html" title="Scala基础-1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111082146936.png/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">Scala基础-1</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p0.meituan.net/csc/8a1b1d488e6a8ab5108c9c78f36b3a1776955.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lvxiaoyi</div><div class="author-info__description">ISFP到ESFJ</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">205</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">51</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lvxiaoyi"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">冲鸭！内卷起来了兄弟</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spark%E5%9F%BA%E7%A1%80-1SparkCore"><span class="toc-number">1.</span> <span class="toc-text">Spark基础-1SparkCore</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spark-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">Spark 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spark-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.</span> <span class="toc-text">Spark 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spark-and-Hadoop"><span class="toc-number">2.2.</span> <span class="toc-text">Spark and Hadoop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spark-or-Hadoop"><span class="toc-number">2.3.</span> <span class="toc-text">Spark or Hadoop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spark-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97"><span class="toc-number">2.4.</span> <span class="toc-text">Spark 核心模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spark-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B"><span class="toc-number">2.5.</span> <span class="toc-text">Spark 快速上手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Maven-%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.6.</span> <span class="toc-text">创建 Maven 项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0-Scala-%E6%8F%92%E4%BB%B6"><span class="toc-number">2.6.1.</span> <span class="toc-text">增加 Scala 插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">2.6.2.</span> <span class="toc-text">增加依赖关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WordCount"><span class="toc-number">2.6.3.</span> <span class="toc-text">WordCount</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.6.4.</span> <span class="toc-text">异常处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spark-%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">3.</span> <span class="toc-text">Spark 运行环境</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Local-%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">Local 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.1.</span> <span class="toc-text">解压缩文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8-Local-%E7%8E%AF%E5%A2%83"><span class="toc-number">3.1.2.</span> <span class="toc-text">启动 Local 环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7"><span class="toc-number">3.1.3.</span> <span class="toc-text">命令行工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%80%E5%87%BA%E6%9C%AC%E5%9C%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.4.</span> <span class="toc-text">退出本地模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E5%BA%94%E7%94%A8"><span class="toc-number">3.1.5.</span> <span class="toc-text">提交应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Standalone-%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">Standalone 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">解压缩文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.2.</span> <span class="toc-text">修改配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E9%9B%86%E7%BE%A4"><span class="toc-number">3.2.3.</span> <span class="toc-text">启动集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E5%BA%94%E7%94%A8-1"><span class="toc-number">3.2.4.</span> <span class="toc-text">提交应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">3.2.5.</span> <span class="toc-text">提交参数说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%8E%86%E5%8F%B2%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.2.6.</span> <span class="toc-text">配置历史服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%88HA%EF%BC%89"><span class="toc-number">3.2.7.</span> <span class="toc-text">配置高可用（HA）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Yarn-%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">Yarn 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6-2"><span class="toc-number">3.3.1.</span> <span class="toc-text">解压缩文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-1"><span class="toc-number">3.3.2.</span> <span class="toc-text">修改配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8-HDFS-%E4%BB%A5%E5%8F%8A-YARN-%E9%9B%86%E7%BE%A4"><span class="toc-number">3.3.3.</span> <span class="toc-text">启动 HDFS 以及 YARN 集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E5%BA%94%E7%94%A8-2"><span class="toc-number">3.3.4.</span> <span class="toc-text">提交应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%8E%86%E5%8F%B2%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.3.5.</span> <span class="toc-text">配置历史服务器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#K8S-amp-Mesos-%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">K8S &amp; Mesos 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows-%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.5.</span> <span class="toc-text">Windows 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6-3"><span class="toc-number">3.5.1.</span> <span class="toc-text">解压缩文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83"><span class="toc-number">3.5.2.</span> <span class="toc-text">启动本地环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8F%90%E4%BA%A4%E5%BA%94%E7%94%A8"><span class="toc-number">3.5.3.</span> <span class="toc-text">命令行提交应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">3.6.</span> <span class="toc-text">部署模式对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">3.7.</span> <span class="toc-text">端口号</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spark-%E8%BF%90%E8%A1%8C%E6%9E%B6%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">Spark 运行架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%9E%B6%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">运行架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">4.2.</span> <span class="toc-text">核心组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Driver"><span class="toc-number">4.2.1.</span> <span class="toc-text">Driver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor"><span class="toc-number">4.2.2.</span> <span class="toc-text">Executor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Master-amp-Worker"><span class="toc-number">4.2.3.</span> <span class="toc-text">Master &amp; Worker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ApplicationMaster"><span class="toc-number">4.2.4.</span> <span class="toc-text">ApplicationMaster</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">4.3.</span> <span class="toc-text">核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor-%E4%B8%8E-Core"><span class="toc-number">4.3.1.</span> <span class="toc-text">Executor 与 Core</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%BA%A6%EF%BC%88Parallelism%EF%BC%89"><span class="toc-number">4.3.2.</span> <span class="toc-text">并行度（Parallelism）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%EF%BC%88DAG%EF%BC%89"><span class="toc-number">4.3.3.</span> <span class="toc-text">有向无环图（DAG）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B"><span class="toc-number">4.4.</span> <span class="toc-text">提交流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1Yarn-Client-%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.2.1Yarn Client 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Yarn-Cluster-%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.2.</span> <span class="toc-text">Yarn Cluster 模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spark-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">Spark 核心编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RDD"><span class="toc-number">5.1.</span> <span class="toc-text">RDD</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-RDD"><span class="toc-number">5.1.1.</span> <span class="toc-text">什么是 RDD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7"><span class="toc-number">5.1.2.</span> <span class="toc-text">核心属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.3.</span> <span class="toc-text">执行原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B"><span class="toc-number">5.1.4.</span> <span class="toc-text">基础编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RDD-%E5%88%9B%E5%BB%BA"><span class="toc-number">5.1.4.1.</span> <span class="toc-text">RDD 创建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E9%9B%86%E5%90%88%EF%BC%88%E5%86%85%E5%AD%98%EF%BC%89%E4%B8%AD%E5%88%9B%E5%BB%BA-RDD"><span class="toc-number">5.1.4.1.1.</span> <span class="toc-text">从集合（内存）中创建 RDD</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%EF%BC%88%E6%96%87%E4%BB%B6%EF%BC%89%E5%88%9B%E5%BB%BA-RDD"><span class="toc-number">5.1.4.1.2.</span> <span class="toc-text">从外部存储（文件）创建 RDD</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E5%85%B6%E4%BB%96-RDD-%E5%88%9B%E5%BB%BA"><span class="toc-number">5.1.4.1.3.</span> <span class="toc-text">从其他 RDD 创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA-RDD%EF%BC%88new%EF%BC%89"><span class="toc-number">5.1.4.1.4.</span> <span class="toc-text">直接创建 RDD（new）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDD-%E5%B9%B6%E8%A1%8C%E5%BA%A6%E4%B8%8E%E5%88%86%E5%8C%BA"><span class="toc-number">5.1.4.2.</span> <span class="toc-text">RDD 并行度与分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDD-%E8%BD%AC%E6%8D%A2%E7%AE%97%E5%AD%90"><span class="toc-number">5.1.4.3.</span> <span class="toc-text">RDD 转换算子</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Value-%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.4.3.1.</span> <span class="toc-text">Value 类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C-Value-%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.4.3.2.</span> <span class="toc-text">双 Value 类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Key-Value-%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.4.3.3.</span> <span class="toc-text">Key - Value 类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%93%8D"><span class="toc-number">5.1.4.4.</span> <span class="toc-text">案例实操</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDD-%E8%A1%8C%E5%8A%A8%E7%AE%97%E5%AD%90"><span class="toc-number">5.1.4.5.</span> <span class="toc-text">RDD 行动算子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0wordCount%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.4.6.</span> <span class="toc-text">实现wordCount的几种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDD-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">5.1.4.7.</span> <span class="toc-text">RDD 序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDD-%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">5.1.4.8.</span> <span class="toc-text">RDD 依赖关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDD-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">5.1.4.9.</span> <span class="toc-text">RDD 持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDD-%E5%88%86%E5%8C%BA%E5%99%A8"><span class="toc-number">5.1.4.10.</span> <span class="toc-text">RDD 分区器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDD-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E4%BF%9D%E5%AD%98"><span class="toc-number">5.1.4.11.</span> <span class="toc-text">RDD 文件读取与保存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%AF%E5%8A%A0%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">累加器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.1.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B-1"><span class="toc-number">5.2.2.</span> <span class="toc-text">基础编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%B4%AF%E5%8A%A0%E5%99%A8"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">系统累加器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B4%AF%E5%8A%A0%E5%99%A8"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">自定义累加器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F"><span class="toc-number">5.3.</span> <span class="toc-text">广播变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1"><span class="toc-number">5.3.1.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B-2"><span class="toc-number">5.3.2.</span> <span class="toc-text">基础编程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spark-%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%93%8D"><span class="toc-number">6.</span> <span class="toc-text">Spark 案例实操</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82-1%EF%BC%9ATop10-%E7%83%AD%E9%97%A8%E5%93%81%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">需求 1：Top10 热门品类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E8%AF%B4%E6%98%8E"><span class="toc-number">6.1.1.</span> <span class="toc-text">需求说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E4%B8%80"><span class="toc-number">6.1.2.</span> <span class="toc-text">实现方案一</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">需求实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E4%BA%8C"><span class="toc-number">6.1.3.</span> <span class="toc-text">实现方案二</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-1"><span class="toc-number">6.1.3.1.</span> <span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">6.1.3.2.</span> <span class="toc-text">需求实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E4%BA%8C-1"><span class="toc-number">6.1.4.</span> <span class="toc-text">实现方案二</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-2"><span class="toc-number">6.1.4.1.</span> <span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">6.1.4.2.</span> <span class="toc-text">需求实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82-2%EF%BC%9ATop10-%E7%83%AD%E9%97%A8%E5%93%81%E7%B1%BB%E4%B8%AD%E6%AF%8F%E4%B8%AA%E5%93%81%E7%B1%BB%E7%9A%84-Top10-%E6%B4%BB%E8%B7%83-Session-%E7%BB%9F%E8%AE%A1"><span class="toc-number">6.2.</span> <span class="toc-text">需求 2：Top10 热门品类中每个品类的 Top10 活跃 Session 统计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E8%AF%B4%E6%98%8E-1"><span class="toc-number">6.2.1.</span> <span class="toc-text">需求说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82-3%EF%BC%9A%E9%A1%B5%E9%9D%A2%E5%8D%95%E8%B7%B3%E8%BD%AC%E6%8D%A2%E7%8E%87%E7%BB%9F%E8%AE%A1"><span class="toc-number">6.3.</span> <span class="toc-text">需求 3：页面单跳转换率统计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E8%AF%B4%E6%98%8E-2"><span class="toc-number">6.3.1.</span> <span class="toc-text">需求说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">7.</span> <span class="toc-text">架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#application"><span class="toc-number">7.1.</span> <span class="toc-text">application</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bean"><span class="toc-number">7.2.</span> <span class="toc-text">bean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#common"><span class="toc-number">7.3.</span> <span class="toc-text">common</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#controller"><span class="toc-number">7.4.</span> <span class="toc-text">controller</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dao"><span class="toc-number">7.5.</span> <span class="toc-text">dao</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#service"><span class="toc-number">7.6.</span> <span class="toc-text">service</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#util"><span class="toc-number">7.7.</span> <span class="toc-text">util</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/560e8e48.html" title="博客美化"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.zhimg.com/v2-9964d2894516902605191817111ec781_r.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="博客美化"/></a><div class="content"><a class="title" href="/560e8e48.html" title="博客美化">博客美化</a><time datetime="2023-12-29T14:58:12.257Z" title="发表于 2023-12-29 22:58:12">2023-12-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7ef7bbd4.html" title="LeetCode 118. 杨辉三角"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/202111011355394.png/lvxiaoyi" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode 118. 杨辉三角"/></a><div class="content"><a class="title" href="/7ef7bbd4.html" title="LeetCode 118. 杨辉三角">LeetCode 118. 杨辉三角</a><time datetime="2023-03-19T14:25:59.394Z" title="发表于 2023-03-19 22:25:59">2023-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/82c8cab7.html" title="shell基础"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.zhimg.com/v2-9964d2894516902605191817111ec781_r.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="shell基础"/></a><div class="content"><a class="title" href="/82c8cab7.html" title="shell基础">shell基础</a><time datetime="2022-10-12T16:07:18.841Z" title="发表于 2022-10-13 00:07:18">2022-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f1601c3e.html" title="单例模式"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/1002892-20180912131026735-781767905.png/lvxiaoyi" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="单例模式"/></a><div class="content"><a class="title" href="/f1601c3e.html" title="单例模式">单例模式</a><time datetime="2022-09-12T07:22:48.777Z" title="发表于 2022-09-12 15:22:48">2022-09-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/b15f0f1b.html" title="设计模式基础-1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.lvxiaoyi.top/typora-img/image-20211012093705433.png/lvxiaoyi" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式基础-1"/></a><div class="content"><a class="title" href="/b15f0f1b.html" title="设计模式基础-1">设计模式基础-1</a><time datetime="2022-09-12T07:22:48.777Z" title="发表于 2022-09-12 15:22:48">2022-09-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://img.lvxiaoyi.top/typora-img/202111081621419.png/lvxiaoyi')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By lvxiaoyi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/lvxiaoyi.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>