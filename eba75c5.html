<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Spark基础-5Spark优化 | 吕小医's BLOG</title><meta name="keywords" content="大数据"><meta name="author" content="lvxiaoyi"><meta name="copyright" content="lvxiaoyi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spark基础-5Spark优化Spark 性能调优常规性能调优常规性能调优一：最优资源配置Spark 性能调优的第一步，就是为任务分配更多的资源，在一定范围内，增加资源的分配与性能的提升是成正比的，实现了最优的资源配置后，在此基础上再考虑进行后面论述的性能调优策略。 资源的分配在使用脚本提交 Spark 任务时进行指定，标准的 Spark 任务提交脚本如下所示： 123456789bin&#x2F;spa">
<meta property="og:type" content="article">
<meta property="og:title" content="Spark基础-5Spark优化">
<meta property="og:url" content="https://lvxiaoyi.top/eba75c5.html">
<meta property="og:site_name" content="吕小医&#39;s BLOG">
<meta property="og:description" content="Spark基础-5Spark优化Spark 性能调优常规性能调优常规性能调优一：最优资源配置Spark 性能调优的第一步，就是为任务分配更多的资源，在一定范围内，增加资源的分配与性能的提升是成正比的，实现了最优的资源配置后，在此基础上再考虑进行后面论述的性能调优策略。 资源的分配在使用脚本提交 Spark 任务时进行指定，标准的 Spark 任务提交脚本如下所示： 123456789bin&#x2F;spa">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.lvxiaoyi.top/typora-img/202111081621419.png/lvxiaoyi">
<meta property="article:published_time" content="2022-09-12T07:22:48.769Z">
<meta property="article:modified_time" content="2022-09-12T07:22:48.769Z">
<meta property="article:author" content="lvxiaoyi">
<meta property="article:tag" content="大数据">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.lvxiaoyi.top/typora-img/202111081621419.png/lvxiaoyi"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lvxiaoyi.top/eba75c5"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spark基础-5Spark优化',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-12 15:22:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://p0.meituan.net/csc/8a1b1d488e6a8ab5108c9c78f36b3a1776955.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">204</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">50</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 小医</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img.lvxiaoyi.top/typora-img/202111081621419.png/lvxiaoyi')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">吕小医's BLOG</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 小医</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spark基础-5Spark优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-12T07:22:48.769Z" title="发表于 2022-09-12 15:22:48">2022-09-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-12T07:22:48.769Z" title="更新于 2022-09-12 15:22:48">2022-09-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/">Spark</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spark基础-5Spark优化"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Spark基础-5Spark优化"><a href="#Spark基础-5Spark优化" class="headerlink" title="Spark基础-5Spark优化"></a>Spark基础-5Spark优化</h1><h1 id="Spark-性能调优"><a href="#Spark-性能调优" class="headerlink" title="Spark 性能调优"></a>Spark 性能调优</h1><h2 id="常规性能调优"><a href="#常规性能调优" class="headerlink" title="常规性能调优"></a>常规性能调优</h2><h3 id="常规性能调优一：最优资源配置"><a href="#常规性能调优一：最优资源配置" class="headerlink" title="常规性能调优一：最优资源配置"></a>常规性能调优一：最优资源配置</h3><p>Spark 性能调优的第一步，就是为任务分配更多的资源，在一定范围内，增加资源的分配与性能的提升是成正比的，实现了最优的资源配置后，在此基础上再考虑进行后面论述的性能调优策略。</p>
<p>资源的分配在使用脚本提交 Spark 任务时进行指定，标准的 Spark 任务提交脚本如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class com.atguigu.spark.Analysis \</span><br><span class="line">--master yarn</span><br><span class="line">--deploy-mode cluster</span><br><span class="line">--num-executors 80 \</span><br><span class="line">--driver-memory 6g \</span><br><span class="line">--executor-memory 6g \</span><br><span class="line">--executor-cores 3 \</span><br><span class="line">/usr/opt/modules/spark/jar/spark.jar \</span><br></pre></td></tr></table></figure>

<p>可以进行分配的资源如表所示：</p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>–num-executors</td>
<td>配置 Executor 的数量</td>
</tr>
<tr>
<td>–driver-memory</td>
<td>配置 Driver 内存（ 影响不大）</td>
</tr>
<tr>
<td>–executor-memory</td>
<td>配置每个 Executor 的内存大小</td>
</tr>
<tr>
<td>–executor-cores</td>
<td>配置每个 Executor 的 CPU core 数量</td>
</tr>
</tbody></table>
<p>调节原则：尽量将任务分配的资源调节到可以使用的资源的最大限度。</p>
<p>对于具体资源的分配，我们分别讨论 Spark 的两种 Cluster 运行模式：</p>
<ul>
<li><p>第一种是 Spark Standalone 模式，你在提交任务前，一定知道或者可以从运维部门获取到你可以使用的资源情况，在编写 submit 脚本的时候，就根据可用的资源情况进行资源的分配，比如说集群有 15 台机器，每台机器为 8G 内存，2 个 CPU core，那么就指定 15 个 Executor，每个 Executor 分配 8G 内存，2 个 CPU core。 </p>
</li>
<li><p>第二种是 Spark Yarn 模式，由于 Yarn 使用资源队列进行资源的分配和调度，在编写submit 脚本的时候，就根据 Spark 作业要提交到的资源队列，进行资源的分配，比如资源队列有 400G 内存，100 个 CPU core，那么指定 50 个 Executor，每个 Executor 分配8G 内存，2 个 CPU core。</p>
</li>
</ul>
<p>对各项资源进行了调节后，得到的性能提升会有如下表现：</p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>解析</strong></th>
</tr>
</thead>
<tbody><tr>
<td>增加 Executor·个数</td>
<td>在资源允许的情况下，增加 Executor 的个数可以提高执行 task 的并行度。比如有 4 个Executor，每个 Executor 有 2 个 CPU core，那么可以并行执行 8 个 task，如果将 Executor 的个数增加到 8 个（ 资源允许的情况下）， 那么可以并行执行 16 个 task， 此时的并行能力提升了一倍。</td>
</tr>
<tr>
<td>增加每个 Executor 的 CPU core 个数</td>
<td>在资源允许的情况下，增加每个 Executor 的Cpu core 个数， 可以提高执行 task 的并行度。比如有 4 个 Executor，每个 Executor 有 2 个CPU core，那么可以并行执行 8 个 task，如果将每个 Executor 的 CPU core 个数增加到 4 个（ 资源允许的情况下），那么可以并行执行 16个 task， 此时的并行能力提升了一倍。</td>
</tr>
<tr>
<td>增加每个 Executor 的内存量</td>
<td>在资源允许的情况下，增加每个 Executor 的内存量以后， 对性能的提升有三点：1. 可以缓存更多的数据（ 即对 RDD 进行 cache）， 写入磁盘的数据相应减少， 甚至可以不写入磁盘， 减少了可能的磁盘 IO；2. 可以为 shuffle 操作提供更多内存，即有更多空间来存放 reduce 端拉取的数据，写入磁盘的数据相应减少，甚至可以不写入磁盘， 减少了可能的磁盘 IO；3. 可以为 task 的执行提供更多内存，在 task 的执行过程中可能创建很多对象，内存较小时会引发频繁的 GC， 增加内存后， 可以避免频繁的 GC， 提升整体性能。</td>
</tr>
</tbody></table>
<p>补充：生产环境 Spark submit 脚本配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class com.atguigu.spark.WordCount \</span><br><span class="line">--master yarn\</span><br><span class="line">--deploy-mode cluster\</span><br><span class="line">--num-executors 80 \</span><br><span class="line">--driver-memory 6g \</span><br><span class="line">--executor-memory 6g \</span><br><span class="line">--executor-cores 3 \</span><br><span class="line">--queue root.default \</span><br><span class="line">--conf spark.yarn.executor.memoryOverhead=2048 \</span><br><span class="line">--conf spark.core.connection.ack.wait.timeout=300 \</span><br><span class="line">/usr/local/spark/spark.jar</span><br></pre></td></tr></table></figure>

<p>参数配置参考值：</p>
<ul>
<li><p>–num-executors：50~100</p>
</li>
<li><p>–driver-memory：1G~5G</p>
</li>
<li><p>–executor-memory：6G~10G</p>
</li>
<li><p>–executor-cores：3 </p>
</li>
<li><p>–master：实际生产环境一定使用 yarn</p>
</li>
</ul>
<h3 id="常规性能调优二：RDD-优化"><a href="#常规性能调优二：RDD-优化" class="headerlink" title="常规性能调优二：RDD 优化"></a>常规性能调优二：RDD 优化</h3><h4 id="RDD-复用"><a href="#RDD-复用" class="headerlink" title="RDD 复用"></a>RDD 复用</h4><p>在对 RDD 进行算子时，要避免相同的算子和计算逻辑之下对 RDD 进行重复的计算</p>
<p><img src="https://img.lvxiaoyi.top/typora-img/202111091735376.png/lvxiaoyi" alt="image-20211109173518302"></p>
<p>对上图中的 RDD 计算架构进行修改，得到如下图所示的优化结果：</p>
<p><img src="C:/Users/Think/AppData/Roaming/Typora/typora-user-images/image-20211109173522892.png" alt="image-20211109173522892"></p>
<h4 id="RDD-持久化"><a href="#RDD-持久化" class="headerlink" title="RDD 持久化"></a>RDD 持久化</h4><p>在 Spark 中，当多次对同一个 RDD 执行算子操作时，每一次都会对这个 RDD 以之前的父 RDD 重新计算一次，这种情况是必须要避免的，对同一个 RDD 的重复计算是对资源的极大浪费，因此，必须对多次使用的 RDD 进行持久化，通过持久化将公共 RDD 的数据缓存到内存/磁盘中，之后对于公共 RDD 的计算都会从内存/磁盘中直接获取 RDD 数据。对于 RDD 的持久化，有两点需要说明：</p>
<ul>
<li><p>RDD 的持久化是可以进行序列化的，当内存无法将 RDD 的数据完整的进行存放的时候，可以考虑使用序列化的方式减小数据体积，将数据完整存储在内存中。</p>
</li>
<li><p>如果对于数据的可靠性要求很高，并且内存充足，可以使用副本机制，对 RDD 数据进行持久化。当持久化启用了复本机制时，对于持久化的每个数据单元都存储一个副本，放在其他节点上面，由此实现数据的容错，一旦一个副本数据丢失，不需要重新计算，还可以使用另外一个副本。</p>
</li>
<li><p>RDD 尽可能早的 filter 操作</p>
<p>获取到初始 RDD 后，应该考虑尽早地过滤掉不需要的数据，进而减少对内存的占用，从而提升 Spark 作业的运行效率。</p>
</li>
</ul>
<h3 id="常规性能调优三：并行度调节"><a href="#常规性能调优三：并行度调节" class="headerlink" title="常规性能调优三：并行度调节"></a>常规性能调优三：并行度调节</h3><p>Spark 作业中的并行度指各个 stage 的 task 的数量。</p>
<p>如果并行度设置不合理而导致并行度过低，会导致资源的极大浪费，例如，20 个 Executor，每个 Executor 分配 3 个 CPU core，而 Spark 作业有 40 个 task，这样每个 Executor 分配到的task 个数是 2 个，这就使得每个 Executor 有一个 CPU core 空闲，导致资源的浪费。</p>
<p>理想的并行度设置，应该是让并行度与资源相匹配，简单来说就是在资源允许的前提下，并行度要设置的尽可能大，达到可以充分利用集群资源。合理的设置并行度，可以提升整个Spark 作业的性能和运行速度。</p>
<p>Spark 官方推荐，task 数量应该设置为 Spark 作业总 CPU core 数量的 2<del>3 倍。之所以没有推荐 task 数量与 CPU core 总数相等，是因为 task 的执行时间不同，有的 task 执行速度快而有的 task 执行速度慢，如果 task 数量与 CPU core 总数相等，那么执行快的 task 执行完成后，会出现 CPU core 空闲的情况。如果 task 数量设置为 CPU core 总数的 2</del>3 倍，那么一个task 执行完毕后，CPU core 会立刻执行下一个 task，降低了资源的浪费，同时提升了 Spark<br>作业运行的效率。</p>
<p>Spark 作业并行度的设置如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val conf = new SparkConf()</span><br><span class="line">.set(&quot;spark.default.parallelism&quot;, &quot;500&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="常规性能调优四：广播大变量"><a href="#常规性能调优四：广播大变量" class="headerlink" title="常规性能调优四：广播大变量"></a>常规性能调优四：广播大变量</h3><p>默认情况下，task 中的算子中如果使用了外部的变量，每个 task 都会获取一份变量的复本，这就造成了内存的极大消耗。一方面，如果后续对 RDD 进行持久化，可能就无法将 RDD数据存入内存，只能写入磁盘，磁盘 IO 将会严重消耗性能；另一方面，task 在创建对象的时候，也许会发现堆内存无法存放新创建的对象，这就会导致频繁的 GC，GC 会导致工作线程停止，进而导致 Spark 暂停工作一段时间，严重影响 Spark 性能。</p>
<p>假设当前任务配置了 20 个 Executor，指定 500 个 task，有一个 20M 的变量被所有 task共用，此时会在 500 个 task 中产生 500 个副本，耗费集群 10G 的内存，如果使用了广播变量， 那么每个 Executor 保存一个副本，一共消耗 400M 内存，内存消耗减少了 5 倍。</p>
<p>广播变量在每个 Executor 保存一个副本，此 Executor 的所有 task 共用此广播变量，这让变量产生的副本数量大大减少。</p>
<p>在初始阶段，广播变量只在 Driver 中有一份副本。task 在运行的时候，想要使用广播变量中的数据，此时首先会在自己本地的 Executor 对应的 BlockManager 中尝试获取变量，如果本地没有，BlockManager 就会从 Driver 或者其他节点的 BlockManager 上远程拉取变量的复本，并由本地的 BlockManager 进行管理；之后此 Executor 的所有 task 都会直接从本地的BlockManager 中获取变量。</p>
<h3 id="常规性能调优五：Kryo-序列化"><a href="#常规性能调优五：Kryo-序列化" class="headerlink" title="常规性能调优五：Kryo 序列化"></a>常规性能调优五：Kryo 序列化</h3><p>默认情况下，Spark 使用 Java 的序列化机制。Java 的序列化机制使用方便，不需要额外的配置，在算子中使用的变量实现 Serializable 接口即可，但是，Java 序列化机制的效率不高，序列化速度慢并且序列化后的数据所占用的空间依然较大。</p>
<p>Kryo 序列化机制比 Java 序列化机制性能提高 10 倍左右，Spark 之所以没有默认使用Kryo 作为序列化类库，是因为它不支持所有对象的序列化，同时 Kryo 需要用户在使用前注册需要序列化的类型，不够方便，但从 Spark 2.0.0 版本开始，简单类型、简单类型数组、字符串类型的 Shuffling RDDs 已经默认使用 Kryo 序列化方式了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyKryoRegistrator implements KryoRegistrator</span><br><span class="line">&#123;</span><br><span class="line"> @Override</span><br><span class="line"> public void registerClasses(Kryo kryo)</span><br><span class="line"> &#123;</span><br><span class="line"> kryo.register(StartupReportLogs.class);</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>配置 Kryo 序列化方式的实例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建 SparkConf 对象</span><br><span class="line">val conf = new SparkConf().setMaster(…).setAppName(…)</span><br><span class="line">//使用 Kryo 序列化库，如果要使用 Java 序列化库，需要把该行屏蔽掉</span><br><span class="line">conf.set(&quot;spark.serializer&quot;, &quot;org.apache.spark.serializer.KryoSerializer&quot;); </span><br><span class="line">//在 Kryo 序列化库中注册自定义的类集合，如果要使用 Java 序列化库，需要把该行屏蔽掉</span><br><span class="line">conf.set(&quot;spark.kryo.registrator&quot;, &quot;atguigu.com.MyKryoRegistrator&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="常规性能调优六：调节本地化等待时长"><a href="#常规性能调优六：调节本地化等待时长" class="headerlink" title="常规性能调优六：调节本地化等待时长"></a>常规性能调优六：调节本地化等待时长</h3><p>Spark 作业运行过程中，Driver 会对每一个 stage 的 task 进行分配。根据 Spark 的 task 分配算法，Spark 希望 task 能够运行在它要计算的数据算在的节点（数据本地化思想），这样就可以避免数据的网络传输。通常来说，task 可能不会被分配到它处理的数据所在的节点，因为这些节点可用的资源可能已经用尽，此时，Spark 会等待一段时间，默认 3s，如果等待指定时间后仍然无法在指定节点运行，那么会自动降级，尝试将 task 分配到比较差的本地化级别所对应的节点上，比如将 task 分配到离它要计算的数据比较近的一个节点，然后进行计算，如果当前级别仍然不行，那么继续降级。</p>
<p>当 task 要处理的数据不在 task 所在节点上时，会发生数据的传输。task 会通过所在节点的 BlockManager 获取数据，BlockManager 发现数据不在本地时，户通过网络传输组件从数据所在节点的 BlockManager 处获取数据。</p>
<p>网络传输数据的情况是我们不愿意看到的，大量的网络传输会严重影响性能，因此，我们希望通过调节本地化等待时长，如果在等待时长这段时间内，目标节点处理完成了一部分task，那么当前的 task 将有机会得到执行，这样就能够改善 Spark 作业的整体性能。Spark 的本地化等级如表所示：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>解析</th>
</tr>
</thead>
<tbody><tr>
<td>PROCESS_LOCAL</td>
<td>进程本地化，task 和数据在同一个 Executor 中，性能最好。</td>
</tr>
<tr>
<td>NODE_LOCAL</td>
<td>节点本地化，task 和数据在同一个节点中，但是task和数据不在同一个 Executor 中，数据需要在进程间进行传输。</td>
</tr>
<tr>
<td>RACK_LOCAL</td>
<td>机架本地化，task 和数据在同一个机架的两个节点上，数据需要通过网络在节点之间进行传输。</td>
</tr>
<tr>
<td>NO_PREF</td>
<td>对于 task 来说，从哪里获取都一样，没有好坏之分。</td>
</tr>
<tr>
<td>ANY</td>
<td>task 和数据可以在集群的任何地方，而且不在一个机架中，性能最差。</td>
</tr>
</tbody></table>
<p>在 Spark 项目开发阶段，可以使用 client 模式对程序进行测试，此时，可以在本地看到比较全的日志信息，日志信息中有明确的 task 数据本地化的级别，如果大部分都是PROCESS_LOCAL，那么就无需进行调节，但是如果发现很多的级别都是 NODE_LOCAL、ANY，那么需要对本地化的等待时长进行调节，通过延长本地化等待时长，看看 task 的本地化级别有没有提升，并观察 Spark 作业的运行时间有没有缩短。</p>
<p>注意，过犹不及，不要将本地化等待时长延长地过长，导致因为大量的等待时长，使得Spark 作业的运行时间反而增加了。Spark 本地化等待时长的设置如代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val conf = new SparkConf()</span><br><span class="line"> .set(&quot;spark.locality.wait&quot;, &quot;6&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="算子调优"><a href="#算子调优" class="headerlink" title="算子调优"></a>算子调优</h2><h3 id="算子调优一：mapPartitions"><a href="#算子调优一：mapPartitions" class="headerlink" title="算子调优一：mapPartitions"></a>算子调优一：mapPartitions</h3><p>普通的 map 算子对 RDD 中的每一个元素进行操作，而 mapPartitions 算子对 RDD 中每一个分区进行操作。如果是普通的 map 算子，假设一个 partition 有 1 万条数据，那么 map算子中的 function 要执行 1 万次，也就是对每个元素进行操作。</p>
<p><img src="https://img.lvxiaoyi.top/typora-img/202111092146349.png/lvxiaoyi" alt="image-20211109214653302"></p>
<p>如果是 mapPartition 算子，由于一个 task 处理一个 RDD 的 partition，那么一个 task 只会执行一次function，function 一次接收所有的partition 数据，效率比较高。</p>
<p><img src="https://img.lvxiaoyi.top/typora-img/202111092147150.png/lvxiaoyi" alt="image-20211109214704118"></p>
<p>比如，当要把 RDD 中的所有数据通过 JDBC 写入数据，如果使用 map 算子，那么需要对 RDD 中的每一个元素都创建一个数据库连接，这样对资源的消耗很大，如果使用mapPartitions 算子，那么针对一个分区的数据，只需要建立一个数据库连接。</p>
<p>mapPartitions 算子也存在一些缺点：对于普通的 map 操作，一次处理一条数据，如果在处理了 2000 条数据后内存不足，那么可以将已经处理完的 2000 条数据从内存中垃圾回收掉；但是如果使用 mapPartitions 算子，但数据量非常大时，function 一次处理一个分区的数据，如果一旦内存不足，此时无法回收内存，就可能会 OOM，即内存溢出。</p>
<p>因此，mapPartitions 算子适用于数据量不是特别大的时候，此时使用 mapPartitions 算子对性能的提升效果还是不错的。（当数据量很大的时候，一旦使用 mapPartitions 算子，就会直接 OOM）</p>
<p>在项目中，应该首先估算一下 RDD 的数据量、每个 partition 的数据量，以及分配给每个 Executor 的内存资源，如果资源允许，可以考虑使用 mapPartitions 算子代替 map。</p>
<h3 id="算子调优二：foreachPartition-优化数据库操作"><a href="#算子调优二：foreachPartition-优化数据库操作" class="headerlink" title="算子调优二：foreachPartition 优化数据库操作"></a>算子调优二：foreachPartition 优化数据库操作</h3><p>在生产环境中，通常使用 foreachPartition 算子来完成数据库的写入，通过 foreachPartition算子的特性，可以优化写数据库的性能。</p>
<p>如果使用 foreach 算子完成数据库的操作，由于 foreach 算子是遍历 RDD 的每条数据，因此，每条数据都会建立一个数据库连接，这是对资源的极大浪费，因此，对于写数据库操作，我们应当使用 foreachPartition 算子。</p>
<p>与 mapPartitions 算子非常相似，foreachPartition 是将 RDD 的每个分区作为遍历对象，一次处理一个分区的数据，也就是说，如果涉及数据库的相关操作，一个分区的数据只需要创建一次数据库连接，如图所示：</p>
<p><img src="https://img.lvxiaoyi.top/typora-img/202111092148684.png/lvxiaoyi" alt="image-20211109214810651"></p>
<p>使用了 foreachPartition 算子后，可以获得以下的性能提升：</p>
<ul>
<li><p> 对于我们写的 function 函数，一次处理一整个分区的数据；</p>
</li>
<li><p>对于一个分区内的数据，创建唯一的数据库连接；</p>
</li>
<li><p>只需要向数据库发送一次 SQL 语句和多组参数；</p>
</li>
</ul>
<p>在生产环境中，全部都会使用 foreachPartition 算子完成数据库操作。foreachPartition 算子存在一个问题，与 mapPartitions 算子类似，如果一个分区的数据量特别大，可能会造成 OOM，即内存溢出。</p>
<h3 id="算子调优三：filter-与-coalesce-的配合使用"><a href="#算子调优三：filter-与-coalesce-的配合使用" class="headerlink" title="算子调优三：filter 与 coalesce 的配合使用"></a>算子调优三：filter 与 coalesce 的配合使用</h3><p>在 Spark 任务中我们经常会使用 filter 算子完成 RDD 中数据的过滤，在任务初始阶段，从各个分区中加载到的数据量是相近的，但是一旦进过 filter 过滤后，每个分区的数据量有可能会存在较大差异，如图所示：</p>
<p><img src="https://img.lvxiaoyi.top/typora-img/202111092148301.png/lvxiaoyi" alt="image-20211109214855261"></p>
<p>根据图中信息我们可以发现两个问题：</p>
<ul>
<li><p>每个 partition 的数据量变小了，如果还按照之前与 partition 相等的 task 个数去处理当前数据，有点浪费 task 的计算资源；</p>
</li>
<li><p>每个 partition 的数据量不一样，会导致后面的每个 task 处理每个 partition 数据的时候，</p>
</li>
</ul>
<p>每个 task 要处理的数据量不同，这很有可能导致数据倾斜问题。</p>
<p>如上图所示，第二个分区的数据过滤后只剩100条，而第三个分区的数据过滤后剩下800条，在相同的处理逻辑下，第二个分区对应的 task 处理的数据量与第三个分区对应的 task 处理的数据量差距达到了 8 倍，这也会导致运行速度可能存在数倍的差距，这也就是数据倾斜问题。</p>
<p>针对上述的两个问题，我们分别进行分析：</p>
<ul>
<li><p> 针对第一个问题，既然分区的数据量变小了，我们希望可以对分区数据进行重新分配，比如将原来 4 个分区的数据转化到 2 个分区中，这样只需要用后面的两个 task 进行处理即可，避免了资源的浪费。</p>
</li>
<li><p>针对第二个问题，解决方法和第一个问题的解决方法非常相似，对分区数据重新分配，让每个 partition 中的数据量差不多，这就避免了数据倾斜问题。</p>
</li>
</ul>
<p>那么具体应该如何实现上面的解决思路？我们需要 coalesce 算子。</p>
<p>repartition 与 coalesce 都可以用来进行重分区，其中 repartition 只是 coalesce 接口中 shuffle为 true 的简易实现，coalesce 默认情况下不进行 shuffle，但是可以通过参数进行设置。假设我们希望将原本的分区个数 A 通过重新分区变为 B，那么有以下几种情况：</p>
<ul>
<li><p>A &gt; B（多数分区合并为少数分区）</p>
<ol>
<li><p>A 与 B 相差值不大此时使用 coalesce 即可，无需 shuffle 过程。</p>
</li>
<li><p>A 与 B 相差值很大</p>
<p>此时可以使用 coalesce 并且不启用 shuffle 过程，但是会导致合并过程性能低下，所以推荐设置 coalesce 的第二个参数为 true，即启动 shuffle 过程。</p>
</li>
</ol>
</li>
<li><p>A &lt; B（少数分区分解为多数分区）<br>此时使用 repartition 即可，如果使用 coalesce 需要将 shuffle 设置为 true，否则 coalesce 无效。我们可以在 filter 操作之后，使用 coalesce 算子针对每个 partition 的数据量各不相同的情况，压缩 partition 的数量，而且让每个 partition 的数据量尽量均匀紧凑，以便于后面的 task 进行计算操作，在某种程度上能够在一定程度上提升性能。</p>
</li>
</ul>
<p>  注意：local 模式是进程内模拟集群运行，已经对并行度和分区数量有了一定的内部优化，因此不用去设置并行度和分区数量。</p>
<h3 id="算子调优四：repartition-解决-SparkSQL-低并行度问题"><a href="#算子调优四：repartition-解决-SparkSQL-低并行度问题" class="headerlink" title="算子调优四：repartition 解决 SparkSQL 低并行度问题"></a>算子调优四：repartition 解决 SparkSQL 低并行度问题</h3><p>​      在第一节的常规性能调优中我们讲解了并行度的调节策略，但是，并行度的设置对于Spark SQL 是不生效的，用户设置的并行度只对于 Spark SQL 以外的所有 Spark 的 stage 生效。<br>​         Spark SQL 的并行度不允许用户自己指定，Spark SQL 自己会默认根据 hive 表对应的HDFS 文件的 split 个数自动设置 Spark SQL 所在的那个 stage 的并行度，用户自己通spark.default.parallelism 参数指定的并行度，只会在没 Spark SQL 的 stage 中生效。<br>​         由于 Spark SQL 所在 stage 的并行度无法手动设置，如果数据量较大，并且此 stage 中后续的 transformation 操作有着复杂的业务逻辑，而 Spark SQL 自动设置的 task 数量很少，这就意味着每个 task 要处理为数不少的数据量，然后还要执行非常复杂的处理逻辑，这就可能表现为第一个有 Spark SQL 的 stage 速度很慢，而后续的没有 Spark SQL 的 stage 运行速度非常快。<br>为了解决 Spark SQL 无法设置并行度和 task 数量的问题，我们可以使用 repartition 算子。</p>
<p><img src="https://img.lvxiaoyi.top/typora-img/202111092152626.png/lvxiaoyi" alt="image-20211109215201577"></p>
<p>Spark SQL 这一步的并行度和 task 数量肯定是没有办法去改变了，但是，对于Spark SQL 查询出来的 RDD，立即使用 repartition 算子，去重新进行分区，这样可以重新分区为多个 partition，从 repartition 之后的 RDD 操作，由于不再设计 Spark SQL，因此 stage 的并行度就会等于你手动设置的值，这样就避免了 Spark SQL 所在的 stage 只能用少量的 task 去处理大量数据并执行复杂的算法逻辑。</p>
<h3 id="算子调优五：reduceByKey-预聚合"><a href="#算子调优五：reduceByKey-预聚合" class="headerlink" title="算子调优五：reduceByKey 预聚合"></a>算子调优五：reduceByKey 预聚合</h3><p>reduceByKey 相较于普通的 shuffle 操作一个显著的特点就是会进行 map 端的本地聚合，map 端会先对本地的数据进行 combine 操作，然后将数据写入给下个 stage 的每个 task 创建的文件中，也就是在 map 端，对每一个 key 对应的 value，执行 reduceByKey 算子函数。reduceByKey 算子的执行过程如图所示：</p>
<p><img src="https://img.lvxiaoyi.top/typora-img/202111092152358.png/lvxiaoyi" alt="image-20211109215251306"></p>
<p>使用 reduceByKey 对性能的提升如下：</p>
<ul>
<li><p>本地聚合后，在 map 端的数据量变少，减少了磁盘 IO，也减少了对磁盘空间的占用；</p>
</li>
<li><p>本地聚合后，下一个 stage 拉取的数据量变少，减少了网络传输的数据量；</p>
</li>
<li><p>本地聚合后，在 reduce 端进行数据缓存的内存占用减少；</p>
</li>
<li><p>本地聚合后，在 reduce 端进行聚合的数据量减少。</p>
</li>
</ul>
<p>基于 reduceByKey 的本地聚合特征，我们应该考虑使用 reduceByKey 代替其他的 shuffle 算子，例如 groupByKey。reduceByKey 与groupByKey 的运行原理如图所示</p>
<p>根据上图可知，groupByKey 不会进行 map 端的聚合，而是将所有 map 端的数据 shuffle 到reduce 端，然后在 reduce 端进行数据的聚合操作。由于 reduceByKey 有 map 端聚合的特性， 使得网络传输的数据量减小，因此效率要明显高于groupByKey。</p>
<h2 id="Shuffle-调优"><a href="#Shuffle-调优" class="headerlink" title="Shuffle 调优"></a>Shuffle 调优</h2><h3 id="Shuffle-调优一：调节-map-端缓冲区大小"><a href="#Shuffle-调优一：调节-map-端缓冲区大小" class="headerlink" title="Shuffle 调优一：调节 map 端缓冲区大小"></a>Shuffle 调优一：调节 map 端缓冲区大小</h3><p>在 Spark 任务运行过程中，如果 shuffle 的 map 端处理的数据量比较大，但是map 端缓冲的大小是固定的，可能会出现 map 端缓冲数据频繁 spill 溢写到磁盘文件中的情况，使得性能非常低下，通过调节 map 端缓冲的大小，可以避免频繁的磁盘 IO 操作，进而提升 Spark 任务的整体性能。</p>
<p>map 端缓冲的默认配置是 32KB，如果每个 task 处理 640KB 的数据，那么会发生 640/32= 20 次溢写，如果每个 task 处理 64000KB 的数据，机会发生 64000/32=2000 此溢写，这对于性能的影响是非常严重的。</p>
<p>map 端缓冲的配置方法如代码清单所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val conf = new SparkConf()</span><br><span class="line"> .set(&quot;spark.shuffle.file.buffer&quot;, &quot;64&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="Shuffle-调优二：调节-reduce-端拉取数据缓冲区大小"><a href="#Shuffle-调优二：调节-reduce-端拉取数据缓冲区大小" class="headerlink" title="Shuffle 调优二：调节 reduce 端拉取数据缓冲区大小"></a>Shuffle 调优二：调节 reduce 端拉取数据缓冲区大小</h3><p>Spark Shuffle 过程中，shuffle reduce task 的 buffer 缓冲区大小决定了 reduce task 每次能够缓冲的数据量，也就是每次能够拉取的数据量，如果内存资源较为充足，适当增加拉取数据缓冲区的大小，可以减少拉取数据的次数，也就可以减少网络传输的次数，进而提升性能。reduce 端数据拉取缓冲区的大小可以通过 spark.reducer.maxSizeInFlight 参数进行设置，默认为 48MB，该参数的设置方法如代码清单所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val conf = new SparkConf()</span><br><span class="line"> .set(&quot;spark.reducer.maxSizeInFlight&quot;, &quot;96&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="Shuffle-调优三：调节-reduce-端拉取数据重试次数"><a href="#Shuffle-调优三：调节-reduce-端拉取数据重试次数" class="headerlink" title="Shuffle 调优三：调节 reduce 端拉取数据重试次数"></a>Shuffle 调优三：调节 reduce 端拉取数据重试次数</h3><p>Spark Shuffle 过程中，reduce task 拉取属于自己的数据时，如果因为网络异常等原因导致失败会自动进行重试。对于那些包含了特别耗时的 shuffle 操作的作业，建议增加重试最大次数（比如 60 次），以避免由于 JVM 的 full gc 或者网络不稳定等因素导致的数据拉取失败。在实践中发现，对于针对超大数据量（数十亿~上百亿）的 shuffle 过程，调节该参数可以大幅度提升稳定性。</p>
<p>reduce 端拉取数据重试次数可以通过 spark.shuffle.io.maxRetries 参数进行设置，该参数就代表了可以重试的最大次数。如果在指定次数之内拉取还是没有成功，就可能会导致作业执行失败，默认为 3，该参数的设置方法如代码清单所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val conf = new SparkConf()</span><br><span class="line"> .set(&quot;spark.shuffle.io.maxRetries&quot;, &quot;6&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="Shuffle-调优四：调节-reduce-端拉取数据等待间隔"><a href="#Shuffle-调优四：调节-reduce-端拉取数据等待间隔" class="headerlink" title="Shuffle 调优四：调节 reduce 端拉取数据等待间隔"></a>Shuffle 调优四：调节 reduce 端拉取数据等待间隔</h3><p>Spark Shuffle 过程中，reduce task 拉取属于自己的数据时，如果因为网络异常等原因导致失败会自动进行重试，在一次失败后，会等待一定的时间间隔再进行重试，可以通过加大间隔时长（比如 60s），以增加 shuffle 操作的稳定性。</p>
<p>reduce 端拉取数据等待间隔可以通过 spark.shuffle.io.retryWait 参数进行设置，默认值为 5s，该参数的设置方法如代码清单所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val conf = new SparkConf()</span><br><span class="line"> .set(&quot;spark.shuffle.io.retryWait&quot;, &quot;60s&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="Shuffle-调优五：调节-SortShuffle-排序操作阈值"><a href="#Shuffle-调优五：调节-SortShuffle-排序操作阈值" class="headerlink" title="Shuffle 调优五：调节 SortShuffle 排序操作阈值"></a>Shuffle 调优五：调节 SortShuffle 排序操作阈值</h2><p>对于 SortShuffleManager，如果 shuffle reduce task 的数量小于某一阈值则 shuffle write 过程中不会进行排序操作，而是直接按照未经优化的 HashShuffleManager 的方式去写数据，但是最后会将每个 task 产生的所有临时磁盘文件都合并成一个文件，并会创建单独的索引文件。</p>
<p>当你使用 SortShuffleManager 时，如果的确不需要排序操作，那么建议将这个参数调大一些，大于 shuffle read task 的数量，那么此时 map-side 就不会进行排序了，减少了排序的性能开销，但是这种方式下，依然会产生大量的磁盘文件，因此 shuffle write 性能有待提高。SortShuffleManager 排序操作阈值的设置可以通过 spark.shuffle.sort. bypassMergeThreshold 这一参数进行设置，默认值为 200，该参数的设置方法如代码清单所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val conf = new SparkConf()</span><br><span class="line"> .set(&quot;spark.shuffle.sort.bypassMergeThreshold&quot;, &quot;400&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="JVM-调优"><a href="#JVM-调优" class="headerlink" title="JVM 调优"></a>JVM 调优</h2><p>对于 JVM 调优，首先应该明确，full gc/minor gc，都会导致 JVM 的工作线程停止工作，即 stop the world。</p>
<h3 id="JVM-调优一：降低-cache-操作的内存占比"><a href="#JVM-调优一：降低-cache-操作的内存占比" class="headerlink" title="JVM 调优一：降低 cache 操作的内存占比"></a>JVM 调优一：降低 cache 操作的内存占比</h3><ol>
<li><p>静态内存管理机制</p>
<p>根据 Spark 静态内存管理机制，堆内存被划分为了两块，Storage 和 Execution。Storage主要用于缓存 RDD 数据和 broadcast 数据，Execution 主要用于缓存在 shuffle 过程中产生的中间数据，Storage 占系统内存的 60%，Execution 占系统内存的 20%，并且两者完全独立。在一般情况下，Storage 的内存都提供给了 cache 操作，但是如果在某些情况下 cache 操作内存不是很紧张，而 task 的算子中创建的对象很多，Execution 内存又相对较小，这回导致频繁的 minor gc，甚至于频繁的 full gc，进而导致 Spark 频繁的停止工作，性能影响会很大。在 Spark UI 中可以查看每个 stage 的运行情况，包括每个 task 的运行时间、gc 时间等等，如果发现 gc 太频繁，时间太长，就可以考虑调节 Storage 的内存占比，让 task 执行算子函数式，有更多的内存可以使用。Storage 内存区域可以通过 spark.storage.memoryFraction 参数进行指定，默认为 0.6，即60%，可以逐级向下递减，如代码清单所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val conf = new SparkConf()</span><br><span class="line"> .set(&quot;spark.storage.memoryFraction&quot;, &quot;0.4&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p>统一内存管理机制</p>
<p>根据 Spark 统一内存管理机制，堆内存被划分为了两块，Storage 和 Execution。Storage主要用于缓存数据，Execution 主要用于缓存在 shuffle 过程中产生的中间数据，两者所组成的内存部分称为统一内存，Storage 和 Execution 各占统一内存的 50%，由于动态占用机制的实现，shuffle 过程需要的内存过大时，会自动占用 Storage 的内存区域，因此无需手动进行调节。</p>
</li>
</ol>
<h3 id="JVM-调优二：调节-Executor-堆外内存"><a href="#JVM-调优二：调节-Executor-堆外内存" class="headerlink" title="JVM 调优二：调节 Executor 堆外内存"></a>JVM 调优二：调节 Executor 堆外内存</h3><p>Executor 的堆外内存主要用于程序的共享库、Perm Space、 线程 Stack 和一些 Memory mapping 等, 或者类 C 方式 allocate object。</p>
<p>有时，如果你的 Spark 作业处理的数据量非常大，达到几亿的数据量，此时运行 Spark作业会时不时地报错，例如 shuffle output file cannot find，executor lost，task lost，out of memory等，这可能是 Executor 的堆外内存不太够用，导致 Executor 在运行的过程中内存溢出。</p>
<p>stage 的 task 在运行的时候，可能要从一些 Executor 中去拉取 shuffle map output 文件，但是 Executor 可能已经由于内存溢出挂掉了，其关联的 BlockManager 也没有了，这就可能会报出 shuffle output file cannot find，executor lost，task lost，out of memory 等错误，此时，就可以考虑调节一下 Executor 的堆外内存，也就可以避免报错，与此同时，堆外内存调节的比较大的时候，对于性能来讲，也会带来一定的提升。</p>
<p>默认情况下，Executor 堆外内存上限大概为 300 多 MB，在实际的生产环境下，对海量数据进行处理的时候，这里都会出现问题，导致 Spark 作业反复崩溃，无法运行，此时就会去调节这个参数，到至少 1G，甚至于 2G、4G。</p>
<p>Executor 堆外内存的配置需要在 spark-submit 脚本里配置，如代码清单所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--conf spark.yarn.executor.memoryOverhead=2048</span><br></pre></td></tr></table></figure>

<p>以上参数配置完成后，会避免掉某些 JVM OOM 的异常问题，同时，可以提升整体 Spark作业的性能。</p>
<h3 id="JVM-调优三：调节连接等待时长"><a href="#JVM-调优三：调节连接等待时长" class="headerlink" title="JVM 调优三：调节连接等待时长"></a>JVM 调优三：调节连接等待时长</h3><p>在 Spark 作业运行过程中，Executor 优先从自己本地关联的 BlockManager 中获取某份数据，如果本地BlockManager没有的话，会通过TransferService远程连接其他节点上Executor的 BlockManager 来获取数据。</p>
<p>如果 task 在运行过程中创建大量对象或者创建的对象较大，会占用大量的内存，这回导致频繁的垃圾回收，但是垃圾回收会导致工作现场全部停止，也就是说，垃圾回收一旦执行，Spark 的 Executor 进程就会停止工作，无法提供相应，此时，由于没有响应，无法建立网络连接，会导致网络连接超时。</p>
<p>在生产环境下，有时会遇到 file not found、file lost 这类错误，在这种情况下，很有可能是 Executor 的 BlockManager 在拉取数据的时候，无法建立连接，然后超过默认的连接等待时长 60s 后，宣告数据拉取失败，如果反复尝试都拉取不到数据，可能会导致 Spark 作业的崩溃。这种情况也可能会导致 DAGScheduler 反复提交几次 stage，TaskScheduler 返回提交几次 task，大大延长了我们的 Spark 作业的运行时间。</p>
<p>此时，可以考虑调节连接的超时时长，连接等待时长需要在 spark-submit 脚本中进行设置，</p>
<p>设置方式如代码清单所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--conf spark.core.connection.ack.wait.timeout=300</span><br></pre></td></tr></table></figure>

<p>调节连接等待时长后，通常可以避免部分的 XX 文件拉取失败、XX 文件 lost 等报错。</p>
<h1 id="第-2-章-Spark-数据倾斜"><a href="#第-2-章-Spark-数据倾斜" class="headerlink" title="第 2 章 Spark 数据倾斜"></a>第 2 章 Spark 数据倾斜</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://lvxiaoyi.top">lvxiaoyi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lvxiaoyi.top/eba75c5.html">https://lvxiaoyi.top/eba75c5.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lvxiaoyi.top" target="_blank">吕小医's BLOG</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></div><div class="post_share"><div class="social-share" data-image="https://img.lvxiaoyi.top/typora-img/202111081621419.png/lvxiaoyi" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/4443ccc7.html"><img class="prev-cover" src="https://img.lvxiaoyi.top/typora-img/202111081621419.png/lvxiaoyi" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spark基础-4Spark核心</div></div></a></div><div class="next-post pull-right"><a href="/6362a21d.html"><img class="next-cover" src="https://img.lvxiaoyi.top/typora-img/202111082146936.png/lvxiaoyi" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Scala基础-1</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/5eb2dc8b.html" title="hadoop基础-3Yarn"><img class="cover" src="https://img.lvxiaoyi.top/typora-img/image-20211028174657424.png/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">hadoop基础-3Yarn</div></div></a></div><div><a href="/bc13a2ae.html" title="HBase基础"><img class="cover" src="https://img.lvxiaoyi.top/typora-img/image-20211028174657424.png/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">HBase基础</div></div></a></div><div><a href="/9cbb2d93.html" title="hive基础-2"><img class="cover" src="https://img.lvxiaoyi.top/typora-img/image-20211028174657424.png/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">hive基础-2</div></div></a></div><div><a href="/1d83a7d1.html" title="Hive基础-1"><img class="cover" src="https://img.lvxiaoyi.top/typora-img/image-20211028174657424.png/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">Hive基础-1</div></div></a></div><div><a href="/6362a21d.html" title="Scala基础-1"><img class="cover" src="https://img.lvxiaoyi.top/typora-img/202111082146936.png/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">Scala基础-1</div></div></a></div><div><a href="/fa6bf3a7.html" title="Scala基础-2"><img class="cover" src="https://img.lvxiaoyi.top/typora-img/202111082146936.png/lvxiaoyi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">Scala基础-2</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://p0.meituan.net/csc/8a1b1d488e6a8ab5108c9c78f36b3a1776955.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lvxiaoyi</div><div class="author-info__description">ISFP到ESFJ</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">204</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">50</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spark%E5%9F%BA%E7%A1%80-5Spark%E4%BC%98%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">Spark基础-5Spark优化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spark-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-number">2.</span> <span class="toc-text">Spark 性能调优</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-number">2.1.</span> <span class="toc-text">常规性能调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%80%EF%BC%9A%E6%9C%80%E4%BC%98%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE"><span class="toc-number">2.1.1.</span> <span class="toc-text">常规性能调优一：最优资源配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%BA%8C%EF%BC%9ARDD-%E4%BC%98%E5%8C%96"><span class="toc-number">2.1.2.</span> <span class="toc-text">常规性能调优二：RDD 优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RDD-%E5%A4%8D%E7%94%A8"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">RDD 复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDD-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">RDD 持久化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%89%EF%BC%9A%E5%B9%B6%E8%A1%8C%E5%BA%A6%E8%B0%83%E8%8A%82"><span class="toc-number">2.1.3.</span> <span class="toc-text">常规性能调优三：并行度调节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%9B%9B%EF%BC%9A%E5%B9%BF%E6%92%AD%E5%A4%A7%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.4.</span> <span class="toc-text">常规性能调优四：广播大变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%BA%94%EF%BC%9AKryo-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">2.1.5.</span> <span class="toc-text">常规性能调优五：Kryo 序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%85%AD%EF%BC%9A%E8%B0%83%E8%8A%82%E6%9C%AC%E5%9C%B0%E5%8C%96%E7%AD%89%E5%BE%85%E6%97%B6%E9%95%BF"><span class="toc-number">2.1.6.</span> <span class="toc-text">常规性能调优六：调节本地化等待时长</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E5%AD%90%E8%B0%83%E4%BC%98"><span class="toc-number">2.2.</span> <span class="toc-text">算子调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E5%AD%90%E8%B0%83%E4%BC%98%E4%B8%80%EF%BC%9AmapPartitions"><span class="toc-number">2.2.1.</span> <span class="toc-text">算子调优一：mapPartitions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E5%AD%90%E8%B0%83%E4%BC%98%E4%BA%8C%EF%BC%9AforeachPartition-%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.2.</span> <span class="toc-text">算子调优二：foreachPartition 优化数据库操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E5%AD%90%E8%B0%83%E4%BC%98%E4%B8%89%EF%BC%9Afilter-%E4%B8%8E-coalesce-%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.3.</span> <span class="toc-text">算子调优三：filter 与 coalesce 的配合使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E5%AD%90%E8%B0%83%E4%BC%98%E5%9B%9B%EF%BC%9Arepartition-%E8%A7%A3%E5%86%B3-SparkSQL-%E4%BD%8E%E5%B9%B6%E8%A1%8C%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.4.</span> <span class="toc-text">算子调优四：repartition 解决 SparkSQL 低并行度问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E5%AD%90%E8%B0%83%E4%BC%98%E4%BA%94%EF%BC%9AreduceByKey-%E9%A2%84%E8%81%9A%E5%90%88"><span class="toc-number">2.2.5.</span> <span class="toc-text">算子调优五：reduceByKey 预聚合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shuffle-%E8%B0%83%E4%BC%98"><span class="toc-number">2.3.</span> <span class="toc-text">Shuffle 调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Shuffle-%E8%B0%83%E4%BC%98%E4%B8%80%EF%BC%9A%E8%B0%83%E8%8A%82-map-%E7%AB%AF%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">Shuffle 调优一：调节 map 端缓冲区大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shuffle-%E8%B0%83%E4%BC%98%E4%BA%8C%EF%BC%9A%E8%B0%83%E8%8A%82-reduce-%E7%AB%AF%E6%8B%89%E5%8F%96%E6%95%B0%E6%8D%AE%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.3.2.</span> <span class="toc-text">Shuffle 调优二：调节 reduce 端拉取数据缓冲区大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shuffle-%E8%B0%83%E4%BC%98%E4%B8%89%EF%BC%9A%E8%B0%83%E8%8A%82-reduce-%E7%AB%AF%E6%8B%89%E5%8F%96%E6%95%B0%E6%8D%AE%E9%87%8D%E8%AF%95%E6%AC%A1%E6%95%B0"><span class="toc-number">2.3.3.</span> <span class="toc-text">Shuffle 调优三：调节 reduce 端拉取数据重试次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shuffle-%E8%B0%83%E4%BC%98%E5%9B%9B%EF%BC%9A%E8%B0%83%E8%8A%82-reduce-%E7%AB%AF%E6%8B%89%E5%8F%96%E6%95%B0%E6%8D%AE%E7%AD%89%E5%BE%85%E9%97%B4%E9%9A%94"><span class="toc-number">2.3.4.</span> <span class="toc-text">Shuffle 调优四：调节 reduce 端拉取数据等待间隔</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shuffle-%E8%B0%83%E4%BC%98%E4%BA%94%EF%BC%9A%E8%B0%83%E8%8A%82-SortShuffle-%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C%E9%98%88%E5%80%BC"><span class="toc-number">2.4.</span> <span class="toc-text">Shuffle 调优五：调节 SortShuffle 排序操作阈值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E8%B0%83%E4%BC%98"><span class="toc-number">2.5.</span> <span class="toc-text">JVM 调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E8%B0%83%E4%BC%98%E4%B8%80%EF%BC%9A%E9%99%8D%E4%BD%8E-cache-%E6%93%8D%E4%BD%9C%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%A0%E6%AF%94"><span class="toc-number">2.5.1.</span> <span class="toc-text">JVM 调优一：降低 cache 操作的内存占比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E8%B0%83%E4%BC%98%E4%BA%8C%EF%BC%9A%E8%B0%83%E8%8A%82-Executor-%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98"><span class="toc-number">2.5.2.</span> <span class="toc-text">JVM 调优二：调节 Executor 堆外内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E8%B0%83%E4%BC%98%E4%B8%89%EF%BC%9A%E8%B0%83%E8%8A%82%E8%BF%9E%E6%8E%A5%E7%AD%89%E5%BE%85%E6%97%B6%E9%95%BF"><span class="toc-number">2.5.3.</span> <span class="toc-text">JVM 调优三：调节连接等待时长</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-2-%E7%AB%A0-Spark-%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C"><span class="toc-number">3.</span> <span class="toc-text">第 2 章 Spark 数据倾斜</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/7ef7bbd4.html" title="LeetCode 118. 杨辉三角"><img src="https://img.lvxiaoyi.top/typora-img/202111011355394.png/lvxiaoyi" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode 118. 杨辉三角"/></a><div class="content"><a class="title" href="/7ef7bbd4.html" title="LeetCode 118. 杨辉三角">LeetCode 118. 杨辉三角</a><time datetime="2023-03-19T14:25:59.394Z" title="发表于 2023-03-19 22:25:59">2023-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/82c8cab7.html" title="shell基础"><img src="https://pic2.zhimg.com/v2-9964d2894516902605191817111ec781_r.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="shell基础"/></a><div class="content"><a class="title" href="/82c8cab7.html" title="shell基础">shell基础</a><time datetime="2022-10-12T16:07:18.841Z" title="发表于 2022-10-13 00:07:18">2022-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f1601c3e.html" title="单例模式"><img src="https://img.lvxiaoyi.top/typora-img/1002892-20180912131026735-781767905.png/lvxiaoyi" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="单例模式"/></a><div class="content"><a class="title" href="/f1601c3e.html" title="单例模式">单例模式</a><time datetime="2022-09-12T07:22:48.777Z" title="发表于 2022-09-12 15:22:48">2022-09-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/b15f0f1b.html" title="设计模式基础-1"><img src="https://img.lvxiaoyi.top/typora-img/image-20211012093705433.png/lvxiaoyi" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式基础-1"/></a><div class="content"><a class="title" href="/b15f0f1b.html" title="设计模式基础-1">设计模式基础-1</a><time datetime="2022-09-12T07:22:48.777Z" title="发表于 2022-09-12 15:22:48">2022-09-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2109f677.html" title="计算机网络常见面试题"><img src="https://img.lvxiaoyi.top/typora-img/java-interview/1.png/lvxiaoyi" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络常见面试题"/></a><div class="content"><a class="title" href="/2109f677.html" title="计算机网络常见面试题">计算机网络常见面试题</a><time datetime="2022-09-12T07:22:48.777Z" title="发表于 2022-09-12 15:22:48">2022-09-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://img.lvxiaoyi.top/typora-img/202111081621419.png/lvxiaoyi')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By lvxiaoyi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/lvxiaoyi.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>