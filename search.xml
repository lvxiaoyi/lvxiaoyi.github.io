<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深究Spring中Bean的生命周期</title>
    <url>/440fb577.html</url>
    <content><![CDATA[<html><head></head><body><h2 id="深究Spring中Bean的生命周期"><a href="#深究Spring中Bean的生命周期" class="headerlink" title="深究Spring中Bean的生命周期"></a>深究Spring中Bean的生命周期</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这其实是一道面试题，是我在面试百度的时候被问到的，当时没有答出来(因为自己真的很菜)，后来在网上寻找答案，看到也是一头雾水，直到看到了《Spring in action》这本书，书上有对Bean声明周期的大致解释，但是没有代码分析，所以就自己上网寻找资料，一定要把这个Bean生命周期弄明白！</p>
<p>网上大部分都是验证的Bean 在面试问的生命周期，其实查阅JDK还有一个完整的Bean生命周期，这同时也验证了书是具有片面性的，最fresh 的资料还是查阅原始JDK!!!</p>
<span id="more"></span>
<h2 id="一、Bean-的完整生命周期"><a href="#一、Bean-的完整生命周期" class="headerlink" title="一、Bean 的完整生命周期"></a>一、Bean 的完整生命周期</h2><p>在传统的Java应用中，bean的生命周期很简单，使用Java关键字 new 进行Bean 的实例化，然后该Bean 就能够使用了。一旦bean不再被使用，则由Java自动进行垃圾回收。</p>
<p>相比之下，Spring管理Bean的生命周期就复杂多了，正确理解Bean 的生命周期非常重要，因为Spring对Bean的管理可扩展性非常强，下面展示了一个Bean的构造过程</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/05/java0-1558500658.jpg" alt="深究Spring中Bean的生命周期"></p>
<p><strong>Bean 的生命周期</strong></p>
<p>如上图所示，Bean 的生命周期还是比较复杂的，下面来对上图每一个步骤做文字描述:</p>
<ol>
<li>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</li>
<li>Bean实例化后对将Bean的引入和值注入到Bean的属性中</li>
<li>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</li>
<li>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</li>
<li>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。</li>
<li>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</li>
<li>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</li>
<li>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</li>
<li>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</li>
<li>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</li>
</ol>
<blockquote>
<p><strong>上面是Spring 中Bean的核心接口和生命周期，面试回答上述过程已经足够了。但是翻阅JavaDoc文档发现除了以上接口外，还有另外的初始化过程涉及的接口：</strong></p>
<p><strong>摘自org.springframework.beans.factory.BeanFactory， 全部相关接口如下，上述已有的就不用着重标注，把额外的相关接口着重标注下</strong></p>
</blockquote>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/05/java10-1558500659.jpg" alt="深究Spring中Bean的生命周期"></p>
<p><strong>Bean 完整的生命周期</strong></p>
<p>文字解释如下：</p>
<p>————————————初始化————————————</p>
<ul>
<li>BeanNameAware.setBeanName() 在创建此bean的bean工厂中设置bean的名称，在普通属性设置之后调用，在InitializinngBean.afterPropertiesSet()方法之前调用</li>
<li><code>BeanClassLoaderAware.setBeanClassLoader()</code>: 在普通属性设置之后，InitializingBean.afterPropertiesSet()之前调用</li>
<li>BeanFactoryAware.setBeanFactory() : 回调提供了自己的bean实例工厂，在普通属性设置之后，在InitializingBean.afterPropertiesSet()或者自定义初始化方法之前调用</li>
<li><code>EnvironmentAware.setEnvironment()</code>: 设置environment在组件使用时调用</li>
<li><code>EmbeddedValueResolverAware.setEmbeddedValueResolver()</code>: 设置StringValueResolver 用来解决嵌入式的值域问题</li>
<li><code>ResourceLoaderAware.setResourceLoader()</code>: 在普通bean对象之后调用，在afterPropertiesSet 或者自定义的init-method 之前调用，在 ApplicationContextAware 之前调用。</li>
<li><code>ApplicationEventPublisherAware.setApplicationEventPublisher()</code>: 在普通bean属性之后调用，在初始化调用afterPropertiesSet 或者自定义初始化方法之前调用。在 ApplicationContextAware 之前调用。</li>
<li><code>MessageSourceAware.setMessageSource()</code>: 在普通bean属性之后调用，在初始化调用afterPropertiesSet 或者自定义初始化方法之前调用，在 ApplicationContextAware 之前调用。</li>
<li>ApplicationContextAware.setApplicationContext(): 在普通Bean对象生成之后调用，在InitializingBean.afterPropertiesSet之前调用或者用户自定义初始化方法之前。在ResourceLoaderAware.setResourceLoader，ApplicationEventPublisherAware.setApplicationEventPublisher，MessageSourceAware之后调用。</li>
<li><code>ServletContextAware.setServletContext()</code>: 运行时设置ServletContext，在普通bean初始化后调用，在InitializingBean.afterPropertiesSet之前调用，在 ApplicationContextAware 之后调用<strong>注：是在WebApplicationContext 运行时</strong></li>
<li>BeanPostProcessor.postProcessBeforeInitialization() : 将此BeanPostProcessor 应用于给定的新bean实例 在任何bean初始化回调方法(像是InitializingBean.afterPropertiesSet或者自定义的初始化方法）之前调用。这个bean将要准备填充属性的值。返回的bean示例可能被普通对象包装，默认实现返回是一个bean。</li>
<li>BeanPostProcessor.postProcessAfterInitialization() : 将此BeanPostProcessor 应用于给定的新bean实例 在任何bean初始化回调方法(像是InitializingBean.afterPropertiesSet或者自定义的初始化方法)之后调用。这个bean将要准备填充属性的值。返回的bean示例可能被普通对象包装</li>
<li>InitializingBean.afterPropertiesSet(): 被BeanFactory在设置所有bean属性之后调用(并且满足BeanFactory 和 ApplicationContextAware)。</li>
</ul>
<p>————————————销毁————————————</p>
<p>在BeanFactory 关闭的时候，Bean的生命周期会调用如下方法:</p>
<ul>
<li><code>DestructionAwareBeanPostProcessor.postProcessBeforeDestruction()</code>: 在销毁之前将此BeanPostProcessor 应用于给定的bean实例。能够调用自定义回调，像是DisposableBean 的销毁和自定义销毁方法，这个回调仅仅适用于工厂中的单例bean(包括内部bean)</li>
<li>实现了自定义的destory()方法</li>
</ul>
<h2 id="二、Bean-的生命周期验证"><a href="#二、Bean-的生命周期验证" class="headerlink" title="二、Bean 的生命周期验证"></a>二、Bean 的生命周期验证</h2><p>为了验证Bean生命周期的过程，有两种形式：一种是为面试而准备的，一种是为了解全过程而准备的，下面来看代码：</p>
<p>Book.class</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">public class Book implements BeanNameAware,BeanFactoryAware,</span><br><span class="line">        ApplicationContextAware,InitializingBean,DisposableBean {</span><br><span class="line"></span><br><span class="line">    private String bookName;</span><br><span class="line">    public Book(){</span><br><span class="line">        System.out.println("Book Initializing ");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {</span><br><span class="line">        System.out.println("Book.setBeanFactory invoke");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setBeanName(String name) {</span><br><span class="line">        System.out.println("Book.setBeanName invoke");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void destroy() throws Exception {</span><br><span class="line">        System.out.println("Book.destory invoke");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void afterPropertiesSet() throws Exception {</span><br><span class="line">        System.out.println("Book.afterPropertiesSet invoke");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {</span><br><span class="line">        System.out.println("Book.setApplicationContext invoke");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public String getBookName() {</span><br><span class="line">        return bookName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setBookName(String bookName) {</span><br><span class="line">        this.bookName = bookName;</span><br><span class="line">        System.out.println("setBookName: Book name has set.");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void myPostConstruct(){</span><br><span class="line">        System.out.println("Book.myPostConstruct invoke");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">     // 自定义初始化方法</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void springPostConstruct(){</span><br><span class="line">        System.out.println("@PostConstruct");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void myPreDestory(){</span><br><span class="line">        System.out.println("Book.myPreDestory invoke");</span><br><span class="line">        System.out.println("---------------destroy-----------------");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 自定义销毁方法</span><br><span class="line">    @PreDestroy</span><br><span class="line">    public void springPreDestory(){</span><br><span class="line">        System.out.println("@PreDestory");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable {</span><br><span class="line">        System.out.println("------inside finalize-----");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>自定义实现BeanPostProcessor 的MyBeanPostProcessor：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">public class MyBeanPostProcessor implements BeanPostProcessor {</span><br><span class="line"></span><br><span class="line">    // 容器加载的时候会加载一些其他的bean，会调用初始化前和初始化后方法</span><br><span class="line">    // 这次只关注book(bean)的生命周期</span><br><span class="line">    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {</span><br><span class="line">        if(bean instanceof Book){</span><br><span class="line">            System.out.println("MyBeanPostProcessor.postProcessBeforeInitialization");</span><br><span class="line">        }</span><br><span class="line">        return bean;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {</span><br><span class="line">        if(bean instanceof Book){</span><br><span class="line">            System.out.println("MyBeanPostProcessor.postProcessAfterInitialization");</span><br><span class="line">        }</span><br><span class="line">        return bean;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure>



<p>在resources 目录下新建Bean-Lifecycle.xml</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</span><br><span class="line">       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class="line">       xmlns:context="http://www.springframework.org/schema/context"</span><br><span class="line">       xsi:schemaLocation="http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- 扫描bean --&gt;</span><br><span class="line">    &lt;context:component-scan base-package="com.bean.lifecycle"/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 实现了用户自定义初始化和销毁方法 --&gt;</span><br><span class="line">    &lt;bean id="book" class="com.bean.lifecycle.Book" init-method="myPostConstruct" destroy-method="myPreDestory"&gt;</span><br><span class="line">          &lt;!-- 注入bean 属性名称 --&gt;</span><br><span class="line">        &lt;property name="bookName" value="thingking in java" /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!--引入自定义的BeanPostProcessor--&gt;</span><br><span class="line">    &lt;bean class="com.bean.lifecycle.MyBeanPostProcessor"/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></tbody></table></figure>



<p>做一个启动类的测试，新建SpringBeanLifecycleApplication</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">public class SpringBeanLifecycleApplication {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException {</span><br><span class="line">        // 为面试而准备的Bean生命周期加载过程</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext("Bean-Lifecycle.xml");</span><br><span class="line">        Book book = (Book)context.getBean("book");</span><br><span class="line">        System.out.println("Book name = " + book.getBookName());</span><br><span class="line">        ((ClassPathXmlApplicationContext) context).destroy();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>启动测试，输出结果如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Book Initializing </span><br><span class="line">setBookName: Book name has set.</span><br><span class="line">Book.setBeanName invoke</span><br><span class="line">Book.setBeanFactory invoke</span><br><span class="line">Book.setApplicationContext invoke</span><br><span class="line">MyBeanPostProcessor.postProcessBeforeInitialization</span><br><span class="line">@PostConstruct</span><br><span class="line">Book.afterPropertiesSet invoke</span><br><span class="line">Book.myPostConstruct invoke</span><br><span class="line">MyBeanPostProcessor.postProcessAfterInitialization</span><br><span class="line">Book name = thingking in java</span><br><span class="line"></span><br><span class="line">@PreDestory</span><br><span class="line">Book.destory invoke</span><br><span class="line">Book.myPreDestory invoke</span><br><span class="line">---------------destroy-----------------</span><br></pre></td></tr></tbody></table></figure>



<p>为了验证Bean完整的生命周期，需要新建一个SubBookClass 继承Book类</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">public class SubBookClass extends Book implements BeanClassLoaderAware,</span><br><span class="line">        EnvironmentAware,EmbeddedValueResolverAware,ResourceLoaderAware,</span><br><span class="line">        ApplicationEventPublisherAware,MessageSourceAware{</span><br><span class="line"></span><br><span class="line">    private String bookSystem;</span><br><span class="line"></span><br><span class="line">    public String getBookSystem() {</span><br><span class="line">        return bookSystem;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setBookSystem(String bookSystem) {</span><br><span class="line">        System.out.println("设置BookSystem 的属性值");</span><br><span class="line">        this.bookSystem = bookSystem;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setBeanClassLoader(ClassLoader classLoader) {</span><br><span class="line">        System.out.println("SubBookClass.setBeanClassLoader() 方法被调用了");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {</span><br><span class="line">        System.out.println("SubBookClass.setApplicationEventPublisher() 方法被调用了");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setEmbeddedValueResolver(StringValueResolver resolver) {</span><br><span class="line">        System.out.println("SubBookClass.setEmbeddedValueResolver() 方法被调用了");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setEnvironment(Environment environment) {</span><br><span class="line">        System.out.println("SubBookClass.setEnvironment() 方法被调用了");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setMessageSource(MessageSource messageSource) {</span><br><span class="line">        System.out.println("SubBookClass.setMessageSource() 方法被调用了");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setResourceLoader(ResourceLoader resourceLoader) {</span><br><span class="line">        System.out.println("SubBookClass.setResourceLoader() 方法被调用了");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>上述SubBookClass类与Book是<code>互补</code>关系。</p>
</blockquote>
<p>新建一个SubBean-Lifecycle.xml，注入SubBookClass</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</span><br><span class="line">       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class="line">       xmlns:context="http://www.springframework.org/schema/context"</span><br><span class="line">       xsi:schemaLocation="http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;bean id="bookClass" class="com.bean.lifecycle.SubBookClass" init-method="myPostConstruct" destroy-method="myPreDestory"&gt;</span><br><span class="line">        &lt;property name="bookSystem" value="Java System" /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class="com.bean.lifecycle.MyBeanPostProcessor"/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></tbody></table></figure>



<p>完整的SpringBeanLifecycleApplication 如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">public class SpringBeanLifecycleApplication {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException {</span><br><span class="line">        // 为面试而准备的Bean生命周期加载过程</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext("Bean-Lifecycle.xml");</span><br><span class="line">        Book book = (Book)context.getBean("book");</span><br><span class="line">        System.out.println("Book name = " + book.getBookName());</span><br><span class="line">        ((ClassPathXmlApplicationContext) context).destroy();</span><br><span class="line"></span><br><span class="line">        // 完整的加载过程，当然了解的越多越好</span><br><span class="line">        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("SubBean-Lifecycle.xml");</span><br><span class="line">        SubBookClass subBookClass = (SubBookClass) applicationContext.getBean("bookClass");</span><br><span class="line">        System.out.println("BookSystemName = " + subBookClass.getBookSystem());</span><br><span class="line">        ((ClassPathXmlApplicationContext) applicationContext).registerShutdownHook();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>输出完整的结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Book Initializing </span><br><span class="line">setBookName: Book name has set.</span><br><span class="line">Book.setBeanName invoke</span><br><span class="line">Book.setBeanFactory invoke</span><br><span class="line">Book.setApplicationContext invoke</span><br><span class="line">MyBeanPostProcessor.postProcessBeforeInitialization</span><br><span class="line">@PostConstruct</span><br><span class="line">Book.afterPropertiesSet invoke</span><br><span class="line">Book.myPostConstruct invoke</span><br><span class="line">MyBeanPostProcessor.postProcessAfterInitialization</span><br><span class="line">Book name = thingking in java</span><br><span class="line">@PreDestory</span><br><span class="line">Book.destory invoke</span><br><span class="line">Book.myPreDestory invoke</span><br><span class="line">---------------destroy-----------------</span><br><span class="line"></span><br><span class="line">Book Initializing </span><br><span class="line">设置BookSystem 的属性值</span><br><span class="line">Book.setBeanName invoke</span><br><span class="line">SubBookClass.setBeanClassLoader() 方法被调用了</span><br><span class="line">Book.setBeanFactory invoke</span><br><span class="line">SubBookClass.setEnvironment() 方法被调用了</span><br><span class="line">SubBookClass.setEmbeddedValueResolver() 方法被调用了</span><br><span class="line">SubBookClass.setResourceLoader() 方法被调用了</span><br><span class="line">SubBookClass.setApplicationEventPublisher() 方法被调用了</span><br><span class="line">SubBookClass.setMessageSource() 方法被调用了</span><br><span class="line">Book.setApplicationContext invoke</span><br><span class="line">MyBeanPostProcessor.postProcessBeforeInitialization</span><br><span class="line">Book.afterPropertiesSet invoke</span><br><span class="line">Book.myPostConstruct invoke</span><br><span class="line">MyBeanPostProcessor.postProcessAfterInitialization</span><br><span class="line">BookSystemName = Java System</span><br><span class="line">Book.destory invoke</span><br><span class="line">Book.myPreDestory invoke</span><br><span class="line">---------------destroy-----------------</span><br></pre></td></tr></tbody></table></figure>



<p>后记：这篇文章是我翻阅各种书籍和从网上查找资料，包括国外一些网站从而得到的结论，记录下来，但是我没有发现<em>Spring Bean的生命周期（非常详细）</em> 这篇文章中InstantiationAwareBeanPostProcessorAdapter 这个类和工厂后置处理器接口方法，知道的朋友欢迎指教，感谢。</p>
<p><em><a href="https://www.cnblogs.com/zrtqsk/p/3735273.html">https://www.cnblogs.com/zrtqsk/p/3735273.html</a></em></p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><blockquote>
<p><a href="https://www.cnblogs.com/zrtqsk/p/3735273.html">https://www.cnblogs.com/zrtqsk/p/3735273.html</a><br><a href="https://www.journaldev.com/2637/spring-bean-life-cycle">https://www.journaldev.com/2637/spring-bean-life-cycle</a><br><a href="http://www.wideskills.com/spring/spring-bean-lifecycle">http://www.wideskills.com/spring/spring-bean-lifecycle</a><br><a href="http://www.concretepage.com/spring/spring-bean-life-cycle-tutorial">www.concretepage.com/spring/spring-bean-life-cycle-tutorial</a></p>
</blockquote>
</body></html>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/f1601c3e.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h1><p>单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。</p>
<p>许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p>
<span id="more"></span>

<p><img src="https://images2018.cnblogs.com/blog/1002892/201809/1002892-20180912131026735-781767905.png" alt="img"></p>
<h1 id="单例模式应用场景"><a href="#单例模式应用场景" class="headerlink" title="单例模式应用场景"></a>单例模式应用场景</h1><p>举一个小例子，在我们的windows桌面上，我们打开了一个回收站，当我们试图再次打开一个新的回收站时，Windows系统并不会为你弹出一个新的回收站窗口。，也就是说在整个系统运行的过程中，系统只维护一个回收站的实例。这就是一个典型的单例模式运用。</p>
<p> 继续说回收站，我们在实际使用中并不存在需要同时打开两个回收站窗口的必要性。假如我每次创建回收站时都需要消耗大量的资源，而每个回收站之间资源是共享的，那么在没有必要多次重复创建该实例的情况下，创建了多个实例，这样做就会给系统造成不必要的负担，造成资源浪费。</p>
<p> 再举一个例子，网站的计数器，一般也是采用单例模式实现，如果你存在多个计数器，每一个用户的访问都刷新计数器的值，这样的话你的实计数的值是难以同步的。但是如果采用单例模式实现就不会存在这样的问题，而且还可以避免线程安全问题。同样多线程的线程池的设计一般也是采用单例模式，这是由于线程池需要方便对池中的线程进行控制</p>
<p> 同样，对于一些应用程序的日志应用，或者web开发中读取配置文件都适合使用单例模式，如HttpApplication 就是单例的典型应用。</p>
<p> 从上述的例子中我们可以总结出适合使用单例模式的场景和优缺点： </p>
<p>  <strong>适用场景：</strong></p>
<ul>
<li><strong>1.需要生成唯一序列的环境</strong></li>
<li><strong>2.需要频繁实例化然后销毁的对象。</strong></li>
<li><strong>3.创建对象时耗时过多或者耗资源过多，但又经常用到的对象。</strong> </li>
<li><strong>4.方便资源相互通信的环境</strong></li>
</ul>
<h1 id="单例模式的优缺点"><a href="#单例模式的优缺点" class="headerlink" title="单例模式的优缺点"></a>单例模式的优缺点</h1><p><strong>优点</strong>：</p>
<ul>
<li>在内存中只有一个对象，节省内存空间；</li>
<li>避免频繁的创建销毁对象，可以提高性能；</li>
<li>避免对共享资源的多重占用，简化访问；</li>
<li>为整个系统提供一个全局访问点。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li> 不适用于变化频繁的对象；</li>
<li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；</li>
<li>如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失；</li>
</ul>
<h1 id="单例模式实现"><a href="#单例模式实现" class="headerlink" title="单例模式实现"></a>单例模式实现</h1><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p><code>jvm加载类的的时候就把单例对象生成</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>{</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 指向自己实例的私有静态引用，主动创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>{}</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 以自己实例为返回值的静态的公有方法，静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>我们知道，<strong>类加载的方式是按需加载，且加载一次</strong>。。因此，在上述单例类被加载时，就会实例化一个对象并交给自己的引用，供系统使用；而且，由于这个类在整个生命周期中只会被加载一次，因此只会创建一个实例，<strong>jvm底层保证了单例</strong>。</p>
<p>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p>
<p>缺点：在类装载的时候就完成实例化，<strong>没有达到Lazy Loading的效果</strong>。如果从始至终从未使用过这个实例，则会造成内存的浪费。</p>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p><code>jvm加载类的的时候不生成单例对象，而是需要的时候才第一次创建，线程不安全</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 懒汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>{</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 指向自己实例的私有静态引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span></span>{}</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 以自己实例为返回值的静态的公有方法，静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">// 被动创建，在真正需要使用时才去创建</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>们从懒汉式单例可以看到，单例实例被<strong>延迟加载</strong>，即只有在真正使用的时候才会实例化一个对象并交给自己的引用。</p>
<p>这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了if (instance== null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。</p>
<h2 id="线程安全饿汉式之全锁"><a href="#线程安全饿汉式之全锁" class="headerlink" title="线程安全饿汉式之全锁"></a>线程安全饿汉式之全锁</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    	<span class="comment">// 创建单例的具体业务逻辑.....省略</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) { </span><br><span class="line">        	instance = <span class="keyword">new</span> Singleton3(); </span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 创建单例的具体业务逻辑.....省略</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>优点：保证了线程安全和懒加载</p>
<p>缺点：效率低。这种模式保证的线程安全，但是效率特别低，在高并发情况下，每次调用getInstance方法都需要加锁，显然不符合高并发情况的效率。</p>
<h2 id="线程安全饿汉式之部分锁-双重判空检查"><a href="#线程安全饿汉式之部分锁-双重判空检查" class="headerlink" title="线程安全饿汉式之部分锁+双重判空检查"></a>线程安全饿汉式之部分锁+双重判空检查</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance; <span class="comment">// 不使用volatile关键字</span></span><br><span class="line">    <span class="comment">// 双重锁检验</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) { </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton4.class) {</span><br><span class="line">                <span class="comment">//这里必须要在使用一次判空检查，在多线程情况下，可能多个线程都判断为空，进入了synchronized</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton4(); <span class="comment">// 第10行</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果发生了重排序（在高并发情况下小概率出现，但是确实会出现）：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">instance = <span class="keyword">new</span> Singleton4(); <span class="comment">// 第10行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以分解为以下三个步骤</span></span><br><span class="line"><span class="number">1</span> memory=allocate();<span class="comment">// 分配内存 相当于c的malloc</span></span><br><span class="line"><span class="number">2</span> ctorInstanc(memory) <span class="comment">//初始化对象</span></span><br><span class="line"><span class="number">3</span> s=memory <span class="comment">//设置s指向刚分配的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述三个步骤可能会被重排序为 1-3-2，也就是：</span></span><br><span class="line"><span class="number">1</span> memory=allocate();<span class="comment">// 分配内存 相当于c的malloc</span></span><br><span class="line"><span class="number">3</span> s=memory <span class="comment">//设置s指向刚分配的地址</span></span><br><span class="line"><span class="number">2</span> ctorInstanc(memory) <span class="comment">//初始化对象</span></span><br></pre></td></tr></tbody></table></figure>

<p>而一旦假设发生了这样的重排序，比如线程A在第10行执行了步骤1和步骤3，但是步骤2还没有执行完。这个时候线程A执行到了第7行，它会判定instance不为空，然后直接返回了一个未初始化完成的instance！</p>
<p>优点：保证了加锁的效率，线程安全和懒加载</p>
<p>缺点：在高并发情况下，小概率出现实例为空（或者一个默认值）的情况</p>
<h2 id="线程安全饿汉式之双重锁检查"><a href="#线程安全饿汉式之双重锁检查" class="headerlink" title="线程安全饿汉式之双重锁检查"></a>线程安全饿汉式之双重锁检查</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton4 instance; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双重锁检验</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) { </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton5.class) {</span><br><span class="line">                <span class="comment">//这里必须要在使用一次判空检查，在多线程情况下，可能多个线程都判断为空，进入了synchronized</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton5(); </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这里使用volatile禁止了instance = new Singleton5(); 中发生的指令重排序，保证了线程安全。</p>
</body></html>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/0.html</url>
    <content><![CDATA[<html><head></head><body><p></p>
</body></html>]]></content>
  </entry>
  <entry>
    <title>netty基础-2</title>
    <url>/de7d93c2.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="Netty-概述"><a href="#Netty-概述" class="headerlink" title="Netty 概述"></a>Netty 概述</h1><h2 id="原生-NIO-存在的问题"><a href="#原生-NIO-存在的问题" class="headerlink" title="原生 NIO 存在的问题"></a>原生 NIO 存在的问题</h2><ol>
<li><code>NIO</code> 的类库和 <code>API</code> 繁杂，使用麻烦：需要熟练掌握 <code>Selector</code>、<code>ServerSocketChannel</code>、<code>SocketChannel</code>、<code>ByteBuffer</code>等。</li>
<li>需要具备其他的额外技能：要熟悉 <code>Java</code> 多线程编程，因为 <code>NIO</code> 编程涉及到 <code>Reactor</code> 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 <code>NIO</code> 程序。</li>
<li>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。</li>
<li><code>JDK NIO</code> 的 <code>Bug</code>：例如臭名昭著的 <code>Epoll Bug</code>，它会导致 <code>Selector</code> 空轮询，最终导致 <code>CPU100%</code>。直到 <code>JDK1.7</code> 版本该问题仍旧存在，没有被根本解决。</li>
</ol>
<span id="more"></span>

<h2 id="Netty-官网说明"><a href="#Netty-官网说明" class="headerlink" title="Netty 官网说明"></a>Netty 官网说明</h2><p>官网：<a href="https://netty.io/">https://netty.io/</a></p>
<p>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</p>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0001.png" alt="img"></p>
<h2 id="Netty-的优点"><a href="#Netty-的优点" class="headerlink" title="Netty 的优点"></a>Netty 的优点</h2><p><code>Netty</code> 对 <code>JDK</code> 自带的 <code>NIO</code> 的 <code>API</code> 进行了封装，解决了上述问题。</p>
<ol>
<li>设计优雅：适用于各种传输类型的统一 <code>API</code> 阻塞和非阻塞 <code>Socket</code>；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型-单线程，一个或多个线程池。</li>
<li>使用方便：详细记录的 <code>Javadoc</code>，用户指南和示例；没有其他依赖项，<code>JDK5（Netty3.x）</code>或 <code>6（Netty4.x）</code>就足够了。</li>
<li>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</li>
<li>安全：完整的 <code>SSL/TLS</code> 和 <code>StartTLS</code> 支持。</li>
<li>社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 <code>Bug</code> 可以被及时修复，同时，更多的新功能会被加入。</li>
</ol>
<h2 id="Netty-版本说明"><a href="#Netty-版本说明" class="headerlink" title="Netty 版本说明"></a>Netty 版本说明</h2><ol>
<li><code>Netty</code> 版本分为 <code>Netty 3.x</code> 和 <code>Netty 4.x</code>、<code>Netty 5.x</code></li>
<li>因为 <code>Netty 5</code> 出现重大 <code>bug</code>，已经被官网废弃了，目前推荐使用的是 <code>Netty 4.x</code>的稳定版本</li>
<li>目前在官网可下载的版本 <code>Netty 3.x</code>、<code>Netty 4.0.x</code> 和 <code>Netty 4.1.x</code></li>
<li>在本套课程中，我们讲解 <code>Netty4.1.x</code> 版本</li>
<li><code>Netty</code> 下载地址：<a href="https://bintray.com/netty/downloads/netty/">https://bintray.com/netty/downloads/netty/</a></li>
</ol>
<h1 id="Netty-高性能架构设计"><a href="#Netty-高性能架构设计" class="headerlink" title="Netty 高性能架构设计"></a>Netty 高性能架构设计</h1><h2 id="线程模型基本介绍"><a href="#线程模型基本介绍" class="headerlink" title="线程模型基本介绍"></a>线程模型基本介绍</h2><ol>
<li><p>不同的线程模式，对程序的性能有很大影响，为了搞清 <code>Netty</code> 线程模式，我们来系统的讲解下各个线程模式，最后看看 <code>Netty</code> 线程模型有什么优越性。</p>
</li>
<li><p>目前存在的线程模型有：传统阻塞 <code>I/O</code> 服务模型 和<code>Reactor</code> 模式</p>
</li>
<li><p>根据<br>Reactor的数量和处理资源池线程的数量不同，有3 种典型的实现</p>
<ul>
<li>单 <code>Reactor</code> 单线程；</li>
<li>单 <code>Reactor</code> 多线程；</li>
<li>主从 <code>Reactor</code>多线程</li>
</ul>
</li>
<li><p><code>Netty</code> 线程模式（<code>Netty</code> 主要基于主从 <code>Reactor</code> 多线程模型做了一定的改进，其中主从 <code>Reactor</code> 多线程模型有多个 <code>Reactor</code>）</p>
</li>
</ol>
<h2 id="传统阻塞-I-O-服务模型"><a href="#传统阻塞-I-O-服务模型" class="headerlink" title="传统阻塞 I/O 服务模型"></a>传统阻塞 I/O 服务模型</h2><h3 id="工作原理图"><a href="#工作原理图" class="headerlink" title="工作原理图"></a>工作原理图</h3><ol>
<li>黄色的框表示对象，蓝色的框表示线程</li>
<li>白色的框表示方法（<code>API</code>）</li>
</ol>
<h3 id="模型特点"><a href="#模型特点" class="headerlink" title="模型特点"></a>模型特点</h3><ol>
<li>采用阻塞 <code>IO</code> 模式获取输入的数据</li>
<li>每个连接都需要独立的线程完成数据的输入，业务处理，数据返回</li>
</ol>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ol>
<li>当并发数很大，就会创建大量的线程，占用很大系统资源</li>
<li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在 Handler对象中的<code>read</code> 操作，导致上面的处理线程资源浪费</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0002.png" alt="img"></p>
<h2 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h2><h3 id="针对传统阻塞-I-O-服务模型的-2-个缺点，解决方案："><a href="#针对传统阻塞-I-O-服务模型的-2-个缺点，解决方案：" class="headerlink" title="针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案："></a>针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案：</h3><p>基于 <code>I/O</code> 复用模型：多个连接共用一个阻塞对象<code>ServiceHandler</code>，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。</p>
<p><code>Reactor</code> 在不同书中的叫法：</p>
<ol>
<li>反应器模式</li>
<li>分发者模式（Dispatcher）</li>
<li>通知者模式（notifier）</li>
<li>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。（解决了当并发数很大时，会创建大量线程，占用很大系统资源）</li>
<li>基于 <code>I/O</code> 复用模型：多个客户端进行连接，先把连接请求给<code>ServiceHandler</code>。多个连接共用一个阻塞对象<code>ServiceHandler</code>。假设，当C1连接没有数据要处理时，C1客户端只需要阻塞于<code>ServiceHandler</code>，C1之前的处理线程便可以处理其他有数据的连接，不会造成线程资源的浪费。当C1连接再次有数据时，<code>ServiceHandler</code>根据线程池的空闲状态，将请求分发给空闲的线程来处理C1连接的任务。（解决了线程资源浪费的那个问题）</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0003.png" alt="img"></p>
<h3 id="I-O-复用结合线程池，就是-Reactor-模式基本设计思想，如图"><a href="#I-O-复用结合线程池，就是-Reactor-模式基本设计思想，如图" class="headerlink" title="I/O 复用结合线程池，就是 Reactor 模式基本设计思想，如图"></a>I/O 复用结合线程池，就是 Reactor 模式基本设计思想，如图</h3><p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0004.png" alt="img"></p>
<p>对上图说明：</p>
<ol>
<li><code>Reactor</code> 模式，通过一个或多个输入同时传递给服务处理器（ServiceHandler）的模式（基于事件驱动）</li>
<li>服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程，因此 <code>Reactor</code> 模式也叫 <code>Dispatcher</code> 模式</li>
<li><code>Reactor</code> 模式使用 <code>IO</code> 复用监听事件，收到事件后，分发给某个线程（进程），这点就是网络服务器高并发处理关键</li>
</ol>
<blockquote>
<p>原先有多个Handler阻塞，现在只用一个ServiceHandler阻塞</p>
</blockquote>
<h3 id="Reactor-模式中核心组成"><a href="#Reactor-模式中核心组成" class="headerlink" title="Reactor 模式中核心组成"></a>Reactor 模式中核心组成</h3><ol>
<li><code>Reactor（也就是那个ServiceHandler）</code>：<code>Reactor</code> 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理线程来对 <code>IO</code> 事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；</li>
<li><code>Handlers（处理线程EventHandler）</code>：处理线程执行 <code>I/O</code> 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。<code>Reactor</code> 通过调度适当的处理线程来响应 <code>I/O</code> 事件，处理程序执行非阻塞操作。</li>
</ol>
<h3 id="Reactor-模式分类"><a href="#Reactor-模式分类" class="headerlink" title="Reactor 模式分类"></a>Reactor 模式分类</h3><p>根据 <code>Reactor</code> 的数量和处理资源池线程的数量不同，有 <code>3</code> 种典型的实现</p>
<ol>
<li>单 <code>Reactor</code> 单线程</li>
<li>单 <code>Reactor</code> 多线程</li>
<li>主从 <code>Reactor</code> 多线程</li>
</ol>
<h2 id="单-Reactor-单线程"><a href="#单-Reactor-单线程" class="headerlink" title="单 Reactor 单线程"></a>单 Reactor 单线程</h2><p>原理图，并使用 <code>NIO</code> 群聊系统验证</p>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0005.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0005.png" alt="img"></p>
<h3 id="方案说明"><a href="#方案说明" class="headerlink" title="方案说明"></a>方案说明</h3><ol>
<li><code>Select</code> 是前面 <code>I/O</code> 复用模型介绍的标准网络编程 <code>API</code>，可以实现应用程序通过一个阻塞对象监听多路连接请求</li>
<li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后通过 <code>Dispatch</code> 进行分发</li>
<li>如果是建立连接请求事件，则由 <code>Acceptor</code> 通过 <code>Accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理连接完成后的后续业务处理</li>
<li>如果不是建立连接事件，则 <code>Reactor</code> 会分发调用连接对应的 <code>Handler</code> 来响应</li>
<li><code>Handler</code> 会完成 <code>Read</code> → 业务处理 → <code>Send</code> 的完整业务流程</li>
</ol>
<p>结合实例：服务器端用一个线程通过多路复用搞定所有的 <code>IO</code> 操作（包括连接，读、写等），编码简单，清晰明了，但是如果客户端连接数量较多，将无法支撑，前面的 <code>NIO</code> 案例就属于这种模型。</p>
<h3 id="方案优缺点分析"><a href="#方案优缺点分析" class="headerlink" title="方案优缺点分析"></a>方案优缺点分析</h3><ol>
<li>优点：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</li>
<li>缺点：性能问题，只有一个线程，无法完全发挥多核 <code>CPU</code> 的性能。<code>Handler</code>在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li>
<li>缺点：可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li>
<li>使用场景：客户端的数量有限，业务处理非常快速，比如 <code>Redis</code> 在业务处理的时间复杂度 <code>O(1)</code> 的情况</li>
</ol>
<h2 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor 多线程"></a>单 Reactor 多线程</h2><h3 id="方案说明-1"><a href="#方案说明-1" class="headerlink" title="方案说明"></a>方案说明</h3><p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0006.png" alt="img"></p>
<ol>
<li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后，通过 <code>Dispatch</code> 进行分发</li>
<li>如果是建立连接请求，则由 <code>Acceptor</code> 通过 <code>accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理完成连接后的各种事件</li>
<li>如果不是连接请求，则由 <code>Reactor</code> 分发调用连接对应的 <code>handler</code> 来处理（也就是说连接已经建立，后续客户端再来请求，那基本就是数据请求了，直接调用之前为这个连接创建好的handler来处理）</li>
<li><code>handler</code> 只负责响应事件，不做具体的业务处理（这样不会使handler阻塞太久），通过 <code>read</code> 读取数据后，会分发给后面的 <code>worker</code> 线程池的某个线程处理业务。【业务处理是最费时的，所以将业务处理交给线程池去执行】</li>
<li><code>worker</code> 线程池会分配独立线程完成真正的业务，并将结果返回给 <code>handler</code></li>
<li><code>handler</code> 收到响应后，通过 <code>send</code> 将结果返回给 <code>client</code></li>
</ol>
<h3 id="方案优缺点分析-1"><a href="#方案优缺点分析-1" class="headerlink" title="方案优缺点分析"></a>方案优缺点分析</h3><ol>
<li>优点：可以充分的利用多核 <code>cpu</code> 的处理能力</li>
<li>缺点：多线程数据共享和访问比较复杂。<code>Reactor</code> 承担所有的事件的监听和响应，它是单线程运行，在高并发场景容易出现性能瓶颈。也就是说<code>Reactor</code>主线程承担了过多的事</li>
</ol>
<h2 id="主从-Reactor-多线程"><a href="#主从-Reactor-多线程" class="headerlink" title="主从 Reactor 多线程"></a>主从 Reactor 多线程</h2><h3 id="工作原理图-1"><a href="#工作原理图-1" class="headerlink" title="工作原理图"></a>工作原理图</h3><p>针对单 <code>Reactor</code> 多线程模型中，<code>Reactor</code> 在单线程中运行，高并发场景下容易成为性能瓶颈，可以让 <code>Reactor</code> 在多线程中运行</p>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0007.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0008.jpg" alt="img"></p>
<blockquote>
<p>SubReactor是可以有多个的，如果只有一个SubReactor的话那和<code>单 Reactor 多线程</code>就没什么区别了。</p>
</blockquote>
<ol>
<li><code>Reactor</code> 主线程 <code>MainReactor</code> 对象通过 <code>select</code> 监听连接事件，收到事件后，通过 <code>Acceptor</code> 处理连接事件</li>
<li>当 <code>Acceptor</code> 处理连接事件后，<code>MainReactor</code> 将连接分配给 <code>SubReactor</code></li>
<li><code>subreactor</code> 将连接加入到连接队列进行监听，并创建 <code>handler</code> 进行各种事件处理</li>
<li>当有新事件发生时，<code>subreactor</code> 就会调用对应的 <code>handler</code> 处理</li>
<li><code>handler</code> 通过 <code>read</code> 读取数据，分发给后面的 <code>worker</code> 线程处理</li>
<li><code>worker</code> 线程池分配独立的 <code>worker</code> 线程进行业务处理，并返回结果</li>
<li><code>handler</code> 收到响应的结果后，再通过 <code>send</code> 将结果返回给 <code>client</code></li>
<li><code>Reactor</code> 主线程可以对应多个 <code>Reactor</code> 子线程，即 <code>MainRecator</code> 可以关联多个 <code>SubReactor</code></li>
</ol>
<h3 id="Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解"><a href="#Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解" class="headerlink" title="Scalable IO in Java 对 Multiple Reactors 的原理图解"></a>Scalable IO in Java 对 Multiple Reactors 的原理图解</h3><p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0009.jpg" alt="img"></p>
<h3 id="方案优缺点说明"><a href="#方案优缺点说明" class="headerlink" title="方案优缺点说明"></a>方案优缺点说明</h3><ol>
<li>优点：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</li>
<li>优点：父线程与子线程的数据交互简单，<code>Reactor</code> 主线程只需要把新连接传给子线程，子线程无需返回数据。</li>
<li>缺点：编程复杂度较高</li>
</ol>
<p>结合实例：这种模型在许多项目中广泛使用，包括 <code>Nginx</code> 主从 <code>Reactor</code> 多进程模型，<code>Memcached</code> 主从多线程，<code>Netty</code> 主从多线程模型的支持</p>
<h2 id="Reactor-模式小结"><a href="#Reactor-模式小结" class="headerlink" title="Reactor 模式小结"></a>Reactor 模式小结</h2><h3 id="3-种模式用生活案例来理解"><a href="#3-种模式用生活案例来理解" class="headerlink" title="3 种模式用生活案例来理解"></a>3 种模式用生活案例来理解</h3><ol>
<li>单 <code>Reactor</code> 单线程，前台接待员和服务员是同一个人，全程为顾客服</li>
<li>单 <code>Reactor</code> 多线程，<code>1</code> 个前台接待员，多个服务员，接待员只负责接待</li>
<li>主从 <code>Reactor</code> 多线程，多个前台接待员，多个服务生</li>
</ol>
<h3 id="Reactor-模式具有如下的优点"><a href="#Reactor-模式具有如下的优点" class="headerlink" title="Reactor 模式具有如下的优点"></a>Reactor 模式具有如下的优点</h3><ol>
<li>响应快，不必为单个同步时间所阻塞，虽然 <code>Reactor</code> 本身依然是同步的（比如你第一个SubReactor阻塞了，我可以调下一个 SubReactor为客户端服务）</li>
<li>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销</li>
<li>扩展性好，可以方便的通过增加 <code>Reactor</code> 实例个数来充分利用 <code>CPU</code> 资源</li>
<li>复用性好，<code>Reactor</code> 模型本身与具体事件处理逻辑无关，具有很高的复用性</li>
</ol>
<h2 id="Netty-模型"><a href="#Netty-模型" class="headerlink" title="Netty 模型"></a>Netty 模型</h2><blockquote>
<p>讲解netty的时候采用的是先写代码体验一下，再细讲里面的原理。前面看不懂的可以先不用纠结，先往后面看，后面基本都会讲清楚</p>
</blockquote>
<h3 id="工作原理示意图1-简单版"><a href="#工作原理示意图1-简单版" class="headerlink" title="工作原理示意图1 - 简单版"></a>工作原理示意图1 - 简单版</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Netty` 主要基于主从 `Reactors` 多线程模型（如图）做了一定的改进，其中主从 `Reactor` 多线程模型有多个 `Reactor</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0010.png" alt="img"></p>
<p><strong>对上图说明</strong></p>
<ol>
<li><code>BossGroup</code> 线程维护 <code>Selector</code>，只关注 <code>Accecpt</code></li>
<li>当接收到 <code>Accept</code> 事件，获取到对应的 <code>SocketChannel</code>，封装成 <code>NIOScoketChannel</code> 并注册到 <code>Worker</code> 线程（事件循环），并进行维护</li>
<li>当 <code>Worker</code> 线程监听到 <code>Selector</code> 中通道发生自己感兴趣的事件后，就进行处理（就由 <code>handler</code>），注意 <code>handler</code> 已经加入到通道</li>
</ol>
<h3 id="工作原理示意图2-进阶版"><a href="#工作原理示意图2-进阶版" class="headerlink" title="工作原理示意图2 - 进阶版"></a>工作原理示意图2 - 进阶版</h3><p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0011.png" alt="img"></p>
<p><code>BossGroup</code>有点像主<code>Reactor</code> 可以有多个，<code>WorkerGroup</code>则像<code>SubReactor</code>一样可以有多个。</p>
<h3 id="工作原理示意图3-详细版"><a href="#工作原理示意图3-详细版" class="headerlink" title="工作原理示意图3 - 详细版"></a>工作原理示意图3 - 详细版</h3><p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0012.png" alt="img"></p>
<ol>
<li><p><code>Netty</code> 抽象出两组线程池 ，<code>BossGroup</code> 专门负责接收客户端的连接，<code>WorkerGroup</code> 专门负责网络的读写</p>
</li>
<li><p><code>BossGroup</code> 和 <code>WorkerGroup</code> 类型都是 <code>NioEventLoopGroup</code></p>
</li>
<li><p><code>NioEventLoopGroup</code> 相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是 <code>NioEventLoop</code></p>
</li>
<li><p><code>NioEventLoop</code> 表示一个不断循环的执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code> 的网络通讯</p>
</li>
<li><p><code>NioEventLoopGroup</code> 可以有多个线程，即可以含有多个 <code>NioEventLoop</code></p>
</li>
<li><p>每个BossGroup下面的NioEventLoop循环执行的步骤有 3步</p>
<ul>
<li>轮询 <code>accept</code> 事件</li>
<li>处理 <code>accept</code> 事件，与 <code>client</code> 建立连接，生成 <code>NioScocketChannel</code>，并将其注册到某个 <code>workerGroup</code> <code>NIOEventLoop</code> 上的 <code>Selector</code></li>
<li>继续处理任务队列的任务，即 <code>runAllTasks</code></li>
</ul>
</li>
<li><p>每个WorkerGroupNIOEventLoop循环执行的步骤</p>
<ul>
<li>轮询 <code>read</code>，<code>write</code> 事件</li>
<li>处理 <code>I/O</code> 事件，即 <code>read</code>，<code>write</code> 事件，在对应 <code>NioScocketChannel</code> 处理</li>
<li>处理任务队列的任务，即 <code>runAllTasks</code></li>
</ul>
</li>
<li><p>每个 <code>Worker</code> <code>NIOEventLoop</code> 处理业务时，会使用 <code>pipeline</code>（管道），<code>pipeline</code> 中包含了 <code>channel（通道）</code>，即通过 <code>pipeline</code> 可以获取到对应通道，管道中维护了很多的处理器。（这个点目前只是简单的讲，后面重点说）</p>
</li>
</ol>
<h3 id="Netty-快速入门实例-TCP-服务"><a href="#Netty-快速入门实例-TCP-服务" class="headerlink" title="Netty 快速入门实例 - TCP 服务"></a>Netty 快速入门实例 - TCP 服务</h3><p>实例要求：使用 <code>IDEA</code> 创建 <code>Netty</code> 项目</p>
<ol>
<li><code>Netty</code> 服务器在 <code>6668</code> 端口监听，客户端能发送消息给服务器”hello,服务器~”</li>
<li>服务器可以回复消息给客户端”hello,客户端~”</li>
<li>目的：对 <code>Netty</code> 线程模型有一个初步认识，便于理解 <code>Netty</code> 模型理论</li>
<li><ol>
<li>编写服务端</li>
<li>编写客户端</li>
<li>对 <code>netty</code> 程序进行分析，看看 <code>netty</code> 模型特点</li>
<li>说明：创建 <code>Maven</code> 项目，并引入 <code>Netty</code> 包</li>
</ol>
</li>
<li>代码如下</li>
</ol>
<h4 id="NettyServer"><a href="#NettyServer" class="headerlink" title="NettyServer"></a>NettyServer</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建BossGroup 和 WorkerGroup</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. 创建两个线程组 bossGroup 和 workerGroup</span></span><br><span class="line">        <span class="comment">//2. bossGroup 只是处理连接请求 , 真正的和客户端业务处理，会交给 workerGroup完成</span></span><br><span class="line">        <span class="comment">//3. 两个都是无限循环</span></span><br><span class="line">        <span class="comment">//4. bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数</span></span><br><span class="line">        <span class="comment">//   默认实际 cpu核数 * 2</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//创建服务器端的启动对象，配置参数</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用链式编程来进行设置</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup) <span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">//使用NioSocketChannel 作为服务器的通道实现</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) <span class="comment">// 设置线程队列等待连接个数</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>) <span class="comment">//设置保持活动连接状态</span></span><br><span class="line"><span class="comment">//                    .handler(null) // 该 handler对应 bossGroup , childHandler 对应 workerGroup</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {<span class="comment">//创建一个通道初始化对象(匿名对象)</span></span><br><span class="line">                        <span class="comment">//给pipeline 设置处理器</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                            System.out.println(<span class="string">"客户socketchannel hashcode="</span> + ch.hashCode()); <span class="comment">//可以使用一个集合管理 SocketChannel， 再推送消息时，可以将业务加入到各个channel 对应的 NIOEventLoop 的 taskQueue 或者 scheduleTaskQueue</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        }</span><br><span class="line">                    }); <span class="comment">// 给我们的workerGroup 的 EventLoop 对应的管道设置处理器</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">".....服务器 is ready..."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绑定一个端口并且同步生成了一个 ChannelFuture 对象（也就是立马返回这样一个对象）</span></span><br><span class="line">            <span class="comment">//启动服务器(并绑定端口)</span></span><br><span class="line">            ChannelFuture cf = bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给cf 注册监听器，监控我们关心的事件</span></span><br><span class="line"></span><br><span class="line">            cf.addListener(<span class="keyword">new</span> ChannelFutureListener() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                    <span class="keyword">if</span> (cf.isSuccess()) {</span><br><span class="line">                        System.out.println(<span class="string">"监听端口 6668 成功"</span>);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        System.out.println(<span class="string">"监听端口 6668 失败"</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//对关闭通道事件  进行监听</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="NettyServerHandler"><a href="#NettyServerHandler" class="headerlink" title="NettyServerHandler"></a>NettyServerHandler</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明</span></span><br><span class="line"><span class="comment">1. 我们自定义一个Handler 需要继承netty 规定好的某个HandlerAdapter(规范)</span></span><br><span class="line"><span class="comment">2. 这时我们自定义一个Handler , 才能称为一个handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据事件(这里我们可以读取客户端发送的消息)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span></span><br><span class="line"><span class="comment">    2. Object msg: 就是客户端发送的数据 默认Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(<span class="string">"服务器读取线程 "</span> + Thread.currentThread().getName() + <span class="string">" channle ="</span> + ctx.channel());</span><br><span class="line">        System.out.println(<span class="string">"server ctx ="</span> + ctx);</span><br><span class="line">        System.out.println(<span class="string">"看看channel 和 pipeline的关系"</span>);</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        ChannelPipeline pipeline = ctx.pipeline(); <span class="comment">//本质是一个双向链表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 msg 转成一个 ByteBuf</span></span><br><span class="line">        <span class="comment">//ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.</span></span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">"客户端发送消息是:"</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">"客户端地址:"</span> + channel.remoteAddress());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//writeAndFlush 是 write + flush</span></span><br><span class="line">        <span class="comment">//将数据写入到缓存，并刷新</span></span><br><span class="line">        <span class="comment">//一般讲，我们对这个发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello, 客户端~(&gt;^ω^&lt;)喵1"</span>, CharsetUtil.UTF_8));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发生异常后, 一般是需要关闭通道</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="NettyClient"><a href="#NettyClient" class="headerlink" title="NettyClient"></a>NettyClient</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            <span class="comment">//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(group) <span class="comment">//设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel.class) <span class="comment">// 设置客户端通道的实现类(反射)</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyClientHandler()); <span class="comment">//加入自己的处理器</span></span><br><span class="line">                        }</span><br><span class="line">                    });</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"客户端 ok.."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动客户端去连接服务器端</span></span><br><span class="line">            <span class="comment">//关于 ChannelFuture 要分析，涉及到netty的异步模型</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//对关闭通道事件  进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line"></span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="NettyClientHandler"><a href="#NettyClientHandler" class="headerlink" title="NettyClientHandler"></a>NettyClientHandler</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通道就绪就会触发该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(<span class="string">"client "</span> + ctx);</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello, server: (&gt;^ω^&lt;)喵"</span>, CharsetUtil.UTF_8));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通道有读取事件时，会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">"服务器回复的消息:"</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">"服务器的地址： "</span>+ ctx.channel().remoteAddress());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="任务队列中的-Task-有-3-种典型使用场景"><a href="#任务队列中的-Task-有-3-种典型使用场景" class="headerlink" title="任务队列中的 Task 有 3 种典型使用场景"></a>任务队列中的 Task 有 3 种典型使用场景</h3><ol>
<li>用户程序自定义的普通任务【举例说明】</li>
<li>用户自定义定时任务</li>
<li>非当前 <code>Reactor</code> 线程调用 <code>Channel</code> 的各种方法<br>例如在<strong>推送系统</strong>的业务线程里面，根据用户的标识，找到对应的 <code>Channel</code> 引用，然后调用 <code>Write</code> 类方法向该用户推送消息，就会进入到这种场景。最终的 <code>Write</code> 会提交到任务队列中后被异步消费</li>
</ol>
<p>前两种的代码举例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明</span></span><br><span class="line"><span class="comment"> * 1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范)</span></span><br><span class="line"><span class="comment"> * 2. 这时我们自定义一个Handler , 才能称为一个handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span></span><br><span class="line"><span class="comment">     * 2. Object msg: 就是客户端发送的数据 默认Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比如这里我们有一个非常耗时长的业务-&gt; 异步执行 -&gt; 提交该channel 对应的</span></span><br><span class="line">        <span class="comment">// NIOEventLoop 的 taskQueue中,</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解决方案1 用户程序自定义的普通任务</span></span><br><span class="line"></span><br><span class="line">        ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello, 客户端~(&gt;^ω^&lt;)喵2"</span>, CharsetUtil.UTF_8));</span><br><span class="line">                    System.out.println(<span class="string">"channel code="</span> + ctx.channel().hashCode());</span><br><span class="line">                } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">                    System.out.println(<span class="string">"发生异常"</span> + ex.getMessage());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello, 客户端~(&gt;^ω^&lt;)喵3"</span>, CharsetUtil.UTF_8));</span><br><span class="line">                    System.out.println(<span class="string">"channel code="</span> + ctx.channel().hashCode());</span><br><span class="line">                } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">                    System.out.println(<span class="string">"发生异常"</span> + ex.getMessage());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解决方案2 : 用户自定义定时任务 -》 该任务是提交到 scheduleTaskQueue中</span></span><br><span class="line"></span><br><span class="line">        ctx.channel().eventLoop().schedule(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello, 客户端~(&gt;^ω^&lt;)喵4"</span>, CharsetUtil.UTF_8));</span><br><span class="line">                    System.out.println(<span class="string">"channel code="</span> + ctx.channel().hashCode());</span><br><span class="line">                } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">                    System.out.println(<span class="string">"发生异常"</span> + ex.getMessage());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"go on ..."</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println("服务器读取线程 " + Thread.currentThread().getName() + " channle =" + ctx.channel());</span></span><br><span class="line"><span class="comment">//        System.out.println("server ctx =" + ctx);</span></span><br><span class="line"><span class="comment">//        System.out.println("看看channel 和 pipeline的关系");</span></span><br><span class="line"><span class="comment">//        Channel channel = ctx.channel();</span></span><br><span class="line"><span class="comment">//        ChannelPipeline pipeline = ctx.pipeline(); //本质是一个双向链接, 出站入站</span></span><br><span class="line"><span class="comment">//        </span></span><br><span class="line"><span class="comment">//        //将 msg 转成一个 ByteBuf</span></span><br><span class="line"><span class="comment">//        //ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.</span></span><br><span class="line"><span class="comment">//        ByteBuf buf = (ByteBuf) msg;</span></span><br><span class="line"><span class="comment">//        System.out.println("客户端发送消息是:" + buf.toString(CharsetUtil.UTF_8));</span></span><br><span class="line"><span class="comment">//        System.out.println("客户端地址:" + channel.remoteAddress());</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//writeAndFlush 是 write + flush</span></span><br><span class="line">        <span class="comment">//将数据写入到缓存，并刷新</span></span><br><span class="line">        <span class="comment">//一般讲，我们对这个发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello, 客户端~(&gt;^ω^&lt;)喵1"</span>, CharsetUtil.UTF_8));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常, 一般是需要关闭通道</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="方案再说明"><a href="#方案再说明" class="headerlink" title="方案再说明"></a>方案再说明</h3><ol>
<li><code>Netty</code> 抽象出两组线程池，<code>BossGroup</code> 专门负责接收客户端连接，<code>WorkerGroup</code> 专门负责网络读写操作。</li>
<li><code>NioEventLoop</code> 表示一个不断循环执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code>网络通道。</li>
<li><code>NioEventLoop</code> 内部采用串行化设计，从消息的 <strong>读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送</strong>，始终由 <code>IO</code> 线程 <code>NioEventLoop</code> 负责</li>
</ol>
<ul>
<li><code>NioEventLoopGroup</code> 下包含多个 <code>NioEventLoop</code></li>
<li>每个 <code>NioEventLoop</code> 中包含有一个 <code>Selector</code>，一个 <code>taskQueue</code></li>
<li>每个 <code>NioEventLoop</code> 的 <code>Selector</code> 上可以注册监听多个 <code>NioChannel</code></li>
<li>每个 <code>NioChannel</code> 只会绑定在唯一的 <code>NioEventLoop</code> 上</li>
<li>每个 <code>NioChannel</code> 都绑定有一个自己的 <code>ChannelPipeline</code></li>
</ul>
<h2 id="异步模型"><a href="#异步模型" class="headerlink" title="异步模型"></a>异步模型</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。</li>
<li><code>Netty</code> 中的 <code>I/O</code> 操作是异步的，包括 <code>Bind、Write、Connect</code> 等操作会首先简单的返回一个 <code>ChannelFuture</code>。</li>
<li>调用者并不能立刻获得结果，而是通过 <code>Future-Listener</code> 机制，用户可以方便的主动获取或者通过通知机制获得 <code>IO</code> 操作结果。</li>
<li><code>Netty</code> 的异步模型是建立在 <code>future</code> 和 <code>callback</code> 的之上的。<code>callback</code> 就是回调。重点说 <code>Future</code>，它的核心思想是：假设一个方法 <code>fun</code>，计算过程可能非常耗时，等待 <code>fun</code> 返回显然不合适。那么可以在调用 <code>fun</code> 的时候，立马返回一个 <code>Future</code>，后续可以通过 <code>Future</code> 去监控方法 <code>fun</code> 的处理过程（即：<code>Future-Listener</code> 机制）</li>
</ol>
<h3 id="Future-说明"><a href="#Future-说明" class="headerlink" title="Future 说明"></a>Future 说明</h3><ol>
<li>表示异步的执行结果,可以通过它提供的方法来检测执行是否完成，比如检索计算等等。</li>
<li><code>ChannelFuture</code> 是一个接口：<code>public interface ChannelFuture extends Future&lt;Void&gt;</code> 我们可以添加监听器，当监听的事件发生时，就会通知到监听器。</li>
</ol>
<h3 id="工作原理示意图"><a href="#工作原理示意图" class="headerlink" title="工作原理示意图"></a>工作原理示意图</h3><p>下面第一张图就是管道，中间会经过多个handler</p>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0013.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0014.png" alt="img"></p>
<p>说明：</p>
<ol>
<li>在使用 <code>Netty</code> 进行编程时，拦截操作和转换出入站数据只需要您提供 <code>callback</code> 或利用 <code>future</code> 即可。这使得链式操作简单、高效，并有利于编写可重用的、通用的代码。</li>
<li><code>Netty</code> 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来。</li>
</ol>
<h3 id="Future-Listener-机制"><a href="#Future-Listener-机制" class="headerlink" title="Future-Listener 机制"></a>Future-Listener 机制</h3><ol>
<li>当 <code>Future</code> 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 <code>ChannelFuture</code> 来获取操作执行的状态，注册监听函数来执行完成后的操作。</li>
<li>常见有如下操作<ul>
<li>通过 <code>isDone</code> 方法来判断当前操作是否完成；</li>
<li>通过 <code>isSuccess</code> 方法来判断已完成的当前操作是否成功；</li>
<li>通过 <code>getCause</code> 方法来获取已完成的当前操作失败的原因；</li>
<li>通过 <code>isCancelled</code> 方法来判断已完成的当前操作是否被取消；</li>
<li>通过 <code>addListener</code> 方法来注册监听器，当操作已完成（<code>isDone</code>方法返回完成），将会通知指定的监听器；如果 <code>Future</code> 对象已完成，则通知指定的监听器</li>
</ul>
</li>
</ol>
<p>举例说明<br>演示：绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//绑定一个端口并且同步,生成了一个ChannelFuture对象</span></span><br><span class="line"><span class="comment">//启动服务器(并绑定端口)</span></span><br><span class="line">ChannelFuture cf = bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"><span class="comment">//给cf注册监听器，监控我们关心的事件</span></span><br><span class="line">cf.addListener(<span class="keyword">new</span> ChannelFutureListener() {</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span> <span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">      <span class="keyword">if</span> (cf.isSuccess()) {</span><br><span class="line">         System.out.println(<span class="string">"监听端口6668成功"</span>);</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">         System.out.println(<span class="string">"监听端口6668失败"</span>);</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<h2 id="快速入门实例-HTTP服务"><a href="#快速入门实例-HTTP服务" class="headerlink" title="快速入门实例 - HTTP服务"></a>快速入门实例 - HTTP服务</h2><ol>
<li>实例要求：使用 <code>IDEA</code> 创建 <code>Netty</code> 项目</li>
<li><code>Netty</code> 服务器在 <code>6668</code> 端口监听，浏览器发出请求 <code>http://localhost:6668/</code></li>
<li>服务器可以回复消息给客户端”Hello!我是服务器5”,并对特定请求资源进行过滤。</li>
<li>目的：<code>Netty</code> 可以做 <code>Http</code> 服务开发，并且理解 <code>Handler</code> 实例和客户端及其请求的关系。</li>
<li>看老师代码演示</li>
</ol>
<h3 id="TestServer"><a href="#TestServer" class="headerlink" title="TestServer"></a>TestServer</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).childHandler(<span class="keyword">new</span> TestServerInitializer());</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line">            </span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="TestServerInitializer"><a href="#TestServerInitializer" class="headerlink" title="TestServerInitializer"></a>TestServerInitializer</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向管道加入处理器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到管道</span></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入一个netty 提供的httpServerCodec codec =&gt;[coder - decoder]</span></span><br><span class="line">        <span class="comment">//HttpServerCodec 说明</span></span><br><span class="line">        <span class="comment">//1. HttpServerCodec 是netty 提供的处理http的 编-解码器</span></span><br><span class="line">        pipeline.addLast(<span class="string">"MyHttpServerCodec"</span>,<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        <span class="comment">//2. 增加一个自定义的handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">"MyTestHttpServerHandler"</span>, <span class="keyword">new</span> TestHttpServerHandler());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"ok~~~~"</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="TestHttpServerHandler"><a href="#TestHttpServerHandler" class="headerlink" title="TestHttpServerHandler"></a>TestHttpServerHandler</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明</span></span><br><span class="line"><span class="comment">1. SimpleChannelInboundHandler 是 ChannelInboundHandlerAdapter</span></span><br><span class="line"><span class="comment">2. HttpObject 客户端和服务器端相互通讯的数据被封装成 HttpObject</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//channelRead0 读取客户端数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"对应的channel="</span> + ctx.channel() + <span class="string">" pipeline="</span> + ctx</span><br><span class="line">        .pipeline() + <span class="string">" 通过pipeline获取channel"</span> + ctx.pipeline().channel());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"当前ctx的handler="</span> + ctx.handler());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断 msg 是不是 httprequest请求</span></span><br><span class="line">        <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> HttpRequest) {</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"ctx 类型="</span>+ctx.getClass());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"pipeline hashcode"</span> + ctx.pipeline().hashCode() + <span class="string">" TestHttpServerHandler hash="</span> + <span class="keyword">this</span>.hashCode());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"msg 类型="</span> + msg.getClass());</span><br><span class="line">            System.out.println(<span class="string">"客户端地址"</span> + ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取到</span></span><br><span class="line">            HttpRequest httpRequest = (HttpRequest) msg;</span><br><span class="line">            <span class="comment">//获取uri, 过滤指定的资源</span></span><br><span class="line">            URI uri = <span class="keyword">new</span> URI(httpRequest.uri());</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"/favicon.ico"</span>.equals(uri.getPath())) {</span><br><span class="line">                System.out.println(<span class="string">"请求了 favicon.ico, 不做响应"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//回复信息给浏览器 [http协议]</span></span><br><span class="line"></span><br><span class="line">            ByteBuf content = Unpooled.copiedBuffer(<span class="string">"hello, 我是服务器"</span>, CharsetUtil.UTF_8);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//构造一个http的相应，即 httpresponse</span></span><br><span class="line">            FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line"></span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">"text/plain"</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将构建好 response返回</span></span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Netty-核心模块组件"><a href="#Netty-核心模块组件" class="headerlink" title="Netty 核心模块组件"></a>Netty 核心模块组件</h1><h2 id="Bootstrap、ServerBootstrap"><a href="#Bootstrap、ServerBootstrap" class="headerlink" title="Bootstrap、ServerBootstrap"></a>Bootstrap、ServerBootstrap</h2><ol>
<li><code>Bootstrap</code> 意思是引导，一个 <code>Netty</code> 应用通常由一个 <code>Bootstrap</code> 开始，主要作用是配置整个 <code>Netty</code> 程序，串联各个组件，<code>Netty</code> 中 <code>Bootstrap</code> 类是客户端程序的启动引导类，<code>ServerBootstrap</code> 是服务端启动引导类。</li>
<li>常见的方法有<ul>
<li><code>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code>，该方法用于服务器端，用来设置两个 <code>EventLoop</code></li>
<li><code>public B group(EventLoopGroup group)</code>，该方法用于客户端，用来设置一个 <code>EventLoop</code></li>
<li><code>public B channel(Class&lt;? extends C&gt; channelClass)</code>，该方法用来设置一个服务器端的通道实现</li>
<li><code>public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value)</code>，用来给 <code>ServerChannel</code> 添加配置</li>
<li><code>public &lt;T&gt; ServerBootstrap childOption(ChannelOption&lt;T&gt; childOption, T value)</code>，用来给接收到的通道添加配置</li>
<li><code>public ServerBootstrap childHandler(ChannelHandler childHandler)</code>，该方法用来设置业务处理类（自定义的<code>handler</code>）</li>
<li><code>public ChannelFuture bind(int inetPort)</code>，该方法用于服务器端，用来设置占用的端口号</li>
<li><code>public ChannelFuture connect(String inetHost, int inetPort)</code>，该方法用于客户端，用来连接服务器端</li>
</ul>
</li>
</ol>
<h2 id="Future、ChannelFuture"><a href="#Future、ChannelFuture" class="headerlink" title="Future、ChannelFuture"></a>Future、ChannelFuture</h2><p><code>Netty</code> 中所有的 <code>IO</code> 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 <code>Future</code> 和 <code>ChannelFutures</code>，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</p>
<p>常见的方法有</p>
<ul>
<li><code>Channel channel()</code>，返回当前正在进行 <code>IO</code> 操作的通道</li>
<li><code>ChannelFuture sync()</code>，等待异步操作执行完毕</li>
</ul>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><ol>
<li><p><code>Netty</code> 网络通信的组件，能够用于执行网络 <code>I/O</code> 操作。</p>
</li>
<li><p>通过 <code>Channel</code> 可获得当前网络连接的通道的状态</p>
</li>
<li><p>通过 <code>Channel</code> 可获得网络连接的配置参数（例如接收缓冲区大小）</p>
</li>
<li><p><code>Channel</code> 提供异步的网络 <code>I/O</code> 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 <code>I/O</code> 调用都将立即返回，并且不保证在调用结束时所请求的 <code>I/O</code> 操作已完成</p>
</li>
<li><p>调用立即返回一个 <code>ChannelFuture</code> 实例，通过注册监听器到 <code>ChannelFuture</code> 上，可以 <code>I/O</code> 操作成功、失败或取消时回调通知调用方</p>
</li>
<li><p>支持关联 <code>I/O</code> 操作与对应的处理程序</p>
</li>
<li><p>不同协议、不同的阻塞类型的连接都有不同的Channel类型与之对应，常用的Channel类型：</p>
<ul>
<li><code>NioSocketChannel</code>，异步的客户端 <code>TCP</code> <code>Socket</code> 连接。</li>
<li><code>NioServerSocketChannel</code>，异步的服务器端 <code>TCP</code> <code>Socket</code> 连接。</li>
<li><code>NioDatagramChannel</code>，异步的 <code>UDP</code> 连接。</li>
<li><code>NioSctpChannel</code>，异步的客户端 <code>Sctp</code> 连接。</li>
<li><code>NioSctpServerChannel</code>，异步的 <code>Sctp</code> 服务器端连接，这些通道涵盖了 <code>UDP</code> 和 <code>TCP</code> 网络 <code>IO</code> 以及文件 <code>IO</code>。</li>
</ul>
</li>
</ol>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><ol>
<li><code>Netty</code> 基于 <code>Selector</code> 对象实现 <code>I/O</code> 多路复用，通过 <code>Selector</code> 一个线程可以监听多个连接的 <code>Channel</code> 事件。</li>
<li>当向一个 <code>Selector</code> 中注册 <code>Channel</code> 后，<code>Selector</code> 内部的机制就可以自动不断地查询（<code>Select</code>）这些注册的 <code>Channel</code> 是否有已就绪的 <code>I/O</code> 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 <code>Channel</code></li>
</ol>
<h2 id="ChannelHandler-及其实现类"><a href="#ChannelHandler-及其实现类" class="headerlink" title="ChannelHandler 及其实现类"></a>ChannelHandler 及其实现类</h2><ol>
<li><code>ChannelHandler</code> 是一个接口，处理 <code>I/O</code> 事件或拦截 <code>I/O</code> 操作，并将其转发到其 <code>ChannelPipeline</code>（业务处理链）中的下一个处理程序。</li>
<li><code>ChannelHandler</code> 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</li>
<li><code>ChannelHandler</code> 及其实现类一览图（后）</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0015.png" alt="img"></p>
<ol>
<li>我们经常需要自定义一个 <code>Handler</code> 类去继承 <code>ChannelInboundHandlerAdapter</code>，然后通过重写相应方法实现业务逻辑，我们接下来看看一般都需要重写哪些方法</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0016.png" alt="img"></p>
<h2 id="Pipeline-和-ChannelPipeline"><a href="#Pipeline-和-ChannelPipeline" class="headerlink" title="Pipeline 和 ChannelPipeline"></a>Pipeline 和 ChannelPipeline</h2><p><code>ChannelPipeline</code> 是一个重点：</p>
<ol>
<li><code>ChannelPipeline</code> 是一个 <code>Handler</code> 的集合，它负责处理和拦截 <code>inbound</code> 或者 <code>outbound</code> 的事件和操作，相当于一个贯穿 <code>Netty</code> 的链。（也可以这样理解：<code>ChannelPipeline</code> 是保存 <code>ChannelHandler</code> 的 <code>List</code>，用于处理或拦截 <code>Channel</code> 的入站事件和出站操作）</li>
<li><code>ChannelPipeline</code> 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 <code>Channel</code> 中各个的 <code>ChannelHandler</code> 如何相互交互</li>
<li>在 <code>Netty</code> 中每个 <code>Channel</code> 都有且仅有一个 <code>ChannelPipeline</code> 与之对应，它们的组成关系如下</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0017.png" alt="img"></p>
<ol>
<li>常用方法<br><code>ChannelPipeline addFirst(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的第一个位置<code>ChannelPipeline addLast(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的最后一个位置</li>
</ol>
<blockquote>
<p>想要更清楚的了解pipeline，可以对之前的代码进行debug，看一下pipeline里究竟有什么东西。</p>
</blockquote>
<p>从head看一下debug</p>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0018.jpg" alt="img"></p>
<ul>
<li><code>TestServerInitializer</code>和<code>HttpServerCodec</code>这些东西本身也是<code>handler</code></li>
<li>一般来说事件从客户端往服务器走我们称为出站，反之则是入站。</li>
</ul>
<h2 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h2><ol>
<li>保存 <code>Channel</code> 相关的所有上下文信息，同时关联一个 <code>ChannelHandler</code> 对象</li>
<li>即 <code>ChannelHandlerContext</code> 中包含一个具体的事件处理器 <code>ChannelHandler</code>，同时 <code>ChannelHandlerContext</code> 中也绑定了对应的 <code>pipeline</code> 和 <code>Channel</code> 的信息，方便对 <code>ChannelHandler</code> 进行调用。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0019.jpg" alt="img"></p>
<ol>
<li>常用方法</li>
</ol>
<ul>
<li><code>ChannelFuture close()</code>，关闭通道</li>
<li><code>ChannelOutboundInvoker flush()</code>，刷新</li>
<li><code>ChannelFuture writeAndFlush(Object msg)</code>，将数据写到</li>
<li><code>ChannelPipeline</code> 中当前 <code>ChannelHandler</code> 的下一个 <code>ChannelHandler</code> 开始处理（出站）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0020.png" alt="img"></p>
<h2 id="ChannelOption"><a href="#ChannelOption" class="headerlink" title="ChannelOption"></a>ChannelOption</h2><ol>
<li><code>Netty</code> 在创建 <code>Channel</code> 实例后，一般都需要设置 <code>ChannelOption</code> 参数。</li>
<li><code>ChannelOption</code> 参数如下：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0021.png" alt="img"></p>
<h2 id="EventLoopGroup-和其实现类-NioEventLoopGroup"><a href="#EventLoopGroup-和其实现类-NioEventLoopGroup" class="headerlink" title="EventLoopGroup 和其实现类 NioEventLoopGroup"></a>EventLoopGroup 和其实现类 NioEventLoopGroup</h2><ol>
<li><code>EventLoopGroup</code> 是一组 <code>EventLoop</code> 的抽象，<code>Netty</code> 为了更好的利用多核 <code>CPU</code> 资源，一般会有多个 <code>EventLoop</code> 同时工作，每个 <code>EventLoop</code> 维护着一个 <code>Selector</code> 实例。</li>
<li><code>EventLoopGroup</code> 提供 <code>next</code> 接口，可以从组里面按照一定规则获取其中一个 <code>EventLoop</code> 来处理任务。在 <code>Netty</code> 服务器端编程中，我们一般都需要提供两个 <code>EventLoopGroup</code>，例如：<code>BossEventLoopGroup</code> 和 <code>WorkerEventLoopGroup</code>。</li>
<li>通常一个服务端口即一个 <code>ServerSocketChannel</code> 对应一个 <code>Selector</code> 和一个 <code>EventLoop</code> 线程。<code>BossEventLoop</code> 负责接收客户端的连接并将 <code>SocketChannel</code> 交给 <code>WorkerEventLoopGroup</code> 来进行 <code>IO</code> 处理，如下图所示</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0022.png" alt="img"></p>
<ol>
<li>常用方法<br><code>public NioEventLoopGroup()</code>，构造方法<br><code>public Future&lt;?&gt; shutdownGracefully()</code>，断开连接，关闭线程</li>
</ol>
<h2 id="Unpooled-类"><a href="#Unpooled-类" class="headerlink" title="Unpooled 类"></a>Unpooled 类</h2><ol>
<li><code>Netty</code> 提供一个专门用来操作缓冲区（即 <code>Netty</code> 的数据容器）的工具类</li>
<li>常用方法如下所示</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0023.png" alt="img"></p>
<ol>
<li>举例说明 <code>Unpooled</code> 获取 <code>Netty</code> 的数据容器 <code>ByteBuf</code> 的基本使用</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0024.png" alt="img"></p>
<p>案例 1</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyByteBuf01</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个ByteBuf</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. 创建 对象，该对象包含一个数组arr , 是一个byte[10]</span></span><br><span class="line">        <span class="comment">//2. 在netty 的buffer中，不需要使用flip 进行反转</span></span><br><span class="line">        <span class="comment">//   底层维护了 readerindex 和 writerIndex</span></span><br><span class="line">        <span class="comment">//3. 通过 readerindex 和  writerIndex 和  capacity， 将buffer分成三个区域</span></span><br><span class="line">        <span class="comment">// 0---readerindex 已经读取的区域</span></span><br><span class="line">        <span class="comment">// readerindex---writerIndex ， 可读的区域</span></span><br><span class="line">        <span class="comment">// writerIndex -- capacity, 可写的区域</span></span><br><span class="line">        ByteBuf buffer = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            buffer.writeByte(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"capacity="</span> + buffer.capacity());<span class="comment">//10</span></span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line"><span class="comment">//        for(int i = 0; i&lt;buffer.capacity(); i++) {</span></span><br><span class="line">        	  <span class="comment">//这个方法readerindex不会变</span></span><br><span class="line"><span class="comment">//            System.out.println(buffer.getByte(i));</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i++) {</span><br><span class="line">            <span class="comment">//这个方法readerindex会变</span></span><br><span class="line">            System.out.println(buffer.readByte());</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"执行完毕"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>案例 2</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyByteBuf02</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ByteBuf</span></span><br><span class="line">        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">"hello,world!"</span>, Charset.forName(<span class="string">"utf-8"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用相关的方法</span></span><br><span class="line">        <span class="keyword">if</span> (byteBuf.hasArray()) { <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] content = byteBuf.array();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将 content 转成字符串</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(content, Charset.forName(<span class="string">"utf-8"</span>)));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"byteBuf="</span> + byteBuf);</span><br><span class="line"></span><br><span class="line">            System.out.println(byteBuf.arrayOffset()); <span class="comment">// 0</span></span><br><span class="line">            System.out.println(byteBuf.readerIndex()); <span class="comment">// 0</span></span><br><span class="line">            System.out.println(byteBuf.writerIndex()); <span class="comment">// 12</span></span><br><span class="line">            System.out.println(byteBuf.capacity()); <span class="comment">// 36</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//System.out.println(byteBuf.readByte()); //</span></span><br><span class="line">            System.out.println(byteBuf.getByte(<span class="number">0</span>)); <span class="comment">// 104</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len = byteBuf.readableBytes(); <span class="comment">//可读的字节数  12</span></span><br><span class="line">            System.out.println(<span class="string">"len="</span> + len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用for取出各个字节</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">                System.out.println((<span class="keyword">char</span>) byteBuf.getByte(i));</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//按照某个范围读取</span></span><br><span class="line">            System.out.println(byteBuf.getCharSequence(<span class="number">0</span>, <span class="number">4</span>, Charset.forName(<span class="string">"utf-8"</span>)));</span><br><span class="line">            System.out.println(byteBuf.getCharSequence(<span class="number">4</span>, <span class="number">6</span>, Charset.forName(<span class="string">"utf-8"</span>)));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Netty-应用实例-群聊系统"><a href="#Netty-应用实例-群聊系统" class="headerlink" title="Netty 应用实例-群聊系统"></a>Netty 应用实例-群聊系统</h2><p>实例要求：</p>
<ol>
<li>编写一个 <code>Netty</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>实现多人群聊</li>
<li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li>
<li>客户端：通过 <code>channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li>
<li>目的：进一步理解 <code>Netty</code> 非阻塞网络编程机制</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0025.png" alt="img"></p>
<p>代码如下：</p>
<h3 id="GroupChatServer"><a href="#GroupChatServer" class="headerlink" title="GroupChatServer"></a>GroupChatServer</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port; <span class="comment">//监听端口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写run方法，处理客户端的请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">//8个NioEventLoop</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//获取到pipeline</span></span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//向pipeline加入解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            <span class="comment">//向pipeline加入编码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            <span class="comment">//加入自己的业务处理handler</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> GroupChatServerHandler());</span><br><span class="line"></span><br><span class="line">                        }-</span><br><span class="line">                    });</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"netty 服务器启动"</span>);</span><br><span class="line">            ChannelFuture channelFuture = b.bind(port).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//监听关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> GroupChatServer(<span class="number">7000</span>).run();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="GroupChatServerHandler"><a href="#GroupChatServerHandler" class="headerlink" title="GroupChatServerHandler"></a>GroupChatServerHandler</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.ChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.DefaultChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这样写还要自己遍历Channel</span></span><br><span class="line">    <span class="comment">//public static List&lt;Channel&gt; channels = new ArrayList&lt;Channel&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用一个hashmap 管理私聊（私聊本案例并未实现，只是提供个思路）</span></span><br><span class="line">    <span class="comment">//public static Map&lt;String, Channel&gt; channels = new HashMap&lt;String,Channel&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个channle 组，管理所有的channel</span></span><br><span class="line">    <span class="comment">//GlobalEventExecutor.INSTANCE) 是全局的事件执行器，是一个单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelGroup  channelGroup = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//handlerAdded 表示连接建立，一旦连接，第一个被执行</span></span><br><span class="line">    <span class="comment">//将当前channel 加入到  channelGroup</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">//将该客户加入聊天的信息推送给其它在线的客户端</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//该方法会将 channelGroup 中所有的channel 遍历，并发送消息，我们不需要自己遍历</span></span><br><span class="line"></span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">"[客户端]"</span> + channel.remoteAddress() + <span class="string">" 加入聊天"</span> + sdf.format(<span class="keyword">new</span> java.util.Date()) + <span class="string">" \n"</span>);</span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//私聊如何实现</span></span><br><span class="line"><span class="comment">//         channels.put（"userid100",channel）;</span></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//断开连接, 将xx客户离开信息推送给当前在线的客户</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">"[客户端]"</span> + channel.remoteAddress() + <span class="string">" 离开了\n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"channelGroup size"</span> + channelGroup.size());</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示channel 处于活动状态, 提示 xx上线</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//这个是给服务端看的，客户端上面已经提示xxx加入群聊了</span></span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">" 上线了~"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示channel 处于不活动状态, 提示 xx离线了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">" 离线了~"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据，转发给在线的每一个客户端</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到当前channel</span></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">//这时我们遍历channelGroup, 根据不同的情况，回送不同的消息</span></span><br><span class="line"></span><br><span class="line">        channelGroup.forEach(ch -&gt; {</span><br><span class="line">            <span class="keyword">if</span>(channel != ch) { <span class="comment">//不是当前的channel,转发消息</span></span><br><span class="line">                ch.writeAndFlush(<span class="string">"[客户]"</span> + channel.remoteAddress() + <span class="string">" 发送了消息"</span> + msg + <span class="string">"\n"</span>);</span><br><span class="line">            }<span class="keyword">else</span> {<span class="comment">//回显自己发送的消息给自己</span></span><br><span class="line">                ch.writeAndFlush(<span class="string">"[自己]发送了消息"</span> + msg + <span class="string">"\n"</span>);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//关闭通道</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="GroupChatClient"><a href="#GroupChatClient" class="headerlink" title="GroupChatClient"></a>GroupChatClient</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//得到pipeline</span></span><br><span class="line">                        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                        <span class="comment">//加入相关handler</span></span><br><span class="line">                        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">                        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">                        <span class="comment">//加入自定义的handler</span></span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> GroupChatClientHandler());</span><br><span class="line">                    }</span><br><span class="line">                });</span><br><span class="line"></span><br><span class="line">        ChannelFuture channelFuture = bootstrap.connect(host, port).sync();</span><br><span class="line">        <span class="comment">//得到channel</span></span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line">            System.out.println(<span class="string">"-------"</span> + channel.localAddress()+ <span class="string">"--------"</span>);</span><br><span class="line">            <span class="comment">//客户端需要输入信息，创建一个扫描器</span></span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine()) {</span><br><span class="line">                String msg = scanner.nextLine();</span><br><span class="line">                <span class="comment">//通过channel 发送到服务器端</span></span><br><span class="line">                channel.writeAndFlush(msg + <span class="string">"\r\n"</span>);</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">new</span> GroupChatClient(<span class="string">"127.0.0.1"</span>, <span class="number">7000</span>).run();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="GroupChatClientHandler"><a href="#GroupChatClientHandler" class="headerlink" title="GroupChatClientHandler"></a>GroupChatClientHandler</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从服务器拿到的数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(msg.trim());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Netty-心跳检测机制案例"><a href="#Netty-心跳检测机制案例" class="headerlink" title="Netty 心跳检测机制案例"></a>Netty 心跳检测机制案例</h2><p>实例要求：</p>
<ol>
<li>编写一个 <code>Netty</code> 心跳检测机制案例,当服务器超过 <code>3</code> 秒没有读时，就提示读空闲</li>
<li>当服务器超过 <code>5</code> 秒没有写操作时，就提示写空闲</li>
<li>实现当服务器超过 <code>7</code> 秒没有读或者写操作时，就提示读写空闲</li>
<li>代码如下：</li>
</ol>
<h3 id="MyServer"><a href="#MyServer" class="headerlink" title="MyServer"></a>MyServer</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.heartbeat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">//8个NioEventLoop</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup);</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            <span class="comment">//在bossGroup增加一个日志处理器</span></span><br><span class="line">            serverBootstrap.handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                    <span class="comment">//加入一个netty 提供 IdleStateHandler</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    说明</span></span><br><span class="line"><span class="comment">                    1. IdleStateHandler 是netty 提供的处理空闲状态的处理器</span></span><br><span class="line"><span class="comment">                    2. long readerIdleTime : 表示多长时间没有读, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">                    3. long writerIdleTime : 表示多长时间没有写, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">                    4. long allIdleTime : 表示多长时间没有读写, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    5. 文档说明</span></span><br><span class="line"><span class="comment">                    triggers an {@link IdleStateEvent} when a {@link Channel} has not performed</span></span><br><span class="line"><span class="comment">                   read, write, or both operation for a while.</span></span><br><span class="line"><span class="comment">                    6. 当 IdleStateEvent 触发后 , 就会传递给管道 的下一个handler去处理，通过调用(触发)</span></span><br><span class="line"><span class="comment">                   下一个handler 的 userEventTiggered , 在该方法中去处理 IdleStateEvent(读空闲，写空闲，读写空闲)</span></span><br><span class="line"><span class="comment">                    7.handlerRemoved有时候是无法感知连接断掉，所以还是需要心跳包的检测来判断连接是否还有效</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>, TimeUnit.SECONDS));</span><br><span class="line">                    <span class="comment">//加入一个对空闲检测进一步处理的handler(自定义)</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动服务器</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyServerHandler"><a href="#MyServerHandler" class="headerlink" title="MyServerHandler"></a>MyServerHandler</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.heartbeat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt 事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将  evt 向下转型 IdleStateEvent</span></span><br><span class="line">            IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">            String eventType = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (event.state()) {</span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                  eventType = <span class="string">"读空闲"</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    eventType = <span class="string">"写空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    eventType = <span class="string">"读写空闲"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress() + <span class="string">"--超时时间--"</span> + eventType);</span><br><span class="line">            System.out.println(<span class="string">"服务器做相应处理.."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果发生空闲，我们关闭通道</span></span><br><span class="line">           <span class="comment">// ctx.channel().close();</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Netty-通过-WebSocket-编程实现服务器和客户端长连接"><a href="#Netty-通过-WebSocket-编程实现服务器和客户端长连接" class="headerlink" title="Netty 通过 WebSocket 编程实现服务器和客户端长连接"></a>Netty 通过 WebSocket 编程实现服务器和客户端长连接</h2><p>实例要求：</p>
<ol>
<li><code>Http</code> 协议是无状态的，浏览器和服务器间的请求响应一次，下一次会重新创建连接。</li>
<li>要求：实现基于 <code>WebSocket</code> 的长连接的全双工的交互</li>
<li>改变 <code>Http</code> 协议多次请求的约束，实现长连接了，服务器可以发送消息给浏览器</li>
<li>客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</li>
<li>运行界面</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0026.png" alt="img"></p>
<h3 id="MyServer-1"><a href="#MyServer-1" class="headerlink" title="MyServer"></a>MyServer</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.websocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.heartbeat.MyServerHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpObjectAggregator;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">//8个NioEventLoop</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup);</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//因为基于http协议，使用http的编码和解码器</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                    <span class="comment">//http是以块方式写，添加ChunkedWriteHandler处理器</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    说明</span></span><br><span class="line"><span class="comment">                    1. http数据在传输过程中是分段, HttpObjectAggregator ，就是可以将多个段聚合</span></span><br><span class="line"><span class="comment">                    2. 这就就是为什么，当浏览器发送大量数据时，就会发出多次http请求</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">8192</span>));</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    说明</span></span><br><span class="line"><span class="comment">                    1. 对应websocket ，它的数据是以 帧(frame) 形式传递</span></span><br><span class="line"><span class="comment">                    2. 可以看到WebSocketFrame 下面有六个子类</span></span><br><span class="line"><span class="comment">                    3. 浏览器请求时 ws://localhost:7000/hello 表示请求的uri</span></span><br><span class="line"><span class="comment">                    4. WebSocketServerProtocolHandler 核心功能是将 http协议升级为 ws协议 , 保持长连接</span></span><br><span class="line"><span class="comment">                    5. 是通过一个 状态码 101</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">"/hello"</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//自定义的handler ，处理业务逻辑</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> MyTextWebSocketFrameHandler());</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动服务器</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyTextWebSocketFrameHandler"><a href="#MyTextWebSocketFrameHandler" class="headerlink" title="MyTextWebSocketFrameHandler"></a>MyTextWebSocketFrameHandler</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.websocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.TextWebSocketFrame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里 TextWebSocketFrame 类型，表示一个文本帧(frame)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTextWebSocketFrameHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt;</span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器收到消息 "</span> + msg.text());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回复消息</span></span><br><span class="line">        ctx.channel().writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">"服务器时间"</span> + LocalDateTime.now() + <span class="string">" "</span> + msg.text()));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当web客户端连接后， 触发方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//id 表示唯一的值，LongText 是唯一的 ShortText 不是唯一</span></span><br><span class="line">        System.out.println(<span class="string">"handlerAdded 被调用"</span> + ctx.channel().id().asLongText());</span><br><span class="line">        System.out.println(<span class="string">"handlerAdded 被调用"</span> + ctx.channel().id().asShortText());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"handlerRemoved 被调用"</span> + ctx.channel().id().asLongText());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(<span class="string">"异常发生 "</span> + cause.getMessage());</span><br><span class="line">        ctx.close(); <span class="comment">//关闭连接</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="hello-html"><a href="#hello-html" class="headerlink" title="hello.html"></a>hello.html</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">HTML</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var socket;</span><br><span class="line">    //判断当前浏览器是否支持websocket</span><br><span class="line">    if(window.WebSocket) {</span><br><span class="line">        //go on</span><br><span class="line">        socket = new WebSocket("ws://localhost:7000/hello2");</span><br><span class="line">        //相当于channelReado, ev 收到服务器端回送的消息</span><br><span class="line">        socket.onmessage = function (ev) {</span><br><span class="line">            var rt = document.getElementById("responseText");</span><br><span class="line">            rt.value = rt.value + "\n" + ev.data;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        //相当于连接开启(感知到连接开启)</span><br><span class="line">        socket.onopen = function (ev) {</span><br><span class="line">            var rt = document.getElementById("responseText");</span><br><span class="line">            rt.value = "连接开启了.."</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        //相当于连接关闭(感知到连接关闭)</span><br><span class="line">        socket.onclose = function (ev) {</span><br><span class="line"></span><br><span class="line">            var rt = document.getElementById("responseText");</span><br><span class="line">            rt.value = rt.value + "\n" + "连接关闭了.."</span><br><span class="line">        }</span><br><span class="line">    } else {</span><br><span class="line">        alert("当前浏览器不支持websocket")</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //发送消息到服务器</span><br><span class="line">    function send(message) {</span><br><span class="line">        if(!window.socket) { //先判断socket是否创建好</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line">        if(socket.readyState == WebSocket.OPEN) {</span><br><span class="line">            //通过socket 发送消息</span><br><span class="line">            socket.send(message)</span><br><span class="line">        } else {</span><br><span class="line">            alert("连接没有开启");</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">    &lt;form onsubmit="return false"&gt;</span><br><span class="line">        &lt;textarea name="message" style="height: 300px; width: 300px"&gt;&lt;/textarea&gt;</span><br><span class="line">        &lt;input type="button" value="发生消息" onclick="send(this.form.message.value)"&gt;</span><br><span class="line">        &lt;textarea id="responseText" style="height: 300px; width: 300px"&gt;&lt;/textarea&gt;</span><br><span class="line">        &lt;input type="button" value="清空内容" onclick="document.getElementById('responseText').value=''"&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到并不是发一次数据，连接就关闭了，而是可以继续发送。</p>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0027.png" alt="img"></p>
<p>参考：</p>
<p><strong>视频：</strong><a href="https://www.bilibili.com/video/BV1DJ411m7NR?from=search&amp;seid=7455267981675039441">https://www.bilibili.com/video/BV1DJ411m7NR?from=search&amp;seid=7455267981675039441</a></p>
<p><strong>文章链接:</strong> <a href="https://imlql.cn/post/3f9283e7.html">https://imlql.cn/post/3f9283e7.html</a></p>
</body></html>]]></content>
      <categories>
        <category>计算机网络</category>
        <category>netty</category>
      </categories>
  </entry>
  <entry>
    <title>netty基础-1</title>
    <url>/de7d93c1.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="Netty简介"><a href="#Netty简介" class="headerlink" title="Netty简介"></a>Netty简介</h1><h2 id="Netty-的介绍"><a href="#Netty-的介绍" class="headerlink" title="Netty 的介绍"></a>Netty 的介绍</h2><ol>
<li><code>Netty</code> 是由 <code>JBOSS</code> 提供的一个 <code>Java</code> 开源框架，现为 <code>Github</code> 上的独立项目。</li>
<li><code>Netty</code> 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 <code>IO</code> 程序。</li>
<li><code>Netty</code> 主要针对在 <code>TCP</code> 协议下，面向 <code>Client</code> 端的高并发应用，或者 <code>Peer-to-Peer</code> 场景下的大量数据持续传输的应用。</li>
<li><code>Netty</code> 本质是一个 <code>NIO</code> 框架，适用于服务器通讯相关的多种应用场景。</li>
<li>要透彻理解 <code>Netty</code>，需要先学习 <code>NIO</code>，这样我们才能阅读 <code>Netty</code> 的源码。</li>
</ol>
<span id="more"></span>

<p>相对简单的一个体系图</p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0001.png"><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/0001.png" alt="img"></a></p>
<h2 id="Netty-的应用场景"><a href="#Netty-的应用场景" class="headerlink" title="Netty 的应用场景"></a>Netty 的应用场景</h2><h3 id="互联网行业"><a href="#互联网行业" class="headerlink" title="互联网行业"></a>互联网行业</h3><ol>
<li>互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 <code>RPC</code> 框架必不可少，<code>Netty</code> 作为异步高性能的通信框架，往往作为基础通信组件被这些 <code>RPC</code> 框架使用。</li>
<li>典型的应用有：阿里分布式服务框架 <code>Dubbo</code> 的 <code>RPC</code> 框 架使用 <code>Dubbo</code> 协议进行节点间通信，<code>Dubbo</code> 协议默认使用 <code>Netty</code> 作为基础通信组件，用于实现各进程节点之间的内部通信。</li>
</ol>
<h3 id="游戏行业"><a href="#游戏行业" class="headerlink" title="游戏行业"></a>游戏行业</h3><ol>
<li>无论是手游服务端还是大型的网络游戏，<code>Java</code> 语言得到了越来越广泛的应用。</li>
<li><code>Netty</code> 作为高性能的基础通信组件，提供了 <code>TCP/UDP</code> 和 <code>HTTP</code> 协议栈，方便定制和开发私有协议栈，账号登录服务器。</li>
<li>地图服务器之间可以方便的通过 <code>Netty</code> 进行高性能的通信。</li>
</ol>
<h3 id="大数据领域"><a href="#大数据领域" class="headerlink" title="大数据领域"></a>大数据领域</h3><ol>
<li>经典的 <code>Hadoop</code> 的高性能通信和序列化组件 <code>Avro</code> 的 <code>RPC</code> 框架，默认采用 <code>Netty</code> 进行跨界点通信。</li>
<li>它的 <code>NettyService</code> 基于 <code>Netty</code> 框架二次封装实现。</li>
</ol>
<h3 id="其它开源项目使用到-Netty"><a href="#其它开源项目使用到-Netty" class="headerlink" title="其它开源项目使用到 Netty"></a>其它开源项目使用到 Netty</h3><p>网址：<a href="https://netty.io/wiki/related-projects.html">https://netty.io/wiki/related-projects.html</a></p>
<h2 id="Netty-的学习资料参考"><a href="#Netty-的学习资料参考" class="headerlink" title="Netty 的学习资料参考"></a>Netty 的学习资料参考</h2><p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0002.png"><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/0002.png" alt="img"></a></p>
<h1 id="Java-BIO编程"><a href="#Java-BIO编程" class="headerlink" title="Java BIO编程"></a>Java BIO编程</h1><h2 id="I-O-模型"><a href="#I-O-模型" class="headerlink" title="I/O 模型"></a>I/O 模型</h2><ol>
<li><code>I/O</code> 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能。</li>
<li><code>Java</code> 共支持 <code>3</code> 种网络编程模型 <code>I/O</code> 模式：<code>BIO</code>、<code>NIO</code>、<code>AIO</code>。</li>
<li><code>Java BIO</code>：同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。【简单示意图】</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0003.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0003.png" alt="img"></a></p>
<ol>
<li><code>Java NIO</code>：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 <code>I/O</code> 请求就进行处理。【简单示意图】</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0004.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0004.png" alt="img"></a></p>
<ol>
<li><code>Java AIO(NIO.2)</code>：异步非阻塞，<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</li>
<li>我们依次展开讲解。</li>
</ol>
<h2 id="BIO、NIO、AIO-使用场景分析"><a href="#BIO、NIO、AIO-使用场景分析" class="headerlink" title="BIO、NIO、AIO 使用场景分析"></a>BIO、NIO、AIO 使用场景分析</h2><ol>
<li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，但程序简单易理解。</li>
<li><code>NIO</code> 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，<code>JDK1.4</code> 开始支持。</li>
<li><code>AIO</code> 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 <code>OS</code> 参与并发操作，编程比较复杂，<code>JDK7</code> 开始支持。</li>
</ol>
<h2 id="Java-BIO-基本介绍"><a href="#Java-BIO-基本介绍" class="headerlink" title="Java BIO 基本介绍"></a>Java BIO 基本介绍</h2><ol>
<li><code>Java BIO</code> 就是传统的 <code>Java I/O</code> 编程，其相关的类和接口在 <code>java.io</code>。</li>
<li><code>BIO(BlockingI/O)</code>：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）。【后有应用实例】</li>
<li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，程序简单易理解。</li>
</ol>
<h2 id="Java-BIO-工作机制"><a href="#Java-BIO-工作机制" class="headerlink" title="Java BIO 工作机制"></a>Java BIO 工作机制</h2><p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0005.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0005.png" alt="img"></a></p>
<p>对 <code>BIO</code> 编程流程的梳理</p>
<ol>
<li>服务器端启动一个 <code>ServerSocket</code>。</li>
<li>客户端启动 <code>Socket</code> 对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯。</li>
<li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝。</li>
<li>如果有响应，客户端线程会等待请求结束后，再继续执行。</li>
</ol>
<h2 id="Java-BIO-应用实例"><a href="#Java-BIO-应用实例" class="headerlink" title="Java BIO 应用实例"></a>Java BIO 应用实例</h2><p>实例说明：</p>
<ol>
<li>使用 <code>BIO</code> 模型编写一个服务器端，监听 <code>6666</code> 端口，当有客户端连接时，就启动一个线程与之通讯。</li>
<li>要求使用线程池机制改善，可以连接多个客户端。</li>
<li>服务器端可以接收客户端发送的数据（<code>telnet</code> 方式即可）。</li>
<li>代码演示：</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//线程池机制</span></span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1. 创建一个线程池</span></span><br><span class="line">        <span class="comment">//2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class="line">        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//创建ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            System.out.println(<span class="string">"线程信息id = "</span> + Thread.currentThread().getId() + <span class="string">"名字 = "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//监听，等待客户端连接</span></span><br><span class="line">            System.out.println(<span class="string">"等待连接...."</span>);</span><br><span class="line">            <span class="comment">//会阻塞在accept()</span></span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">"连接到一个客户端"</span>);</span><br><span class="line">            <span class="comment">//就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class="line">            newCachedThreadPool.execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{<span class="comment">//我们重写</span></span><br><span class="line">                    <span class="comment">//可以和客户端通讯</span></span><br><span class="line">                    handler(socket);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个handler方法，和客户端通讯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"线程信息id = "</span> + Thread.currentThread().getId() + <span class="string">"名字 = "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//通过socket获取输入流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="comment">//循环的读取客户端发送的数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                System.out.println(<span class="string">"线程信息id = "</span> + Thread.currentThread().getId() + <span class="string">"名字 = "</span> + Thread.currentThread().getName());</span><br><span class="line">                System.out.println(<span class="string">"read...."</span>);</span><br><span class="line">                <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">                <span class="keyword">if</span> (read != -<span class="number">1</span>) {</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, read));<span class="comment">//输出客户端发送的数据</span></span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            System.out.println(<span class="string">"关闭和client的连接"</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                socket.close();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0006.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0006.png" alt="img"></a></p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ol>
<li>每个请求都需要创建独立的线程，与对应的客户端进行数据 <code>Read</code>，业务处理，数据 <code>Write</code>。</li>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 <code>Read</code> 操作上，造成线程资源浪费。</li>
</ol>
<h1 id="Java-NIO编程"><a href="#Java-NIO编程" class="headerlink" title="Java NIO编程"></a>Java NIO编程</h1><h2 id="Java-NIO-基本介绍"><a href="#Java-NIO-基本介绍" class="headerlink" title="Java NIO 基本介绍"></a>Java NIO 基本介绍</h2><ol>
<li><code>Java NIO</code> 全称 <code>Java non-blocking IO</code>，是指 <code>JDK</code> 提供的新 <code>API</code>。从 <code>JDK1.4</code> 开始，<code>Java</code> 提供了一系列改进的输入/输出的新特性，被统称为 <code>NIO</code>（即 <code>NewIO</code>），是同步非阻塞的。</li>
<li><code>NIO</code> 相关类都被放在 <code>java.nio</code> 包及子包下，并且对原 <code>java.io</code> 包中的很多类进行改写。【基本案例】</li>
<li><code>NIO</code> 有三大核心部分：**<code>Channel</code>（通道）、<code>Buffer</code>（缓冲区）、<code>Selector</code>（选择器）** 。</li>
<li><code>NIO</code> 是<strong>面向缓冲区，或者面向块编程</strong>的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。</li>
<li><code>Java NIO</code> 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。【后面有案例说明】</li>
<li>通俗理解：<code>NIO</code> 是可以做到用一个线程来处理多个操作的。假设有 <code>10000</code> 个请求过来,根据实际情况，可以分配 <code>50</code> 或者 <code>100</code> 个线程来处理。不像之前的阻塞 <code>IO</code> 那样，非得分配 <code>10000</code> 个。</li>
<li><code>HTTP 2.0</code> 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 <code>HTTP 1.1</code> 大了好几个数量级。</li>
<li>案例说明 <code>NIO</code> 的 <code>Buffer</code></li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.IntBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicBuffer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//举例说明 Buffer 的使用(简单说明)</span></span><br><span class="line">        <span class="comment">//创建一个 Buffer，大小为 5，即可以存放 5 个 int</span></span><br><span class="line">        IntBuffer intBuffer = IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向buffer存放数据</span></span><br><span class="line">        <span class="comment">//intBuffer.put(10);</span></span><br><span class="line">        <span class="comment">//intBuffer.put(11);</span></span><br><span class="line">        <span class="comment">//intBuffer.put(12);</span></span><br><span class="line">        <span class="comment">//intBuffer.put(13);</span></span><br><span class="line">        <span class="comment">//intBuffer.put(14);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intBuffer.capacity(); i++) {</span><br><span class="line">            intBuffer.put(i * <span class="number">2</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//如何从 buffer 读取数据</span></span><br><span class="line">        <span class="comment">//将 buffer 转换，读写切换(!!!)</span></span><br><span class="line">        intBuffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (intBuffer.hasRemaining()) {</span><br><span class="line">            System.out.println(intBuffer.get());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NIO-和-BIO-的比较"><a href="#NIO-和-BIO-的比较" class="headerlink" title="NIO 和 BIO 的比较"></a>NIO 和 BIO 的比较</h2><ol>
<li><code>BIO</code> 以流的方式处理数据，而 <code>NIO</code> 以块的方式处理数据，块 <code>I/O</code> 的效率比流 <code>I/O</code> 高很多。</li>
<li><code>BIO</code> 是阻塞的，<code>NIO</code> 则是非阻塞的。</li>
<li><code>BIO</code> 基于字节流和字符流进行操作，而 <code>NIO</code> 基于 <code>Channel</code>（通道）和 <code>Buffer</code>（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<code>Selector</code>（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。</li>
<li>Buffer和Channel之间的数据流向是双向的</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0007.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0007.png" alt="img"></a></p>
<p>推荐文章：<a href="https://blog.csdn.net/vtopqx/article/details/88115899">https://blog.csdn.net/vtopqx/article/details/88115899</a></p>
<h2 id="NIO-三大核心原理示意图"><a href="#NIO-三大核心原理示意图" class="headerlink" title="NIO 三大核心原理示意图"></a>NIO 三大核心原理示意图</h2><p>一张图描述 <code>NIO</code> 的 <code>Selector</code>、<code>Channel</code> 和 <code>Buffer</code> 的关系。</p>
<h3 id="Selector、Channel-和-Buffer-关系图（简单版）"><a href="#Selector、Channel-和-Buffer-关系图（简单版）" class="headerlink" title="Selector、Channel 和 Buffer 关系图（简单版）"></a>Selector、Channel 和 Buffer 关系图（简单版）</h3><p>关系图的说明:</p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0008.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0008.png" alt="img"></a></p>
<ol>
<li>每个 <code>Channel</code> 都会对应一个 <code>Buffer</code>。</li>
<li><code>Selector</code> 对应一个线程，一个线程对应多个 <code>Channel</code>（连接）。</li>
<li>该图反应了有三个 <code>Channel</code> 注册到该 <code>Selector</code> //程序</li>
<li>程序切换到哪个 <code>Channel</code> 是由事件决定的，<code>Event</code> 就是一个重要的概念。</li>
<li><code>Selector</code> 会根据不同的事件，在各个通道上切换。</li>
<li><code>Buffer</code> 就是一个内存块，底层是有一个数组。</li>
<li>数据的读取写入是通过 <code>Buffer</code>，这个和 <code>BIO</code>是不同的，<code>BIO</code> 中要么是输入流，或者是输出流，不能双向，但是 <code>NIO</code> 的 <code>Buffer</code> 是可以读也可以写，需要 <code>flip</code> 方法切换 <code>Channel</code> 是双向的，可以返回底层操作系统的情况，比如 <code>Linux</code>，底层的操作系统通道就是双向的。</li>
</ol>
<h2 id="缓冲区（Buffer）"><a href="#缓冲区（Buffer）" class="headerlink" title="缓冲区（Buffer）"></a>缓冲区（Buffer）</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>缓冲区（<code>Buffer</code>）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，可以理解成是一个<strong>容器对象（含数组）</strong>，该对象提供了一组方法，可以更轻松地使用内存块，，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。<code>Channel</code> 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 <code>Buffer</code>，如图:【后面举例说明】</p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0009.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0009.png" alt="img"></a></p>
<h3 id="Buffer-类及其子类"><a href="#Buffer-类及其子类" class="headerlink" title="Buffer 类及其子类"></a>Buffer 类及其子类</h3><ol>
<li>在 <code>NIO</code> 中，<code>Buffer</code> 是一个顶层父类，它是一个抽象类，类的层级关系图：</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0010.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0010.png" alt="img"></a></p>
<ol>
<li><code>Buffer</code> 类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息：</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0011.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0011.png" alt="img"></a></p>
<ol>
<li><code>Buffer</code> 类相关方法一览</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0013.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0013.png" alt="img"></a></p>
<h3 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h3><p>从前面可以看出对于 <code>Java</code> 中的基本数据类型（<code>boolean</code> 除外），都有一个 <code>Buffer</code> 类型与之相对应，最常用的自然是 <code>ByteBuffer</code> 类（二进制数据），该类的主要方法如下：</p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0014.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0014.png" alt="img"></a></p>
<h2 id="通道（Channel）"><a href="#通道（Channel）" class="headerlink" title="通道（Channel）"></a>通道（Channel）</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li><p>NIO的通道类似于流，但有些区别如下：</p>
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲:</li>
</ul>
</li>
<li><p><code>BIO</code> 中的 <code>Stream</code> 是单向的，例如 <code>FileInputStream</code> 对象只能进行读取数据的操作，而 <code>NIO</code> 中的通道（<code>Channel</code>）是双向的，可以读操作，也可以写操作。</p>
</li>
<li><p><code>Channel</code> 在 <code>NIO</code> 中是一个接口 <code>public interface Channel extends Closeable{}</code></p>
</li>
<li><p>常用的 <code>Channel</code> 类有：**<code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code> 和 <code>SocketChannel</code>**。【<code>ServerSocketChanne</code> 类似 <code>ServerSocket</code>、<code>SocketChannel</code> 类似 <code>Socket</code>】</p>
</li>
<li><p><code>FileChannel</code> 用于文件的数据读写，<code>DatagramChannel</code> 用于 <code>UDP</code> 的数据读写，<code>ServerSocketChannel</code> 和 <code>SocketChannel</code> 用于 <code>TCP</code> 的数据读写。</p>
</li>
<li><p>图示</p>
</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0015.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0015.png" alt="img"></a></p>
<h3 id="FileChannel-类"><a href="#FileChannel-类" class="headerlink" title="FileChannel 类"></a>FileChannel 类</h3><p><code>FileChannel</code> 主要用来对本地文件进行 <code>IO</code> 操作，常见的方法有</p>
<ul>
<li><code>public int read(ByteBuffer dst)</code>，从通道读取数据并放到缓冲区中</li>
<li><code>public int write(ByteBuffer src)</code>，把缓冲区的数据写到通道中</li>
<li><code>public long transferFrom(ReadableByteChannel src, long position, long count)</code>，从目标通道中复制数据到当前通道</li>
<li><code>public long transferTo(long position, long count, WritableByteChannel target)</code>，把数据从当前通道复制给目标通道</li>
</ul>
<h3 id="应用实例1-本地文件写数据"><a href="#应用实例1-本地文件写数据" class="headerlink" title="应用实例1 - 本地文件写数据"></a>应用实例1 - 本地文件写数据</h3><p>实例要求：</p>
<ol>
<li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 “hello,尚硅谷” 写入到 <code>file01.txt</code> 中</li>
<li>文件不存在就创建</li>
<li>代码演示</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel01</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        String str = <span class="string">"hello,尚硅谷"</span>;</span><br><span class="line">        <span class="comment">//创建一个输出流 -&gt; channel</span></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\file01.txt"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过 fileOutputStream 获取对应的 FileChannel</span></span><br><span class="line">        <span class="comment">//这个 fileChannel 真实类型是 FileChannelImpl</span></span><br><span class="line">        FileChannel fileChannel = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个缓冲区 ByteBuffer</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 str 放入 byteBuffer</span></span><br><span class="line">        byteBuffer.put(str.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对 byteBuffer 进行 flip</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 byteBuffer 数据写入到 fileChannel</span></span><br><span class="line">        fileChannel.write(byteBuffer);</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="应用实例2-本地文件读数据"><a href="#应用实例2-本地文件读数据" class="headerlink" title="应用实例2 - 本地文件读数据"></a>应用实例2 - 本地文件读数据</h3><p>实例要求：</p>
<ol>
<li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 <code>file01.txt</code> 中的数据读入到程序，并显示在控制台屏幕</li>
<li>假定文件已经存在</li>
<li>代码演示</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel02</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建文件的输入流</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"d:\\file01.txt"</span>);</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过 fileInputStream 获取对应的 FileChannel -&gt; 实际类型 FileChannelImpl</span></span><br><span class="line">        FileChannel fileChannel = fileInputStream.getChannel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建缓冲区</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="keyword">int</span>)file.length());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将通道的数据读入到 Buffer</span></span><br><span class="line">        fileChannel.read(byteBuffer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将 byteBuffer 的字节数据转成 String</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="应用实例3-使用一个-Buffer-完成文件读取、写入"><a href="#应用实例3-使用一个-Buffer-完成文件读取、写入" class="headerlink" title="应用实例3 - 使用一个 Buffer 完成文件读取、写入"></a>应用实例3 - 使用一个 Buffer 完成文件读取、写入</h3><p>实例要求：</p>
<ol>
<li>使用 <code>FileChannel</code>（通道）和方法 <code>read、write</code>，完成文件的拷贝</li>
<li>拷贝一个文本文件 <code>1.txt</code>，放在项目下即可</li>
<li>代码演示</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0016.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0016.png" alt="img"></a></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel03</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"1.txt"</span>);</span><br><span class="line">        FileChannel fileChannel01 = fileInputStream.getChannel();</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"2.txt"</span>);</span><br><span class="line">        FileChannel fileChannel02 = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) { <span class="comment">//循环读取</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里有一个重要的操作，一定不要忘了</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public final Buffer clear() {</span></span><br><span class="line"><span class="comment">                position = 0;</span></span><br><span class="line"><span class="comment">                limit = capacity;</span></span><br><span class="line"><span class="comment">                mark = -1;</span></span><br><span class="line"><span class="comment">                return this;</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            byteBuffer.clear(); <span class="comment">//清空 buffer</span></span><br><span class="line">            <span class="keyword">int</span> read = fileChannel01.read(byteBuffer);</span><br><span class="line">            System.out.println(<span class="string">"read = "</span> + read);</span><br><span class="line">            <span class="keyword">if</span> (read == -<span class="number">1</span>) { <span class="comment">//表示读完</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将 buffer 中的数据写入到 fileChannel02--2.txt</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            fileChannel02.write(byteBuffer);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭相关的流</span></span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="应用实例4-拷贝文件-transferFrom-方法"><a href="#应用实例4-拷贝文件-transferFrom-方法" class="headerlink" title="应用实例4 - 拷贝文件 transferFrom 方法"></a>应用实例4 - 拷贝文件 transferFrom 方法</h3><ol>
<li>实例要求：</li>
<li>使用 <code>FileChannel</code>（通道）和方法 <code>transferFrom</code>，完成文件的拷贝</li>
<li>拷贝一张图片</li>
<li>代码演示</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel04</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建相关流</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"d:\\a.jpg"</span>);</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\a2.jpg"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取各个流对应的 FileChannel</span></span><br><span class="line">        FileChannel sourceCh = fileInputStream.getChannel();</span><br><span class="line">        FileChannel destCh = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用 transferForm 完成拷贝</span></span><br><span class="line">        destCh.transferFrom(sourceCh, <span class="number">0</span>, sourceCh.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭相关通道和流</span></span><br><span class="line">        sourceCh.close();</span><br><span class="line">        destCh.close();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="关于-Buffer-和-Channel-的注意事项和细节"><a href="#关于-Buffer-和-Channel-的注意事项和细节" class="headerlink" title="关于 Buffer 和 Channel 的注意事项和细节"></a>关于 Buffer 和 Channel 的注意事项和细节</h3><ol>
<li><code>ByteBuffer</code> 支持类型化的 <code>put</code> 和 <code>get</code>，<code>put</code> 放入的是什么数据类型，<code>get</code> 就应该使用相应的数据类型来取出，否则可能有 <code>BufferUnderflowException</code> 异常。【举例说明】</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOByteBufferPutGet</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个 Buffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类型化方式放入数据</span></span><br><span class="line">        buffer.putInt(<span class="number">100</span>);</span><br><span class="line">        buffer.putLong(<span class="number">9</span>);</span><br><span class="line">        buffer.putChar(<span class="string">'尚'</span>);</span><br><span class="line">        buffer.putShort((<span class="keyword">short</span>) <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        System.out.println(buffer.getInt());</span><br><span class="line">        System.out.println(buffer.getLong());</span><br><span class="line">        System.out.println(buffer.getChar());</span><br><span class="line">        System.out.println(buffer.getShort());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>可以将一个普通 <code>Buffer</code> 转成只读 <code>Buffer</code>【举例说明】</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadOnlyBuffer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个 buffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) {</span><br><span class="line">            buffer.put((<span class="keyword">byte</span>) i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到一个只读的 Buffer</span></span><br><span class="line">        ByteBuffer readOnlyBuffer = buffer.asReadOnlyBuffer();</span><br><span class="line">        System.out.println(readOnlyBuffer.getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        <span class="keyword">while</span> (readOnlyBuffer.hasRemaining()) {</span><br><span class="line">            System.out.println(readOnlyBuffer.get());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        readOnlyBuffer.put((<span class="keyword">byte</span>) <span class="number">100</span>); <span class="comment">//ReadOnlyBufferException</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><code>NIO</code> 还提供了 <code>MappedByteBuffer</code>，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由 <code>NIO</code> 来完成。【举例说明】</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.MappedByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明 1.MappedByteBuffer 可让文件直接在内存（堆外内存）修改,操作系统不需要拷贝一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBufferTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"1.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        <span class="comment">//获取对应的通道</span></span><br><span class="line">        FileChannel channel = randomAccessFile.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数 1:FileChannel.MapMode.READ_WRITE 使用的读写模式</span></span><br><span class="line"><span class="comment">         * 参数 2：0：可以直接修改的起始位置</span></span><br><span class="line"><span class="comment">         * 参数 3:5: 是映射到内存的大小（不是索引位置），即将 1.txt 的多少个字节映射到内存</span></span><br><span class="line"><span class="comment">         * 可以直接修改的范围就是 0-5</span></span><br><span class="line"><span class="comment">         * 实际类型 DirectByteBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        mappedByteBuffer.put(<span class="number">0</span>, (<span class="keyword">byte</span>) <span class="string">'H'</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">3</span>, (<span class="keyword">byte</span>) <span class="string">'9'</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">5</span>, (<span class="keyword">byte</span>) <span class="string">'Y'</span>);<span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"></span><br><span class="line">        randomAccessFile.close();</span><br><span class="line">        System.out.println(<span class="string">"修改成功~~"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>前面我们讲的读写操作，都是通过一个 <code>Buffer</code> 完成的，<code>NIO</code> 还支持通过多个 <code>Buffer</code>（即 <code>Buffer</code>数组）完成读写操作，即 <code>Scattering</code> 和 <code>Gathering</code>【举例说明】</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scattering：将数据写入到 buffer 时，可以采用 buffer 数组，依次写入 [分散]</span></span><br><span class="line"><span class="comment"> * Gathering：从 buffer 读取数据时，可以采用 buffer 数组，依次读</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScatteringAndGatheringTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用 ServerSocketChannel 和 SocketChannel 网络</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="number">7000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定端口到 socket，并启动</span></span><br><span class="line">        serverSocketChannel.socket().bind(inetSocketAddress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建 buffer 数组</span></span><br><span class="line">        ByteBuffer[] byteBuffers = <span class="keyword">new</span> ByteBuffer[<span class="number">2</span>];</span><br><span class="line">        byteBuffers[<span class="number">0</span>] = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">        byteBuffers[<span class="number">1</span>] = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等客户端连接 (telnet)</span></span><br><span class="line">        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> messageLength = <span class="number">8</span>; <span class="comment">//假定从客户端接收 8 个字节</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环的读取</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">int</span> byteRead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (byteRead &lt; messageLength) {</span><br><span class="line">                <span class="keyword">long</span> l = socketChannel.read(byteBuffers);</span><br><span class="line">                byteRead += l; <span class="comment">//累计读取的字节数</span></span><br><span class="line">                System.out.println(<span class="string">"byteRead = "</span> + byteRead);</span><br><span class="line">                <span class="comment">//使用流打印,看看当前的这个 buffer 的 position 和 limit</span></span><br><span class="line">                Arrays.asList(byteBuffers).stream().map(buffer -&gt; <span class="string">"position = "</span> + buffer.position() + <span class="string">", limit = "</span> + buffer.limit()).forEach(System.out::println);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将所有的 buffer 进行 flip</span></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip());</span><br><span class="line">            <span class="comment">//将数据读出显示到客户端</span></span><br><span class="line">            <span class="keyword">long</span> byteWirte = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (byteWirte &lt; messageLength) {</span><br><span class="line">                <span class="keyword">long</span> l = socketChannel.write(byteBuffers);<span class="comment">//</span></span><br><span class="line">                byteWirte += l;</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将所有的buffer进行clear</span></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(buffer -&gt; {</span><br><span class="line">                buffer.clear();</span><br><span class="line">            });</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">"byteRead = "</span> + byteRead + <span class="string">", byteWrite = "</span> + byteWirte + <span class="string">", messagelength = "</span> + messageLength);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>buffer的分散和聚合，适用于消息的分工合作</p>
<p>分散度：</p>
<p>从一个channel的一个分散读是读数据进入不止一个buffer的一个读操作。因此，这个channel的“分散”这些数据从这个channel中到多个buffer中。</p>
<p>如果你有一个头和体，并且这个头是固定大小的（例如是128字节），然后这个分散读将会工作的很好。</p>
<p>聚集写：</p>
<p>一个聚集写到一个channel中是来自于不止一个buffer写数据进入一个单独的channel的一个写操作。因此，这个channel的“聚集”这个数据从多个buffer中到一个channel中。</p>
<p>一个聚集写操作通过动态可变大小的消息部分会工作的很好，跟分散读取正好相反。</p>
<h2 id="Selector（选择器）"><a href="#Selector（选择器）" class="headerlink" title="Selector（选择器）"></a>Selector（选择器）</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li><code>Java</code> 的 <code>NIO</code>，用非阻塞的 <code>IO</code> 方式。可以用一个线程，处理多个的客户端连接，就会使用到 <code>Selector</code>（选择器）。</li>
<li><code>Selector</code> 能够检测多个注册的通道上是否有事件发生（注意：多个 <code>Channel</code> 以事件的方式可以注册到同一个 <code>Selector</code>），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</li>
<li>只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</li>
<li>避免了多线程之间的上下文切换导致的开销。</li>
</ol>
<h3 id="Selector-示意图和特点说明"><a href="#Selector-示意图和特点说明" class="headerlink" title="Selector 示意图和特点说明"></a>Selector 示意图和特点说明</h3><p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0017.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0017.png" alt="img"></a></p>
<p>说明如下：</p>
<ol>
<li><code>Netty</code> 的 <code>IO</code> 线程 <code>NioEventLoop</code> 聚合了 <code>Selector</code>（选择器，也叫多路复用器），可以同时并发处理成百上千个客户端连接。</li>
<li>当线程从某客户端 <code>Socket</code> 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</li>
<li>线程通常将非阻塞 <code>IO</code> 的空闲时间用于在其他通道上执行 <code>IO</code> 操作，所以单独的线程可以管理多个输入和输出通道。</li>
<li>由于读写操作都是非阻塞的，这就可以充分提升 <code>IO</code> 线程的运行效率，避免由于频繁 <code>I/O</code> 阻塞导致的线程挂起。</li>
<li>一个 <code>I/O</code> 线程可以并发处理 <code>N</code> 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 <code>I/O</code> 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</li>
</ol>
<h3 id="Selector-类相关方法"><a href="#Selector-类相关方法" class="headerlink" title="Selector 类相关方法"></a>Selector 类相关方法</h3><p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0018.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0018.png" alt="img"></a></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p><code>NIO</code> 中的 <code>ServerSocketChannel</code> 功能类似 <code>ServerSocket</code>、<code>SocketChannel</code> 功能类似 <code>Socket</code>。</p>
</li>
<li><p>Selector相关方法说明</p>
<ul>
<li><code>selector.select();</code> //阻塞</li>
<li><code>selector.select(1000);</code> //阻塞 1000 毫秒，在 1000 毫秒后返回</li>
<li><code>selector.wakeup();</code> //唤醒 selector</li>
<li><code>selector.selectNow();</code> //不阻塞，立马返还</li>
</ul>
</li>
</ol>
<h2 id="NIO-非阻塞网络编程原理分析图"><a href="#NIO-非阻塞网络编程原理分析图" class="headerlink" title="NIO 非阻塞网络编程原理分析图"></a>NIO 非阻塞网络编程原理分析图</h2><p><code>NIO</code> 非阻塞网络编程相关的（<code>Selector</code>、<code>SelectionKey</code>、<code>ServerScoketChannel</code> 和 <code>SocketChannel</code>）关系梳理图</p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0019.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0019.png" alt="img"></a></p>
<p>对上图的说明：</p>
<ol>
<li>当客户端连接时，会通过 <code>ServerSocketChannel</code> 得到 <code>SocketChannel</code>。</li>
<li><code>Selector</code> 进行监听 <code>select</code> 方法，返回有事件发生的通道的个数。</li>
<li>将 <code>socketChannel</code> 注册到 <code>Selector</code> 上，<code>register(Selector sel, int ops)</code>，一个 <code>Selector</code> 上可以注册多个 <code>SocketChannel</code>。</li>
<li>注册后返回一个 <code>SelectionKey</code>，会和该 <code>Selector</code> 关联（集合）。</li>
<li>进一步得到各个 <code>SelectionKey</code>（有事件发生）。</li>
<li>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code>，方法 <code>channel()</code>。</li>
<li>可以通过得到的 <code>channel</code>，完成业务处理。</li>
<li>直接看后面代码吧</li>
</ol>
<h2 id="NIO-非阻塞网络编程快速入门"><a href="#NIO-非阻塞网络编程快速入门" class="headerlink" title="NIO 非阻塞网络编程快速入门"></a>NIO 非阻塞网络编程快速入门</h2><p>案例：</p>
<ol>
<li>编写一个 <code>NIO</code> 入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>目的：理解 <code>NIO</code> 非阻塞网络编程机制</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ServerSocketChannel -&gt; ServerSocket</span></span><br><span class="line"></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到一个Selecor对象</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定一个端口6666, 在服务器端监听</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>));</span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把 serverSocketChannel 注册到  selector 关心 事件为 OP_ACCEPT       pos_1</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"注册后的selectionkey 数量="</span> + selector.keys().size()); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环等待客户端连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里我们等待1秒，如果没有事件发生, 返回</span></span><br><span class="line">            <span class="keyword">if</span>(selector.select(<span class="number">1000</span>) == <span class="number">0</span>) { <span class="comment">//没有事件发生</span></span><br><span class="line">                System.out.println(<span class="string">"服务器等待了1秒，无连接"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果返回的&gt;0, 就获取到相关的 selectionKey集合</span></span><br><span class="line">            <span class="comment">//1.如果返回的&gt;0， 表示已经获取到关注的事件</span></span><br><span class="line">            <span class="comment">//2. selector.selectedKeys() 返回关注事件的集合</span></span><br><span class="line">            <span class="comment">//   通过 selectionKeys 反向获取通道</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            System.out.println(<span class="string">"selectionKeys 数量 = "</span> + selectionKeys.size());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历 Set&lt;SelectionKey&gt;, 使用迭代器遍历</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) {</span><br><span class="line">                <span class="comment">//获取到SelectionKey</span></span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line">                <span class="comment">//根据key 对应的通道发生的事件做相应处理</span></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable()) { <span class="comment">//如果是 OP_ACCEPT, 有新的客户端连接</span></span><br><span class="line">                    <span class="comment">//该该客户端生成一个 SocketChannel</span></span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    System.out.println(<span class="string">"客户端连接成功 生成了一个 socketChannel "</span> + socketChannel.hashCode());</span><br><span class="line">                    <span class="comment">//将  SocketChannel 设置为非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//将socketChannel 注册到selector, 关注事件为 OP_READ， 同时给socketChannel</span></span><br><span class="line">                    <span class="comment">//关联一个Buffer</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"客户端连接后 ，注册的selectionkey 数量="</span> + selector.keys().size()); <span class="comment">//2,3,4..</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(key.isReadable()) {  <span class="comment">//发生 OP_READ</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//通过key 反向获取到对应channel</span></span><br><span class="line">                    SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//获取到该channel关联的buffer</span></span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer)key.attachment();</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="string">"form 客户端 "</span> + <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">//手动从集合中移动当前的selectionKey, 防止重复操作</span></span><br><span class="line">                keyIterator.remove();</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>pos1：</p>
<p>1、对操作系统有一定了解的同学，就会大概知道这里监听的是一个Accept通道。这个通道的<br>作用就是监听，实际建立连接了还会有一个通道。<br>2、简单说一下为什么。因为客户端发请求的时候，服务器这边是肯定要先有一个监听通道，<br>监听某个端口是否有客户端要建立链接，如果有客户端想要建立链接，那么会再创建一个和<br>客户端真正通信的通道。<br>3、如果有其它客户端还想要建立链接，这个Accept监听端口监听到了，就会再创建几个真正<br>的通信通道。<br>4、也就是Server的一个端口可以建立多个TCP连接，因为IP层协议通过<br>目标地址+端口+源地址+源端口四个信息识别一个上下文</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到一个网络通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//提供服务器端的ip 和 端口</span></span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="keyword">if</span> (!socketChannel.connect(inetSocketAddress)) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect()) {</span><br><span class="line">                System.out.println(<span class="string">"因为连接需要时间，客户端不会阻塞，可以做其它工作.."</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...如果连接成功，就发送数据</span></span><br><span class="line">        String str = <span class="string">"hello, 尚硅谷~"</span>;</span><br><span class="line">        <span class="comment">//Wraps a byte array into a buffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(str.getBytes());</span><br><span class="line">        <span class="comment">//发送数据，将 buffer 数据写入 channel</span></span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实际执行效果可以复制代码去试下</p>
<h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><ol>
<li><p>SelectionKey ，表示Selector 和网络通道的注册关系，共四种：</p>
<ul>
<li><code>int OP_ACCEPT</code>：有新的网络连接可以 <code>accept</code>，值为 <code>16</code></li>
<li><code>int OP_CONNECT</code>：代表连接已经建立，值为 <code>8</code></li>
<li><code>int OP_READ</code>：代表读操作，值为 <code>1</code></li>
<li><code>int OP_WRITE</code>：代表写操作，值为 <code>4</code></li>
</ul>
</li>
</ol>
<p>源码中：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><code>SelectionKey</code> 相关方法</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0020.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0020.png" alt="img"></a></p>
<h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><ol>
<li><code>ServerSocketChannel</code> 在服务器端监听新的客户端 <code>Socket</code> 连接，<strong>负责监听，不负责实际的读写操作</strong></li>
<li>相关方法如下</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0021.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0021.png" alt="img"></a></p>
<h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><ol>
<li><code>SocketChannel</code>，网络 <code>IO</code> 通道，<strong>具体负责进行读写操作</strong>。<code>NIO</code> 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</li>
<li>相关方法如下</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0022.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0022.png" alt="img"></a></p>
<h2 id="NIO网络编程应用实例-群聊系统"><a href="#NIO网络编程应用实例-群聊系统" class="headerlink" title="NIO网络编程应用实例 - 群聊系统"></a>NIO网络编程应用实例 - 群聊系统</h2><p>实例要求：</p>
<ol>
<li>编写一个 <code>NIO</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>实现多人群聊</li>
<li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li>
<li>客户端：通过 <code>Channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li>
<li>目的：进一步理解 <code>NIO</code> 非阻塞网络编程机制</li>
<li>示意图分析和代码</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0023.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0023.png" alt="img"></a></p>
<p>代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 服务端：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.nio.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Channel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenChannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//初始化工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//得到选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">//ServerSocketChannel</span></span><br><span class="line">            listenChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            listenChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            <span class="comment">//设置非阻塞模式</span></span><br><span class="line">            listenChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//将该 listenChannel 注册到 selector</span></span><br><span class="line">            listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//循环处理</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                <span class="keyword">int</span> count = selector.select();</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) { <span class="comment">//有事件处理</span></span><br><span class="line">                    <span class="comment">// 遍历得到 selectionKey 集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) {</span><br><span class="line">                        <span class="comment">//取出 selectionkey</span></span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        <span class="comment">//监听到 accept</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) {</span><br><span class="line">                            SocketChannel sc = listenChannel.accept();</span><br><span class="line">                            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="comment">//将该 sc 注册到 seletor</span></span><br><span class="line">                            sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                            <span class="comment">//提示</span></span><br><span class="line">                            System.out.println(sc.getRemoteAddress() + <span class="string">" 上线 "</span>);</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) {<span class="comment">//通道发送read事件，即通道是可读的状态</span></span><br><span class="line">                            <span class="comment">// 处理读(专门写方法..)</span></span><br><span class="line">                            readData(key);</span><br><span class="line">                        }</span><br><span class="line">                        <span class="comment">//当前的 key 删除，防止重复处理</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    System.out.println(<span class="string">"等待...."</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//发生异常处理....</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取客户端消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">(SelectionKey key)</span> </span>{</span><br><span class="line">        SocketChannel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//得到 channel</span></span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//创建 buffer</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">int</span> count = channel.read(buffer);</span><br><span class="line">            <span class="comment">//根据 count 的值做处理</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">//把缓存区的数据转成字符串</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                <span class="comment">//输出该消息</span></span><br><span class="line">                System.out.println(<span class="string">"form客户端:"</span> + msg);</span><br><span class="line">                <span class="comment">//向其它的客户端转发消息(去掉自己),专门写一个方法来处理</span></span><br><span class="line">                sendInfoToOtherClients(msg, channel);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">"离线了.."</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="comment">//关闭通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e2) {</span><br><span class="line">                e2.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转发消息给其它客户(通道)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendInfoToOtherClients</span><span class="params">(String msg, SocketChannel self)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器转发消息中..."</span>);</span><br><span class="line">        <span class="comment">//遍历所有注册到 selector 上的 SocketChannel,并排除 self</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey key : selector.keys()) {</span><br><span class="line">            <span class="comment">//通过 key 取出对应的 SocketChannel</span></span><br><span class="line">            Channel targetChannel = key.channel();</span><br><span class="line">            <span class="comment">//排除自己</span></span><br><span class="line">            <span class="keyword">if</span> (targetChannel <span class="keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel != self) {</span><br><span class="line">                <span class="comment">//转型</span></span><br><span class="line">                SocketChannel dest = (SocketChannel) targetChannel;</span><br><span class="line">                <span class="comment">//将 msg 存储到 buffer</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">//将 buffer 的数据写入通道</span></span><br><span class="line">                dest.write(buffer);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//创建服务器对象</span></span><br><span class="line">        GroupChatServer groupChatServer = <span class="keyword">new</span> GroupChatServer();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.nio.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义相关的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String HOST = <span class="string">"127.0.0.1"</span>;<span class="comment">//服务器的ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>;<span class="comment">//服务器端口</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器,完成初始化工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        </span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(HOST, PORT));</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//将 channel 注册到selector</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">//得到 username</span></span><br><span class="line">        username = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(username + <span class="string">" is ok..."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInfo</span><span class="params">(String info)</span> </span>{</span><br><span class="line">        info = username + <span class="string">" 说："</span> + info;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取从服务器端回复的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readInfo</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">int</span> readChannels = selector.select();</span><br><span class="line">            <span class="keyword">if</span> (readChannels &gt; <span class="number">0</span>) {<span class="comment">//有可以用的通道</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) {</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    <span class="keyword">if</span> (key.isReadable()) {</span><br><span class="line">                        <span class="comment">//得到相关的通道</span></span><br><span class="line">                        SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">//得到一个 Buffer</span></span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//读取</span></span><br><span class="line">                        sc.read(buffer);</span><br><span class="line">                        <span class="comment">//把读到的缓冲区的数据转成字符串</span></span><br><span class="line">                        String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                        System.out.println(msg.trim());</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                iterator.remove(); <span class="comment">//删除当前的 selectionKey,防止重复操作</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">//System.out.println("没有可以用的通道...");</span></span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动我们客户端</span></span><br><span class="line">        GroupChatClient chatClient = <span class="keyword">new</span> GroupChatClient();</span><br><span class="line">        <span class="comment">//启动一个线程,每个 3 秒，读取从服务器发送数据</span></span><br><span class="line">        <span class="keyword">new</span> Thread() {</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                    chatClient.readInfo();</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">3000</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据给服务器端</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) {</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            chatClient.sendInfo(s);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NIO与零拷贝"><a href="#NIO与零拷贝" class="headerlink" title="NIO与零拷贝"></a>NIO与零拷贝</h2><blockquote>
<p>1、尚硅谷这里的零拷贝感觉讲的感觉有点问题，但是为了笔记的完整性，任然保留了这里的笔记。不过笔者考虑再写一篇零拷贝。</p>
<p>2、而且这里课件的图也看不太清</p>
<p>3、读者可以将我写的零拷贝和尚硅谷这里讲的零拷贝对照着看，取长补短</p>
</blockquote>
<h3 id="零拷贝基本介绍"><a href="#零拷贝基本介绍" class="headerlink" title="零拷贝基本介绍"></a>零拷贝基本介绍</h3><ol>
<li>零拷贝是网络编程的关键，很多性能优化都离不开。</li>
<li>在 <code>Java</code> 程序中，常用的零拷贝有 <code>mmap</code>（内存映射）和 <code>sendFile</code>。那么，他们在 <code>OS</code> 里，到底是怎么样的一个的设计？我们分析 <code>mmap</code> 和 <code>sendFile</code> 这两个零拷贝</li>
<li>另外我们看下 <code>NIO</code> 中如何使用零拷贝</li>
</ol>
<h3 id="传统-IO-数据读写"><a href="#传统-IO-数据读写" class="headerlink" title="传统 IO 数据读写"></a>传统 IO 数据读写</h3><p><code>Java</code> 传统 <code>IO</code> 和网络编程的一段代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"test.txt"</span>);</span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) file.length()];</span><br><span class="line">raf.read(arr);</span><br><span class="line"></span><br><span class="line">Socket socket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>).accept();</span><br><span class="line">socket.getOutputStream().write(arr);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="传统-IO-模型"><a href="#传统-IO-模型" class="headerlink" title="传统 IO 模型"></a>传统 IO 模型</h3><p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0024.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0024.png" alt="img"></a></p>
<p><strong>DMA</strong>：<code>direct memory access</code> 直接内存拷贝（不使用 <code>CPU</code>）</p>
<h3 id="mmap-优化"><a href="#mmap-优化" class="headerlink" title="mmap 优化"></a>mmap 优化</h3><ol>
<li><code>mmap</code> 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。如下图</li>
<li><code>mmap</code> 示意图</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0025.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0025.png" alt="img"></a></p>
<h3 id="sendFile-优化"><a href="#sendFile-优化" class="headerlink" title="sendFile 优化"></a>sendFile 优化</h3><ol>
<li><code>Linux2.1</code> 版本提供了 <code>sendFile</code> 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 <code>SocketBuffer</code>，同时，由于和用户态完全无关，就减少了一次上下文切换</li>
<li>示意图和小结</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0026.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0026.png" alt="img"></a></p>
<ol>
<li>提示：零拷贝从操作系统角度，是没有 <code>cpu</code> 拷贝</li>
<li><code>Linux在2.4</code> 版本中，做了一些修改，避免了从内核缓冲区拷贝到 <code>Socketbuffer</code> 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。具体如下图和小结：</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0027.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0027.png" alt="img"></a></p>
<ol>
<li>这里其实有一次 <code>cpu</code> 拷贝 <code>kernel buffer</code> -&gt; <code>socket buffer</code> 但是，拷贝的信息很少，比如 <code>lenght</code>、<code>offset</code> 消耗低，可以忽略</li>
</ol>
<h3 id="零拷贝的再次理解"><a href="#零拷贝的再次理解" class="headerlink" title="零拷贝的再次理解"></a>零拷贝的再次理解</h3><ol>
<li>我们说零拷贝，是从操作系统的角度来说的。因为内核缓冲区之间，没有数据是重复的（只有 <code>kernel buffer</code> 有一份数据）。</li>
<li>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 <code>CPU</code> 缓存伪共享以及无 <code>CPU</code> 校验和计算。</li>
</ol>
<h3 id="mmap-和-sendFile-的区别"><a href="#mmap-和-sendFile-的区别" class="headerlink" title="mmap 和 sendFile 的区别"></a>mmap 和 sendFile 的区别</h3><ol>
<li><code>mmap</code> 适合小数据量读写，<code>sendFile</code> 适合大文件传输。</li>
<li><code>mmap</code> 需要 <code>4</code> 次上下文切换，<code>3</code> 次数据拷贝；<code>sendFile</code> 需要 <code>3</code> 次上下文切换，最少 <code>2</code> 次数据拷贝。</li>
<li><code>sendFile</code> 可以利用 <code>DMA</code> 方式，减少 <code>CPU</code> 拷贝，<code>mmap</code> 则不能（必须从内核拷贝到 <code>Socket</code>缓冲区）。</li>
</ol>
<h3 id="NIO-零拷贝案例"><a href="#NIO-零拷贝案例" class="headerlink" title="NIO 零拷贝案例"></a>NIO 零拷贝案例</h3><p>案例要求：</p>
<ol>
<li>使用传统的 <code>IO</code> 方法传递一个大文件</li>
<li>使用 <code>NIO</code> 零拷贝方式传递（<code>transferTo</code>）一个大文件</li>
<li>看看两种传递方式耗时时间分别是多少</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">NewIOServer.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.nio.zerocopy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewIOServer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="number">7001</span>);</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建buffer</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            <span class="keyword">int</span> readcount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != readcount) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    readcount = socketChannel.read(byteBuffer);</span><br><span class="line">                } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">                    <span class="comment">// ex.printStackTrace();</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                byteBuffer.rewind(); <span class="comment">//倒带 position = 0 mark 作废</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">NewIOClient.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.nio.zerocopy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewIOClient</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">7001</span>));</span><br><span class="line">        String filename = <span class="string">"protoc-3.6.1-win32.zip"</span>;</span><br><span class="line">        <span class="comment">//得到一个文件channel</span></span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> FileInputStream(filename).getChannel();</span><br><span class="line">        <span class="comment">//准备发送</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//在 linux 下一个 transferTo 方法就可以完成传输</span></span><br><span class="line">        <span class="comment">//在 windows 下一次调用 transferTo 只能发送 8m, 就需要分段传输文件,而且要主要</span></span><br><span class="line">        <span class="comment">//传输时的位置=》课后思考...</span></span><br><span class="line">        <span class="comment">//transferTo 底层使用到零拷贝</span></span><br><span class="line">        <span class="keyword">long</span> transferCount = fileChannel.transferTo(<span class="number">0</span>, fileChannel.size(), socketChannel);</span><br><span class="line">        System.out.println(<span class="string">"发送的总的字节数 = "</span> + transferCount + <span class="string">" 耗时: "</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        fileChannel.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Java-AIO-基本介绍"><a href="#Java-AIO-基本介绍" class="headerlink" title="Java AIO 基本介绍"></a>Java AIO 基本介绍</h2><ol>
<li><code>JDK7</code> 引入了 <code>AsynchronousI/O</code>，即 <code>AIO</code>。在进行 <code>I/O</code> 编程中，常用到两种模式：<code>Reactor</code> 和 <code>Proactor</code>。<code>Java</code> 的 <code>NIO</code> 就是 <code>Reactor</code>，当有事件触发时，服务器端得到通知，进行相应的处理</li>
<li><code>AIO</code> 即 <code>NIO2.0</code>，叫做异步不阻塞的 <code>IO</code>。<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li>
<li>目前 <code>AIO</code> 还没有广泛应用，<code>Netty</code> 也是基于 <code>NIO</code>，而不是 <code>AIO</code>，因此我们就不详解 <code>AIO</code> 了，有兴趣的同学可以参考<a href="http://www.52im.net/thread-306-1-1.html">《Java新一代网络编程模型AIO原理及Linux系统AIO介绍》</a></li>
</ol>
<h2 id="BIO、NIO、AIO-对比表"><a href="#BIO、NIO、AIO-对比表" class="headerlink" title="BIO、NIO、AIO 对比表"></a>BIO、NIO、AIO 对比表</h2><table>
<thead>
<tr>
<th></th>
<th>BIO</th>
<th>NIO</th>
<th>AIO</th>
</tr>
</thead>
<tbody><tr>
<td>IO模型</td>
<td>同步阻塞</td>
<td>同步非阻塞（多路复用）</td>
<td>异步非阻塞</td>
</tr>
<tr>
<td>编程难度</td>
<td>简单</td>
<td>复杂</td>
<td>复杂</td>
</tr>
<tr>
<td>可靠性</td>
<td>差</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>吞吐量</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
</tbody></table>
<p><strong>举例说明</strong></p>
<ol>
<li>同步阻塞：到理发店理发，就一直等理发师，直到轮到自己理发。</li>
<li>同步非阻塞：到理发店理发，发现前面有其它人理发，给理发师说下，先干其他事情，一会过来看是否轮到自己.</li>
<li>异步非阻塞：给理发师打电话，让理发师上门服务，自己干其它事情，理发师自己来家给你理发</li>
</ol>
<p>参考：</p>
<p><strong>视频：</strong><a href="https://www.bilibili.com/video/BV1DJ411m7NR?from=search&amp;seid=7455267981675039441">https://www.bilibili.com/video/BV1DJ411m7NR?from=search&amp;seid=7455267981675039441</a></p>
<p><strong>文章链接:</strong> <a href="https://imlql.cn/post/3f9283e7.html">https://imlql.cn/post/3f9283e7.html</a></p>
</body></html>]]></content>
      <categories>
        <category>计算机网络</category>
        <category>netty</category>
      </categories>
  </entry>
  <entry>
    <title>Jmeter基础一</title>
    <url>/60bbc03b.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="Jmeter介绍"><a href="#Jmeter介绍" class="headerlink" title="Jmeter介绍"></a>Jmeter介绍</h1><h1 id="Jmeter入门"><a href="#Jmeter入门" class="headerlink" title="Jmeter入门"></a>Jmeter入门</h1></body></html>]]></content>
      <categories>
        <category>测试</category>
        <category>Jmeter</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>协程</title>
    <url>/bb1e53b0.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="进程和线程的痛点"><a href="#进程和线程的痛点" class="headerlink" title="进程和线程的痛点"></a>进程和线程的痛点</h1><ol>
<li>线程之间的通讯要设计到同步锁</li>
<li>涉及到线程上下文切换</li>
<li>涉及到阻塞状态和运行状态切换</li>
</ol>
<span id="more"></span>

<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p><strong>协程，英文Coroutines，是一种比线程更加轻量级的存在。</strong>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/6765e36cc4604fba897976638af03524.jpeg" alt="img"></p>
<p>最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</p>
<p>这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
<p>由于Java的原生语法中并没有实现协程（某些开源框架实现了协程，但是很少被使用），比较多的是python、lua中使用协程</p>
<p>具体了解推荐：</p>
<p><a href="https://blog.csdn.net/zheng199172/article/details/88800275">https://blog.csdn.net/zheng199172/article/details/88800275</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272">https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272</a></p>
</body></html>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程1</title>
    <url>/cfe2d636.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="线程、进程、协程-纤程"><a href="#线程、进程、协程-纤程" class="headerlink" title="线程、进程、协程/纤程"></a>线程、进程、协程/纤程</h1><p>进程是资源分配的基本单位，一个进程中包括过个线程，各个进程之间互不影响</p>
<p>线程是资源调度的基本单位，线程之间共享进程的部分资源</p>
<p>协程：协程是一种程序组件，一个线程中可以有多个协程，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<span id="more"></span>

<p>协程优势：</p>
<ol>
<li>协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</li>
<li>就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</li>
</ol>
<h1 id="创建或者启动线程的几种方式"><a href="#创建或者启动线程的几种方式" class="headerlink" title="创建或者启动线程的几种方式"></a>创建或者启动线程的几种方式</h1><p>总：</p>
<p>一共有三种方式</p>
<ul>
<li><p>继承Thread类</p>
</li>
<li><p>实现Runnable接口</p>
</li>
<li><p>实现CallAble接口</p>
</li>
</ul>
<p>分：</p>
<ul>
<li><p>继承Thread类</p>
</li>
<li><p>实现Runnable接口</p>
</li>
<li><p>实现CallAble接口</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/25 18:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HowToCreateThread</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyCall())).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"继承Thread线程"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"实现Runnable接口"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCall</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Object</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            System.out.println(<span class="string">"实现Callable接口"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="sleep、wait、yield、join、await、park的作用"><a href="#sleep、wait、yield、join、await、park的作用" class="headerlink" title="sleep、wait、yield、join、await、park的作用"></a>sleep、wait、yield、join、await、park的作用</h1><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>sleep方法是属于Thread类中的方法，sleep过程中线程不会释放锁，只会阻塞线程，让出cpu给其他线程，但是监控状态依然保持着，当指定的时间到了后又会自动进入cpu争夺（如果有锁但是没有释放，则立即恢复运行；如果没有锁，则会进入等待队列，等待cpu的调度），可中断，sleep给其他线程运行机会时不会考虑线程的优先级，因此会给低优先级的线程以运行机会</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/25 20:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleep</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread1()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread2()).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">synchronized</span> (obj){</span><br><span class="line">                System.out.println(<span class="string">"thread1 start"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(<span class="string">"thread1 end"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) {</span><br><span class="line">                System.out.println(<span class="string">"thread2 start"</span>);</span><br><span class="line">                System.out.println(<span class="string">"thread2 end"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 没有加sleep的情况下运行结果</span></span><br><span class="line">thread1 start</span><br><span class="line">thread2 start</span><br><span class="line">thread2 end</span><br><span class="line">thread1 end</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 加sleep的情况下运行结果</span></span><br><span class="line">thread1 start</span><br><span class="line">thread1 end</span><br><span class="line">thread2 start</span><br><span class="line">thread2 end</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>说明在有锁的情况下，调用sleep方法不会释放锁，也就是不会退出cpu资源</p>
<h3 id="说一下sleep-0-有什么用"><a href="#说一下sleep-0-有什么用" class="headerlink" title="说一下sleep(0)有什么用"></a>说一下sleep(0)有什么用</h3><p>sleep通常用在没有加锁的多线程上，Sleep(0)是指CPU交出当前线程的执行权，进入就绪队列，这个时候操作系统重新计算优先级，然后竞争cpu的使用权</p>
<p>应用场景：</p>
<ul>
<li>如果当前线程比较耗时占用cpu资源，可以在结尾处加上sleep(0)，这样可以提高整体的执行效率</li>
<li>保证线程同步，线程池工作的时候，主线程使用sleep(0)来等待线程池中所有线程都完成运行。当在线程池中的线程非常多的时候，使用该方法减少线程上下文的切换，节省cpu的开销</li>
</ul>
<p>推荐文章：<a href="https://blog.csdn.net/qiaoquan3/article/details/56281092/?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.essearch_pc_relevant&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/qiaoquan3/article/details/56281092/?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.essearch_pc_relevant&amp;spm=1001.2101.3001.4242</a></p>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>wait方法是属于object类中，wait过程中线程会释放对象锁，只有当其他线程调用notify才能唤醒次线程。wait使用时必须先获取对象锁，即必须在synchronized修饰的代码块中使用，那么响应的notify方法同样必须在synchronized修饰的代码块中使用，如果没有在synchronized修饰的代码块中使用时3会抛出IllegalMonitorStateException的异常</p>
<p>wait方法用notify唤醒后不一定继续执行后续内容，因为wait会释放锁，然后进入等待池（WaitSet，是一个双向循环链表。在调用wait的时候，会做两件事，想将吱声加入到waitset中，然后释放掉对象锁持有的锁），在被notify唤醒后，进入锁池（EntryList，唤醒后加入到对象的moitor对象的EntryList中），这个时候会尝试获取该对象的锁，如果获取成功后才会接着<strong>按照wait方法之后路径继续执行</strong>，没有拿到锁就进入阻塞状态</p>
<p>虚假唤醒：notify/notifyAll时唤醒的线程并不一定是满足真正可以执行的条件了。比如对象o，不满足A条件时发出o.wait（），然后不满足条件B时也发出o.wait；然后条件B满足了，发出o.notify()，唤醒对象o的等待池里的对象，但是唤醒的线程有可能是因为条件A进入等待的线程，这时把他唤醒条件A还是不满足。这是底层系统决定的一个小遗憾。为了避免这种情况，判断调用o.wait（）的条件时必须使用while，而不是if，这样在虚假唤醒后会继续判断是否满足A条件，不满足说明是虚假唤醒又会调用o.wait()。</p>
<p>moitor：是对象头监听锁的数据结构</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/25 21:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWait</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread1()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread2()).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) {</span><br><span class="line">                System.out.println(<span class="string">"thread1 start"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    obj.wait();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(<span class="string">"thread1 end"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) {</span><br><span class="line">                System.out.println(<span class="string">"thread2 start"</span>);</span><br><span class="line">                obj.notify();</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(<span class="string">"thread2 end"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 没有加wait的情况下运行结果</span></span><br><span class="line">thread1 start</span><br><span class="line">thread2 start</span><br><span class="line">thread2 end</span><br><span class="line">thread1 end</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 加wait的情况下运行结果</span></span><br><span class="line">thread1 start</span><br><span class="line">thread2 start</span><br><span class="line">thread2 end<span class="comment">//因为加有锁的缘故， obj.notify()虽然唤醒了thread1但是不会运行thread1，要等待当前锁释放掉</span></span><br><span class="line">thread1 end</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 注释掉MyThread2的synchronized (obj) 后，并且程序陷入死循环</span></span><br><span class="line">thread1 start</span><br><span class="line">thread2 start</span><br><span class="line">Exception in thread <span class="string">"Thread-1"</span> java.lang.IllegalMonitorStateException</span><br><span class="line">	at java.lang.Object.notify(Native Method)</span><br><span class="line">	at top.thread1.ThreadWait$MyThread2.run(ThreadWait.java:<span class="number">37</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></tbody></table></figure>



<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>和sleep一样都是Thread类的方法，都是暂停当前正在执行的线程对象，不会释放资源锁，和sleep不同的是yield方法不会让线程进入阻塞状态，而是让线程重新进入就绪状态，它只需要等待重新获取cpu执行时间，所以yield（）的线程有可能在进入到可执行状态后马上又被执行。还有一点和sleep不同的是yield方法只能使同优先级或更高优先级的线程有执行的机会，不会发生优先级重排。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/25 21:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadYidle</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread3()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread1()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread2()).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">synchronized</span> (obj){</span><br><span class="line">                System.out.println(<span class="string">"thread1 start"</span>);</span><br><span class="line">                Thread.yield();</span><br><span class="line">                System.out.println(<span class="string">"thread1 end"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) {</span><br><span class="line">                System.out.println(<span class="string">"thread2 start"</span>);</span><br><span class="line">                System.out.println(<span class="string">"thread2 end"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) {</span><br><span class="line">                System.out.println(<span class="string">"thread3 start"</span>);</span><br><span class="line">                Thread.yield();</span><br><span class="line">                System.out.println(<span class="string">"thread3 end"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 没有加yield的情况下运行结果</span></span><br><span class="line">thread3 start</span><br><span class="line">thread3 end</span><br><span class="line">thread1 start</span><br><span class="line">thread1 end</span><br><span class="line">thread2 start</span><br><span class="line">thread2 end</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 有yield的情况下运行结果</span></span><br><span class="line">thread3 start</span><br><span class="line">thread3 end</span><br><span class="line">thread1 start</span><br><span class="line">thread1 end</span><br><span class="line">thread2 start</span><br><span class="line">thread2 end</span><br><span class="line">    </span><br></pre></td></tr></tbody></table></figure>

<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>等待调用join方法的线程结束之后，程序在继续执行，相当于让另一个线程加入当前线程，另一个线程执行完毕，在接着执行这个线程，相当于串行。一般用于等待异步线程执行完结果之后才能继续运行的场景。例如：主线程创建并启动了子线程，如果子线程中药进行大量耗时运算计算某个数据值，而主线程要获取这个数据值才能运行，这时要用到join方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/25 21:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoin</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread1());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread2());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"count:"</span> + count);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) {</span><br><span class="line">                System.out.println(<span class="string">"thread1 start"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                    count++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(<span class="string">"thread1 end"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) {</span><br><span class="line">                System.out.println(<span class="string">"thread2 start"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                    count++;</span><br><span class="line">                }</span><br><span class="line">                System.out.println(<span class="string">"thread2 end"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 没有加入join</span></span><br><span class="line">thread1 start</span><br><span class="line">count:<span class="number">10</span></span><br><span class="line">thread1 end</span><br><span class="line">thread2 start</span><br><span class="line">thread2 end</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入join</span></span><br><span class="line">thread1 start</span><br><span class="line">thread1 end</span><br><span class="line">thread2 start</span><br><span class="line">thread2 end</span><br><span class="line">count:<span class="number">20</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>Condition的方法，用于线程的阻塞，是执行在代码块中，可以通过方法释放锁，在唤醒后就进入就绪状态</p>
<h2 id="park"><a href="#park" class="headerlink" title="park"></a>park</h2><p>是LockSupport.park()调用的，但是真正调用者是Unsafe类的native方法。可以使用LockSupport.unpark()方法唤醒，然后一定会执行后续内容（但是wait方法用notify唤醒后不一定继续执行后续内容）。</p>
<p>park()可以在任意位置运行、不需要抛出异常。park在执行前执行了unpark（）方法，线程不会被阻塞，直接跳过park，继续执行后续内容（而wait之前执行了notify方法，则直接抛出异常）</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTY0ODkzOC8yMDE5MTAvMTY0ODkzOC0yMDE5MTAzMTAwMDM0MDIxOC0xMzI1MDc0OTg3LnBuZw.png" alt="aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTY0ODkzOC8yMDE5MTAvMTY0ODkzOC0yMDE5MTAzMTAwMDM0MDIxOC0xMzI1MDc0OTg3LnBuZw"></p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/ywlmsm1224811/article/details/94022647">https://blog.csdn.net/ywlmsm1224811/article/details/94022647</a></p>
<p><a href="https://blog.csdn.net/asdasdasd123123123/article/details/107814280">https://blog.csdn.net/asdasdasd123123123/article/details/107814280</a></p>
<h1 id="java线程的状态及主要转化方式"><a href="#java线程的状态及主要转化方式" class="headerlink" title="java线程的状态及主要转化方式"></a>java线程的状态及主要转化方式</h1><h2 id="操作系统中的线程状态转换和生命周期"><a href="#操作系统中的线程状态转换和生命周期" class="headerlink" title="操作系统中的线程状态转换和生命周期"></a><strong>操作系统中的线程状态转换和生命周期</strong></h2><p>线程的生命周期和java线程的转态：<a href="https://www.cnblogs.com/duanxz/p/3733179.html">https://www.cnblogs.com/duanxz/p/3733179.html</a></p>
<p>首先我们来看看操作系统中的线程状态转换。</p>
<blockquote>
<p>在现在的操作系统中，线程是被视为轻量级进程的，所以<strong>操作系统线程的状态其实和操作系统进程的状态是一致的</strong>。</p>
</blockquote>
<p><img src="https://gblobscdn.gitbook.com/assets%2F-L_5HvtIhTFW9TQlOF8e%2F-L_5TIKcBFHWPtY3OwUo%2F-L_5TJM1VhwmwbNGzqwJ%2F%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png?alt=media" alt="img"></p>
<h3 id="系统进程-线程转换图"><a href="#系统进程-线程转换图" class="headerlink" title="系统进程/线程转换图"></a>系统进程/线程转换图</h3><p>操作系统线程主要有以下三个状态：</p>
<ul>
<li>就绪状态(ready)：线程正在等待使用CPU，经调度程序调用之后可进入running状态。</li>
<li>执行状态(running)：线程正在使用CPU。</li>
<li>等待状态(waiting): 线程经过等待事件的调用或者正在等待其他资源（如I/O）。  </li>
</ul>
<h3 id="线程的生命周期："><a href="#线程的生命周期：" class="headerlink" title="线程的生命周期："></a>线程的生命周期：</h3><ul>
<li><h3 id="新建（NEW）"><a href="#新建（NEW）" class="headerlink" title="新建（NEW）"></a>新建（NEW）</h3><ul>
<li>new关键字创建了一个线程之后，该线程就处于新建状态</li>
<li>JVM为线程分配内存，初始化成员变量值</li>
</ul>
</li>
<li><h3 id="就绪（RUNNABLE）"><a href="#就绪（RUNNABLE）" class="headerlink" title="就绪（RUNNABLE）"></a>就绪（RUNNABLE）</h3><ul>
<li>当线程对象调用了start()方法之后，该线程处于就绪状态</li>
<li>JVM为线程创建方法栈和程序计数器，等待线程调度器调度</li>
</ul>
</li>
<li><h3 id="运行（RUNNING）"><a href="#运行（RUNNING）" class="headerlink" title="运行（RUNNING）"></a>运行（RUNNING）</h3><ul>
<li>就绪状态的线程获得CPU资源，开始运行run()方法，该线程进入运行状态</li>
</ul>
</li>
<li><h3 id="阻塞（BLOCKED）"><a href="#阻塞（BLOCKED）" class="headerlink" title="阻塞（BLOCKED）"></a>阻塞（BLOCKED）</h3><ul>
<li><p>当发生如下情况时，线程将会进入阻塞状态</p>
<blockquote>
<p>线程调用sleep()方法主动放弃所占用的处理器资源</p>
<p>线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞</p>
<p>线程试图获得一个同步锁（同步监视器），但该同步锁正被其他线程所持有。 </p>
<p>线程在等待某个通知（notify）</p>
<p>程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法</p>
</blockquote>
</li>
</ul>
</li>
<li><h3 id="死亡（TERMINTED）"><a href="#死亡（TERMINTED）" class="headerlink" title="死亡（TERMINTED）"></a>死亡（TERMINTED）</h3><ul>
<li><p>线程会以如下3种方式结束，结束后就处于死亡状态：</p>
<blockquote>
<p>run()或call()方法执行完成，线程正常结束</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>线程抛出一个未捕获的Exception或Error。</p>
<p>调用该线程stop()方法来结束该线程，该方法容易导致死锁，不推荐使用。</p>
</blockquote>
<p>​     </p>
<h2 id="Java线程的6个状态"><a href="#Java线程的6个状态" class="headerlink" title="Java线程的6个状态"></a><strong>Java线程的6个状态</strong></h2><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/thread-2-img/285763-20200617223221933-644434653.png" alt="img"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/thread-2-img/285763-20191022085010399-1732523132.png" alt="img"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Thread.State 源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>{</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="NEW（新建）"><a href="#NEW（新建）" class="headerlink" title="NEW（新建）"></a><strong>NEW</strong>（新建）</h3><p>处于NEW状态的线程此时尚未启动。这里的尚未启动指的是还没调用Thread实例的start()方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testStateNew</span><span class="params">()</span> </span>{</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; {});</span><br><span class="line">    System.out.println(thread.getState()); <span class="comment">// 输出 NEW </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从上面可以看出，只是创建了线程而并没有调用start()方法，此时线程处于NEW状态。</p>
<p><strong>关于start()的两个引申问题</strong></p>
<ol>
<li>反复调用同一个线程的start()方法是否可行？</li>
<li>假如一个线程执行完毕（此时处于TERMINATED状态），再次调用这个线程的start()方法是否可行？</li>
</ol>
<p>要分析这两个问题，我们先来看看start()的源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (!started) {</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable ignore) {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以看到，在start()内部，这里有一个threadStatus的变量。如果它不等于0，调用start()是会直接抛出异常的。</p>
<p>我们接着往下看，有一个native的<code>start0()</code>方法。这个方法里并没有对<strong>threadStatus</strong>的处理。到了这里我们仿佛就拿这个threadStatus没辙了，我们通过debug的方式再看一下:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStartMethod</span><span class="params">()</span> </span>{</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; {});</span><br><span class="line">    thread.start(); <span class="comment">// 第一次调用</span></span><br><span class="line">    thread.start(); <span class="comment">// 第二次调用</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我是在start()方法内部的最开始打的断点，叙述下在我这里打断点看到的结果：</p>
<ul>
<li>第一次调用时threadStatus的值是0。</li>
<li>第二次调用时threadStatus的值不为0。</li>
</ul>
<p>查看当前线程状态的源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Thread.getState方法源码：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// get current thread state</span></span><br><span class="line">    <span class="keyword">return</span> sun.misc.VM.toThreadState(threadStatus);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// sun.misc.VM 源码：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> State <span class="title">toThreadState</span><span class="params">(<span class="keyword">int</span> var0)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> ((var0 &amp; <span class="number">4</span>) != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> State.RUNNABLE;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> ((var0 &amp; <span class="number">1024</span>) != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> State.BLOCKED;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> ((var0 &amp; <span class="number">16</span>) != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> State.WAITING;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> ((var0 &amp; <span class="number">32</span>) != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> State.TIMED_WAITING;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> ((var0 &amp; <span class="number">2</span>) != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> State.TERMINATED;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> (var0 &amp; <span class="number">1</span>) == <span class="number">0</span> ? State.NEW : State.RUNNABLE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>所以，我们结合上面的源码可以得到引申的两个问题的结果：</p>
<blockquote>
<p>两个问题的答案都是不可行，在调用一次start()之后，threadStatus的值会改变（threadStatus !=0），此时再次调用start()方法会抛出IllegalThreadStateException异常。</p>
<p>比如，threadStatus为2代表当前线程状态为TERMINATED。</p>
</blockquote>
<h3 id="RUNNABLE（就绪和运行）"><a href="#RUNNABLE（就绪和运行）" class="headerlink" title="RUNNABLE（就绪和运行）"></a><strong>RUNNABLE（就绪和运行）</strong></h3><p>表示当前线程正在运行中。处于RUNNABLE状态的线程在Java虚拟机中运行，也有可能在等待其他系统资源（比如I/O）。</p>
<p><strong>Java中线程的RUNNABLE状态</strong></p>
<p>看了操作系统线程的几个状态之后我们来看看Thread源码里对RUNNABLE状态的定义：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="line"> * state is executing in the Java virtual machine but it may</span><br><span class="line"> * be waiting for other resources from the operating system</span><br><span class="line"> * such as processor.</span><br><span class="line"> */</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>Java线程的<strong>RUNNABLE</strong>状态其实是包括了传统操作系统线程的<strong>ready</strong>和<strong>running</strong>两个状态的。</p>
<p>当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</p>
<p>因为就绪状态是进入运行状态的唯一入口，也就是说：在线程进入到运行状态执行，首先必须处于就绪状态，所以java把Runnable状态包括了传统的就绪和运行</p>
</blockquote>
<h3 id="BLOCKED（阻塞）"><a href="#BLOCKED（阻塞）" class="headerlink" title="BLOCKED（阻塞）"></a><strong>BLOCKED（阻塞）</strong></h3><p>阻塞状态。处于BLOCKED状态的线程正等待锁的释放以进入同步区。</p>
<blockquote>
<p>处于运行状态中的线程由于某种（当线程处于运行状态时，试图获得某个对象的同步锁时，如果该对象的同步锁已经被其他线程占用，Java虚拟机就会把这个线程放到这个对象的锁池中，这涉及到“线程同步”的内容。【线程在获取synchronized同步锁失败(因为锁被其它线程所占用)】）原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态。 </p>
</blockquote>
<p>我们用BLOCKED状态举个生活中的例子：</p>
<blockquote>
<p>假如今天你下班后准备去食堂吃饭。你来到食堂仅有的一个窗口，发现前面已经有个人在窗口前了，此时你必须得等前面的人从窗口离开才行。 假设你是线程t2，你前面的那个人是线程t1。此时t1占有了锁（食堂唯一的窗口），t2正在等待锁的释放，所以此时t2就处于BLOCKED状态。</p>
</blockquote>
<h3 id="WAITING（无限期等待）"><a href="#WAITING（无限期等待）" class="headerlink" title="WAITING（无限期等待）"></a><strong>WAITING（无限期等待）</strong></h3><p>等待状态。处于等待状态的线程变成RUNNABLE状态需要其他线程唤醒。</p>
<p>调用如下3个方法会使线程进入等待状态：</p>
<ul>
<li>没有设置timeout参数的Object.wait()：使当前线程处于等待状态直到另一个线程唤醒它；</li>
<li>没有设置timeout参数的Thread.join()：等待线程执行完毕，底层调用的是Object实例的wait方法；</li>
<li>LockSupport.park()：除非获得调用许可，否则禁用当前线程进行线程调度。  </li>
</ul>
<p>我们延续上面的例子继续解释一下WAITING状态：</p>
<blockquote>
<p>你等了好几分钟现在终于轮到你了，突然你们有一个“不懂事”的经理突然来了。你看到他你就有一种不祥的预感，果然，他是来找你的。</p>
<p>他把你拉到一旁叫你待会儿再吃饭，说他下午要去作报告，赶紧来找你了解一下项目的情况。你心里虽然有一万个不愿意但是你还是从食堂窗口走开了。</p>
<p>此时，假设你还是线程t2，你的经理是线程t1。虽然你此时都占有锁（窗口）了，“不速之客”来了你还是得释放掉锁。此时你t2的状态就是WAITING。然后经理t1获得锁，进入RUNNABLE状态。</p>
<p>要是经理t1不主动唤醒你t2（notify、notifyAll..），可以说你t2只能一直等待了。</p>
</blockquote>
<h3 id="TIMED-WAITING（限期等待）"><a href="#TIMED-WAITING（限期等待）" class="headerlink" title="TIMED_WAITING（限期等待）"></a><strong>TIMED_WAITING（限期等待）</strong></h3><p>超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。</p>
<p>调用如下方法会使线程进入超时等待状态：</p>
<ul>
<li>Thread.sleep(long millis)：使当前线程睡眠指定时间；</li>
<li>设置了timeout参数的Object.wait(long timeout)：线程休眠指定时间，等待期间可以通过notify()/notifyAll()唤醒；</li>
<li>设置了timeout参数的Thread.join(long millis)：等待当前线程最多执行millis毫秒，如果millis为0，则会一直执行；</li>
<li>LockSupport.parkNanos(long nanos)： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；</li>
<li>LockSupport.parkUntil(long deadline)：同上，也是禁止线程进行调度指定时间；</li>
</ul>
<p>我们继续延续上面的例子来解释一下TIMED_WAITING状态：</p>
<blockquote>
<p>到了第二天中午，又到了饭点，你还是到了窗口前。</p>
<p>突然间想起你的同事叫你等他一起，他说让你等他十分钟他改个bug。</p>
<p>好吧，你说那你就等等吧，你就离开了窗口。很快十分钟过去了，你见他还没来，你想都等了这么久了还不来，那你还是先去吃饭好了。</p>
<p>这时你还是线程t1，你改bug的同事是线程t2。t2让t1等待了指定时间，t1先主动释放了锁。此时t1等待期间就属于TIMED_WATING状态。</p>
<p>t1等待10分钟后，就自动唤醒，拥有了去争夺锁的资格。</p>
</blockquote>
<h3 id="TERMINATED（死亡）"><a href="#TERMINATED（死亡）" class="headerlink" title="TERMINATED（死亡）"></a><strong>TERMINATED</strong>（死亡）</h3><p>终止状态。此时线程已执行完毕。</p>
<blockquote>
<p>线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p>
</blockquote>
<h2 id="线程状态的转换"><a href="#线程状态的转换" class="headerlink" title="线程状态的转换"></a><strong>线程状态的转换</strong></h2><p>根据上面关于线程状态的介绍我们可以得到下面的<strong>线程状态转换图</strong>： <img src="https://firebasestorage.googleapis.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-L_5HvtIhTFW9TQlOF8e%2F-L_5TIKcBFHWPtY3OwUo%2F-L_5TJM7CvFzBq6T_50d%2F%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png?generation=1551665550335701&amp;alt=media" alt="线程状态转换图"></p>
<h3 id="BLOCKED与RUNNABLE状态的转换"><a href="#BLOCKED与RUNNABLE状态的转换" class="headerlink" title="BLOCKED与RUNNABLE状态的转换"></a><strong>BLOCKED与RUNNABLE状态的转换</strong></h3><p>我们在上面说到：处于BLOCKED状态的线程是因为在等待锁的释放。假如这里有两个线程a和b，a线程提前获得了锁并且暂未释放锁，此时b就处于BLOCKED状态。我们先来看一个例子：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockedTest</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    Thread a = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            testMethod();</span><br><span class="line">        }</span><br><span class="line">    }, <span class="string">"a"</span>);</span><br><span class="line">    Thread b = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            testMethod();</span><br><span class="line">        }</span><br><span class="line">    }, <span class="string">"b"</span>);</span><br><span class="line"></span><br><span class="line">    a.start();</span><br><span class="line">    b.start();</span><br><span class="line">    System.out.println(a.getName() + <span class="string">":"</span> + a.getState()); <span class="comment">// 输出？</span></span><br><span class="line">    System.out.println(b.getName() + <span class="string">":"</span> + b.getState()); <span class="comment">// 输出？</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步方法争夺锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>初看之下，大家可能会觉得线程a会先调用同步方法，同步方法内又调用了Thread.sleep()方法，必然会输出TIMED_WAITING，而线程b因为等待线程a释放锁所以必然会输出BLOCKED。</p>
<p>其实不然，有两点需要值得大家注意，一是<strong>在测试方法blockedTest()内还有一个main线程</strong>，二是<strong>启动线程后执行run方法还是需要消耗一定时间的</strong>。不打断点的情况下，上面代码中都应该输出<strong>RUNNABLE</strong>。</p>
<blockquote>
<p>测试方法的main线程只保证了a，b两个线程调用start()方法（转化为RUNNABLE状态），还没等两个线程真正开始争夺锁，就已经打印此时两个线程的状态（RUNNABLE）了。</p>
</blockquote>
<p>这时你可能又会问了，要是我想要打印出BLOCKED状态我该怎么处理呢？其实就处理下测试方法里的main线程就可以了，你让它“休息一会儿”，打断点或者调用Thread.sleep方法就行。</p>
<p>这里需要注意的是main线程休息的时间，要保证在线程争夺锁的时间内，不要等到前一个线程锁都释放了你再去争夺锁，此时还是得不到BLOCKED状态的。</p>
<p>我们把上面的测试方法blockedTest()改动一下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockedTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    ······</span><br><span class="line">    a.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000L</span>); <span class="comment">// 需要注意这里main线程休眠了1000毫秒，而testMethod()里休眠了2000毫秒</span></span><br><span class="line">    b.start();</span><br><span class="line">    System.out.println(a.getName() + <span class="string">":"</span> + a.getState()); <span class="comment">// 输出？</span></span><br><span class="line">    System.out.println(b.getName() + <span class="string">":"</span> + b.getState()); <span class="comment">// 输出？</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这个例子中，由于main线程休眠，所以线程a的run()方法跟着执行，线程b再接着执行。</p>
<p>在线程a执行run()调用testMethod()之后，线程a休眠了2000ms（注意这里是没有释放锁的），main线程休眠完毕，接着b线程执行的时候是争夺不到锁的，所以这里输出：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">a:TIMED_WAITING</span><br><span class="line">b:BLOCKED</span><br></pre></td></tr></tbody></table></figure>

<h3 id="WAITING状态与RUNNABLE状态的转换"><a href="#WAITING状态与RUNNABLE状态的转换" class="headerlink" title="WAITING状态与RUNNABLE状态的转换"></a><strong>WAITING状态与RUNNABLE状态的转换</strong></h3><p>根据转换图我们知道有3个方法可以使线程从RUNNABLE状态转为WAITING状态。我们主要介绍下**Object.wait()<strong>和</strong>Thread.join()**。 <strong>Object.wait()</strong></p>
<blockquote>
<p>调用wait()方法前线程必须持有对象的锁。</p>
<p>线程调用wait()方法时，会释放当前的锁，直到有其他线程调用notify()/notifyAll()方法唤醒等待锁的线程。</p>
<p>需要注意的是，其他线程调用notify()方法只会唤醒单个等待锁的线程，如有有多个线程都在等待这个锁的话不一定会唤醒到之前调用wait()方法的线程。</p>
<p>同样，调用notifyAll()方法唤醒所有等待锁的线程之后，也不一定会马上把时间片分给刚才放弃锁的那个线程，具体要看系统的调度。</p>
</blockquote>
<p><strong>Thread.join()</strong></p>
<blockquote>
<p>调用join()方法不会释放锁，会一直等待当前线程执行完毕（转换为TERMINATED状态）。</p>
</blockquote>
<p>我们再把上面的例子线程启动那里改变一下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockedTest</span><span class="params">()</span> </span>{</span><br><span class="line">    ······</span><br><span class="line">    a.start();</span><br><span class="line">    a.join();</span><br><span class="line">    b.start();</span><br><span class="line">    System.out.println(a.getName() + <span class="string">":"</span> + a.getState()); <span class="comment">// 输出 TERMINATED</span></span><br><span class="line">    System.out.println(b.getName() + <span class="string">":"</span> + b.getState());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>要是没有调用join方法，main线程不管a线程是否执行完毕都会继续往下走。</p>
<p>a线程启动之后马上调用了join方法，这里main线程就会等到a线程执行完毕，所以这里a线程打印的状态固定是<strong>TERMIATED</strong>。</p>
<p>至于b线程的状态，有可能打印RUNNABLE（尚未进入同步方法），也有可能打印TIMED_WAITING（进入了同步方法）。</p>
<h3 id="TIMED-WAITING与RUNNABLE状态转换"><a href="#TIMED-WAITING与RUNNABLE状态转换" class="headerlink" title="TIMED_WAITING与RUNNABLE状态转换"></a><strong>TIMED_WAITING与RUNNABLE状态转换</strong></h3><p>TIMED_WAITING与WAITING状态类似，只是TIMED_WAITING状态等待的时间是指定的。</p>
<p><strong>Thread.sleep(long)</strong></p>
<blockquote>
<p>使当前线程睡眠指定时间。需要注意这里的“睡眠”只是暂时使线程停止执行，并不会释放锁。时间到后，线程会重新进入RUNNABLE状态。</p>
</blockquote>
<p><strong>Object.wait(long)</strong></p>
<blockquote>
<p>wait(long)方法使线程进入TIMED_WAITING状态。这里的wait(long)方法与无参方法wait()相同的地方是，都可以通过其他线程调用notify()或notifyAll()方法来唤醒。</p>
<p>不同的地方是，有参方法wait(long)就算其他线程不来唤醒它，经过指定时间long之后它会自动唤醒，拥有去争夺锁的资格。</p>
</blockquote>
<p><strong>Thread.join(long)</strong></p>
<blockquote>
<p>join(long)使当前线程执行指定时间，并且使线程进入TIMED_WAITING状态。</p>
<p>我们再来改一改刚才的示例:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockedTest</span><span class="params">()</span> </span>{</span><br><span class="line">······</span><br><span class="line">a.start();</span><br><span class="line">a.join(<span class="number">1000L</span>);</span><br><span class="line">b.start();</span><br><span class="line">System.out.println(a.getName() + <span class="string">":"</span> + a.getState()); <span class="comment">// 输出 TIEMD_WAITING</span></span><br><span class="line">System.out.println(b.getName() + <span class="string">":"</span> + b.getState());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里调用a.join(1000L)，因为是指定了具体a线程执行的时间的，并且执行时间是小于a线程sleep的时间，所以a线程状态输出TIMED_WAITING。</p>
</blockquote>
<p>b线程状态仍然不固定（RUNNABLE或BLOCKED）。</p>
<h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a><strong>线程中断</strong></h2><blockquote>
<p>在某些情况下，我们在线程启动后发现并不需要它继续执行下去时，需要中断线程。目前在Java里还没有安全直接的方法来停止线程，但是Java提供了线程中断机制来处理需要中断线程的情况。</p>
<p>线程中断机制是一种协作机制。需要注意，通过中断操作并不能直接终止一个线程，而是通知需要被中断的线程自行处理。</p>
</blockquote>
<p>简单介绍下Thread类里提供的关于线程中断的几个方法：</p>
<ul>
<li>Thread.interrupt()：中断线程。这里的中断线程并不会立即停止线程，而是设置线程的中断状态为true（默认是flase）；</li>
<li>Thread.interrupted()：测试当前线程是否被中断。线程的中断状态受这个方法的影响，意思是调用一次使线程中断状态设置为true，连续调用两次会使得这个线程的中断状态重新转为false；</li>
<li>Thread.isInterrupted()：测试当前线程是否被中断。与上面方法不同的是调用这个方法并不会影响线程的中断状态。</li>
</ul>
<blockquote>
<p>在线程中断机制里，当其他线程通知需要被中断的线程后，线程中断的状态被设置为true，但是具体被要求中断的线程要怎么处理，完全由被中断线程自己而定，可以在合适的实际处理中断请求，也可以完全不处理继续执行下去。</p>
</blockquote>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>一般不推荐直接中断（interrupt）线程，而是让线程正常结束，如果发生了死锁（或者锁的时间特别长，需要打断），则<strong>使用interrupt()后，必须要在catch中处理</strong>，避免线程的数据不一致问题</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="为什么需要加锁"><a href="#为什么需要加锁" class="headerlink" title="为什么需要加锁"></a>为什么需要加锁</h2><p>多个线程对某个数据的操作，在大多数情况下都不是原子性的，例如多个线程同时进行i++；</p>
<p>第一个线程读取当前值为0，然后把0拿到自己的线程栈中进行操作，然后把操作后的数据放回原来的线程共享资源区</p>
<p>第二个线程在在第一个线程对数据++的时候，读取共享资源区的值，发现是0，然后把0拿到自己的线程栈中，进行++操作，然后写入线程共享资源区</p>
<p>这个时候，第一个线程i++后放回去为1，然后第二个线程又放回去也是1，就直接把原来的数据覆盖了，造成了多线程情况下的数据不一致</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>一般用于加类锁、对象锁、方法锁，看上面案例（创建线程的几种方式）</p>
<p>jvm没有规定synchronized具体应该怎么实现，这个说hospot虚拟机中的synchronized底层实现</p>
<ol>
<li>添加对象锁</li>
<li>添加方法锁<ol>
<li>在普通方法上上添加synchronized，相当于在本方法代码块中添加synchronized（this）</li>
</ol>
</li>
<li>添加类锁<ol>
<li>在static方法上添加synchronized，相当于在本方法代码块中添加synchronized（当前类.class）</li>
</ol>
</li>
</ol>
<h3 id="使用主要事项（面试题）"><a href="#使用主要事项（面试题）" class="headerlink" title="使用主要事项（面试题）"></a>使用主要事项（面试题）</h3><ol>
<li><p>synchronized方法能与非synchronized同时运行吗</p>
<p>能，但是会<strong>带来一些问题</strong></p>
<p>如果在synchronized方法中调用非加锁方法，那么非加锁方法是不需要等待的，是一个异步执行，那么在这个方法中有可能会出现脏读，但是如果项目中对这个脏读数据不是特别看重，没有业务影响那么就不用管。如果有影响，那么这个非加锁方法需要加上synchronized，避免脏读，但是会减低效率。</p>
</li>
<li><p>synchronized是可冲入锁</p>
<p>一个synchronized方法可以调用另一个synchronized方法，如果是不可重入的，那么这个就发生死锁了。</p>
<p>一个synchronized方法可以调用另一个synchronized方法，第二个发现这是一个线程调用，那么就可重入，但是每加锁一次就要解锁一次。</p>
</li>
<li><p><strong>程序中如果出现异常，默认锁是会被释放的，会被其他线程运行</strong></p>
</li>
<li><p><strong>synchronized不能锁基本数据类型和String（不推荐）</strong></p>
<p>基本数据类型中的所有字节空间都是用来存放数据的，没有额外的空间存放锁的标志位（只有对象头中有锁的标志位）。</p>
<p>string在拼接或者改变的时候都会新创建一个string对象，而synchronized比较锁是使用的==,比较hashcode。因为每次都会new一个String,所以内存肯定不同.。而且不同程序中使用的同一个string字符串，使用的同一个地址，这样这两个不相干的程序结果锁的是同一个对象，而且极难发现。</p>
<p>看下图，会把对象的init的hashcode存放到对象头（makeword）中，而且只有对象有锁的标志位</p>
</li>
</ol>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20191022154451548.png" alt="在这里插入图片描述"></p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>主要是：</p>
<ol>
<li>保证线程可见性（intel中的mesi，缓存一致性协议）</li>
<li>禁止指令重排（内存屏障）</li>
</ol>
<p>注意：</p>
<p>只能保证线程的可见性（一个线程对共享变量的修改，另一个线程可以感知到），不能保证线程操作中的原子性（<strong>一个或者多个操作在 CPU 执行的过程中不被中断</strong>）</p>
<p>例如用volatile修饰一个变量i，执行i++操作，可见性是保证i被修改后立即通知其他线程，从主存中读取。但是i++的操作是不是原子性的</p>
<p>i++的过程分为三步：</p>
<ol>
<li>从主存中读取i的值</li>
<li>对值进行计算</li>
<li>把最新的值写入内存</li>
</ol>
<p>如果有多个线程同时读取了i的值都是0，这个时候都没有修改，所以都进行计算操作，这个时候就不是一个线程安全的操作，可能这一步后三个线程执行了i++，但是最后的结果都是1；</p>
<p>推荐文章：</p>
<p>可见性、有序性和原子性：<a href="https://zhuanlan.zhihu.com/p/296301631">https://zhuanlan.zhihu.com/p/296301631</a></p>
<p><a href="https://blog.csdn.net/qq_32222165/article/details/106571793">https://blog.csdn.net/qq_32222165/article/details/106571793</a></p>
<h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>synchronized本身就是一个可重入锁</p>
<h1 id="原子性操作"><a href="#原子性操作" class="headerlink" title="原子性操作"></a>原子性操作</h1><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>主要为因为在多线程下，i++不是一个原子性的操作，所以java提供了一个AtomicInteger</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li><p>Compare And Set（比较并交换）</p>
</li>
<li><p>cas（value,expected,newValue）</p>
<ul>
<li>cpu指令级别的执行（原子性）</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">if(value == expected){</span><br><span class="line">	value = newValue</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>ABA问题</p>
<p> 如果知识一个值是没有影响的，但是如果是一个对象，可能会造成影响，这个值（地址）指向的是一个对象，这个对象没有发生改变，但是对象里面的引用发生了改变 ，这个时候如果恰好有对应的逻辑操作，就会出现问题</p>
</li>
</ul>
<h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><p>可以直接操作虚拟机中的内存 ，所有的Atomic的类底层都是通过unsafe来完成的。</p>
<p>但是Unsafe在jdk1.9的时候已经关闭了，不能运行Unsafe</p>
<p><a href="https://blog.csdn.net/zyzzxycj/article/details/89877863">https://blog.csdn.net/zyzzxycj/article/details/89877863</a></p>
<h1 id="LongAdder和Sync和Atomic"><a href="#LongAdder和Sync和Atomic" class="headerlink" title="LongAdder和Sync和Atomic"></a>LongAdder和Sync和Atomic</h1><p>LongAdder内部使用了分段锁，将单一的CAS操作分散为对数组Cells中多个元祖的CAS</p>
<p>在高并发（千、万级并发以上）LongAdder的效率大于Atomi大于Sync</p>
<p><a href="https://www.jianshu.com/p/ec045c38ef0c">https://www.jianshu.com/p/ec045c38ef0c</a></p>
</body></html>]]></content>
      <categories>
        <category>多线程</category>
        <category>多线程理论篇</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>偏向锁四秒延迟探究</title>
    <url>/77ed6e38.html</url>
    <content><![CDATA[<html><head></head><body><p>在项目中发现偏向锁并不是立即生效的，而是有着一个默认延迟，下面深入探究一下，为什么偏向锁有着四秒延迟，以及怎么调优</p>
<span id="more"></span>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/26 17:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JOL</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (o){</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>打印：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           28 f2 5a 03 (00101000 11110010 01011010 00000011) (56291880)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></tbody></table></figure>

<p>然后我们发现，我们明明添加了synchronized，为什么第二次的打印信息为00</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210826172322380.png" alt="image-20210826172322380"></p>
<p>不应该是01吗，开始jvm是使用的偏向锁，偏向锁是101啊</p>
<h1 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h1><p>原因：</p>
<p>创建一个对象后，jvm偏向锁的启动是有4秒延时的（默认），这个时候为匿名偏向，因为在开始创建的过程中肯定有大量的线程参与竞争（内存分配的竞争等等），这个时候如果立即打开偏向锁的话，肯定是有性能浪费的（锁竞争过程、锁撤掉），所以打开偏向锁的效率不是一定会提升效率。</p>
<p>这个时候我们，在代码最前面添加睡眠5秒钟</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/26 17:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JOL</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (o){</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>打印：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210826172904965.png" alt="image-20210826172904965"></p>
<p>这个时候状态为101，才升级为偏向锁</p>
<h2 id="调整默认参数"><a href="#调整默认参数" class="headerlink" title="调整默认参数"></a>调整默认参数</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">jvm中设置立即打开偏向锁</span></span><br><span class="line">-XX:BiasedLockingStartupDelay=0</span><br></pre></td></tr></tbody></table></figure>



<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210826173209886.png" alt="image-20210826173209886" style="zoom:67%;">

<p>然后注释掉睡眠5秒钟</p>
<p>打印：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210826173301227.png" alt="image-20210826173301227"></p>
</body></html>]]></content>
      <categories>
        <category>多线程</category>
        <category>多线程理论篇</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile的底层实现</title>
    <url>/db022879.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h2><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210827154138917.png" alt="image-20210827154138917"><span id="more"></span></p>
<h2 id="cpu读取数据"><a href="#cpu读取数据" class="headerlink" title="cpu读取数据"></a>cpu读取数据</h2><ol>
<li><p>三级缓存</p>
</li>
<li><p>cpu读取数据的时候，先从寄存器中读取数据，如果没有然后从L1（一级缓存）中读取数据，如果没有然后从L2（二级缓存总读取数据），如果没有然后从L3中读取数据，L3中没有，从内存中读取数据，内存中还没有从磁盘中读取数据，拿到数据后在一级一级放回（L3到L2到L1到寄存器）</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210827154320590.png" alt="image-20210827154320590"></p>
</li>
</ol>
<h2 id="cpu线程切换"><a href="#cpu线程切换" class="headerlink" title="cpu线程切换"></a>cpu线程切换</h2><ol>
<li>每个线程独占cpu寄存器中的数据，当第二个线程执行的之后，把寄存器中的数据保存起来，然后读取第二个线程的数据到寄存器，然后执行第二个线程</li>
<li>一核两线程cpu是，一核内有两个寄存器，在两个线程切换的时候，不需要切换寄存器中的数据</li>
</ol>
<img src="C:/Users/Think/AppData/Roaming/Typora/typora-user-images/image-20210826203900185.png" alt="image-20210826203900185" style="zoom:50%;">

<h2 id="cpu缓存意义"><a href="#cpu缓存意义" class="headerlink" title="cpu缓存意义"></a>cpu缓存意义</h2><ul>
<li><p>时间局部性：如果某个数据被访问，那么在不久的将来它很有可能会被再次访问。</p>
</li>
<li><p>空间局部性：如果某个数据被访问，那么与它相邻的数据很快也能被访问。</p>
<h2 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h2></li>
</ul>
<h3 id="按块预读取（也叫缓存行）（cache-line）"><a href="#按块预读取（也叫缓存行）（cache-line）" class="headerlink" title="按块预读取（也叫缓存行）（cache line）"></a>按块预读取（也叫缓存行）（cache line）</h3><p>缓存在读取的数据的时候并不是只拿需要的数据，这样缓存的意义也就没有了，获取一个数据的时候，其周边的数据也会顺便拿过来，这如果当这个数据执行完成后，马上会旁边的数据的情况下，可以立即从最近的缓存中直接拿到，而不用再次逐级读取</p>
<p>缓存行经过实践后一般缓存行大小为<strong>64BIt(字节)</strong></p>
<img src="C:/Users/Think/AppData/Roaming/Typora/typora-user-images/image-20210826204905874.png" alt="image-20210826204905874" style="zoom:50%;">

<h3 id="缓存一致性："><a href="#缓存一致性：" class="headerlink" title="缓存一致性："></a>缓存一致性：</h3><p>两个核一个用到了x，一个用到了y，但是都把周边的数据读取到了缓存中，当核1执行完x的逻辑后，接着执行y的逻辑，这个时候两个核内的数据并没有同步，这个就是</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="intel的cpu"><a href="#intel的cpu" class="headerlink" title="intel的cpu"></a>intel的cpu</h5><p>因特尔通常使用MESI协议保证缓存一致性。也就是一个核对数据更改后，通知另一个cpu把这个数据状态改为<code>Invalid</code>状态，然后该核执行的时候要到缓存中再次读取数据。</p>
<p>推荐文章：<a href="https://www.cnblogs.com/z00377750/p/9180644.html">https://www.cnblogs.com/z00377750/p/9180644.html</a></p>
<p>然后项目在运行过程中，如果有大量的这样的缓存行，高并发情况下<strong>频繁写</strong>会造成效率的降低。</p>
<h5 id="解决方案：缓存行对齐"><a href="#解决方案：缓存行对齐" class="headerlink" title="解决方案：缓存行对齐"></a>解决方案：缓存行对齐</h5><p>让X和Y这个连个数据不在一个缓存行中，及在XY数据中间添加无用的数据，这样反而在高并发情况下<strong>频繁写</strong>会增加运行效率。</p>
<p>例如：</p>
<ul>
<li><p>disruptor（世界上最快的单机MQ）中的RingBuffer；</p>
</li>
<li><p>jdk1.7中的集合</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongWithPadding</span> </span>{</span><br><span class="line">	<span class="keyword">long</span> value;<span class="comment">//8个字节</span></span><br><span class="line">	<span class="keyword">long</span> p0, p1, p2, p3, p4, p5, p6;<span class="comment">//7*8=56个字节，然后下一个value必然独占一个缓存行</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>然后在jdk1.8中添加了一个注解<code>@sun.misc.Contended</code>，对某字段加上该注解则表示该字段会单独占用一个<strong>缓存行</strong>（Cache Line）</p>
<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>主要适用于<strong>频繁写</strong>的<strong>共享数据</strong>上。如果不是频繁写的数据，那么 CPU 缓存行被锁的几率就不多，所以没必要使用了，否则不仅占空间还会浪费 CPU 访问操作数据的时间。</p>
<h2 id="java线程内存模型"><a href="#java线程内存模型" class="headerlink" title="java线程内存模型"></a>java线程内存模型</h2><ul>
<li>java线程内存模型和CPU缓存模型类似，是基于CPU缓存模型来建立的，<br>java线程内存模型是标准化的，屏蔽掉了底层不同计算机的区别。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200615155252495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIyMDc1OTEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>重排序是cpu内部的优化过程。</p>
<p>加入有三条指令，指令1，指令2，指令3；如果顺序执行，我必须等待指令1执行完毕，然后才能执行指令3，这样如果指令1在等待有个状态，就会造成cpu资源利用率下降。所以在执行指令1的通知，也可以执行执行2，指令3，只要保证最后执行的结果是争取的，那么这个就是可以的</p>
<p>在java中这个是非常常见的，例如有一个程序</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(isStart) {</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &gt; <span class="number">100000L</span>; i++){</span><br><span class="line">		i = (i + <span class="number">9</span>) / <span class="number">3</span>; </span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个并不是等待if（isStart）判断为ture后，才开始执行里面的for循环，在指令重排后，有可能是里面的for循环先执行，然后执行到一半后在进行判断，如果这个判断为false，则丢弃这个计算for循环的结果。这个指令重排是cpu内部做的，为的就是提高效率</p>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>一旦内存数据被推送到缓存，就会有消息协议来确保所有的缓存会对所有的共享数据同步并保持一致。这个使内存数据对CPU核可见的技术被称为<strong>内存屏障或内存栅栏</strong>。</p>
<p>大多数的内存屏障都是复杂的话题。在不同的CPU架构上内存屏障的实现非常不一样。</p>
<h1 id="volatile底层实现"><a href="#volatile底层实现" class="headerlink" title="volatile底层实现"></a>volatile底层实现</h1><p>volatile的作用是</p>
<ol>
<li>内存可见性</li>
<li>禁止指令重排序</li>
</ol>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p><strong>volatile 是怎么实现共享变量在多个线程之间工作内存的可见性的呢?</strong></p>
<h3 id="JMM的8种数据原子操作："><a href="#JMM的8种数据原子操作：" class="headerlink" title="JMM的8种数据原子操作："></a>JMM的8种数据原子操作：</h3><p>read 读取，作用于主内存把变量从主内存中读取到本本地内存。<br>load 加载，把从主内存中读取的变量加载到本地内存的变量副本中<br>use 使用，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个<br>需要使用变量的值的字节码指令时将会执行这个操作。、<br>assign 赋值 它把一个从执行引擎接收到的值赋值给工作内存的变量，<br>每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。<br>store 存储 ，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。<br>write 写入 ，它把store操作从工作内存中一个变量的值传送到主内存的变量中。<br>lock 锁定 ：作用于主内存的变量，把一个变量标识为一条线程独占状态。<br>unlock 解锁：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20200615160905272.png" alt="在这里插入图片描述"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20200615142955206.png" alt="在这里插入图片描述"></p>
<p>线程1：先把initFlag变量read读取出来，再load载入工作内存，use使用线程1执行代码!initFlag<br>线程2：先把initFlag变量read读取出来，再load载入工作内存，use使用线程2执行代码initFlag=true，<br>再assign重新赋值，store存储并写入主内存，write写入到主内存中的变量。(线程2对缓存行lock加锁，<br>write写入主内存后会解锁unlock，防止initFlag还未write写入主内存就被线程1读取为false）。<br>线程1：因为initFlag被volatile修饰，使用MESI缓存一致性协议，线程1cpu总线嗅探机制监听到了<br>initFlag值的修改，线程1中initFlag=false失效变为true退出循环继续执行，<br>体现了多线程同步运行共享变量副本的可见性。如果initFlag没有被volatile修饰，<br>线程1将感知不到initFlag的变化，一直循环下去停止不了。</p>
<p><img src="https://img-blog.csdnimg.cn/20200615161340679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIyMDc1OTEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="jmm缓存不一致的问题解决办法"><a href="#jmm缓存不一致的问题解决办法" class="headerlink" title="jmm缓存不一致的问题解决办法"></a>jmm缓存不一致的问题解决办法</h3><h4 id="总线加锁-性能太低-："><a href="#总线加锁-性能太低-：" class="headerlink" title="总线加锁(性能太低)："></a>总线加锁(性能太低)：</h4><p>cpu从主内存读取数据到高速缓存，会在总线对这个数据加锁，这样其它cpu没法去读或写这个数据，直到这个cpu使用完数据释放锁之后其它cpu才能读取该数据，导致结果：改并行为串行。</p>
<h4 id="MESI缓存一致性协议"><a href="#MESI缓存一致性协议" class="headerlink" title="MESI缓存一致性协议"></a>MESI缓存一致性协议</h4><p>多个cpu从主内存读取同一个数据到各自的高速缓存,当其中某个cpu修改了缓存里的数据，该数据会马上同步回主内存,其它cpu通过总线嗅探机制可以感知到数据的变化从而将自己缓存里的数据失效。</p>
<h2 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h2><h3 id="为什么要禁止"><a href="#为什么要禁止" class="headerlink" title="为什么要禁止"></a>为什么要禁止</h3><p>为了提高程序执行的性能，编译器和执行器（处理器）通常会对指令做一些优化（重排序）</p>
<ol>
<li>编译器重排序。编译器在不改变单线程语义的前提下，可以重新安排语句的执行顺序；</li>
<li>处理器重排序。如果不存在数据依赖性，处理器可以改变语句对机器指令的执行顺序</li>
</ol>
<p>现在的操作系统执行命令一般都是流水线式的执行，为了保证cpu的执行效率。</p>
<p>volatile底层是通过lock前缀指令、内存屏障来实现的</p>
<p>参考：</p>
<p>多线程：<a href="https://www.bilibili.com/video/BV1aQ4y1P7Me?p=9&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1aQ4y1P7Me?p=9&amp;spm_id_from=pageDriver</a></p>
<p>可见性：<a href="https://blog.csdn.net/qq_22075913/article/details/106758864">https://blog.csdn.net/qq_22075913/article/details/106758864</a></p>
<p>重排序：<a href="https://blog.csdn.net/ljheee/article/details/82317448">https://blog.csdn.net/ljheee/article/details/82317448</a></p>
<p>内存屏障：<a href="http://ifeve.com/memory-barriers-or-fences/">http://ifeve.com/memory-barriers-or-fences/</a></p>
</body></html>]]></content>
      <categories>
        <category>多线程</category>
        <category>多线程理论篇</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>hospot虚拟机中的synchronized底层实现</title>
    <url>/cbd84e4c.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="synchronized作用"><a href="#synchronized作用" class="headerlink" title="synchronized作用"></a>synchronized作用</h2><ul>
<li>原子性：synchronized保证语句块内操作是原子的</li>
<li>可见性：synchronized保证可见性（通过“在执行unlock之前，必须先把此变量同步回主内存”实现）</li>
<li>有序性：synchronized保证有序性（通过“一个变量在同一时刻只允许一条线程对其进行lock操作”）</li>
</ul>
<h2 id="synchronized的使用"><a href="#synchronized的使用" class="headerlink" title="synchronized的使用"></a>synchronized的使用</h2><ul>
<li>修饰实例方法，对当前实例对象加锁</li>
<li>修饰静态方法，多当前类的Class对象加锁</li>
<li>修饰代码块，对synchronized括号内的对象加锁</li>
</ul>
<span id="more"></span>

<h2 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h2><p>内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。</p>
<p>用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。</p>
<p>为什么要有用户态和内核态？</p>
<p>在最初的时候，没有这样的权限划分，程序可以访问所有的内容，这样很容易就直接把系统卡死，影响其他程序的运行，所以后来添加了访问限制。</p>
<p>由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 – 用户态和内核态。</p>
<p>现在操作系统中一般都是用户态向内核态（操作系统）获取资源，内核态获取cpu等等这个底层资源</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h2 id="理解Java对象头"><a href="#理解Java对象头" class="headerlink" title="理解Java对象头"></a>理解Java对象头</h2><p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20190310224348833.jpg" alt="在这里插入图片描述"></p>
<p>实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</p>
<p>填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</p>
<p>HotSpot虚拟机的对象头分为两部分信息，第一部分用于存储对象自身运行时数据，如哈希码、GC分代年龄等，这部分数据的长度在32位和64位的虚拟机中分别为32位和64位。官方称为Mark Word。另一部分用于存储指向对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分存储数组长度。</p>
<p>虚拟机位数    对象头结构    描述<br>32位/64位    Mark Word    存储对象的哈希码、GC分代年龄、锁信息等<br>32位/64位    Class MetaData Address    指向对象类型数据的指针<br>32位/64位    数组长度    如果是数组对象的话，有这一部分，否则没有<br>由于对象头的信息是与对象自身定义的数据没有关系的额外存储成本，因此考虑到JVM的空间效率，Mark Word 被设计成为一个非固定的数据结构，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间。</p>
<h2 id="锁的状态码"><a href="#锁的状态码" class="headerlink" title="锁的状态码"></a>锁的状态码</h2><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210826152109346.png" alt="image-20210826152109346"></p>
<h3 id="虚拟机中判断锁的状态"><a href="#虚拟机中判断锁的状态" class="headerlink" title="虚拟机中判断锁的状态"></a>虚拟机中判断锁的状态</h3><table>
<thead>
<tr>
<th>锁标志位</th>
<th>锁</th>
<th>偏向锁位</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td><strong>轻量级锁</strong>（自旋锁、无锁）</td>
<td></td>
<td>指向线程栈中lock Record的指针</td>
</tr>
<tr>
<td>10</td>
<td><strong>重量级锁</strong></td>
<td></td>
<td>指向互斥锁（重量级锁）的指针</td>
</tr>
<tr>
<td>11</td>
<td><strong>GC标记信息</strong></td>
<td></td>
<td>CMS过程用到的标记信息</td>
</tr>
<tr>
<td>01</td>
<td>看偏向锁，偏向锁为0，<strong>无锁</strong></td>
<td>0</td>
<td>当前线程指针javaThread</td>
</tr>
<tr>
<td>01</td>
<td>看偏向锁，偏向锁为1，<strong>偏向锁</strong></td>
<td>1</td>
<td>当前线程指针javaThread</td>
</tr>
</tbody></table>
<h3 id="上图内容"><a href="#上图内容" class="headerlink" title="上图内容"></a>上图内容</h3><ol>
<li><p>hashcode，这里面存放的是原始的hashcode，不是重写的hashcode</p>
</li>
<li><p>分代年龄</p>
<ol>
<li>虚拟机中有新生代和老年代，这个就是这个分代年龄<ol>
<li>在PS、PO、G1默认15次（这里的分代年龄为4bit，最大为16，所以15次就是最大值）还没有回收，从新生代转移到老年代</li>
<li>CMS默认是6次</li>
</ol>
</li>
</ol>
</li>
<li><p>Epoch，偏向锁撤销，调优内容</p>
</li>
<li><p>在锁转化的过程中，记录信息越来越少，那原来的信息呢（hashcode、分代年龄）</p>
<ol>
<li>这个信息都记录到当前线程的线程栈（在加锁情况下，只有这一个线程在使用）中，也就是Lock Record，所以轻量级锁和重量级锁会有指针</li>
</ol>
</li>
</ol>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="JVM对synchronized的锁优化"><a href="#JVM对synchronized的锁优化" class="headerlink" title="JVM对synchronized的锁优化"></a>JVM对synchronized的锁优化</h2><p>Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的。而操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。</p>
<p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”：锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁可以升级但不能降级。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210826151316460.png" alt="image-20210826151316460"></p>
<h3 id="1、偏向锁"><a href="#1、偏向锁" class="headerlink" title="1、偏向锁"></a>1、偏向锁</h3><p>偏向锁是JDK1.6中引用的优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的性能。</p>
<h4 id="偏向锁的获取："><a href="#偏向锁的获取：" class="headerlink" title="偏向锁的获取："></a>偏向锁的获取：</h4><p>判断是否为可偏向状态<br>如果为可偏向状态，则判断线程ID是否是当前线程，如果是进入同步块；<br>如果线程ID并未指向当前线程，利用CAS操作竞争锁，如果竞争成功，<strong>将Mark Word中线程ID更新为当前线程ID</strong>，进入同步块<br>如果竞争失败，等待全局安全点，准备撤销偏向锁，根据线程是否处于活动状态，决定是转换为无锁状态还是升级为轻量级锁。<br>当锁对象第一次被线程获取的时候，虚拟机会把对象头中的锁标志位设置为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word中，如果CAS操作成功。持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。</p>
<h4 id="偏向锁的释放："><a href="#偏向锁的释放：" class="headerlink" title="偏向锁的释放："></a>偏向锁的释放：</h4><p>偏向锁使用了遇到竞争才释放锁的机制。<strong>偏向锁的撤销需要等待全局安全点</strong>，然后它会首先暂停拥有偏向锁的线程，然后判断线程是否还活着，如果线程还活着，则升级为轻量级锁，否则，将锁设置为无锁状态。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20190311190530462.png" alt="在这里插入图片描述"></p>
<p>注意：</p>
<p>创建一个对象后，jvm偏向锁的启动是有4秒延时的（默认），这个时候为匿名偏向，因为在开始创建的过程中肯定有大量的线程参与竞争（内存分配的竞争等等），这个时候如果立即打开偏向锁的话，肯定是有性能浪费的（锁竞争过程、锁撤掉），所以打开偏向锁的效率不是一定会提升效率。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">jvm中设置立即打开偏向锁</span></span><br><span class="line">-xx:BiasedLockingstartupDelay=0</span><br></pre></td></tr></tbody></table></figure>





<h3 id="2、轻量级锁"><a href="#2、轻量级锁" class="headerlink" title="2、轻量级锁"></a>2、轻量级锁</h3><p>轻量级锁也是在JDK1.6中引入的新型锁机制。它不是用来替换重量级锁的，它的本意是在没有多线程竞争的情况下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
<h4 id="加锁过程："><a href="#加锁过程：" class="headerlink" title="加锁过程："></a>加锁过程：</h4><p>在代码进入同步块的时候，如果此对象没有被锁定（锁标志位为“01”状态），虚拟机首先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储对象目前Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）。然后虚拟机使用CAS操作尝试将对象的Mark Word更新为指向锁记录（Lock Record）的指针。如果更新成功，那么这个线程就拥有了该对象的锁，并且对象的Mark Word标志位转变为“00”，即表示此对象处于轻量级锁定状态；如果更新失败，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块中执行，否则说明这个锁对象已经被其他线程占有了。<strong>如果有两条以上的线程竞争同一个锁，那轻量级锁不再有效，要膨胀为重量级锁，锁标志变为“10”</strong>，Mark Word中存储的就是指向重量级锁的指针，而后面等待的线程也要进入阻塞状态。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20190311190732602.jpg" alt="在这里插入图片描述"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20190311190736763.jpg" alt="在这里插入图片描述"></p>
<h4 id="锁升级过程："><a href="#锁升级过程：" class="headerlink" title="锁升级过程："></a>锁升级过程：</h4><p>jdk1.6之前：</p>
<p>CAS某线程自旋次数大于10次（默认）<strong>或者</strong>竞争的线程数超过cpu总核数的一半（例如：8核cpu超过了4个线程），升级为重量级锁。</p>
<p>可以进行jvm调优</p>
<p>jdk1.6后：</p>
<p>自适应升级</p>
<h4 id="解锁过程："><a href="#解锁过程：" class="headerlink" title="解锁过程："></a>解锁过程：</h4><p>如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作将对象当前的Mark Word与线程栈帧中的Displaced Mark Word交换回来，如果替换成功，整个同步过程就完成了。如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。</p>
<p>如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁比传统重量级锁开销更大。</p>
<h3 id="3、重量级锁"><a href="#3、重量级锁" class="headerlink" title="3、重量级锁"></a>3、重量级锁</h3><p>Synchronized的重量级锁是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的。而操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。</p>
<p>但是如果是多线程高兵发的情况下，需要加锁，这个时候无意使用Synchronized是最好的的。</p>
<p>如果是单纯的cas在多线程情况下，大量的线程在自旋，这个自旋操作是需要占据cpu资源的。但是如果用的重量级锁，这个时候是放在一个wait队列中，轮到那个线程，cpu调度哪个线程，后续的那个线程是不占局cpu资源的，这个时候无疑重量级锁的效率更高。</p>
<p>总结：</p>
<p>线程少或者线程运行时间少，适用于自旋锁</p>
<p>线程多或者线程运行时间长，应用与重量级锁</p>
<h3 id="4、自旋锁"><a href="#4、自旋锁" class="headerlink" title="4、自旋锁"></a>4、自旋锁</h3><p>互斥同步对性能影响最大的是阻塞的实现，挂起线程和恢复线程的操作都需要转入到内核态中完成，这些操作给系统的并发性能带来很大的压力。<br>于是在阻塞之前，我们让线程执行一个忙循环（自旋），看看持有锁的线程是否释放锁，如果很快释放锁，则没有必要进行阻塞。</p>
<h3 id="5、锁消除"><a href="#5、锁消除" class="headerlink" title="5、锁消除"></a>5、锁消除</h3><p>锁消除是指虚拟机即时编译器（JIT）在运行时，对一些代码上要求同步，但是检测到不可能发生数据竞争的锁进行消除。</p>
<h3 id="6、锁粗化"><a href="#6、锁粗化" class="headerlink" title="6、锁粗化"></a>6、锁粗化</h3><p>如果虚拟机检测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p>
<h2 id="jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。"><a href="#jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。" class="headerlink" title="jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。"></a>jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。</h2><p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。</p>
<p>代码块的同步是利用monitorenter和monitorexit这两个字节码指令。它们分别位于同步代码块的开始和结束位置。当jvm执行到monitorenter指令时，当前线程试图获取monitor对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取monitor对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。</p>
<p>这里要注意：</p>
<p>synchronized是可重入的，所以不会自己把自己锁死<br>synchronized锁一旦被一个线程持有，其他试图获取该锁的线程将被阻塞。<br>关于ACC_SYNCHRONIZED 、monitorenter、monitorexit指令，可以看一下下面的反编译代码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>{    <span class="comment">//这个是同步方法</span></span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>){		<span class="comment">//这个是同步代码块</span></span><br><span class="line">            System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>使用javap -verbose SynchronizedDemo反编译后得到</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20190310221443337.jpg"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20190311182248435.jpg" alt="在这里插入图片描述"></p>
<p>我们看到对于同步方法，反编译后得到ACC_SYNCHRONIZED 标志，对于同步代码块反编译后得到monitorenter和monitorexit指令。</p>
<h1 id="synchronized是否支持锁重入"><a href="#synchronized是否支持锁重入" class="headerlink" title="synchronized是否支持锁重入"></a>synchronized是否支持锁重入</h1><p>支持</p>
<p>最简单的理解：在继承中，父类的A方法是synchronized方法，子类重写了A方法，调用父类方法super.A()，这个时候要是不支持可重入是不是立即发生了死锁。</p>
<p>每次上锁都要进行一次解锁，所以在每次执行synchronized方法后，在本地方法栈中都要生成一个Lock Record，在锁释放后弹出一个LR</p>
<p>————————————————<br>参考：</p>
<p><a href="https://www.bilibili.com/video/BV1aQ4y1P7Me?from=search&amp;seid=16212058743276143027">https://www.bilibili.com/video/BV1aQ4y1P7Me?from=search&amp;seid=16212058743276143027</a></p>
<p><a href="https://blog.csdn.net/weixin_38481963/article/details/88384493">https://blog.csdn.net/weixin_38481963/article/details/88384493</a></p>
<p><a href="https://www.cnblogs.com/maxigang/p/9041080.html">https://www.cnblogs.com/maxigang/p/9041080.html</a></p>
</body></html>]]></content>
      <categories>
        <category>多线程</category>
        <category>多线程理论篇</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>ReentrantLock底层实现原理</title>
    <url>/9682c195.html</url>
    <content><![CDATA[<html><head></head><body></body></html>]]></content>
      <categories>
        <category>多线程</category>
        <category>多线程理论篇</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JOL使用</title>
    <url>/9fbd3b67.html</url>
    <content><![CDATA[<html><head></head><body><p>查看普通java对象的内部布局工具JOL(JAVA OBJECT LAYOUT)</p>
<p>使用此工具可以查看new出来的一个java对象的内部布局,以及一个普通的java对象占用多少字节。</p>
<span id="more"></span>

<h1 id="导入依赖或者jar包"><a href="#导入依赖或者jar包" class="headerlink" title="导入依赖或者jar包"></a>导入依赖或者jar包</h1><ul>
<li>可以选择导入pom依赖</li>
</ul>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jol/jol-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>可以使用jar包</p>
<p>地址：<a href="https://mvnrepository.com/artifact/org.openjdk.jol/jol-core/0.9">https://mvnrepository.com/artifact/org.openjdk.jol/jol-core/0.9</a></p>
</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/26 17:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JOL</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (o){</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>打印：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           28 f2 5a 03 (00101000 11110010 01011010 00000011) (56291880)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></tbody></table></figure>

<p>前面两行是java对象头的Mark Word共占8个字节,第三行是java对象头的Klass Pointer类指针,本来也是占8个字节,因JDK默认开启类指针压缩所以占4个字节,总共12个字节,又因12不能被8整除,所有最后又加了四个空字节.所以java中new一个空对象总共占16个字节.</p>
<p>涉及内容：jVM对象的内存布局，请看博客：</p>
</body></html>]]></content>
      <categories>
        <category>多线程</category>
        <category>多线程理论篇</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>CAS</title>
    <url>/969d9481.html</url>
    <content><![CDATA[<html><head></head><body><p>CAS：compar and swap，是一种自旋锁</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210826103838080.png" alt="image-20210826103838080" style="zoom:33%;">

<p>属于乐观锁，是解决多线程并行情况下使用锁造成性能损耗的一种机制，CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值。CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。</p>
<span id="more"></span>

<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>加入有三个线程，线程A读取内存中数据为0，然后i++，线程B读取内存中数据位0，然后i++，线程A运行比较慢，线程B把1写入内存，然后有一个线程C，读取内存中数据位1，进行i–操作，然后把0写入内存，这个时候线程A才运行完毕，然后读取内存中数据位0，认为没有发生修改，则把1写入数据。</p>
<p>这个时候线程A认为内存中0的数据没有修改，写入内存了，但是这个数据确实发生了修改。这就是ABA问题</p>
<p>解决方案：</p>
<ol>
<li>不管<ul>
<li>这个一个值，我不在在乎，你想改就改，我要的是最终的值</li>
</ul>
</li>
<li>添加版本<ul>
<li>这是一个引用，应用的地址没有发生改变，但是这个地址指向的对象内容可能已经改变了，这个时候添加版本号解决</li>
<li>在值上添加一个版本号，（可以是线程id）在比较的时候会比较值和版本号，如果这两个都一样，则会赋值</li>
</ul>
</li>
</ol>
<p>CAS在java中的底层实现是native，是用的C++实现的（下面为linuxX86操作系统的实现）</p>
<ol>
<li><p>Unsafe_CompareAnSwapINT</p>
</li>
<li><p>调用Atomic的cmpxchg</p>
</li>
<li><p>调用汇编码<code>__asm__</code></p>
</li>
<li><p>调用cmpxchg1，（如果是多核cpu执行这个方法会添加lock）</p>
</li>
<li><p>最终实现： <code>lock cmpxchg 指令</code></p>
<p>在多核cpu情况下，如果没有加锁，执行还不是原子性的，有可能被其他核干扰，所以添加了lock解决，总线嗅探（Bus Snooping）技术。这个策略总线嗅探，本质上就是把所有的读写请求都通过总线（Bus）广播给所有的CPU核心，然后让各个核心去“嗅探”这些请求，再根据本地的情况进行响应。</p>
</li>
</ol>
<p> synchronized和violate的底层实现都是<code>lock cmpxchg 指令</code></p>
<p>硬件：lock指定在执行后面指令的时候锁定一个北桥信号（不采用锁总线的方式）</p>
<p>推荐文章：</p>
<p>cpu底层cas原理：<a href="https://blog.csdn.net/weixin_30691871/article/details/100004896">https://blog.csdn.net/weixin_30691871/article/details/100004896</a></p>
</body></html>]]></content>
      <categories>
        <category>多线程</category>
        <category>多线程理论篇</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>百万数据快速插入数据库</title>
    <url>/859f2ea9.html</url>
    <content><![CDATA[<html><head></head><body><p><a href="https://blog.csdn.net/zl1zl2zl3/article/details/105007492?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control">https://blog.csdn.net/zl1zl2zl3/article/details/105007492?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control</a></p>
</body></html>]]></content>
      <categories>
        <category>多线程</category>
        <category>多线程实战篇</category>
      </categories>
      <tags>
        <tag>多线程实战</tag>
      </tags>
  </entry>
  <entry>
    <title>lua基础教程2-基础语法</title>
    <url>/ef2fc5a3.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h1><figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"hello world!"</span>)</span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>

<p>推荐菜鸟教程或者W3Cschool</p>
<p><a href="https://www.w3cschool.cn/lua/lua-basic-syntax.html">https://www.w3cschool.cn/lua/lua-basic-syntax.html</a></p>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="交互式编程"><a href="#交互式编程" class="headerlink" title="交互式编程"></a>交互式编程</h2><figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(<span class="string">"Hello World！"</span>)</span><br><span class="line">Hello World！</span><br><span class="line">&gt; </span><br></pre></td></tr></tbody></table></figure>

<h2 id="脚本式编程"><a href="#脚本式编程" class="headerlink" title="脚本式编程"></a>脚本式编程</h2><figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line">#!/usr/<span class="keyword">local</span>/bin/lua</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Hello World！"</span>)</span><br></pre></td></tr></tbody></table></figure>



<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>两个减号是单行注释:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">--</span><br></pre></td></tr></tbody></table></figure>

<h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">--[[</span><br><span class="line"> 多行注释</span><br><span class="line"> 多行注释</span><br><span class="line"> --]]</span><br></pre></td></tr></tbody></table></figure>

<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>Lua 标示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上0个或多个字母，下划线，数字（0到9）。</p>
<p>最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的。</p>
<p>Lua 不允许使用特殊字符如 @, $, 和 % 来定义标示符。 Lua 是一个区分大小写的编程语言。因此在 Lua 中 W3c 与 w3c 是两个不同的标示符。以下列出了一些正确的标示符：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mohd         zara      abc     move_name    a_123</span><br><span class="line">myname50     _temp     j       a23b9        retVal</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><p>以下列出了 Lua 的保留关键字。保留关键字不能作为常量或变量或其他用户自定义标示符：</p>
<table>
<thead>
<tr>
<th>and</th>
<th>break</th>
<th>do</th>
<th>else</th>
</tr>
</thead>
<tbody><tr>
<td>elseif</td>
<td>end</td>
<td>false</td>
<td>for</td>
</tr>
<tr>
<td>function</td>
<td>if</td>
<td>in</td>
<td>local</td>
</tr>
<tr>
<td>nil</td>
<td>not</td>
<td>or</td>
<td>repeat</td>
</tr>
<tr>
<td>return</td>
<td>then</td>
<td>true</td>
<td>until</td>
</tr>
<tr>
<td>while</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。</p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>在默认情况下，变量总是认为是全局的。</p>
<p>全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：nil。</p>
<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(b)</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">&gt; b=<span class="number">10</span></span><br><span class="line">&gt; <span class="built_in">print</span>(b)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果你想删除一个全局变量，只需要将变量赋值为nil。</p>
<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line">b = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(b)      <span class="comment">--&gt; nil</span></span><br></pre></td></tr></tbody></table></figure>

<p>这样变量b就好像从没被使用过一样。换句话说, 当且仅当一个变量不等于nil时，这个变量即存在。</p>
<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- #!/usr/local/bin/lua开头，指定lua的解释器</span></span><br><span class="line"><span class="comment">-- 加上 # 号标记解释器会忽略它</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 两个中线时单行注释</span></span><br><span class="line"><span class="comment">-- 分号，加不加都可以。类似js</span></span><br><span class="line"><span class="comment">--  print控制天输出</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- lua hello.lua 控制台运行lua文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 错误命名标识符</span></span><br><span class="line"><span class="comment">-- local a@ = 1</span></span><br><span class="line"><span class="comment">-- local then = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正确命名标识符</span></span><br><span class="line"><span class="keyword">local</span> a_123 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment">-- 输出为nil</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Lua是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。</p>
<p>Lua中有8个基本类型分别为：nil、boolean、number、string、userdata、function、thread和table。</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">nil</td>
<td align="left">这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">包含两个值：false和true。</td>
</tr>
<tr>
<td align="left">number</td>
<td align="left">表示双精度类型的实浮点数</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">字符串由一对双引号或单引号来表示</td>
</tr>
<tr>
<td align="left">function</td>
<td align="left">由 C 或 Lua 编写的函数</td>
</tr>
<tr>
<td align="left">userdata</td>
<td align="left">表示任意存储在变量中的C数据结构</td>
</tr>
<tr>
<td align="left">thread</td>
<td align="left">表示执行的独立线路，用于执行协同程序</td>
</tr>
<tr>
<td align="left">table</td>
<td align="left">Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。</td>
</tr>
</tbody></table>
<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">---</span></span><br><span class="line"><span class="comment">--- Generated by EmmyLua(https://github.com/EmmyLua)</span></span><br><span class="line"><span class="comment">--- Created by Think.</span></span><br><span class="line"><span class="comment">--- DateTime: 2021/9/2 10:21</span></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">"Hello world"</span>))      <span class="comment">--&gt; string</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">10.4</span>*<span class="number">3</span>))             <span class="comment">--&gt; number</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">print</span>))              <span class="comment">--&gt; function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>))               <span class="comment">--&gt; function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">true</span>))               <span class="comment">--&gt; boolean</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">nil</span>))                <span class="comment">--&gt; nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(X))                      <span class="comment">--&gt; nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(X)))            <span class="comment">--&gt; string</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">控制台打印：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">lua.exe 数据类型.lua</span></span><br><span class="line"><span class="comment">string</span></span><br><span class="line"><span class="comment">number</span></span><br><span class="line"><span class="comment">function</span></span><br><span class="line"><span class="comment">function</span></span><br><span class="line"><span class="comment">boolean</span></span><br><span class="line"><span class="comment">nil</span></span><br><span class="line"><span class="comment">nil</span></span><br><span class="line"><span class="comment">string</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h2><p>nil 类型表示一种没有任何有效值，它只有一个值 – nil，例如打印一个没有赋值的变量，便会输出一个 nil 值：</p>
<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>对于全局变量和 table，nil 还有一个”删除”作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉</p>
<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line">tab1 = { key1 = <span class="string">"val1"</span>, key2 = <span class="string">"val2"</span>, <span class="string">"val3"</span> }</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(tab1) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k .. <span class="string">" - "</span> .. v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">tab1.key1 = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(tab1) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k .. <span class="string">" - "</span> .. v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">控制台打印：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 - val3</span></span><br><span class="line"><span class="comment">key1 - val1 第一次有这个值，置空后没有这个值了</span></span><br><span class="line"><span class="comment">key2 - val2</span></span><br><span class="line"><span class="comment">1 - val3</span></span><br><span class="line"><span class="comment">key2 - val2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>使用 nil 作比较时应该加上双引号：</strong></p>
<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">type</span>(X)</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">&gt; <span class="built_in">type</span>(X)==<span class="literal">nil</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; <span class="built_in">type</span>(X)==<span class="string">"nil"</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h2><p>boolean 类型只有两个可选值：true（真） 和 false（假），<strong>Lua 把 false 和 nil 看作是”假”，其他的都为”真”（0也是真）:</strong></p>
<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">true</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">false</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">nil</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">if</span> <span class="literal">false</span> <span class="keyword">or</span> <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"至少有一个是 true"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"false 和 nil 都为 false"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"数字 0 是 true"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"数字 0 为 false"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">控制台打印：</span></span><br><span class="line"><span class="comment">lua.exe 数据类型.lua</span></span><br><span class="line"><span class="comment">boolean</span></span><br><span class="line"><span class="comment">boolean</span></span><br><span class="line"><span class="comment">nil</span></span><br><span class="line"><span class="comment">number</span></span><br><span class="line"><span class="comment">false 和 nil 都为 false</span></span><br><span class="line"><span class="comment">数字 0 是 true</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h2 id="number"><a href="#number" class="headerlink" title="number"></a>number</h2><p>Lua 默认只有一种 number 类型 – double（双精度）类型（默认类型可以修改 luaconf.h 里的定义），以下几种写法都被看作是 number 类型：</p>
<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">2.2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">0.2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">2e+1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">0.2e-1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">7.8263692594256e-06</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">number</span></span><br><span class="line"><span class="comment">number</span></span><br><span class="line"><span class="comment">number</span></span><br><span class="line"><span class="comment">number</span></span><br><span class="line"><span class="comment">number</span></span><br><span class="line"><span class="comment">number</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li><p>字符串由一对双引号或单引号来表示。</p>
</li>
<li><p>也可以用 2 个方括号 “[[]]” 来表示”一块”字符串。</p>
</li>
</ul>
<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line">string1 = <span class="string">"this is string1"</span></span><br><span class="line">string2 = <span class="string">'this is string2'</span></span><br><span class="line">html = <span class="string">[[</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;a href="//www.lvxiaoyi.top/"&gt;吕小医&amp;博客&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(string1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(string2))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(html))</span><br><span class="line"><span class="built_in">print</span>(html)</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">string</span></span><br><span class="line"><span class="comment">string</span></span><br><span class="line"><span class="comment">string</span></span><br><span class="line"><span class="comment">&lt;html&gt;</span></span><br><span class="line"><span class="comment">&lt;head&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="comment">&lt;body&gt;</span></span><br><span class="line"><span class="comment">    &lt;a href="//www.lvxiaoyi.top/"&gt;吕小医&amp;博客&lt;/a&gt;</span></span><br><span class="line"><span class="comment">&lt;/body&gt;</span></span><br><span class="line"><span class="comment">&lt;/html&gt;</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字:</p>
<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"2"</span> + <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"2"</span> + <span class="string">"6"</span>).</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>字符串连接使用的是 .. ,而不是用的+</p>
</li>
</ul>
<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"lvxiaoyi"</span> + <span class="string">".top"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">lua.exe: ��������.lua:1: attempt to perform arithmetic on a string value</span></span><br><span class="line"><span class="comment">stack traceback:</span></span><br><span class="line"><span class="comment">	��������.lua:1: in main chunk</span></span><br><span class="line"><span class="comment">	[C]: ?</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"lvxiaoyi"</span> .. <span class="string">".top"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">lvxiaoyi.top</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="table-表"><a href="#table-表" class="headerlink" title="table(表)"></a>table(表)</h2><p>在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。也可以在表里添加一些数据，直接初始化表:</p>
<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建一个空的 table</span></span><br><span class="line"><span class="keyword">local</span> tbl1 = {}</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 直接初始表</span></span><br><span class="line"><span class="keyword">local</span> tbl2 = {<span class="string">"lvxiaoyi.top"</span>, <span class="string">"pear"</span>, <span class="string">"orange"</span>, <span class="string">"grape"</span>}</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(tbl1))</span><br><span class="line"><span class="built_in">print</span>(tbl1)</span><br><span class="line"><span class="built_in">print</span>(tbl2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, val <span class="keyword">in</span> <span class="built_in">pairs</span>(tbl2) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>( key,val)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">table</span></span><br><span class="line"><span class="comment">table: 00CC99A0</span></span><br><span class="line"><span class="comment">table: 00CC99C8</span></span><br><span class="line"><span class="comment">1	lvxiaoyi.top</span></span><br><span class="line"><span class="comment">2	pear</span></span><br><span class="line"><span class="comment">3	orange</span></span><br><span class="line"><span class="comment">4	grape</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></tbody></table></figure>

<p>Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字或者是字符串。</p>
<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line">a = {}</span><br><span class="line">a[<span class="string">"key"</span>] = <span class="number">22</span></span><br><span class="line">key = <span class="string">"blog"</span></span><br><span class="line">a[key] = <span class="string">"lvxioayi"</span></span><br><span class="line">a[key] = a[key] .. <span class="string">".top"</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k .. <span class="string">" : "</span> .. v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">key : 22</span></span><br><span class="line"><span class="comment">blog : lvxioayi.top</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></tbody></table></figure>

<p>不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始。</p>
<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> tbl2 = {<span class="string">"lvxiaoyi.top"</span>, <span class="string">"blog"</span>, <span class="string">"study"</span>, <span class="string">"lvxiaoyi"</span>}</span><br><span class="line"><span class="keyword">for</span> key, val <span class="keyword">in</span> <span class="built_in">pairs</span>(tbl2) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Key"</span>, key)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">Key	1</span></span><br><span class="line"><span class="comment">Key	2</span></span><br><span class="line"><span class="comment">Key	3</span></span><br><span class="line"><span class="comment">Key	4</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></tbody></table></figure>

<p>table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。</p>
</body></html>]]></content>
      <categories>
        <category>lua</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>lua基础教程1-环境安装</title>
    <url>/b35e3780.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="什么是lua"><a href="#什么是lua" class="headerlink" title="什么是lua"></a>什么是lua</h1><p>Lua 是由巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组于1993年开发的一种轻量、小巧的脚本语言，用标准 C 语言编写，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p>
<p>官网：<a href="http://www.lua.org/">http://www.lua.org/</a></p>
<p>Redis 在 2.6 版本中推出了脚本功能，允许开发者将 Lua 语言编写的脚本传到 Redis 中执行。使用 Lua 脚本的优点有如下几点:</p>
<ul>
<li><p>减少网络开销：本来需要多次请求的操作，可以一次请求完成，从而节约网络开销；</p>
</li>
<li><p>原子操作：Redis 会将整个脚本作为一个整体执行，中间不会执行其它命令；</p>
</li>
<li><p>复用：客户端发送的脚本会存储在 Redis 中，从而实现脚本的复用。</p>
</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="基础lua环境安装"><a href="#基础lua环境安装" class="headerlink" title="基础lua环境安装"></a>基础lua环境安装</h2><h3 id="lua环境下载"><a href="#lua环境下载" class="headerlink" title="lua环境下载"></a>lua环境下载</h3><p>github项目地址：<a href="https://github.com/rjpcomputing/luaforwindows/releases">https://github.com/rjpcomputing/luaforwindows/releases</a></p>
<p>github下载地址：<a href="https://github.com/rjpcomputing/luaforwindows/releases/download/v5.1.5-52/LuaForWindows_v5.1.5-52.exe">https://github.com/rjpcomputing/luaforwindows/releases/download/v5.1.5-52/LuaForWindows_v5.1.5-52.exe</a></p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902092517785.png" alt="image-20210902092517785" style="zoom:50%;">

<h3 id="lua环境安装"><a href="#lua环境安装" class="headerlink" title="lua环境安装"></a>lua环境安装</h3><p>安装说明：</p>
<p>Lua for Windows安装依赖于MSVC++ 2005运行时库，如果没有安装Lua for Windows安装目录自动下载运行时并安装；</p>
<ol>
<li>双击下载的exe文件</li>
</ol>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902093357173.png" alt="image-20210902093357173" style="zoom:50%;">

<ol start="2">
<li>选择安装目录</li>
</ol>
<p>一般安装到D盘，直接把C改成D就可以</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902093430965.png" alt="image-20210902093430965" style="zoom:50%;">

<ol start="3">
<li><p>选择安装组件（默认全选）</p>
<p>lua为核心苦，必须</p>
<p>DcliTe是ide，就是记事本编译器</p>
<p>剩下的就是一些module和document，因为本身也不大，默认全选</p>
</li>
</ol>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902093446343.png" alt="image-20210902093446343"></p>
<ol start="3">
<li><p>之后一直下一步</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902093627097.png" alt="image-20210902093627097" style="zoom:50%;">



<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902093643267.png" alt="image-20210902093643267" style="zoom:50%;"></li>
</ol>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902093711705.png" alt="image-20210902093711705"></p>
<ol start="4">
<li><p>安装完成</p>
</li>
<li><p>检验</p>
</li>
</ol>
<p>注意：这一步有延迟，可以安装完成后等待半分钟在检验</p>
<ul>
<li><code>win + R</code>命令</li>
<li><code>cmd</code>命令</li>
<li><code>lua</code>命令</li>
<li><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902093028533.png" alt="image-20210902093028533"></li>
</ul>
<h2 id="IDE环境"><a href="#IDE环境" class="headerlink" title="IDE环境"></a>IDE环境</h2><h3 id="EmmyLua插件基于idea"><a href="#EmmyLua插件基于idea" class="headerlink" title="EmmyLua插件基于idea"></a>EmmyLua插件基于idea</h3><p><a href="https://github.com/EmmyLua/IntelliJ-EmmyLua">https://github.com/EmmyLua/IntelliJ-EmmyLua</a></p>
<p><a href="https://emmylua.github.io/zh_CN/">https://emmylua.github.io/zh_CN/</a></p>
<h3 id="LDT-基于eclipse"><a href="#LDT-基于eclipse" class="headerlink" title="LDT 基于eclipse"></a>LDT 基于eclipse</h3><p><a href="https://www.eclipse.org/ldt/">https://www.eclipse.org/ldt/</a></p>
<p>本次使用的java的idea编译器，直接安装EmmyLua插件，安装后重启</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902085450831.png" alt="image-20210902085450831" style="zoom:67%;">

<h1 id="创建第一个lua项目"><a href="#创建第一个lua项目" class="headerlink" title="创建第一个lua项目"></a>创建第一个lua项目</h1><h2 id="idea创建项目"><a href="#idea创建项目" class="headerlink" title="idea创建项目"></a>idea创建项目</h2><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902094157023.png" alt="image-20210902094157023"></p>
<h2 id="创建lua项目"><a href="#创建lua项目" class="headerlink" title="创建lua项目"></a>创建lua项目</h2><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902094233389.png" alt="image-20210902094233389" style="zoom: 67%;">



<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902094312684.png" alt="image-20210902094312684" style="zoom:67%;">



<h2 id="创建lua文件"><a href="#创建lua文件" class="headerlink" title="创建lua文件"></a>创建lua文件</h2><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902094359276.png" alt="image-20210902094359276" style="zoom:67%;">



<p>然后输入文件名hello</p>
<h2 id="第一个项目"><a href="#第一个项目" class="headerlink" title="第一个项目"></a>第一个项目</h2><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902094508410.png" alt="image-20210902094508410" style="zoom: 80%;">



<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"hello world"</span>)</span><br></pre></td></tr></tbody></table></figure>



<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>右键</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902094714491.png" alt="image-20210902094714491" style="zoom:67%;">

<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902094809680.png" alt="image-20210902094809680" style="zoom:67%;">



<h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902094845809.png" alt="image-20210902094845809"></p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/niuba123456/article/details/81197585">https://blog.csdn.net/niuba123456/article/details/81197585</a></p>
<p><a href="https://blog.csdn.net/weixin_41611450/article/details/104507532">https://blog.csdn.net/weixin_41611450/article/details/104507532</a></p>
</body></html>]]></content>
      <categories>
        <category>lua</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm中对象的内存布局</title>
    <url>/561c47f9.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="对象的创建、内存布局和访问定位"><a href="#对象的创建、内存布局和访问定位" class="headerlink" title="对象的创建、内存布局和访问定位"></a>对象的创建、内存布局和访问定位</h1><hr>
<h2 id="1-对象创建"><a href="#1-对象创建" class="headerlink" title="1. 对象创建"></a>1. 对象创建</h2><ul>
<li>在开发使用时，创建 <code>Java</code> 对象仅仅只是是通过关键字<code>new</code>：</li>
</ul>
<span id="more"></span>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A()；</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>可是 <code>Java</code>对象在虚拟机中创建则是相对复杂。今天，我将详解<code>Java</code>对象在虚拟机中的创建过程</li>
</ul>
<blockquote>
<p>限于普通对象，不包括数组和Class对象等</p>
</blockquote>
<h3 id="1-1-创建过程"><a href="#1-1-创建过程" class="headerlink" title="1.1 创建过程"></a>1.1 创建过程</h3><p>当遇到关键字<code>new</code>指令时，Java对象创建过程便开始，整个过程如下：</p>
<img src="https://upload-images.jianshu.io/upload_images/944365-2db1b11a4cb98f1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/290/format/webp" alt="img">

<p>Java对象创建过程</p>
<p>下面我将对每个步骤进行讲解。</p>
<h3 id="步骤1：类加载检查"><a href="#步骤1：类加载检查" class="headerlink" title="步骤1：类加载检查"></a>步骤1：类加载检查</h3><ol>
<li>检查 该<code>new</code>指令的参数 是否能在 常量池中 定位到一个类的符号引用</li>
<li>检查 该类符号引用 代表的类是否已被加载、解析和初始化过</li>
</ol>
<blockquote>
<p>如果没有，需要先执行相应的类加载过程</p>
</blockquote>
<h4 id="关于类加载请看文章："><a href="#关于类加载请看文章：" class="headerlink" title="关于类加载请看文章："></a>关于类加载请看文章：</h4><hr>
<h3 id="步骤2：为对象分配内存"><a href="#步骤2：为对象分配内存" class="headerlink" title="步骤2：为对象分配内存"></a>步骤2：为对象分配内存</h3><ul>
<li>虚拟机将为对象分配内存，即把一块确定大小的内存从 <code>Java</code> 堆中划分出来</li>
</ul>
<blockquote>
<p>对象所需内存的大小在类加载完成后便可完全确定</p>
</blockquote>
<ul>
<li>关于分配内存，此处主要讲解内存分配方式</li>
<li>内存分配 根据 <strong>Java堆内存是否绝对规整</strong> 分为两种方式：指针碰撞 &amp; 空闲列表</li>
</ul>
<blockquote>
<ol>
<li><code>Java</code>堆内存 规整：已使用的内存在一边，未使用内存在另一边</li>
<li><code>Java</code>堆内存 不规整：已使用的内存和未使用内存相互交错</li>
</ol>
</blockquote>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/944365-56bc4829fec010da.png" alt="img"></p>
<p>示意图</p>
<p>方式1：指针碰撞</p>
<ul>
<li>假设Java堆内存绝对规整，内存分配将采用指针碰撞</li>
<li>分配形式：已使用内存在一边，未使用内存在另一边，中间放一个作为分界点的指示器</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-139d8747844ca098.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/471/format/webp" alt="img"></p>
<p>正常状态</p>
<ul>
<li>那么，分配对象内存 = 把指针向 未使用内存 移动一段 与对象大小相等的距离</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-454f011a868e66d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/501/format/webp" alt="img"></p>
<p>分配内存空间</p>
<p>方式2：空闲列表</p>
<ul>
<li>假设Java堆内存不规整，内存分配将采用 空闲列表</li>
<li>分配形式：虚拟机维护着一个 记录可用内存块 的列表，在分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</li>
</ul>
<p>额外知识</p>
<ul>
<li><p>分配方式的选择 取决于 <code>Java</code>堆内存是否规整；</p>
</li>
<li><p>而<code>Java</code>堆是否规整 由所采用的垃圾收集器是否带有压缩整理功能决定。因此：</p>
<ol>
<li>使用带 <code>Compact</code> 过程的垃圾收集器时，采用指针碰撞；</li>
</ol>
</li>
</ul>
<blockquote>
<p>如<code>Serial、ParNew</code>垃圾收集器</p>
</blockquote>
<ol>
<li>使用基于 <code>Mark_sweep</code>算法的垃圾收集器时，采用空闲列表。</li>
</ol>
<blockquote>
<p>如 <code>CMS</code>垃圾收集器</p>
</blockquote>
<p>特别注意</p>
<ul>
<li>对象创建在虚拟机中是非常频繁的操作，即使仅仅修改一个指针所指向的位置，在并发情况下也会引起线程不安全</li>
</ul>
<blockquote>
<p>如，正在给对象A分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存</p>
</blockquote>
<p><strong>所以，给对象分配内存会存在线程不安全的问题。</strong></p>
<p>解决 线程不安全 有两种方案：</p>
<ol>
<li>同步处理分配内存空间的行为</li>
</ol>
<blockquote>
<p>虚拟机采用 <strong><code>CAS</code> + 失败重试的方式</strong> 保证更新操作的原子性</p>
</blockquote>
<ol>
<li>把内存分配行为 按照线程 划分在不同的内存空间进行</li>
</ol>
<blockquote>
<ol>
<li>即每个线程在 <code>Java</code>堆中预先分配一小块内存（本地线程分配缓冲（<code>Thread Local Allocation Buffer</code> ，<code>TLAB</code>）），哪个线程要分配内存，就在哪个线程的<code>TLAB上</code>分配，只有TLAB用完并分配新的TLAB时才需要同步锁。</li>
<li>虚拟机是否使用<code>TLAB</code>，可以通过<code>-XX:+/-UseTLAB</code>参数来设定。</li>
</ol>
</blockquote>
<hr>
<h3 id="步骤3：-将内存空间初始化为零值"><a href="#步骤3：-将内存空间初始化为零值" class="headerlink" title="步骤3： 将内存空间初始化为零值"></a>步骤3： 将内存空间初始化为零值</h3><p>内存分配完成后，虚拟机需要将分配到的内存空间初始化为零（不包括对象头）</p>
<blockquote>
<ol>
<li>保证了对象的实例字段在使用时可不赋初始值就直接使用（对应值 = 0）</li>
<li>如使用本地线程分配缓冲（TLAB），这一工作过程也可以提前至TLAB分配时进行。</li>
</ol>
</blockquote>
<hr>
<h3 id="步骤4：-对对象进行必要的设置"><a href="#步骤4：-对对象进行必要的设置" class="headerlink" title="步骤4： 对对象进行必要的设置"></a>步骤4： 对对象进行必要的设置</h3><blockquote>
<p>如，设置 这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。</p>
</blockquote>
<p><strong>这些信息存放在对象的对象头中</strong>。</p>
<hr>
<ul>
<li>至此，从 <code>Java</code> 虚拟机的角度来看，一个新的 <code>Java</code>对象创建完毕</li>
<li>但从 <code>Java</code> 程序开发来说，对象创建才刚开始，需要进行一些初始化操作。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>下面用一张图总结 <code>Java</code>对象创建的过程</p>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-dcaca2aa784300fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/892/format/webp" alt="img"></p>
<p>示意图</p>
<hr>
<h2 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2. 对象的内存布局"></a>2. 对象的内存布局</h2><ul>
<li><p>问题：在 <code>Java</code> 对象创建后，到底是如何被存储在Java内存里的呢？（美团面试题）</p>
</li>
<li><p>答：在<code>Java</code>虚拟机（<code>HotSpot</code>）中，对象在Java<br>内存中的 存储布局 可分为三块：</p>
<ol>
<li>对象头 存储区域<ol>
<li>运行时数据（<code>Mark Word</code>）</li>
<li>对象类型指针（KP）</li>
</ol>
</li>
<li>实例数据 存储区域</li>
<li>对齐填充 存储区域</li>
</ol>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-06bc64cd744e28b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/450/format/webp" alt="img"></p>
<h3 id="2-1-对象头-区域"><a href="#2-1-对象头-区域" class="headerlink" title="2.1 对象头 区域"></a>2.1 对象头 区域</h3><p>此处存储的信息包括两部分：</p>
<ul>
<li>对象自身的运行时数据（<code>Mark Word</code>）</li>
</ul>
<blockquote>
<ol>
<li>如哈希码（<code>HashCode</code>）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等</li>
<li>该部分数据被设计成1个 非固定的数据结构 以便在极小的空间存储尽量多的信息（会根据对象状态复用存储空间）</li>
<li>64位默认占据8个字节</li>
</ol>
</blockquote>
<ul>
<li>对象类型指针</li>
</ul>
<blockquote>
<ol>
<li>即对象指向它的类元数据的指针</li>
<li>虚拟机通过这个指针来确定这个对象是哪个类的实例</li>
<li>.64位默认占据4个字节</li>
</ol>
</blockquote>
<p>特别注意</p>
<p>如果对象 是 数组，那么在对象头中还必须有一块用于记录数组长度的数据</p>
<blockquote>
<p>因为虚拟机可以通过普通Java对象的元数据信息确定对象的大小，但是从数组的元数据中却无法确定数组的大小。</p>
</blockquote>
<hr>
<h3 id="2-2-实例数据-区域"><a href="#2-2-实例数据-区域" class="headerlink" title="2.2 实例数据 区域"></a>2.2 实例数据 区域</h3><ul>
<li>存储的信息：对象真正有效的信息</li>
</ul>
<blockquote>
<p>即代码中定义的字段内容</p>
</blockquote>
<p>​    注：这部分数据的存储顺序会受到虚拟机分配参数（FieldAllocationStyle）和字段在Java源码中定义顺序的影响。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// HotSpot虚拟机默认的分配策略如下：</span></span><br><span class="line">longs/doubles、ints、shorts/chars、bytes/booleans、oop(Ordinary Object Pointers)</span><br><span class="line"><span class="comment">// 从分配策略中可以看出，相同宽度的字段总是被分配到一起</span></span><br><span class="line"><span class="comment">// 在满足这个前提的条件下，父类中定义的变量会出现在子类之前</span></span><br><span class="line"> </span><br><span class="line">CompactFields = <span class="keyword">true</span>；</span><br><span class="line"><span class="comment">// 如果 CompactFields 参数值为true，那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>对齐：如果上面的数据长度不能被8整除，则添加一个最小的padding，使整个数据能被8整除（用于64位）</li>
</ul>
<p>参考文章：</p>
<p><a href="https://www.bilibili.com/video/BV1aQ4y1P7Me?p=3&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1aQ4y1P7Me?p=3&amp;spm_id_from=pageDriver</a></p>
<p><a href="https://www.jianshu.com/p/1952061502d0">https://www.jianshu.com/p/1952061502d0</a></p>
</body></html>]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>spring核心知识点</title>
    <url>/de7e93c2.html</url>
    <content><![CDATA[<html><head></head><body><h2 id="说一下spring-ioc的理解，原理和实现"><a href="#说一下spring-ioc的理解，原理和实现" class="headerlink" title="说一下spring ioc的理解，原理和实现"></a>说一下spring ioc的理解，原理和实现</h2><h3 id="总"><a href="#总" class="headerlink" title="总"></a>总</h3><p>ioc：控制反转。原来的对象是由使用者来控制的，有了spring，就直接把整个对象交给spring来帮我们管理。</p>
<p>​    DI：依赖注入。把对应的属性的值注入到具体的对象中，@autowired，populatebean完成属性值得注入</p>
<p>容器：存储对象，使用map结构存储，在spring中一般存在三级缓存，singletonOBjects存放文章的bean对象，在整个bean的生命周期中，从创建到使用到销毁都是由容器来管理的。</p>
<span id="more"></span>

<h3 id="分"><a href="#分" class="headerlink" title="分"></a>分</h3><h4 id="IOC和DI"><a href="#IOC和DI" class="headerlink" title="IOC和DI"></a>IOC和DI</h4><p>举一个例子：有车，底盘，轮胎，在没有spring之前，我们相对这样的整体架构进行设计，一个常用的方法就是通过构造器注入，我们在创建一个底盘的时候，需要new一个轮子的对象，把这个对象的尺寸，材料设置好后，通过底盘的构造器放入底盘中。同样，我们在最终创建一个车的时候，需要先创建一个轮胎对象，在创建一个底盘对象，最后才能创建出我们想要的车的对象。然后spring就帮我解决了这样的而问题，你可以直接去创建一个车的对象，而具体的底盘和轮胎的对象注入，由spring自己来进行，你只需要在开始创建这样的bean就行了</p>
<p><img src="https://pic2.zhimg.com/80/v2-24a96669241e81439c636e83976ba152_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这里的ioc，就像是一个工厂</p>
<img src="https://pic3.zhimg.com/80/v2-5ca61395f37cef73c7bbe7808f9ea219_720w.jpg?source=1940ef5c" alt="img" style="zoom: 33%;">

<p>所以我们在项目中经常回遇到bean找不到报错的问题，应为spring是只是帮你去把你创建的bean给找出来，所以在项目运行的时候需要有一个初始化好的bean。可以通过xml去定义一个bean，也可以通过注解@bean，@controller等等去定义一个bean</p>
<p>推荐文章：Spring IoC有什么好处呢？ - Mingqi的回答 - 知乎 <a href="https://www.zhihu.com/question/23277575/answer/169698662">https://www.zhihu.com/question/23277575/answer/169698662</a></p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ol>
<li>首先开始创建一个容器（beanFactory ， DefaultListableBeanFactory），然后想bean工厂中设置一些参数（beanPostProcessor，Aware接口的子类）等等属性</li>
<li>加载解析bean对象，准备要创建的bean对象的定义对象beanDefintion（XML或者注解）</li>
<li>beanFactoryPostProcessor的处理，在此处可以自定义扩展，PlaceHolderConfigurSupport,ConfigurationClassPostProcessor</li>
<li>BeanPostProcessor的注册功能，方便后续对bean’对象完成具体的扩展功能</li>
<li>通过反射的方式将BeanDefintion对象实例化成具体的bean对象</li>
<li>bean对象的初始化过程（填充属性，调用aware接口子类的方法，调用BeanPostProcesor的前置处理方法，调用init-method方法，调用BeanPostProcessor的后置处理方法）</li>
<li>生成完整的bean对象，通过getBean方法可以直接获取</li>
<li>销毁，（调用DisposableBean的destory方法，调用自定义销毁方法）</li>
<li>结束</li>
</ol>
<h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><ol>
<li><p>通过实现BeanPostProcessor接口，对beanFactory的创建过程进行整体修改</p>
</li>
<li><p>对bean的扩展，在项目中使用@value注入yml的属性，现在在分布式情况下，相对这个@value注入自定义扩展（比如添加前缀或者从特定位置读取默认值）</p>
</li>
</ol>
<h2 id="谈一下spring-IOC的底层实现"><a href="#谈一下spring-IOC的底层实现" class="headerlink" title="谈一下spring IOC的底层实现"></a>谈一下spring IOC的底层实现</h2><h3 id="总-1"><a href="#总-1" class="headerlink" title="总"></a>总</h3><p>createBeanFactory，getBean,doGetBean,doCreatBean,creatBeanInstance（getDeclaredConstructor，newinstance），populateBean，initializingBean</p>
<p>（备注：加do的方法都是主要业务逻辑方法）</p>
<h3 id="分-1"><a href="#分-1" class="headerlink" title="分"></a>分</h3><ol>
<li>先通过creatBeanFactory创建出一个bean工厂（DefaultListableBeanFactory）</li>
<li>开始循环创建对象，因为容器中的bean默认都是单例的，所以优先通过getBean，doGetBean从容器中查找，找不到的话</li>
<li>通过createBean，doCreateBean方法，以反射的放射创建对象，一般情况下使用无参的构造方法（getDeclaredConstructor，newInstance）</li>
<li>进行对象的属性填充populateBean</li>
<li>进行其他的初始化操作（initializingBean）</li>
</ol>
<h2 id="描述一下bena的生命周期"><a href="#描述一下bena的生命周期" class="headerlink" title="描述一下bena的生命周期"></a>描述一下bena的生命周期</h2><h3 id="总-2"><a href="#总-2" class="headerlink" title="总"></a>总</h3><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210819214343270.png" alt="image-20210819214343270" style="zoom:50%;">

<h3 id="分-2"><a href="#分-2" class="headerlink" title="分"></a>分</h3><ol>
<li>实例化bean：反射的方式生成对象</li>
<li>填充bean的属性：populateBean（），循环依赖的问题（三级缓存）</li>
<li>调用aware接口相关的方法：invokeAwareMethod（完成BeanName，BeanFactory，BeanClassLoader对象的属性设置）</li>
<li>调用BeanPostProcessor中的前置处理方法：使用比较多的有（ApplicationContextPostProcessor，设置ApplicationContext，Environment，ResourceLoader，EmbeddValueResolver）</li>
<li>调用initmethod方法：invokeInitmethod（），判断是否实现了initializingBean接口，如果有，调用afterPropertiesSet方法，没有就不调用</li>
<li>调用BeanPostProcessor的后置处理方法：spring中的AOP就是在此处实习的，AbstractAutoProxyCreator。<ol>
<li>注册Destuction相关的回调接口：（钩子函数）</li>
</ol>
</li>
<li>获取到完成bean对象，可以通过getBean的方法进行对象的获取</li>
<li>销毁<ol>
<li>判断是否实现了DisproableBean接口</li>
<li>调用destoryMethod的方法</li>
</ol>
</li>
</ol>
<h2 id="Spring是如何解决循环依赖问题"><a href="#Spring是如何解决循环依赖问题" class="headerlink" title="Spring是如何解决循环依赖问题"></a>Spring是如何解决循环依赖问题</h2><p>核心思想：提前暴露对象，把不完整的对象注入</p>
<h3 id="总-3"><a href="#总-3" class="headerlink" title="总"></a>总</h3><p>使用三级缓存，提前暴露bean的对象，也就是把实例化和初始化分开操作，把不完整的对象注入</p>
<h3 id="分-3"><a href="#分-3" class="headerlink" title="分"></a>分</h3><p>假如A和B对象循环依赖</p>
<ol>
<li>先创建A对象，实例化A对象，此时A对象中的B属性为空，开始填充属性B</li>
<li>从容器中查找B对象，如果找到了，直接赋值不存在循环依赖问题（但是现在A和B对象循环依赖），没有找到直接创建B对象</li>
<li>实例化B对象，此时B对象中的A属性为空，填充A属性</li>
<li>从容器中查找A对象，找不到，直接创建</li>
</ol>
<p>​        在spring中，第四步的A对象是存在的，只不过此时的A对象不是一个完整的状态，只完成了实例化但是未完成初始化，如果在程序调用过程中，拥有了某个对象的引用，能否再后期给他完成赋值操作，可以优先把非完整的对象优先赋值，等待后续操作来完成赋值，相当于提前暴露了某个不完整的对象的引用。</p>
<p>​        所以解决循环依赖问题的关键就是，把实例化和初始化分开操作，当所有的对象都实例化和初始化操作后，还是要把完整的对象放到容器中，此时在容器中存在对象的几个状态：未完成实例化，完成实例化但为完成初始化，完整状态。因为都在容器中，所以要使用不同的map结构来进行存储，此时就有了一级缓存和二级缓存，如果一级缓存中有了，那么耳机缓存中就不会存在同名的对象，因为他们的查找顺序是1,2,3级缓存的方式进行查找的。在一级缓存中存放的是完整对象，二级缓存中存放的是非完整对象</p>
<p>​        为什么需要三级缓存？三级缓存的value类型是ObjectFactory，是一个函数式接口，存在的意义是保证整个容器的运行过程中同名的bean对象只能有一个。</p>
<p>​        如果一个对象需要被代理，或者需要生成代理对象，那么要不要优先生成一个普通对象？需要，在源码中调用的代理方法（BeanPostProcessor）的时候需要传入一个bean对象</p>
<p>​        普通对象和代理对象是不能同时出现在容器中，因此当一个对象需要被代理的时候，就要使用代理对象覆盖掉之前的普通对象，在实际的调用过程中，是没有办法确定什么时候对象被使用，所以就要求当某个对象被调用的时候，优先判断此对象是否需要被代理，类似于一种回调机制的实现，因此传入lambda表达式的时候，可以通过lambda表达式来执行对象的覆盖过程，getEarlyBeanReference（）</p>
<p>​        因此，所有的bean对象在创建的时候都要优先放到三级缓存中，在后续的使用过程中，如果需要被代理则返回代理对象，如果不需要被代理，则直接返回普通对象</p>
<h3 id="三级缓存的放置时间和删除时间"><a href="#三级缓存的放置时间和删除时间" class="headerlink" title="三级缓存的放置时间和删除时间"></a>三级缓存的放置时间和删除时间</h3><p>三级缓存：createBeanInstance之后，addSingletonFactory</p>
<p>二级缓存：第一次从三级缓存确定对象是代理对象还是普通对象，同时删除三级缓存getSingleton</p>
<p>一级缓存：生成完整对象之后放到一级缓存，删除二三级缓存：addSingleton</p>
<h2 id="BeanFactory与FactoryBean有什么区别"><a href="#BeanFactory与FactoryBean有什么区别" class="headerlink" title="BeanFactory与FactoryBean有什么区别"></a>BeanFactory与FactoryBean有什么区别</h2><p>相同点：都是创建bean对象</p>
<p>不同点：使用benaFactory创建对象的时候，必须要遵循严格的生命周期流程，太复杂了。如果想要简单的自定义某个对象的创建，同时创建完成的对象想交给spring来管理，那么就需要实习FactoryBean接口</p>
<p>​        isSingleton：创建的bean是否为单例bean</p>
<p>​        getObjectType：获取返回对象的类型</p>
<p>​        getObjet：自定义创建对象的过程（new，反射，动态代理）</p>
<h2 id="Spring中用的到的设计模式"><a href="#Spring中用的到的设计模式" class="headerlink" title="Spring中用的到的设计模式"></a>Spring中用的到的设计模式</h2><p>单例模式：bean默认都是单例的</p>
<p>原型模式：指定作用域为prototype</p>
<p>工厂模式：BeanFactory</p>
<p>模板方法：postProcessBeanFactory，onRefresh，initPropertyValue</p>
<p>策略模式：XmlBeanDefinitionReader，PropertiesBeanDefinitionReader</p>
<p>观察者模式：listener，event，multicast</p>
<p>适配器模式：Adapter</p>
<p>装饰者模式：BeanWrapper</p>
<p>责任链模式：使用aop的时候回先生成一个拦截器链</p>
<p>代理模式：动态代理</p>
<p>委托者模式：delegate</p>
<h2 id="Spring中AOP的底层实现原理"><a href="#Spring中AOP的底层实现原理" class="headerlink" title="Spring中AOP的底层实现原理"></a>Spring中AOP的底层实现原理</h2><h3 id="总-4"><a href="#总-4" class="headerlink" title="总"></a>总</h3><p>AOP是ioc的一个扩展功能，现有的ioc，在有的aop，只是在ioc的整个流程中新增的一个扩展点而已（BeanPostProcessor），底层是用的动态代理实现的，常用的应用场景油自定义注解等等</p>
<h3 id="分-4"><a href="#分-4" class="headerlink" title="分"></a>分</h3><p>在bean的创建过程中，可以在BeanPostProcessor的后置处理方法实习aop</p>
<ol>
<li>代理对象的创建过程（advice，切面（@around，@After），切点（@pointCut））</li>
<li>通过jdk或者cglib的方式来生成代理对象</li>
<li>在执行方法调用的时候，会调用生成的字节码文件，直接找到DynamicAdvisoredIntercepto类中的intercept方法，从此方法开始执行</li>
<li>根据之前定义好的通知来生成拦截器链</li>
<li>从拦截器链中依次获取每一个通知开始进行执行，在执行的过程中，为了方便找到下一个通知是哪个，会有一个InvocationInterceptor的对象，找的的时候从-1的位置依次开始查找并执行的</li>
</ol>
<h2 id="Spring的事务是如何回滚的"><a href="#Spring的事务是如何回滚的" class="headerlink" title="Spring的事务是如何回滚的"></a>Spring的事务是如何回滚的</h2><h3 id="总-5"><a href="#总-5" class="headerlink" title="总"></a>总</h3><p>spring的事务是由aop来实现的，首先要生成具体的代理对象，然后按照aop的整套流程来执行具体的操作逻辑。正常情况下要通过通知来完成核心功能，但是事务不是通过通知来实现的，而是通过一个TransactionInterceptor来实现的，然后调用invoke来实现具体的逻辑</p>
<h3 id="分-5"><a href="#分-5" class="headerlink" title="分"></a>分</h3><p>mysql中事务的实现机制（下图左）：</p>
<p>具体还设计到了myql的MVCC机制（一致性）、锁（隔离性）、redo log（持久性）、undolog（原子性）</p>
<p>推荐文章：<a href="https://blog.csdn.net/weixin_33560311/article/details/113138290">https://blog.csdn.net/weixin_33560311/article/details/113138290</a></p>
<p>AOP实现事务的机制（下图右）：</p>
<center class="half"> 
    <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210820104629013.png" alt="mysql中事务的实现机制" style="zoom:50%;">
    <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210820105158508.png" alt="AOP实现事务的机制" style="zoom: 50%;">
</center>

<ol>
<li>先做准备工作，解析各个方法上事务的相关属性，根据具体的属性来判断是否开启新的事务</li>
<li>当需要开启的时候，获取数据库连接（这里也是用的连接池），关闭自动提交功能，开启事务</li>
<li>执行具体的sql逻辑操作</li>
<li>在操作过程中，如果执行失败了，那么会通过completeTransactionThrowing看来完成事务的回滚操作，回滚的具体逻辑是通过doRollBack方法来实现的，实现的时候也是先获取连接对象，通过连接对象来回滚</li>
<li>如果执行过程顺利完成，通过commitTransactionAfterReturning来完成事务的提交操作，提交的具体逻辑是通过doCommit方法来实习的，实现的时候也是要获取连接，通过连接对象提交（所以获取的链接对象要保持一致，currentConnection）</li>
<li>当前事务执行完毕后需要清楚相关的事务信息cleanupTransactionInfo(断开连接，释放资源)</li>
</ol>
<p>深入的话，还需要知道TransactionInfo，TransactionStatus</p>
<h2 id="spring事务传播"><a href="#spring事务传播" class="headerlink" title="spring事务传播"></a>spring事务传播</h2><p>一共有七种传播特性：</p>
<p>Required、Requies_new 、nested、support、not_support、never、mandatory</p>
<table>
<thead>
<tr>
<th>事务名称</th>
<th>解析</th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED)</td>
<td>支持当前事务：如果没有事务会创建一个新的事务</td>
</tr>
<tr>
<td>SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS)</td>
<td>支持当前事务：如果没有事务的话以非事务方式执行</td>
</tr>
<tr>
<td>MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY)</td>
<td>支持当前事务：如果没有事务抛出异常</td>
</tr>
<tr>
<td>REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW)</td>
<td>创建一个新的事务并挂起当前事务</td>
</tr>
<tr>
<td>NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED)</td>
<td>如果当前存在事务则将当前事务挂起，以无事务方式运行。外层没有事务，以无事务方式运行</td>
</tr>
<tr>
<td>NEVER(TransactionDefinition.PROPAGATION_NEVER)</td>
<td>如果存在事务则抛出异常</td>
</tr>
<tr>
<td>NESTED(TransactionDefinition.PROPAGATION_NESTED)</td>
<td>嵌套事务：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</td>
</tr>
</tbody></table>
<p>A方法调用B方法，AB都有自己的事务，并且传播特性不同，那么A如果有异常，B怎么办，B如果有异常，A怎么办</p>
<h3 id="总-6"><a href="#总-6" class="headerlink" title="总"></a>总</h3><p>事务的传播特性是在不同事务的嵌套方法调用中，事务应该怎么进行？是用一个事务（用哪个事务？），还是不同的事务？当出现异常的时候是全部回滚，还是提交，这不同事务之间的相关影响的解决。</p>
<h3 id="分-6"><a href="#分-6" class="headerlink" title="分"></a>分</h3><p>1.先说事务的不同分类，可以分为三类，支持当前事务，不支持当前事务，嵌套事务</p>
<p>​        2.如果外层方法是required，内层方法是：required，requireds_new,nested</p>
<p>​        3.如果外层方法是requireds_new，内层方法是：required，requireds_new,nested</p>
<p>​        4.如果外层方法是nested，内层方法是：required，requireds_new,nested</p>
<p>注意：新事物和子事务的区别：</p>
<p>新事物：外层事务回滚，不影响新事物；新事物的回滚，不影响外层事务，除非外层事务又异常处理，代码回滚新事务</p>
<p>子事务：外层事务回滚，子事务也会回滚；子事物的回滚，不影响外层事务，除非外层事务又异常处理，代码回滚子事务</p>
<table>
<thead>
<tr>
<th>外层</th>
<th>内层</th>
<th>结果（外层有事务）</th>
<th>结果（外层没有事务）</th>
<th>原因</th>
<th>外层有事务时出现异常</th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRED</td>
<td>REQUIRED，SUPPORTS，MANDATORY</td>
<td>使用外层事务</td>
<td>使用自己的事务逻辑（创建新事物，无事务运行或者抛异常）</td>
<td></td>
<td>整体回滚</td>
</tr>
<tr>
<td></td>
<td>REQUIRES_NEW，NOT_SUPPORTED，NEVER</td>
<td>使用自己的事务逻辑（外层事务挂起后创建新的事务，外层事务挂起后以无事务方式运行或者抛异常）</td>
<td>使用自己的事务逻辑（创建新事物，无事务运行或者抛异常）</td>
<td>这种有可能会造成死锁，因为会影响上一个事务，如果上一个事务已经表锁了，这个事务又操作表，但获取不到资源</td>
<td>外层事务回滚，不影响新事物</td>
</tr>
<tr>
<td></td>
<td>NESTED</td>
<td>使用自己的事务逻辑（外层事务挂起后创建子事务）</td>
<td>使用自己的事务逻辑（创建子事务）</td>
<td></td>
<td>外层事务回滚，子事务也会回滚</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210820211028606.png" alt="image-20210820211028606" style="zoom:50%;">

<p>在spring中，主要是在beanPostProcessor中进行事务的处理，事务都会生成一个InfrastructureAdvisorAutoProxyCreator对象。</p>
<ol>
<li><p>getAdviceAndAdvisorsForBean（获取事务通知的方法）</p>
</li>
<li><p>creatProxy，创建代理对象</p>
</li>
<li><p>走代理（实现接口走Proxy或者没有实现接口cglib）</p>
</li>
<li><p>执行invoke方法，获取拦截器的链（TransactionInterceptor）</p>
</li>
<li><p>invokeWithTransaction，获取事务上的注解属性（rollbackRules，quailfer，descriptor，propagationBehavior，isolationLevel，timeout，readonly，name）</p>
</li>
<li><p>creatTransactionIfNessary，从当前线程（ThreadLocal）中获取事务（TransactionSynchronizationManager.getResource(obtainDataSource())）</p>
<ol>
<li>当前线程没有事务，就开始这个事务</li>
<li>dobegin，把这个事务绑定到当前线程中，把连接的自动提交关闭，把当前事务设置为活跃的事务</li>
<li>执行事务中的方法</li>
</ol>
</li>
<li><p>事务中的方法还有一个事务，指定方法</p>
</li>
<li><p>获取拦截器中的TransactionInterceptor</p>
</li>
<li><p>invokeWithTransaction，获取事务上的注解属性</p>
</li>
<li><p>creatTransactionIfNessary，从当前线程中获取事务</p>
<ol>
<li><p>这个时候当前线程已经有事务</p>
</li>
<li><p>handlerExistingTransaction，处理存在的事务</p>
</li>
<li><p>如果这个事务（difintion.getPropagationBehavior）是NEVER的话，直接抛出异常</p>
</li>
<li><p>如果事务是NOT_SUPPORTED的话，当前事务挂起</p>
</li>
<li><p>如果事务是REQUIRES_NEW的话，开始一个新的事务（dobegin）</p>
</li>
<li><p>如果是NESTED，开始子事务</p>
</li>
<li><p>执行事务中的方法，如果出现异常，则事务回滚（doRollback）</p>
</li>
</ol>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式id的生成方案</title>
    <url>/d56bbc9.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="分布式id的生成方案"><a href="#分布式id的生成方案" class="headerlink" title="分布式id的生成方案"></a>分布式id的生成方案</h1><p>ID是数据的唯一标识，传统的做法是利用UUID和数据库的自增ID，在互联网企业中，大部分公司使用的都是Mysql，并且因为需要事务支持，所以通常会使用Innodb存储引擎，UUID太长以及无序，所以并不适合在Innodb中来作为主键，自增ID比较合适，但是随着公司的业务发展，数据量将越来越大，需要对数据进行分表，而分表后，每个表中的数据都会按自己的节奏进行自增，很有可能出现ID冲突。这时就需要一个单独的机制来负责生成唯一ID，生成出来的ID也可以叫做分布式ID，或全局ID。下面来分析各个生成分布式ID的机制。</p>
<span id="more"></span>

<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E5%88%86%E5%B8%83%E5%BC%8Fid%E6%96%B9%E6%A1%88.jpeg" alt="常用分布式id方案"></p>
<p>这篇文章并不会分析的特别详细，主要是做一些总结，以后再出一些详细某个方案的文章。</p>
<h2 id="数据库自增ID"><a href="#数据库自增ID" class="headerlink" title="数据库自增ID"></a>数据库自增ID</h2><p>第一种方案仍然还是基于数据库的自增ID，需要单独使用一个数据库实例，在这个实例中新建一个单独的表：</p>
<p>表结构如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">CREATE DATABASE `SEQID`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE SEQID.SEQUENCE_ID (</span><br><span class="line">	id bigint(20) unsigned NOT NULL auto_increment, </span><br><span class="line">	stub char(10) NOT NULL default '',</span><br><span class="line">	PRIMARY KEY (id),</span><br><span class="line">	UNIQUE KEY stub (stub)</span><br><span class="line">) ENGINE=MyISAM;</span><br></pre></td></tr></tbody></table></figure>

<p>可以使用下面的语句生成并获取到一个自增ID</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">replace into SEQUENCE_ID (stub) VALUES ('anyword');</span><br><span class="line">select last_insert_id();</span><br><span class="line">commit;</span><br></pre></td></tr></tbody></table></figure>

<p>stub字段在这里并没有什么特殊的意义，只是为了方便的去插入数据，只有能插入数据才能产生自增id。而对于插入我们用的是replace，replace会先看是否存在stub指定值一样的数据，如果存在则先delete再insert，如果不存在则直接insert。</p>
<p>这种生成分布式ID的机制，需要一个单独的Mysql实例，虽然可行，但是基于性能与可靠性来考虑的话都不够，业务系统每次需要一个ID时，都需要请求数据库获取，性能低，并且如果此数据库实例下线了，那么将影响所有的业务系统。</p>
<p>为了解决数据库可靠性问题，我们可以使用第二种分布式ID生成方案。</p>
<h2 id="数据库多主模式"><a href="#数据库多主模式" class="headerlink" title="数据库多主模式"></a>数据库多主模式</h2><p>如果我们两个数据库组成一个主从模式集群，正常情况下可以解决数据库可靠性问题，但是如果主库挂掉后，数据没有及时同步到从库，这个时候会出现ID重复的现象。我们可以使用双主模式集群，也就是两个Mysql实例都能单独的生产自增ID，这样能够提高效率，但是如果不经过其他改造的话，这两个Mysql实例很可能会生成同样的ID。需要单独给每个Mysql实例配置不同的起始值和自增步长。</p>
<p>第一台Mysql实例配置：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">set @@auto_increment_offset = 1;     -- 起始值</span><br><span class="line">set @@auto_increment_increment = 2;  -- 步长</span><br></pre></td></tr></tbody></table></figure>

<p>第二台Mysql实例配置：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">set @@auto_increment_offset = 2;     -- 起始值</span><br><span class="line">set @@auto_increment_increment = 2;  -- 步长</span><br></pre></td></tr></tbody></table></figure>

<p>经过上面的配置后，这两个Mysql实例生成的id序列如下： mysql1,起始值为1,步长为2,ID生成的序列为：1,3,5,7,9,… mysql2,起始值为2,步长为2,ID生成的序列为：2,4,6,8,10,…</p>
<p>对于这种生成分布式ID的方案，需要单独新增一个生成分布式ID应用，比如DistributIdService，该应用提供一个接口供业务应用获取ID，业务应用需要一个ID时，通过rpc的方式请求DistributIdService，DistributIdService随机去上面的两个Mysql实例中去获取ID。</p>
<p>实行这种方案后，就算其中某一台Mysql实例下线了，也不会影响DistributIdService，DistributIdService仍然可以利用另外一台Mysql来生成ID。</p>
<p>但是这种方案的扩展性不太好，如果两台Mysql实例不够用，需要新增Mysql实例来提高性能时，这时就会比较麻烦。</p>
<p>现在如果要新增一个实例mysql3，要怎么操作呢？ 第一，mysql1、mysql2的步长肯定都要修改为3，而且只能是人工去修改，这是需要时间的。 第二，因为mysql1和mysql2是不停在自增的，对于mysql3的起始值我们可能要定得大一点，以给充分的时间去修改mysql1，mysql2的步长。 第三，在修改步长的时候很可能会出现重复ID，要解决这个问题，可能需要停机才行。</p>
<p>为了解决上面的问题，以及能够进一步提高DistributIdService的性能，如果使用第三种生成分布式ID机制。</p>
<h2 id="号段模式"><a href="#号段模式" class="headerlink" title="号段模式"></a>号段模式</h2><p>我们可以使用号段的方式来获取自增ID，号段可以理解成批量获取，比如DistributIdService从数据库获取ID时，如果能批量获取多个ID并缓存在本地的话，那样将大大提供业务应用获取ID的效率。</p>
<p>比如DistributIdService每次从数据库获取ID时，就获取一个号段，比如(1,1000]，这个范围表示了1000个ID，业务应用在请求DistributIdService提供ID时，DistributIdService只需要在本地从1开始自增并返回即可，而不需要每次都请求数据库，一直到本地自增到1000时，也就是当前号段已经被用完时，才去数据库重新获取下一号段。</p>
<p>所以，我们需要对数据库表进行改动，如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">CREATE TABLE id_generator (</span><br><span class="line">  id int(10) NOT NULL,</span><br><span class="line">  current_max_id bigint(20) NOT NULL COMMENT '当前最大id',</span><br><span class="line">  increment_step int(10) NOT NULL COMMENT '号段的长度',</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></tbody></table></figure>

<p>这个数据库表用来记录自增步长以及当前自增ID的最大值（也就是当前已经被申请的号段的最后一个值），因为自增逻辑被移到DistributIdService中去了，所以数据库不需要这部分逻辑了。</p>
<p>这种方案不再强依赖数据库，就算数据库不可用，那么DistributIdService也能继续支撑一段时间。但是如果DistributIdService重启，会丢失一段ID，导致ID空洞。</p>
<p>为了提高DistributIdService的高可用，需要做一个集群，业务在请求DistributIdService集群获取ID时，会随机的选择某一个DistributIdService节点进行获取，对每一个DistributIdService节点来说，数据库连接的是同一个数据库，那么可能会产生多个DistributIdService节点同时请求数据库获取号段，那么这个时候需要利用乐观锁来进行控制，比如在数据库表中增加一个version字段，在获取号段时使用如下SQL：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">update id_generator set current_max_id=#{newMaxId}, version=version+1 where version = #{version}</span><br></pre></td></tr></tbody></table></figure>

<p>因为newMaxId是DistributIdService中根据oldMaxId+步长算出来的，只要上面的update更新成功了就表示号段获取成功了。</p>
<p>为了提供数据库层的高可用，需要对数据库使用多主模式进行部署，对于每个数据库来说要保证生成的号段不重复，这就需要利用最开始的思路，再在刚刚的数据库表中增加起始值和步长，比如如果现在是两台Mysql，那么 mysql1将生成号段（1,1001]，自增的时候序列为1，3，4，5，7…. mysql1将生成号段（2,1002]，自增的时候序列为2，4，6，8，10…</p>
<p>更详细的可以参考滴滴开源的TinyId：<a href="https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D">github.com/didi/tinyid…</a></p>
<p>在TinyId中还增加了一步来提高效率，在上面的实现中，ID自增的逻辑是在DistributIdService中实现的，而实际上可以把自增的逻辑转移到业务应用本地，这样对于业务应用来说只需要获取号段，每次自增时不再需要请求调用DistributIdService了。</p>
<h2 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h2><p>上面的三种方法总的来说是基于自增思想的，而接下来就介绍比较著名的雪花算法-snowflake。</p>
<p>我们可以换个角度来对分布式ID进行思考，      只要能让负责生成分布式ID的每台机器在每毫秒内生成不一样的ID就行了。</p>
<p>snowflake是twitter开源的分布式ID生成算法，是一种算法，所以它和上面的三种生成分布式ID机制不太一样，它不依赖数据库。</p>
<p>核心思想是：分布式ID固定是一个long型的数字，一个long型占8个字节，也就是64个bit，原始snowflake算法中对于bit的分配如下图：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95.png" alt="雪花算法"></p>
<ul>
<li>第一个bit位是标识部分，在java中由于long的最高位是符号位，正数是0，负数是1，一般生成的ID为正数，所以固定为0。</li>
<li>时间戳部分占41bit，这个是毫秒级的时间，一般实现上不会存储当前的时间戳，而是时间戳的差值（当前时间-固定的开始时间），这样可以使产生的ID从更小值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69年</li>
<li>工作机器id占10bit，这里比较灵活，比如，可以使用前5位作为数据中心机房标识，后5位作为单机房机器标识，可以部署1024个节点。</li>
<li>序列号部分占12bit，支持同一毫秒内同一个节点可以生成4096个ID</li>
</ul>
<p>根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。</p>
<p>snowflake算法实现起来并不难，提供一个github上用java实现的：<a href="https://github.com/beyondfengyu/SnowFlake">github.com/beyondfengy…</a></p>
<p>在大厂里，其实并没有直接使用snowflake，而是进行了改造，因为snowflake算法中最难实践的就是工作机器id，原始的snowflake算法需要人工去为每台机器去指定一个机器id，并配置在某个地方从而让snowflake从此处获取机器id。</p>
<p>但是在大厂里，机器是很多的，人力成本太大且容易出错，所以大厂对snowflake进行了改造。</p>
<h3 id="百度（uid-generator）"><a href="#百度（uid-generator）" class="headerlink" title="百度（uid-generator）"></a>百度（uid-generator）</h3><p>github地址：<a href="https://github.com/baidu/uid-generator">uid-generator</a></p>
<p>uid-generator使用的就是snowflake，只是在生产机器id，也叫做workId时有所不同。</p>
<p>uid-generator中的workId是由uid-generator自动生成的，并且考虑到了应用部署在docker上的情况，在uid-generator中用户可以自己去定义workId的生成策略，默认提供的策略是：应用启动时由数据库分配。说的简单一点就是：应用在启动时会往数据库表(uid-generator需要新增一个WORKER_NODE表)中去插入一条数据，数据插入成功后返回的该数据对应的自增唯一id就是该机器的workId，而数据由host，port组成。</p>
<p>对于uid-generator中的workId，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，需要注意的是，和原始的snowflake不太一样，时间的单位是秒，而不是毫秒，workId也不一样，同一个应用每重启一次就会消费一个workId。</p>
<p>具体可参考<a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">github.com/baidu/uid-g…</a></p>
<h3 id="美团（Leaf）"><a href="#美团（Leaf）" class="headerlink" title="美团（Leaf）"></a>美团（Leaf）</h3><p>github地址：<a href="https://github.com/Meituan-Dianping/Leaf">Leaf</a></p>
<p>美团的Leaf也是一个分布式ID生成框架。它非常全面，即支持号段模式，也支持snowflake模式。号段模式这里就不介绍了，和上面的分析类似。</p>
<p>Leaf中的snowflake模式和原始snowflake算法的不同点，也主要在workId的生成，Leaf中workId是基于ZooKeeper的顺序Id来生成的，每个应用在使用Leaf-snowflake时，在启动时都会都在Zookeeper中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个workId。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总得来说，上面两种都是自动生成workId，以让系统更加稳定以及减少人工成功。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>这里额外再介绍一下使用Redis来生成分布式ID，其实和利用Mysql自增ID类似，可以利用Redis中的incr命令来实现原子性的自增与返回，比如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set seq_id 1     // 初始化自增ID为1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr seq_id      // 增加1，并返回</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; incr seq_id      // 增加1，并返回</span><br><span class="line">(integer) 3</span><br></pre></td></tr></tbody></table></figure>

<p>使用redis的效率是非常高的，但是要考虑持久化的问题。Redis支持RDB和AOF两种持久化的方式。</p>
<p>RDB持久化相当于定时打一个快照进行持久化，如果打完快照后，连续自增了几次，还没来得及做下一次快照持久化，这个时候Redis挂掉了，重启Redis后会出现ID重复。</p>
<p>AOF持久化相当于对每条写命令进行持久化，如果Redis挂掉了，不会出现ID重复的现象，但是会由于incr命令过得，导致重启恢复数据时间过长。</p>
<p>原文：<a href="https://www.cnblogs.com/wuwuyong/p/12212563.html">https://www.cnblogs.com/wuwuyong/p/12212563.html</a></p>
</body></html>]]></content>
      <categories>
        <category>分布式</category>
        <category>分布式ID</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式核心</title>
    <url>/3f9bb49b.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="微服务中核心问题解决方案"><a href="#微服务中核心问题解决方案" class="headerlink" title="微服务中核心问题解决方案"></a>微服务中核心问题解决方案</h1><p>分布式id，分布式锁，鉴权，事务等等</p>
<span id="more"></span>





<h1 id="分布式id生成方案有哪些？"><a href="#分布式id生成方案有哪些？" class="headerlink" title="分布式id生成方案有哪些？"></a>分布式id生成方案有哪些？</h1><p>UUID,数据库主键自增，Redis自增ID，雪花算法。</p>
<table>
<thead>
<tr>
<th></th>
<th>描述</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>数据库主键自增</td>
<td>MySQL数据库设置主键且主键自动增长</td>
<td>1. INT和BIGINT类型占用空间较小；<br>2. 主键自动增长，IO写入连续性好；<br>3. 数字类型查询速度优于字符串</td>
<td>1. 并发性能不高，受限于数据库性能；<br>2. 分库分表，需要改造，复杂；<br>3. 自增：数据和数据量泄露</td>
</tr>
<tr>
<td>UUID</td>
<td>UUID是通用唯一标识码的缩写，其目的是让分布式系统中的所有元素都有唯一的辨识信息，而不需要通过中央控制器来指定唯一标识。</td>
<td>1. 降低全局节点的压力，使得主键生成速度更快；<br>2. 生成的主键全局唯一；<br>3. 跨服务器合并数据方便。</td>
<td>1. UUID占用16个字符，空间占用较多；<br>2. 不是递增有序的数字，数据写入IO随机性很大，且索引效率下降（mysql的B+树索引机制）</td>
</tr>
<tr>
<td>号段模式</td>
<td>量获取多个ID并缓存在本地，集群中每个mysql使用不同的自增步长</td>
<td>1. 不依赖数据库，即使数据库挂了，还能坚持一段时间<br>2.</td>
<td>1. 重启后，会造成号段丢失，ID空洞<br>2.</td>
</tr>
<tr>
<td>Redis自增</td>
<td>Redis计数器，原子性自增</td>
<td>使用内存，并发性能好</td>
<td>1. 数据丢失或者数据恢复慢；<br>2. 需要引入redis‘，而且编码和配置工作量较大<br>3. 自增：数据量泄露</td>
</tr>
<tr>
<td>雪花算法（snowflake）</td>
<td>大名鼎鼎的雪花算法，分布式ID的经典解决方案</td>
<td>1. 不依赖外部组件；<br>2. 性能好</td>
<td>1. 时钟回拨（雪花算法中部分依赖当前时间，如果时间值回拨，回造成重复）<br>2.需要为每台机器配置机器id，这个需要手动配置，工作量大容易出错</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>推荐文章：<a href="https://www.cnblogs.com/wuwuyong/p/12212563.html">https://www.cnblogs.com/wuwuyong/p/12212563.html</a></p>
<h1 id="雪花算法生成的ID由哪些部分组成"><a href="#雪花算法生成的ID由哪些部分组成" class="headerlink" title="雪花算法生成的ID由哪些部分组成?"></a>雪花算法生成的ID由哪些部分组成?</h1><ol>
<li>符号位，占用1位。</li>
<li>时间戳，占用41位，可以支持69年的时间跨度。</li>
<li>机器ID，占用10位。</li>
<li>序列号，占用12位。一毫秒可以生成4095个ID。</li>
</ol>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210521124236027.png" alt="image-20210521124236027"></p>
<h1 id="分布式锁在项目中有哪些应用场景？"><a href="#分布式锁在项目中有哪些应用场景？" class="headerlink" title="分布式锁在项目中有哪些应用场景？"></a>分布式锁在项目中有哪些应用场景？</h1><p>使用分布式锁的场景一般需要满足以下场景：</p>
<ol>
<li>系统是一个分布式系统,集群集群，java的锁已经锁不住了。</li>
<li>操作共享资源，比如库里唯一的用户数据。</li>
<li>同步访问，即多个进程同时操作共享资源。</li>
</ol>
<h1 id="分布锁有哪些解决方案？"><a href="#分布锁有哪些解决方案？" class="headerlink" title="分布锁有哪些解决方案？"></a>分布锁有哪些解决方案？</h1><ol>
<li><p>Reids的分布式锁，很多大公司会基于Reidis做扩展开发。setnx key value ex 10s，Redisson。</p>
<p>watch dog.</p>
</li>
<li><p>基于Zookeeper。临时节点，顺序节点。</p>
</li>
<li><p>基于数据库，比如Mysql。主键或唯一索引的唯一性。</p>
</li>
</ol>
<h1 id="Redis做分布式锁用什么命令？"><a href="#Redis做分布式锁用什么命令？" class="headerlink" title="Redis做分布式锁用什么命令？"></a>Redis做分布式锁用什么命令？</h1><p>SETNX<br>格式：setnx key value 将 key 的值设为 value ，当且仅当 key 不存在。<br>若给定的 key 已经存在，则 SETNX 不做任何动作,操作失败。</p>
<p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p>
<p>加锁：set key value nx ex 10s</p>
<p>释放锁：delete key</p>
<h1 id="Redis做分布式锁死锁有哪些情况，如何解决？"><a href="#Redis做分布式锁死锁有哪些情况，如何解决？" class="headerlink" title="Redis做分布式锁死锁有哪些情况，如何解决？"></a>Redis做分布式锁死锁有哪些情况，如何解决？</h1><p>情况1：加锁，没有释放锁。需要加释放锁的操作。比如delete key。</p>
<p>情况2：加锁后，程序还没有执行释放锁，程序挂了。需要用的key的过期机制。</p>
<h1 id="Redis如何做分布式锁？"><a href="#Redis如何做分布式锁？" class="headerlink" title="Redis如何做分布式锁？"></a>Redis如何做分布式锁？</h1><p>假设有两个服务A、B都希望获得锁，执行过程大致如下:</p>
<p>Step1： 服务A为了获得锁，向Redis发起如下命令: SET productId:lock 0xx9p03001 NX EX 30000 其中，”productId”由自己定义，可以是与本次业务有关的id，”0xx9p03001”是一串随机值，必须保证全局唯一，“NX”指的是当且仅当key(也就是案例中的”productId:lock”)在Redis中不存在时，返回执行成功，否则执行失败。”EX 30000”指的是在30秒后，key将被自动删除。执行命令后返回成功，表明服务成功的获得了锁。</p>
<p>Step2: 服务B为了获得锁，向Redis发起同样的命令: SET productId:lock 0000111 NX  EX 30000<br>由于Redis内已经存在同名key，且并未过期，因此命令执行失败，服务B未能获得锁。服务B进入循环请求状态，比如每隔1秒钟(自行设置)向Redis发送请求，直到执行成功并获得锁。</p>
<p>Step3: 服务A的业务代码执行时长超过了30秒，导致key超时，因此Redis自动删除了key。此时服务B再次发送命令执行成功，假设本次请求中设置的value值为0000222。此时需要在服务A中对key进行续期，watch dog。</p>
<p>Step4: 服务A执行完毕，为了释放锁，服务A会主动向Redis发起删除key的请求。注意: 在删除key之前，一定要判断服务A持有的value与Redis内存储的value是否一致。比如当前场景下，Redis中的锁早就不是服务A持有的那一把了，而是由服务2创建，如果贸然使用服务A持有的key来删除锁，则会误将服务2的锁释放掉。此外，由于删除锁时涉及到一系列判断逻辑，因此一般使用lua脚本，具体如下:</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">if redis.call("get", KEYS[<span class="number">1</span>])<span class="operator">=</span><span class="operator">=</span>ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">return</span> redis.call("del", KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>



<h1 id="基于-ZooKeeper-的分布式锁实现原理是什么"><a href="#基于-ZooKeeper-的分布式锁实现原理是什么" class="headerlink" title="基于 ZooKeeper 的分布式锁实现原理是什么?"></a>基于 ZooKeeper 的分布式锁实现原理是什么?</h1><p>顺序节点特性：</p>
<p>使用 ZooKeeper 的顺序节点特性，假如我们在/lock/目录下创建3个节点，ZK集群会按照发起创建的顺序来创建节点，节点分别为/lock/0000000001、/lock/0000000002、/lock/0000000003，最后一位数是依次递增的，节点名由zk来完成。</p>
<p>临时节点特性：</p>
<p>ZK中还有一种名为临时节点的节点，临时节点由某个客户端创建，当客户端与ZK集群断开连接，则该节点自动被删除。EPHEMERAL_SEQUENTIAL为临时顺序节点。</p>
<p>根据ZK中节点是否存在，可以作为分布式锁的锁状态，以此来实现一个分布式锁，下面是分布式锁的基本逻辑：</p>
<ol>
<li>客户端1调用create()方法创建名为“/业务ID/lock-”的临时顺序节点。</li>
<li>客户端1调用getChildren(“业务ID”)方法来获取所有已经创建的子节点。</li>
<li>客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点是所有节点中序号最小的，就是看自己创建的序列号是否排第一，如果是第一，那么就认为这个客户端1获得了锁，在它前面没有别的客户端拿到锁。</li>
<li>如果创建的节点不是所有节点中需要最小的，那么则监视比自己创建节点的序列号小的最大的节点，进入等待。直到下次监视的子节点变更的时候，再进行子节点的获取，判断是否获取锁。</li>
</ol>
<h1 id="ZooKeeper和Reids做分布式锁的区别？"><a href="#ZooKeeper和Reids做分布式锁的区别？" class="headerlink" title="ZooKeeper和Reids做分布式锁的区别？"></a>ZooKeeper和Reids做分布式锁的区别？</h1><p>Reids：</p>
<ol>
<li>Redis只保证最终一致性，副本间的数据复制是异步进行（Set是写，Get是读，Reids集群一般是读写分离架构，存在主从同步延迟情况），主从切换之后可能有部分数据没有复制过去可能会 <strong>「丢失锁」</strong> 情况，故强一致性要求的业务不推荐使用Reids，推荐使用zk。</li>
<li>Redis集群各方法的响应时间均为最低。随着并发量和业务数量的提升其响应时间会有明显上升（公网集群影响因素偏大），但是极限qps可以达到最大且基本无异常</li>
</ol>
<p>ZooKeeper：</p>
<ol>
<li>使用ZooKeeper集群，锁原理是使用ZooKeeper的临时顺序节点，临时顺序节点的生命周期在Client与集群的Session结束时结束。因此如果某个Client节点存在网络问题，与ZooKeeper集群断开连接，Session超时同样会导致锁被错误的释放（导致被其他线程错误地持有），因此ZooKeeper也无法保证完全一致。</li>
<li>ZK具有较好的稳定性；响应时间抖动很小，没有出现异常。但是随着并发量和业务数量的提升其响应时间和qps会明显下降。</li>
</ol>
<p>总结：</p>
<ol>
<li>Zookeeper每次进行锁操作前都要创建若干节点，完成后要释放节点，会浪费很多时间；</li>
<li>而Redis只是简单的数据操作，没有这个问题。</li>
</ol>
<h1 id="MySQL如何做分布式锁？"><a href="#MySQL如何做分布式锁？" class="headerlink" title="MySQL如何做分布式锁？"></a>MySQL如何做分布式锁？</h1><p>在Mysql中创建一张表，设置一个 主键或者UNIQUE KEY 这个 KEY 就是要锁的 KEY（商品ID），所以同一个 KEY 在mysql表里只能插入一次了，这样对锁的竞争就交给了数据库，处理同一个 KEY 数据库保证了只有一个节点能插入成功，其他节点都会插入失败。</p>
<p>DB分布式锁的实现：通过主键id 或者 唯一索性 的唯一性进行加锁，说白了就是加锁的形式是向一张表中插入一条数据，该条数据的id就是一把分布式锁，例如当一次请求插入了一条id为1的数据，其他想要进行插入数据的并发请求必须等第一次请求执行完成后删除这条id为1的数据才能继续插入，实现了分布式锁的功能。</p>
<p>这样 lock 和 unlock 的思路就很简单了，伪代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">def lock ：</span><br><span class="line">    exec sql: insert into locked—table (xxx) values (xxx)</span><br><span class="line">    if result == true :</span><br><span class="line">        return true</span><br><span class="line">    else :</span><br><span class="line">        return false</span><br><span class="line"></span><br><span class="line">def unlock ：</span><br><span class="line">    exec sql: delete from lockedOrder where order_id='order_id'</span><br></pre></td></tr></tbody></table></figure>





<h1 id="计数器算法是什么？"><a href="#计数器算法是什么？" class="headerlink" title="计数器算法是什么？"></a>计数器算法是什么？</h1><p>​        计数器算法，是指在指定的时间周期内累加访问次数，达到设定的阈值时，触发限流策略。下一个时间周期进行访问时，访问次数清零。此算法无论在单机还是分布式环境下实现都非常简单，使用redis的incr原子自增性，再结合key的过期时间，即可轻松实现。</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/4-6%20%E8%AE%A1%E6%95%B0%E5%99%A8%E7%AE%97%E6%B3%95-1621753094321.jpg" alt="4-6 计数器算法" style="zoom: 33%;">



<p>​        从上图我们来看，我们设置一分钟的阈值是100，在0:00到1:00内请求数是60，当到1:00时，请求数清零，从0开始计算，这时在1:00到2:00之间我们能处理的最大的请求为100，超过100个的请求，系统都拒绝。</p>
<p>​        这个算法有一个临界问题，比如在上图中，在0:00到1:00内，只在0:50有60个请求，而在1:00到2:00之间，只在1:10有60个请求，虽然在两个一分钟的时间内，都没有超过100个请求，但是在0:50到1:10这20秒内，确有120个请求，虽然在每个周期内，都没超过阈值，但是在这20秒内，已经远远超过了我们原来设置的1分钟内100个请求的阈值。</p>
<h1 id="滑动时间窗口算法是什么？"><a href="#滑动时间窗口算法是什么？" class="headerlink" title="滑动时间窗口算法是什么？"></a>滑动时间窗口算法是什么？</h1><p>​        为了解决计数器算法的临界值的问题，发明了滑动窗口算法。在TCP网络通信协议中，就采用滑动时间窗口算法来解决网络拥堵问题。</p>
<p>​        滑动时间窗口是将计数器算法中的实际周期切分成多个小的时间窗口，分别在每个小的时间窗口中记录访问次数，然后根据时间将窗口往前滑动并删除过期的小时间窗口。最终只需要统计滑动窗口范围内的小时间窗口的总的请求数即可。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/4-7%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95-1621753118270.jpg" alt="4-7 滑动窗口算法"></p>
<p>​        在上图中，假设我们设置一分钟的请求阈值是100，我们将一分钟拆分成4个小时间窗口，这样，每个小的时间窗口只能处理25个请求，我们用虚线方框表示滑动时间窗口，当前窗口的大小是2，也就是在窗口内最多能处理50个请求。随着时间的推移，滑动窗口也随着时间往前移动，比如上图开始时，窗口是0:00到0:30的这个范围，过了15秒后，窗口是0:15到0:45的这个范围，窗口中的请求重新清零，这样就很好的解决了计数器算法的临界值问题。</p>
<p>​        在滑动时间窗口算法中，我们的小窗口划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。</p>
<h1 id="漏桶限流算法是什么？"><a href="#漏桶限流算法是什么？" class="headerlink" title="漏桶限流算法是什么？"></a>漏桶限流算法是什么？</h1><p>​        漏桶算法的原理就像它的名字一样，我们维持一个漏斗，它有恒定的流出速度，不管水流流入的速度有多快，漏斗出水的速度始终保持不变，类似于消息中间件，不管消息的生产者请求量有多大，消息的处理能力取决于消费者。</p>
<p>​        漏桶的容量=漏桶的流出速度*可接受的等待时长。在这个容量范围内的请求可以排队等待系统的处理，超过这个容量的请求，才会被抛弃。</p>
<p>​        在漏桶限流算法中，存在下面几种情况：</p>
<ol>
<li><p>当请求速度大于漏桶的流出速度时，也就是请求量大于当前服务所能处理的最大极限值时，触发限流策略。</p>
</li>
<li><p>请求速度小于或等于漏桶的流出速度时，也就是服务的处理能力大于或等于请求量时，正常执行。</p>
<p>漏桶算法有一个缺点：当系统在短时间内有突发的大流量时，漏桶算法处理不了。</p>
</li>
</ol>
<h1 id="令牌桶限流算法是什么？"><a href="#令牌桶限流算法是什么？" class="headerlink" title="令牌桶限流算法是什么？"></a>令牌桶限流算法是什么？</h1><p>​        令牌桶算法，是增加一个大小固定的容器，也就是令牌桶，系统以恒定的速率向令牌桶中放入令牌，如果有客户端来请求，先需要从令牌桶中拿一个令牌，拿到令牌，才有资格访问系统，这时令牌桶中少一个令牌。当令牌桶满的时候，再向令牌桶生成令牌时，令牌会被抛弃。</p>
<p>​        在令牌桶算法中，存在以下几种情况：</p>
<ol>
<li><p>请求速度大于令牌的生成速度：那么令牌桶中的令牌会被取完，后续再进来的请求，由于拿不到令牌，会被限流。</p>
</li>
<li><p>请求速度等于令牌的生成速度：那么此时系统处于平稳状态。</p>
</li>
<li><p>请求速度小于令牌的生成速度：那么此时系统的访问量远远低于系统的并发能力，请求可以被正常处理。</p>
<p>令牌桶算法，由于有一个桶的存在，可以处理短时间大流量的场景。这是令牌桶和漏桶的一个区别。</p>
</li>
</ol>
<h1 id="你设计微服务时遵循什么原则？"><a href="#你设计微服务时遵循什么原则？" class="headerlink" title="你设计微服务时遵循什么原则？"></a>你设计微服务时遵循什么原则？</h1><ol>
<li>单一职责原则：让每个服务能独立，有界限的工作，每个服务只关注自己的业务。做到高内聚。</li>
<li>服务自治原则：每个服务要能做到独立开发、独立测试、独立构建、独立部署，独立运行。与其他服务进行解耦。</li>
<li>轻量级通信原则：让每个服务之间的调用是轻量级，并且能够跨平台、跨语言。比如采用RESTful风格，利用消息队列进行通信等。</li>
<li>粒度进化原则：对每个服务的粒度把控，其实没有统一的标准，这个得结合我们解决的具体业务问题。不要过度设计。服务的粒度随着业务和用户的发展而发展。</li>
</ol>
<p>​    总结一句话，软件是为业务服务的，好的系统不是设计出来的，而是进化出来的。</p>
<h1 id="CAP定理是什么？"><a href="#CAP定理是什么？" class="headerlink" title="CAP定理是什么？"></a>CAP定理是什么？</h1><p>​        CAP定理，又叫布鲁尔定理。指的是：在一个分布式系统中，最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p>
<ul>
<li><p>C：一致性（Consistency），数据在多个副本中保持一致，可以理解成两个用户访问两个系统A和B，当A系统数据有变化时，及时同步给B系统，让两个用户看到的数据是一致的。</p>
</li>
<li><p>A：可用性（Availability），系统对外提供服务必须一直处于可用状态，在任何故障下，客户端都能在合理时间内获得服务端非错误的响应。</p>
</li>
<li><p>P：分区容错性（Partition tolerance），在分布式系统中遇到任何网络分区故障，系统仍然能对外提供服务。网络分区，可以这样理解，在分布式系统中，不同的节点分布在不同的子网络中，有可能子网络中只有一个节点，在所有网络正常的情况下，由于某些原因导致这些子节点之间的网络出现故障，导致整个节点环境被切分成了不同的独立区域，这就是网络分区。</p>
<p>​    </p>
<p>我们来详细分析一下CAP，为什么只能满足两个。看下图所示：</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/10-4%20CAP%E6%BC%94%E7%A4%BA-1617721637028.jpg" alt="10-4 CAP演示" style="zoom: 33%;">



<p>​        用户1和用户2分别访问系统A和系统B，系统A和系统B通过网络进行同步数据。理想情况是：用户1访问系统A对数据进行修改，将data1改成了data2，同时用户2访问系统B，拿到的是data2数据。</p>
<p>​        但是实际中，由于分布式系统具有八大谬论：</p>
<ul>
<li><p>网络相当可靠</p>
</li>
<li><p>延迟为零</p>
</li>
<li><p>传输带宽是无限的</p>
</li>
<li><p>网络相当安全</p>
</li>
<li><p>拓扑结构不会改变</p>
</li>
<li><p>必须要有一名管理员</p>
</li>
<li><p>传输成本为零</p>
</li>
<li><p>网络同质化</p>
</li>
</ul>
<p>我们知道，只要有网络调用，网络总是不可靠的。我们来一一分析。</p>
<ol>
<li>当网络发生故障时，系统A和系统B没法进行数据同步，也就是我们不满足P，同时两个系统依然可以访问，那么此时其实相当于是单机系统，就不是分布式系统了，所以既然我们是分布式系统，P必须满足。</li>
<li>当P满足时，如果用户1通过系统A对数据进行了修改将data1改成了data2，也要让用户2通过系统B正确的拿到data2，那么此时是满足C，就必须等待网络将系统A和系统B的数据同步好，并且在同步期间，任何人不能访问系统B（让系统不可用），否则数据就不是一致的。此时满足的是CP。</li>
<li>当P满足时，如果用户1通过系统A对数据进行了修改将data1改成了data2，也要让系统B能继续提供服务，那么此时，只能接受系统A没有将data2同步给系统B（牺牲了一致性）。此时满足的就是AP。</li>
</ol>
</li>
</ul>
<p>​        我们在前面学过的注册中心Eureka就是满足 的AP，它并不保证C。而Zookeeper是保证CP，它不保证A。在生产中，A和C的选择，没有正确的答案，是取决于自己的业务的。比如12306，是满足CP，因为买票必须满足数据的一致性，不然一个座位多卖了，对铁路运输都是不可以接受的。</p>
<h1 id="BASE理论是什么？"><a href="#BASE理论是什么？" class="headerlink" title="BASE理论是什么？"></a>BASE理论是什么？</h1><p>由于CAP中一致性C和可用性A无法兼得，eBay的架构师，提出了BASE理论，它是通过牺牲数据的强一致性，来获得可用性。它由于如下3种特征：</p>
<ul>
<li><p><strong>B</strong>asically <strong>A</strong>vailable（基本可用）：分布式系统在出现不可预知故障的时候，允许损失部分可用性，保证核心功能的可用。</p>
</li>
<li><p><strong>S</strong>oft state（软状态）：软状态也称为弱状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。、</p>
</li>
<li><p><strong>E</strong>ventually consistent（最终一致性）：最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
</li>
</ul>
<p>​        BASE理论并没有要求数据的强一致性，而是允许数据在一定的时间段内是不一致的，但在最终某个状态会达到一致。在生产环境中，很多公司，会采用BASE理论来实现数据的一致，因为产品的可用性相比强一致性来说，更加重要。比如在电商平台中，当用户对一个订单发起支付时，往往会调用第三方支付平台，比如支付宝支付或者微信支付，调用第三方成功后，第三方并不能及时通知我方系统，在第三方没有通知我方系统的这段时间内，我们给用户的订单状态显示支付中，等到第三方回调之后，我们再将状态改成已支付。虽然订单状态在短期内存在不一致，但是用户却获得了更好的产品体验。</p>
<h1 id="2PC提交协议是什么？"><a href="#2PC提交协议是什么？" class="headerlink" title="2PC提交协议是什么？"></a>2PC提交协议是什么？</h1><p>二阶段提交(Two-phaseCommit)是指，在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。通常，二阶段提交也被称为是一种协议(Protocol))。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。因此，<strong>二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</strong></p>
<p>所谓的两个阶段是指：第一阶段：<strong>准备阶段(投票阶段)<strong>和第二阶段：</strong>提交阶段（执行阶段）</strong>。</p>
<p>准备阶段</p>
<p>事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种“万事俱备，只欠东风”的状态。</p>
<p>可以进一步将准备阶段分为以下三个步骤：</p>
<blockquote>
<p>1）协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。</p>
<p>2）参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</p>
<p>3）各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</p>
</blockquote>
<p>提交阶段</p>
<blockquote>
<p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p>
<p>接下来分两种情况分别讨论提交阶段的过程。</p>
<p>当协调者节点从所有参与者节点获得的相应消息都为”同意”时:</p>
<p><a href="http://www.hollischuang.com/wp-content/uploads/2015/12/success.png"><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/success.png" alt="success"></a></p>
<blockquote>
<p>1）协调者节点向所有参与者节点发出”正式提交(commit)”的请求。</p>
<p>2）参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</p>
<p>3）参与者节点向协调者节点发送”完成”消息。</p>
<p>4）协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。</p>
</blockquote>
</blockquote>
<p>如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</p>
<p><a href="http://www.hollischuang.com/wp-content/uploads/2015/12/fail.png"><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/fail.png" alt="fail"></a></p>
<blockquote>
<p>1）协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。</p>
<p>2）参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</p>
<p>3）参与者节点向协调者节点发送”回滚完成”消息。</p>
<p>4）协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</p>
</blockquote>
<p>　　不管最后结果如何，第二阶段都会结束当前事务。</p>
<h1 id="2PC提交协议有什么缺点？"><a href="#2PC提交协议有什么缺点？" class="headerlink" title="2PC提交协议有什么缺点？"></a>2PC提交协议有什么缺点？</h1><ol>
<li><p><strong>同步阻塞问题</strong>。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</p>
</li>
<li><p><strong>单点故障</strong>。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</p>
</li>
<li><p><strong>数据不一致</strong>。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</p>
</li>
<li><p>二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p>
</li>
</ol>
<h1 id="3PC提交协议是什么？"><a href="#3PC提交协议是什么？" class="headerlink" title="3PC提交协议是什么？"></a>3PC提交协议是什么？</h1><p>CanCommit阶段</p>
<p>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。</p>
<blockquote>
<p><strong>1.事务询问</strong> 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</p>
<p><strong>2.响应反馈</strong> 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No</p>
</blockquote>
<p>PreCommit阶段</p>
<p>协调者根据参与者的反应情况来决定是否可以进行事务的PreCommit操作。根据响应情况，有以下两种可能。</p>
<p><strong>假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。</strong></p>
<blockquote>
<p><strong>1.发送预提交请求</strong> 协调者向参与者发送PreCommit请求，并进入Prepared阶段。</p>
<p><strong>2.事务预提交</strong> 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。</p>
<p><strong>3.响应反馈</strong> 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</p>
</blockquote>
<p><strong>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</strong></p>
<blockquote>
<p><strong>1.发送中断请求</strong> 协调者向所有参与者发送abort请求。</p>
<p><strong>2.中断事务</strong> 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</p>
</blockquote>
<p>pre阶段参与者没收到请求，rollback。</p>
<p>doCommit阶段</p>
<p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p>
<p><strong>执行提交</strong></p>
<blockquote>
<p><strong>1.发送提交请求</strong> 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。</p>
<p><strong>2.事务提交</strong> 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p>
<p><strong>3.响应反馈</strong> 事务提交完之后，向协调者发送Ack响应。</p>
<p><strong>4.完成事务</strong> 协调者接收到所有参与者的ack响应之后，完成事务。</p>
</blockquote>
<p><strong>中断事务</strong> 协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。</p>
<blockquote>
<p><strong>1.发送中断请求</strong> 协调者向所有参与者发送abort请求</p>
<p><strong>2.事务回滚</strong> 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p>
<p><strong>3.反馈结果</strong> 参与者完成事务回滚之后，向协调者发送ACK消息</p>
<p><strong>4.中断事务</strong> 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</p>
</blockquote>
<h1 id="2PC和3PC的区别是什么？"><a href="#2PC和3PC的区别是什么？" class="headerlink" title="2PC和3PC的区别是什么？"></a>2PC和3PC的区别是什么？</h1><p>1、引入超时机制。同时在协调者和参与者中都引入超时机制。</p>
<p>2、三阶段在2PC的第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</p>
<ul>
<li><h1 id="TCC解决方案是什么"><a href="#TCC解决方案是什么" class="headerlink" title="TCC解决方案是什么?"></a>TCC解决方案是什么?</h1><p>​        TCC（Try-Confirm-Cancel）是一种常用的分布式事务解决方案，它将一个事务拆分成三个步骤：</p>
<ul>
<li><p>T（Try）：业务检查阶段，这阶段主要进行业务校验和检查或者资源预留；也可能是直接进行业务操作。</p>
</li>
<li><p>C（Confirm）：业务确认阶段，这阶段对Try阶段校验过的业务或者预留的资源进行确认。</p>
</li>
<li><p>C（Cancel）：业务回滚阶段，这阶段和上面的C（Confirm）是互斥的，用于释放Try阶段预留的资源或者业务。</p>
</li>
</ul>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210521230854476-1621753201509.png" alt="image-20210521230854476" style="zoom: 50%;">



<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210521230904203-1621753201509.png" alt="image-20210521230904203" style="zoom:50%;">



<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210521230919795-1621753201509.png" alt="image-20210521230912365" style="zoom:50%;">



<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210521230919795-1621753201509.png" alt="image-20210521230919795" style="zoom:50%;"></li>
</ul>
<h1 id="TCC空回滚是解决什么问题的？"><a href="#TCC空回滚是解决什么问题的？" class="headerlink" title="TCC空回滚是解决什么问题的？"></a>TCC空回滚是解决什么问题的？</h1><p>​        在没有调用TCC资源Try方法的情况下，调用了二阶段的Cancel方法。比如当Try请求由于网络延迟或故障等原因，没有执行，结果返回了异常，那么此时Cancel就不能正常执行，因为Try没有对数据进行修改，如果Cancel进行了对数据的修改，那就会导致数据不一致。<br>​        解决思路是关键就是要识别出这个空回滚。思路很简单就是需要知道Try阶段是否执行，如果执行了，那就是正常回滚；如果没执行，那就是空回滚。建议TM在发起全局事务时生成全局事务记录，全局事务ID贯穿整个分布式事务调用链条。再额外增加一张<strong>分支事务记录表</strong>，其中有全局事务ID和分支事务ID，第一阶段Try方法里会插入一条记录，表示Try阶段执行了。Cancel接口里读取该记录，如果该记录存在，则正常回滚；如果该记录不存在，则是空回滚。</p>
<h1 id="如何解决TCC幂等问题？"><a href="#如何解决TCC幂等问题？" class="headerlink" title="如何解决TCC幂等问题？"></a>如何解决TCC幂等问题？</h1><p>为了保证TCC二阶段提交重试机制不会引发数据不一致，要求TCC的二阶段Confirm和Cancel接口保证幂等，这样不会重复使用或者释放资源。如果幂等控制没有做好，很有可能导致数据不一致等严重问题。<br>解决思路在上述 <strong>分支事务记录</strong>中增加执行状态，每次执行前都查询该状态。</p>
<p>分布式锁。</p>
<h1 id="如何解决TCC中悬挂问题？"><a href="#如何解决TCC中悬挂问题？" class="headerlink" title="如何解决TCC中悬挂问题？"></a>如何解决TCC中悬挂问题？</h1><p>悬挂就是对于一个分布式事务，其二阶段Cancel接口比Try接口先执行。<br>        出现原因是在调用分支事务Try时，由于网络发生拥堵，造成了超时，TM就会通知RM回滚该分布式事务，可能回滚完成后，Try请求才到达参与者真正执行，而一个Try方法预留的业务资源，只有该分布式事务才能使用，该分布式事务第一阶段预留的业务资源就再也没有人能够处理了，对于这种情况，我们就称为悬挂，即业务资源预留后无法继续处理。<br>        解决思路是如果二阶段执行完成，那一阶段就不能再继续执行。在执行一阶段事务时判断在该全局事务下，判断<strong>分支事务记录表</strong>中是否已经有二阶段事务记录，如果有则不执行Try。</p>
<h1 id="可靠消息服务方案是什么？"><a href="#可靠消息服务方案是什么？" class="headerlink" title="可靠消息服务方案是什么？"></a>可靠消息服务方案是什么？</h1><p>​        可靠消息最终一致性方案指的是：当事务的发起方（事务参与者，消息发送者）执行完本地事务后，同时发出一条消息，事务参与方（事务参与者，消息的消费者）一定能够接受消息并可以成功处理自己的事务。</p>
<p>​        这里面强调两点：</p>
<ol>
<li>可靠消息：发起方一定得把消息传递到消费者。</li>
<li>最终一致性：最终发起方的业务处理和消费方的业务处理得完成，达成最终一致。</li>
</ol>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210522125830646.png" alt="image-20210522125830646" style="zoom: 67%;">



<h1 id="最大努力通知方案的关键是什么？"><a href="#最大努力通知方案的关键是什么？" class="headerlink" title="最大努力通知方案的关键是什么？"></a>最大努力通知方案的关键是什么？</h1><ol>
<li> 有一定的消息重复通知机制。因为接收通知方（上图中的我方支付系统）可能没有接收到通知，此时要有一定的机制对消息重复通知。</li>
<li> 消息校对机制。如果尽最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询消息信息来满足需求。</li>
</ol>
<h1 id="什么是分布式系统中的幂等？"><a href="#什么是分布式系统中的幂等？" class="headerlink" title="什么是分布式系统中的幂等？"></a>什么是分布式系统中的幂等？</h1><p>幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。</p>
<p>在编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。</p>
<p>例如，“getUsername()和 setTrue()”函数就是一个幂等函数. 更复杂的操作幂等保证是利用唯一交易号(流水号)实现. 我的理解：幂等就是一个操作，不论执行多少次，产生的效果和返回的结果都是一样的。</p>
<p>操作：查询，set固定值。逻辑删除。set 固定值。</p>
<p>流程：分布式系统中，网络调用，重试机制。</p>
<h1 id="幂等有哪些技术解决方案？"><a href="#幂等有哪些技术解决方案？" class="headerlink" title="幂等有哪些技术解决方案？"></a>幂等有哪些技术解决方案？</h1><p>1.查询操作</p>
<p>查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select 是天然的幂等操作；</p>
<p>2.删除操作</p>
<p>删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回 0，删除的数据多条，返回结果多个。</p>
<p>3.唯一索引</p>
<p>防止新增脏数据。比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建多个资金账户，那么给资金账户表中的用户 ID 加唯一索引，所以一个用户新增成功一个资金账户记录。要点：唯一索引或唯一组合索引来防止新增数据存在脏数据（当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可。</p>
<p>4.token 机制</p>
<p>防止页面重复提交。</p>
<p><strong>业务要求：</strong>页面的数据只能被点击提交一次；</p>
<p><strong>发生原因：</strong>由于重复点击或者网络重发，或者 nginx 重发等情况会导致数据被重复提交；</p>
<p><strong>解决办法：</strong>集群环境采用 token 加 redis(redis 单线程的，处理需要排队)；单 JVM 环境：采用 token 加 redis 或 token 加 jvm 锁。</p>
<p><strong>处理流程：</strong></p>
<ol>
<li>数据提交前要向服务的申请 token，token 放到 redis 或 jvm 内存，token 有效时间；</li>
<li>提交后后台校验 token，同时删除 token，生成新的 token 返回。</li>
</ol>
<p><strong>token 特点：</strong>要申请，一次有效性，可以限流。</p>
<p>注意：redis 要用删除操作来判断 token，删除成功代表 token 校验通过。</p>
<ol start="5">
<li><p>traceId</p>
<p>操作时唯一的。</p>
</li>
</ol>
<h1 id="对外提供的API如何保证幂等？"><a href="#对外提供的API如何保证幂等？" class="headerlink" title="对外提供的API如何保证幂等？"></a>对外提供的API如何保证幂等？</h1><p>举例说明： 银联提供的付款接口：需要接入商户提交付款请求时附带：source 来源，seq 序列号。</p>
<p>source+seq 在数据库里面做唯一索引，防止多次付款(并发时，只能处理一个请求) 。重点：对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源 source，一个是来源方序列号 seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。</p>
<p>注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理。</p>
<h1 id="双写一致性问题如何解决？"><a href="#双写一致性问题如何解决？" class="headerlink" title="双写一致性问题如何解决？"></a>双写一致性问题如何解决？</h1><p>先做一个说明，从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力更新即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。因此，接下来讨论的思路不依赖于给缓存设置过期时间这个方案。<br>在这里，我们讨论<strong>三种</strong>更新策略：</p>
<ol>
<li>先更新缓存，再更新数据库。（不可取）</li>
<li>先更新数据库，再更新缓存。（不可取）</li>
<li>先删除缓存，再更新数据库。（不可取）</li>
<li>先更新数据库，再删除缓存。（可取，有问题待解决）</li>
</ol>
<h3 id="大前提："><a href="#大前提：" class="headerlink" title="大前提："></a>大前提：</h3><p>先读缓存，如果缓存没有，才从数据库读取。</p>
<h3 id="1-先更新数据库，再更新缓存"><a href="#1-先更新数据库，再更新缓存" class="headerlink" title="(1)先更新数据库，再更新缓存"></a>(1)先更新数据库，再更新缓存</h3><p>这套方案，大家是普遍反对的。为什么呢？有如下两点原因。<br><strong>原因一（线程安全角度）</strong><br>同时有请求A和请求B进行更新操作，那么会出现<br>（1）线程A更新了数据库<br>（2）线程B更新了数据库<br>（3）线程B更新了缓存<br>（4）线程A更新了缓存<br>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。<br><strong>原因二（业务场景角度）</strong><br>有如下两点：<br>（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。<br>（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</p>
<p>接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。</p>
<h3 id="2-先删缓存，再更新数据库"><a href="#2-先删缓存，再更新数据库" class="headerlink" title="(2)先删缓存，再更新数据库"></a>(2)先删缓存，再更新数据库</h3><p>该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:<br>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库<br>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。<br>那么，<strong>如何解决呢？采用延时双删策略</strong></p>
<p>（1）先淘汰缓存<br>（2）再写数据库（这两步和原来一样）<br>（3）休眠1秒，再次淘汰缓存<br>这么做，可以将1秒内所造成的缓存脏数据，再次删除。<br><strong>那么，这个1秒怎么确定的，具体该休眠多久呢？</strong><br>针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。<br><strong>如果你用了mysql的读写分离架构怎么办？</strong><br>ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。<br>（1）请求A进行写操作，删除缓存<br>（2）请求A将数据写入数据库了，<br>（3）请求B查询缓存发现，缓存没有值<br>（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值<br>（5）请求B将旧值写入缓存<br>（6）数据库完成主从同步，从库变为新值<br>上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。<br><strong>采用这种同步淘汰策略，吞吐量降低怎么办？</strong><br>ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。<br><strong>第二次删除,如果删除失败怎么办？</strong><br>这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：<br>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库<br>（6）请求A试图去删除，请求B写入对的缓存值，结果失败了。<br>ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。<br><strong>如何解决呢？</strong></p>
<h3 id="3-先更新数据库，再删缓存"><a href="#3-先更新数据库，再删缓存" class="headerlink" title="(3)先更新数据库，再删缓存"></a>(3)先更新数据库，再删缓存</h3><p>首先，先说一下。老外提出了一个缓存更新套路，名为<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside">《Cache-Aside pattern》</a>。其中就指出</p>
<ul>
<li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>
<li><strong>命中</strong>：应用程序从cache中取数据，取到后返回。</li>
<li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li>
</ul>
<p>另外，知名社交网站facebook也在论文<a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf">《Scaling Memcache at Facebook》</a>中提出，他们用的也是先更新数据库，再删缓存的策略。<br><strong>这种情况不存在并发问题么？</strong><br>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生<br>（1）缓存刚好失效<br>（2）请求A查询数据库，得一个旧值<br>（3）请求B将新值写入数据库<br>（4）请求B删除缓存<br>（5）请求A将查到的旧值写入缓存<br>ok，如果发生上述情况，确实是会发生脏数据。<br><strong>然而，发生这种情况的概率又有多少呢？</strong><br>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。<br>假设，有人非要抬杠，有强迫症，一定要解决怎么办？<br><strong>如何解决上述并发问题？</strong><br>首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。<br><strong>还有其他造成不一致的原因么？</strong><br>有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。<br><strong>如何解决？</strong><br>提供一个保障的重试机制即可，这里给出两套方案。<br><strong>方案一</strong>：<br>如下图所示<br><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/o_update1.png" alt="image"><br>流程如下所示<br>（1）更新数据库数据；<br>（2）缓存因为种种问题删除失败<br>（3）将需要删除的key发送至消息队列<br>（4）自己消费消息，获得需要删除的key<br>（5）继续重试删除操作，直到成功<br>然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。<br><strong>方案二</strong>：<br><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/o_update2.png" alt="image"><br>流程如下图所示：<br>（1）更新数据库数据<br>（2）数据库会将操作信息写入binlog日志当中<br>（3）订阅程序提取出所需要的数据以及key<br>（4）另起一段非业务代码，获得该信息<br>（5）尝试删除缓存操作，发现删除失败<br>（6）将这些信息发送至消息队列<br>（7)重新从消息队列中获得该数据，重试操作。</p>
<p><strong>备注说明：</strong>上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。至于oracle中，博主目前不知道有没有现成中间件可以使用。另外，重试机制，博主是采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，这些大家可以灵活自由发挥，只是提供一个思路。</p>
<h1 id="分布式微服务项目你是如何设计的？"><a href="#分布式微服务项目你是如何设计的？" class="headerlink" title="分布式微服务项目你是如何设计的？"></a>分布式微服务项目你是如何设计的？</h1><p>我一般设计成两层：业务层和能力层（中台），业务层接受用户请求，然后通过调用能力层来完成业务逻辑。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210522172654370.png" alt="image-20210522172654370"></p>
<h1 id="认证-Authentication-和授权-Authorization-的区别是什么？"><a href="#认证-Authentication-和授权-Authorization-的区别是什么？" class="headerlink" title="认证 (Authentication) 和授权 (Authorization)的区别是什么？"></a>认证 (Authentication) 和授权 (Authorization)的区别是什么？</h1><p>Authentication（认证） 是验证您的身份的凭据（例如用户名/用户ID和密码），通过这个凭据，系统得以知道你就是你，也就是说系统存在你这个用户。所以，Authentication 被称为身份/用户验证。<br>Authorization（授权） 发生在 Authentication（认证） 之后。授权，它主要掌管我们访问系统的权限。比如有些特定资源只能具有特定权限的人才能访问比如admin，有些对系统资源操作比如删除、添加、更新只能特定人才具有。<br>这两个一般在我们的系统中被结合在一起使用，目的就是为了保护我们系统的安全性。</p>
<h1 id="Cookie-和-Session-有什么区别？如何使用Session进行身份验证？"><a href="#Cookie-和-Session-有什么区别？如何使用Session进行身份验证？" class="headerlink" title="Cookie 和 Session 有什么区别？如何使用Session进行身份验证？"></a>Cookie 和 Session 有什么区别？如何使用Session进行身份验证？</h1><p>Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<p>那么，如何使用Session进行身份验证？</p>
<p>很多时候我们都是通过 SessionID 来实现特定的用户，SessionID 一般会选择存放在 Redis 中。举个例子：用户成功登陆系统，然后返回给客户端具有 SessionID 的 Cookie，当用户向后端发起请求的时候会把 SessionID 带上，这样后端就知道你的身份状态了。关于这种认证方式更详细的过程如下：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210520130119426.png" alt="image-20210520130119426"></p>
<p>用户向服务器发送用户名和密码用于登陆系统。<br>服务器验证通过后，服务器为用户创建一个 Session，并将 Session信息存储 起来。<br>服务器向用户返回一个 SessionID，写入用户的 Cookie。<br>当用户保持登录状态时，Cookie 将与每个后续请求一起被发送出去。<br>服务器可以将存储在 Cookie 上的 Session ID 与存储在内存中或者数据库中的 Session 信息进行比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态。<br>使用 Session 的时候需要注意下面几个点：</p>
<p>依赖Session的关键业务一定要确保客户端开启了Cookie。<br>注意Session的过期时间</p>
<h1 id="为什么Cookie-无法防止CSRF攻击，而token可以？"><a href="#为什么Cookie-无法防止CSRF攻击，而token可以？" class="headerlink" title="为什么Cookie 无法防止CSRF攻击，而token可以？"></a>为什么Cookie 无法防止CSRF攻击，而token可以？</h1><p><strong>CSRF（Cross Site Request Forgery）</strong>一般被翻译为 跨站请求伪造 。那么什么是 跨站请求伪造 呢？说简单用你的身份去发送一些对你不友好的请求。举个简单的例子：</p>
<p>小壮登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小壮好奇的点开了这个链接，结果发现自己的账户少了10000元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求,也就是通过你的 Cookie 向银行发出请求。</p>
<p>&lt;a src=<a href="http://www.mybank.com/Transfer?bankId=11&amp;money=10000>%E7%A7%91%E5%AD%A6%E7%90%86%E8%B4%A2%EF%BC%8C%E5%B9%B4%E7%9B%88%E5%88%A9%E7%8E%87%E8%BF%87%E4%B8%87">http://www.mybank.com/Transfer?bankId=11&amp;money=10000&gt;科学理财，年盈利率过万</a>&lt;/&gt;<br>进行Session 认证的时候，我们一般使用 Cookie 来存储 SessionId,当我们登陆后后端生成一个SessionId放在Cookie中返回给客户端，服务端通过Redis或者其他存储工具记录保存着这个Sessionid，客户端登录以后每次请求都会带上这个SessionId，服务端通过这个SessionId来标示你这个人。如果别人通过 cookie拿到了 SessionId 后就可以代替你的身份访问系统了。</p>
<p>Session 认证中 Cookie 中的 SessionId是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。</p>
<p>但是，我们使用 token 的话就不会存在这个问题，在我们登录成功获得 token 之后，一般会选择存放在 local storage 中。然后我们在前端通过某些方式会给每个发到后端的请求加上这个 token,这样就不会出现 CSRF 漏洞的问题。因为，即使有个你点击了非法链接发送了请求到服务端，这个非法请求是不会携带 token 的，所以这个请求将是非法的。</p>
<h1 id="什么是-Token-什么是-JWT-如何基于Token进行身份验证？"><a href="#什么是-Token-什么是-JWT-如何基于Token进行身份验证？" class="headerlink" title="什么是 Token?什么是 JWT?如何基于Token进行身份验证？"></a>什么是 Token?什么是 JWT?如何基于Token进行身份验证？</h1><p>我们知道 Session 信息需要保存一份在服务器端。这种方式会带来一些麻烦，比如需要我们保证保存 Session 信息服务器的可用性、不适合移动端（依赖Cookie）等等。</p>
<p>有没有一种不需要自己存放 Session 信息就能实现身份验证的方式呢？使用 Token 即可！JWT （JSON Web Token） 就是这种方式的实现，通过这种方式服务器端就不需要保存 Session 数据了，只用在客户端保存服务端返回给客户的 Token 就可以了，扩展性得到提升。</p>
<p>JWT 本质上就一段签名的 JSON 格式的数据。由于它是带有签名的，因此接收者便可以验证它的真实性。</p>
<p>下面是 RFC 7519 对 JWT 做的较为正式的定义。</p>
<p>JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted. ——JSON Web Token (JWT)</p>
<p>JWT 由 3 部分构成:</p>
<p>Header :描述 JWT 的元数据。定义了生成签名的算法以及 Token 的类型。<br>Payload（负载）:用来存放实际需要传递的数据<br>Signature（签名）：服务器通过Payload、Header和一个密钥(secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。<br>在基于 Token 进行身份验证的的应用程序中，服务器通过Payload、Header和一个密钥(secret)创建令牌（Token）并将 Token 发送给客户端，客户端将 Token 保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 Authorization字段中：Authorization: Bearer Token。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210520130410868.png" alt="image-20210520130410868"></p>
<p>用户向服务器发送用户名和密码用于登陆系统。<br>身份验证服务响应并返回了签名的 JWT，上面包含了用户是谁的内容。<br>用户以后每次向后端发请求都在Header中带上 JWT。<br>服务端检查 JWT 并从中获取用户相关信息。</p>
<h1 id="分布式架构下，Session-共享有什么方案"><a href="#分布式架构下，Session-共享有什么方案" class="headerlink" title="分布式架构下，Session 共享有什么方案?"></a>分布式架构下，Session 共享有什么方案?</h1><ol>
<li>不要有session：但是确实在某些场景下，是可以没有session的，其实在很多接口类系统当中，都提倡【API无状态服务】；也就是每一次的接口访问，都不依赖于session、不依赖于前一次的接口访问；</li>
<li>存入cookie中：将session存储到cookie中，但是缺点也很明显，例如每次请求都得带着session，数据存储在客户端本地，是有风险的；</li>
<li>session同步：对个服务器之间同步session，这样可以保证每个服务器上都有全部的session信息，不过当服务器数量比较多的时候，同步是会有延迟甚至同步失败；</li>
<li>使用Nginx（或其他复杂均衡软硬件）中的ip绑定策略，同一个ip只能在指定的同一个机器访问，但是这样做风险也比较大，而且也是去了负载均衡的意义；</li>
<li>我们现在的系统会把session放到Redis中存储，虽然架构上变得复杂，并且需要多访问一次Redis，但是这种方案带来的好处也是很大的：实现session共享，可以水平扩展（增加Redis服务器），服务器重启session不丢失（不过也要注意session在Redis中的刷新/失效机制），不仅可以跨服务器session共享，甚至可以跨平台（例如网页端和APP端）。</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>分布式</category>
        <category>分布式核心</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>redis核心问题</title>
    <url>/e1fa6938.html</url>
    <content><![CDATA[<html><head></head><body><h2 id="redis核心问题"><a href="#redis核心问题" class="headerlink" title="redis核心问题"></a>redis核心问题</h2><p>redis线程，高并发下的缓存穿透、击穿、血崩、缓存淘汰策略、持久化机制，redis的分布式锁</p>
<span id="more"></span>

<h2 id="01-说一下在你项目中的redis的应用场景"><a href="#01-说一下在你项目中的redis的应用场景" class="headerlink" title="01.说一下在你项目中的redis的应用场景"></a>01.说一下在你项目中的redis的应用场景</h2><p>1,5大value类型 :根据我的redis课有场景的介绍</p>
<p>2,基本上就是缓存~!</p>
<p>3,为的是服务无状态,延申思考,看你的项目有哪些数据结构或对象,再单机里需要单机锁,在多机需要分布式锁,抽出来放入redis中;</p>
<p>4,无锁化</p>
<h2 id="02-redis是单线程还是多线程"><a href="#02-redis是单线程还是多线程" class="headerlink" title="02.redis是单线程还是多线程"></a>02.redis是单线程还是多线程</h2><p>1, 无论什么版本,工作线程就是一个</p>
<p>2, 6.x高版本出现了IO多线程</p>
<p>3,使用上来说,没有变化</p>
<hr>
<p>4, [去学一下系统IO课],你要真正的理解面向IO模型编程的时候,有内核的事,从内核把数据搬运到程序里这是第一步,然后,搬运回来的数据做的计算是第二步,netty</p>
<p>5,单线程,满足redis的串行原子,只不过IO多线程后,把输入/输出放到更多的线程里去并行,好处如下: 1,执行时间短,更快; 2,更好的压榨系统及硬件的资源(网卡能够高效的使用);</p>
<p>*,客户端被读取的顺序不能被保障<br>哪个顺序是可以被保障的: 在一个连接里,socket里</p>
<p>6.x以前</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210309122215735.png" alt="6.x以前" style="zoom: 67%;">缓存不严谨,尽量去分片</p>
<p> 6.x以后</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210309123037436.png" alt=" 6.x以后" style="zoom:67%;">

<h2 id="03-redis存在线程安全的问题么"><a href="#03-redis存在线程安全的问题么" class="headerlink" title="03.redis存在线程安全的问题么"></a>03.redis存在线程安全的问题么</h2><p>重复2中的单线程串行</p>
<p>redis可以保障内部串行</p>
<p>外界使用的时候要保障,业务上要自行保障顺序~!</p>
<h2 id="04-遇到过缓存穿透么"><a href="#04-遇到过缓存穿透么" class="headerlink" title="04.遇到过缓存穿透么"></a>04.遇到过缓存穿透么</h2><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210309132305485.png" alt="image-20210309132305485" style="zoom:67%;">

<h2 id="05-遇到过缓存击穿么"><a href="#05-遇到过缓存击穿么" class="headerlink" title="05.遇到过缓存击穿么"></a>05.遇到过缓存击穿么</h2><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210309133256790.png" alt="image-20210309133256790" style="zoom:67%;">

<h2 id="06-如何避免缓存雪崩"><a href="#06-如何避免缓存雪崩" class="headerlink" title="06.如何避免缓存雪崩"></a>06.如何避免缓存雪崩</h2><p>以上问题,核心就是避免DB无效/重复请求,结合图去理解</p>
<p>涉及一些架构思想上的提升</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210309133911287.png" alt="image-20210309133911287" style="zoom:67%;">



<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210309134226303.png" alt="image-20210309134226303" style="zoom:67%;">



<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210309134154406.png" alt="image-20210309134154406" style="zoom:67%;">

<h2 id="07-缓存课后解答"><a href="#07-缓存课后解答" class="headerlink" title="07.缓存课后解答"></a>07.缓存课后解答</h2><ol>
<li><p>如果查询的key缓存也没有DB也没有,访问的量又比较大会怎么样?</p>
</li>
<li><p>6.x多线程IO模式下,是怎么保证事务的?<br>事务有queue的</p>
</li>
</ol>
<h2 id="08-redis是怎么删除过期key的-缓存时如何回收的"><a href="#08-redis是怎么删除过期key的-缓存时如何回收的" class="headerlink" title="08.redis是怎么删除过期key的(缓存时如何回收的)"></a>08.redis是怎么删除过期key的(缓存时如何回收的)</h2><p>1,后台在轮询,分段分批的删除那些过期的key</p>
<p>2,请求的时候判断是否已经过期了</p>
<p>尽量的把内存无用空间回收回来</p>
<h2 id="09-缓存是如何淘汰的"><a href="#09-缓存是如何淘汰的" class="headerlink" title="09.缓存是如何淘汰的"></a>09.缓存是如何淘汰的</h2><p>0,内存空间不足的情况下:</p>
<p>1,淘汰机制里有不允许淘汰</p>
<p>2,lru/lfu/random/TTL</p>
<p>3,全空间</p>
<p>4,设置过期的key的</p>
<h2 id="10-如何进行缓存预热"><a href="#10-如何进行缓存预热" class="headerlink" title="10.如何进行缓存预热"></a>10.如何进行缓存预热</h2><p>1,提前把数据塞入redis,(你知道那些是热数据么?肯定不知道,会造成上线很多数据没有缓存命中)</p>
<p>2,开发逻辑上也要规避差集(你没缓存的),会造成击穿,穿透,雪崩,实施4,5,6中的锁方案</p>
<p>3,一劳永逸,未来也不怕了</p>
<p>*结合4,5,</p>
<h2 id="10-如何进行缓存预热-1"><a href="#10-如何进行缓存预热-1" class="headerlink" title="10.如何进行缓存预热"></a>10.如何进行缓存预热</h2><p>1,提前把数据塞入redis,(你知道那些是热数据么?肯定不知道,会造成上线很多数据没有缓存命中)</p>
<p>2,开发逻辑上也要规避差集(你没缓存的),会造成击穿,穿透,雪崩,实施4,5,6中的锁方案</p>
<p>3,一劳永逸,未来也不怕了</p>
<p>*结合4,5,</p>
<h2 id="12-简述一下主从不一致的问题"><a href="#12-简述一下主从不一致的问题" class="headerlink" title="12.简述一下主从不一致的问题?"></a>12.简述一下主从不一致的问题?</h2><p>1,redis的确默认时弱一致性,异步的同步</p>
<p>2,锁不能用主从(单实例/分片集群/redlock)==&gt;redisson</p>
<p>3,在配置中提供了必须有多少个client连接能同步,你可以配置同步因子,趋向于强一致性</p>
<p>4,wait 2 0    小心</p>
<p>5,34点就有点违背</p>
<h2 id="13-描述一下持久化原理"><a href="#13-描述一下持久化原理" class="headerlink" title="13.描述一下持久化原理"></a>13.描述一下持久化原理</h2><p>当前线程阻塞服务</p>
<p>异步后台进程完成持久</p>
<p>fork + cow</p>
<h2 id="14-描述一下redis持久化方式"><a href="#14-描述一下redis持久化方式" class="headerlink" title="14.描述一下redis持久化方式?"></a>14.描述一下redis持久化方式?</h2><p>1,RDB,AOF;主从同步也算持久化</p>
<p>2,高版本;开启AOF,AOF时可以通过执行日志得到全部内存数据的方式,但是追求性能</p>
<p>2.1,体积变大,重复无效指令    重写,后台用线程把内存的kv生成指令写个新的aof</p>
<p>2.2,4.x 新</p>
<h2 id="15-Redis也打不住了-万级流量回答到DB上-该怎么处理"><a href="#15-Redis也打不住了-万级流量回答到DB上-该怎么处理" class="headerlink" title="15.Redis也打不住了,万级流量回答到DB上,该怎么处理?"></a>15.Redis也打不住了,万级流量回答到DB上,该怎么处理?</h2><p>见456</p>
<h2 id="16-redis中的事务三条指令是什么-第三条指令到达后执行失败了-怎么处理"><a href="#16-redis中的事务三条指令是什么-第三条指令到达后执行失败了-怎么处理" class="headerlink" title="16.redis中的事务三条指令是什么,第三条指令到达后执行失败了,怎么处理"></a>16.redis中的事务三条指令是什么,第三条指令到达后执行失败了,怎么处理</h2><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210308195931941.png" alt="image-20210308195931941" style="zoom:67%;">

<h2 id="17-为什么使用setnx-redis实现分布式锁的指令"><a href="#17-为什么使用setnx-redis实现分布式锁的指令" class="headerlink" title="17.为什么使用setnx(redis实现分布式锁的指令)"></a>17.为什么使用setnx(redis实现分布式锁的指令)</h2><p>1,好东西,原子    (不存在的情况下完成创建)</p>
<p>1,如果要做分布式锁,就要用set k v nx ex    (不存在,过期时间,避免死锁)</p>
</body></html>]]></content>
      <categories>
        <category>— redis - redis核心问题</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis分布式锁</title>
    <url>/e2ee4148.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>为了保证数据的一致性，在一些业务处理中都会选择加锁来保证数据的一致性。在单机模式下我们通常选择使用synchronized等这种JAVA提供好的jvm锁来实现，但是在集群和分布式情况下，这种jvm级别的锁式无法满足我们的需求，因为一个服务部署在多台服务器上，这些服务器上的jvm是无法通讯的，所以我们需要一种方案来解决分布式情况下数据一致性。</p>
<p>在互联网公司，基本上企业内部都会有自己的一套分布式锁开发框架</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式锁一般有三种实现方式：</p>
<ol>
<li>数据库乐观锁</li>
<li>基于redis实现分布式锁</li>
<li>基于zooKeeper实习哪分布式锁</li>
</ol>
<p>本次讲着重介绍redis实现分布式锁，和与数据库和zooKeeper实习分布式锁的对比。</p>
<h1 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h1><p>为了保证分布式锁的<code>可用</code>，我们至少要保证锁的实现同时满足以下四个条件：</p>
<ol>
<li>互斥性。在任意时刻，只能有一个客户端持有锁</li>
<li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁</li>
<li>具有容错性。只要大部分的redis节点正常运行，客户端就可以加锁和解锁</li>
<li>解铃还须系铃人。加锁和解锁的对象必须是同一个客户端，客户端不能把别人加的锁给解了。</li>
</ol>
<h1 id="redis锁演变过程"><a href="#redis锁演变过程" class="headerlink" title="redis锁演变过程"></a>redis锁演变过程</h1><p>redis本地部署</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">-Dserver.port=<span class="number">8082</span></span><br></pre></td></tr></tbody></table></figure>

<p>Dashboard复制项目后不同端口号运行</p>
<h2 id="单机不安全"><a href="#单机不安全" class="headerlink" title="单机不安全"></a>单机不安全</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  String <span class="title">decuctStock</span><span class="params">()</span> </span>{</span><br><span class="line">     <span class="comment">// 从redis中拿到stock的数量</span></span><br><span class="line">    <span class="keyword">int</span> stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(<span class="string">"stock"</span>)));</span><br><span class="line">    <span class="comment">// stock数量大于零的时候才进行扣减</span></span><br><span class="line">    <span class="keyword">if</span> (stock &gt; <span class="number">0</span>){</span><br><span class="line">        <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">"stock"</span>, realStock + <span class="string">""</span>);</span><br><span class="line">        System.out.println(<span class="string">"扣减库存成功，剩余库存："</span> + realStock + <span class="string">"         卖出数量为："</span> + count.addAndGet(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"扣减库存成功"</span>;</span><br><span class="line">    }<span class="keyword">else</span> {</span><br><span class="line">        System.out.println(<span class="string">"扣减库存失败，库存不足"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"扣减库存失败，库存不足"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在高并发情况下，这种写法肯定会导致超卖现象。假如有3个线程同时从redis中读取stock数据，假如这个时候均为200，然后同时判断都大于零，然后进入减库存操作，都减去一，这个时候在写入数据，那么这个时候三个线程下订单结果库存才减了一；</p>
<ul>
<li><p>jmeter压测</p>
<ul>
<li>100个线程并发</li>
<li>延迟0秒</li>
<li>循环三次</li>
</ul>
</li>
<li><p>总库存为200</p>
</li>
</ul>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210901095800868.png" alt="image-20210901095800868" style="zoom:50%;">

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">扣减库存成功，剩余库存：<span class="number">199</span>         卖出数量为：<span class="number">1</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">198</span>         卖出数量为：<span class="number">2</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">197</span>         卖出数量为：<span class="number">3</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">196</span>         卖出数量为：<span class="number">4</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">196</span>         卖出数量为：<span class="number">5</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">196</span>         卖出数量为：<span class="number">6</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">195</span>         卖出数量为：<span class="number">7</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">195</span>         卖出数量为：<span class="number">8</span></span><br><span class="line">.....</span><br><span class="line">扣减库存成功，剩余库存：<span class="number">2</span>         卖出数量为：<span class="number">257</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">1</span>         卖出数量为：<span class="number">258</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">0</span>         卖出数量为：<span class="number">259</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line">扣减库存失败，库存不足</span><br></pre></td></tr></tbody></table></figure>



<h2 id="单机安全"><a href="#单机安全" class="headerlink" title="单机安全"></a>单机安全</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  String <span class="title">decuctStock</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 从redis中拿到stock的数量</span></span><br><span class="line">    <span class="keyword">int</span> stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(<span class="string">"stock"</span>)));</span><br><span class="line">    <span class="comment">// stock数量大于零的时候才进行扣减</span></span><br><span class="line">    <span class="keyword">if</span> (stock &gt; <span class="number">0</span>){</span><br><span class="line">        <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">"stock"</span>, realStock + <span class="string">""</span>);</span><br><span class="line">        System.out.println(<span class="string">"扣减库存成功，剩余库存："</span> + realStock + <span class="string">"         卖出数量为："</span> + count.addAndGet(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"扣减库存成功"</span>;</span><br><span class="line">    }<span class="keyword">else</span> {</span><br><span class="line">        System.out.println(<span class="string">"扣减库存失败，库存不足"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"扣减库存失败，库存不足"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="单机压测"><a href="#单机压测" class="headerlink" title="单机压测"></a>单机压测</h3><ul>
<li><p>jmeter压测</p>
<ul>
<li>100个线程并发</li>
<li>延迟0秒</li>
<li>循环三次</li>
</ul>
</li>
<li><p>总库存为200</p>
</li>
<li><p>redis单机本地部署</p>
</li>
</ul>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210901100029412.png" alt="image-20210901100029412" style="zoom:50%;">

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">扣减库存成功，剩余库存：<span class="number">199</span>         卖出数量为：<span class="number">1</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">198</span>         卖出数量为：<span class="number">2</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">197</span>         卖出数量为：<span class="number">3</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">196</span>         卖出数量为：<span class="number">4</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">扣减库存成功，剩余库存：<span class="number">3</span>         卖出数量为：<span class="number">197</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">2</span>         卖出数量为：<span class="number">198</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">1</span>         卖出数量为：<span class="number">199</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">0</span>         卖出数量为：<span class="number">200</span></span><br></pre></td></tr></tbody></table></figure>

<p>加入synchronized后能保证单机的数据一致性，但是当这个服务是集群部署的时候，加上负载均衡，jvm级别的锁不能保证线程安全</p>
<h3 id="集群压测"><a href="#集群压测" class="headerlink" title="集群压测"></a>集群压测</h3><ul>
<li>jmeter压测<ul>
<li>100个线程并发</li>
<li>延迟0秒</li>
<li>循环4次</li>
</ul>
</li>
<li>总库存为200</li>
<li>redis单机本地部署</li>
<li>三个服务集群</li>
<li>geteway（本地部署）轮询负载均衡</li>
</ul>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210901104535887.png" alt="image-20210901104535887" style="zoom:50%;">



<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 第一台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">0</span>         卖出数量为：<span class="number">122</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">// 第二台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">0</span>         卖出数量为：<span class="number">115</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">// 第三台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">0</span>         卖出数量为：<span class="number">95</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line">    </span><br><span class="line"><span class="comment">//总卖出数量为：122+115+95=332</span></span><br></pre></td></tr></tbody></table></figure>



<p>优势：单机情况下能够保证数据一致性</p>
<p>劣势：不能保证在分布式情况下的数据一致性</p>
<h2 id="集群安全之redis的SETNX实现"><a href="#集群安全之redis的SETNX实现" class="headerlink" title="集群安全之redis的SETNX实现"></a>集群安全之redis的SETNX实现</h2><p>redis是原子性，可以使用redis api的setnx方法解决。把所有的线程并行请求转为redis中的串行请求。</p>
<p>Redis Setnx（<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists） 命令在指定的 key 不存在时，为 key 设置指定的值。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">redis&gt; EXISTS job                # job 不存在</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETNX job "programmer"    # job 设置成功</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SETNX job "code-farmer"   # 尝试覆盖 job ，失败</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GET job                   # 没有被覆盖</span><br><span class="line">"programmer"</span><br></pre></td></tr></tbody></table></figure>



<p>思想：</p>
<p>所有请求先去到redis中设置相同的key，只有设置成功的那个线程才能执行下面的业务逻辑，当业务逻辑执行完成后删除key，然后其他线程能够再次拿到key，执行。</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="集群压测-1"><a href="#集群压测-1" class="headerlink" title="集群压测"></a>集群压测</h4><ul>
<li>jmeter压测<ul>
<li>100个线程并发</li>
<li>延迟0秒</li>
<li>循环4次</li>
</ul>
</li>
<li>总库存为200</li>
<li>redis单机本地部署</li>
<li>三个服务集群</li>
<li>geteway（本地部署）轮询负载均衡</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  String <span class="title">decuctStock</span><span class="params">()</span> </span>{</span><br><span class="line">       <span class="comment">//当先线程设置redis锁</span></span><br><span class="line">       Boolean isExist = stringRedisTemplate.opsForValue().setIfAbsent(<span class="string">"stocklock"</span>, <span class="string">""</span>);</span><br><span class="line">       <span class="comment">// 如果没有拿到锁，怎返回，或者不断重试</span></span><br><span class="line">       <span class="keyword">if</span> (isExist != <span class="keyword">null</span> &amp;&amp; !isExist){</span><br><span class="line">           <span class="keyword">try</span> {</span><br><span class="line">               Thread.sleep(<span class="number">50</span>);</span><br><span class="line">           } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">               e.printStackTrace();</span><br><span class="line"></span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">return</span> decuctStock();</span><br><span class="line">       }<span class="keyword">else</span> <span class="keyword">if</span> (isExist == <span class="keyword">null</span>){</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"程序错误"</span>;</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 从redis中拿到stock的数量</span></span><br><span class="line">       <span class="keyword">int</span> stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(<span class="string">"stock"</span>)));</span><br><span class="line">       <span class="comment">// stock数量大于零的时候才进行扣减</span></span><br><span class="line">       <span class="keyword">if</span> (stock &gt; <span class="number">0</span>){</span><br><span class="line">           <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">           stringRedisTemplate.opsForValue().set(<span class="string">"stock"</span>, realStock + <span class="string">""</span>);</span><br><span class="line">           System.out.println(<span class="string">"扣减库存成功，剩余库存："</span> + realStock + <span class="string">"         卖出数量为："</span> + count.addAndGet(<span class="number">1</span>));</span><br><span class="line">           <span class="comment">// 删除锁</span></span><br><span class="line">           stringRedisTemplate.delete(<span class="string">"stocklock"</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"扣减库存成功"</span>;</span><br><span class="line">       }<span class="keyword">else</span> {</span><br><span class="line">           stringRedisTemplate.delete(<span class="string">"stocklock"</span>);</span><br><span class="line">           System.out.println(<span class="string">"扣减库存失败，库存不足"</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"扣减库存失败，库存不足"</span>;</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>



<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210901111405543.png" alt="image-20210901111405543" style="zoom:50%;">

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 第一台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">0</span>         卖出数量为：<span class="number">94</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">// 第二台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">1</span>         卖出数量为：<span class="number">60</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">// 第三台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">9</span>         卖出数量为：<span class="number">46</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">//总卖出数量为：94+60+46=200</span></span><br></pre></td></tr></tbody></table></figure>

<p>总卖出数量为200，符合我们的预期</p>
<h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><p> 这样看来我们的程序是不是达到了分布式锁的目的，在分布式条件下，我们的库存和我们预想的情况下一样。但是我们在看一下上面保证分布式情况下的可靠性条件</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">为了保证分布式锁的`可用`，我们至少要保证锁的实现同时满足以下四个条件：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 互斥性。在任意时刻，只能有一个客户端持有锁</span><br><span class="line"><span class="number">2.</span> 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁</span><br><span class="line"><span class="number">3.</span> 具有容错性。只要大部分的redis节点正常运行，客户端就可以加锁和解锁</span><br><span class="line"><span class="number">4.</span> 解铃还须系铃人。加锁和解锁的对象必须是同一个客户端，客户端不能把别人加的锁给解了。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>互斥性问题解决了，然后看我的程序会不会发生死锁</strong></p>
<p><strong>如果在运行的过程中，突然一台机器宕机会发生什么</strong></p>
<p>为了模拟上述情况，更改代码，主要在删除stocklock前，设置一个长时间的休眠，方便我们能够宕机一个服务</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public  String decuctStock() {</span><br><span class="line">       //当先线程设置redis锁</span><br><span class="line">       Boolean isExist = stringRedisTemplate.opsForValue().setIfAbsent("stocklock", "stocklock");</span><br><span class="line">       // 如果没有拿到锁，怎返回，或者不断重试</span><br><span class="line">       if (isExist != null &amp;&amp; !isExist){</span><br><span class="line">           try {</span><br><span class="line">               Thread.sleep(50);</span><br><span class="line">           } catch (InterruptedException e) {</span><br><span class="line">               e.printStackTrace();</span><br><span class="line"></span><br><span class="line">           }</span><br><span class="line">           return decuctStock();</span><br><span class="line">       }else if (isExist == null){</span><br><span class="line">           return "程序错误";</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       // 从redis中拿到stock的数量</span><br><span class="line">       int stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get("stock")));</span><br><span class="line">       // stock数量大于零的时候才进行扣减</span><br><span class="line">       if (stock &gt; 0){</span><br><span class="line">           int realStock = stock - 1;</span><br><span class="line">           stringRedisTemplate.opsForValue().set("stock", realStock + "");</span><br><span class="line">           System.out.println("扣减库存成功，剩余库存：" + realStock + "         卖出数量为：" + count.addAndGet(1));</span><br><span class="line">           // 删除锁</span><br><span class="line">           try {</span><br><span class="line">               Thread.sleep(3000);</span><br><span class="line">           } catch (InterruptedException e) {</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           }</span><br><span class="line">           stringRedisTemplate.delete("stocklock");</span><br><span class="line">           return "扣减库存成功";</span><br><span class="line">       }else {</span><br><span class="line">           // 删除锁</span><br><span class="line">           try {</span><br><span class="line">               Thread.sleep(3000);</span><br><span class="line">           } catch (InterruptedException e) {</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           }</span><br><span class="line">           stringRedisTemplate.delete("stocklock");</span><br><span class="line">           System.out.println("扣减库存失败，库存不足");</span><br><span class="line">           return "扣减库存失败，库存不足";</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 第一台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">199</span>         卖出数量为：<span class="number">1</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">195</span>         卖出数量为：<span class="number">2</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">193</span>         卖出数量为：<span class="number">3</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">192</span>         卖出数量为：<span class="number">4</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">188</span>         卖出数量为：<span class="number">5</span></span><br><span class="line"><span class="comment">// 第二台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">197</span>         卖出数量为：<span class="number">1</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">194</span>         卖出数量为：<span class="number">2</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">191</span>         卖出数量为：<span class="number">3</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">189</span>         卖出数量为：<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">198</span>         卖出数量为：<span class="number">1</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">196</span>         卖出数量为：<span class="number">2</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">190</span>         卖出数量为：<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在运行过程中把第一台服务器停止，然后整个项目陷入一直死锁状态，控制台没有打印</span></span><br></pre></td></tr></tbody></table></figure>

<p>查看redis中的key，发现stocklock存在，说明刚刚在停止第一台服务器的时候，这个key没有删除，所以造成了整个项目的死锁</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210901142008719.png" alt="image-20210901142008719"></p>
<h3 id="改进一"><a href="#改进一" class="headerlink" title="改进一"></a>改进一</h3><p>基础版的主要问题是如果一个客户端在持有锁的过程中因为种种问题，没有主动解锁，那么整个项目将发生死锁。</p>
<p>所以在改进一种可以设置一个超时时间，如果客户端在持有锁的过程中宕机，那么可以等待过了超时时间后，解除死锁。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//设置锁的时候，添加一个超时时间</span></span><br><span class="line">Boolean isExist = stringRedisTemplate.opsForValue().setIfAbsent(<span class="string">"stocklock"</span>, <span class="string">"stocklock"</span>,<span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210901144358811.png" alt="image-20210901144358811"></p>
<p>这样即时一个服务在持有锁的情况下宕机了，没有即时删除key，仍有一个过期时间，在过期时间到了后，整个项目仍然可以正常运行。</p>
<h3 id="改进二"><a href="#改进二" class="headerlink" title="改进二"></a>改进二</h3><p>着看改进一就没有问题了吗，如果在程序运行过程中，一个程序因为未知原因（cpu卡顿，业务逻辑卡顿，业务逻辑中的网络卡顿等等），在过期时间内还没有运行完成，然后这个时候key过期了。这个时候就想当与锁释放了，然后第二个线程就拿到了锁，然后线程进来了，然后在第二个线程运行过程中，第一个线程删除了这个key，这个时候删除了就是第二个线程的key，然后如果整个项目这样一直迭代，那么肯定会出现大量的超卖现象。</p>
<p>之前的方案：</p>
<ul>
<li>可以保证互斥性</li>
<li>可以保证不能发生死锁</li>
<li>但是不能保证解铃还须系铃人</li>
</ul>
<p>第一个线程把第二个线程的锁释放了。</p>
<p>所以，再次改进，然后想到了CAS中的ABA问题，CAS的解决方案是添加了一个线程id，这个线程在一个jvm中是唯一的，在改变值的时候不仅要判断值是否想当，还需要判断这个线程id是否相等</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">decuctStock</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//当先线程设置redis锁</span></span><br><span class="line">        <span class="comment">// 在这只value的时候，添加了额一个uuid，保证唯一性，只有当前线程能够释放</span></span><br><span class="line">        String clientUuid =  UUID.randomUUID().toString();</span><br><span class="line">        Boolean isExist = stringRedisTemplate.opsForValue().setIfAbsent(<span class="string">"stocklock"</span>, clientUuid,<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 如果没有拿到锁，怎返回，或者不断重试</span></span><br><span class="line">        <span class="keyword">if</span> (isExist != <span class="keyword">null</span> &amp;&amp; !isExist) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> decuctStock();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (isExist == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"程序错误"</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从redis中拿到stock的数量</span></span><br><span class="line">        <span class="keyword">int</span> stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(<span class="string">"stock"</span>)));</span><br><span class="line">        <span class="comment">// stock数量大于零的时候才进行扣减</span></span><br><span class="line">        <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">"stock"</span>, realStock + <span class="string">""</span>);</span><br><span class="line">            System.out.println(<span class="string">"扣减库存成功，剩余库存："</span> + realStock + <span class="string">"         卖出数量为："</span> + count.addAndGet(<span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 删除锁</span></span><br><span class="line">            <span class="keyword">if</span> (clientUuid.equals(stringRedisTemplate.opsForValue().get(<span class="string">"stocklock"</span>)) ){</span><br><span class="line">                stringRedisTemplate.delete(<span class="string">"stocklock"</span>);</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"扣减库存成功"</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 删除锁</span></span><br><span class="line">            <span class="keyword">if</span> (clientUuid.equals(stringRedisTemplate.opsForValue().get(<span class="string">"stocklock"</span>)) ){</span><br><span class="line">                stringRedisTemplate.delete(<span class="string">"stocklock"</span>);</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"扣减库存失败，库存不足"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"扣减库存失败，库存不足"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>但是这样真的能够解决了吗，如果是在判断这两个值相等后，这个缓存时间过期了，然后第二个线程拿到了这个锁，然后在执行的过程中，第一个线程删除了这把锁。</p>
<p>这样不是还有上述问题。</p>
<p>所以我们必须要保证删除锁的过程中的原子性：</p>
<h4 id="lua脚本"><a href="#lua脚本" class="headerlink" title="lua脚本"></a>lua脚本</h4><p>一下lua脚本不确定是否正确：</p>
<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> key = <span class="string">"rate.limit:"</span> .. KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> expire_time = ARGV[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> is_exists = redis.call(<span class="string">"EXISTS"</span>, key)</span><br><span class="line"><span class="keyword">if</span> is_exists == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> redis.call(<span class="string">"INCR"</span>, key) &gt; limit <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">"SET"</span>, key, <span class="number">1</span>)</span><br><span class="line">    redis.call(<span class="string">"EXPIRE"</span>, key, expire_time)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">accessLimit</span><span class="params">(String ip, <span class="keyword">int</span> limit, <span class="keyword">int</span> timeout, Jedis connection)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    List&lt;String&gt; keys = Collections.singletonList(ip);</span><br><span class="line">    List&lt;String&gt; argv = Arrays.asList(String.valueOf(limit), String.valueOf(timeout));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> == (<span class="keyword">long</span>) connection.eval(loadScriptString(<span class="string">"script.lua"</span>), keys, argv);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载Lua代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">loadScriptString</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    Reader reader = <span class="keyword">new</span> InputStreamReader(Client.class.getClassLoader().getResourceAsStream(fileName));</span><br><span class="line">    <span class="keyword">return</span> CharStreams.toString(reader);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>lua脚本能够保证redis执行的原子性</p>
<p>这样能够解决解铃还须系铃人问题，但是还有一个问题没有解决，那么就是<strong>如果程序运行时间超过了设定的过期时间</strong>，第二个线程拿到了这个锁，虽然第一个线程不能删除第二个删除的锁，但是第一个线程可以修改这个库存值，这样还是会造成一个超卖问题。</p>
<p>存在问题：</p>
<ol>
<li>非高可用</li>
<li>不支持阻塞和非阻塞</li>
</ol>
<h3 id="改进三"><a href="#改进三" class="headerlink" title="改进三"></a>改进三</h3><p>这个可以设置一个监听线程，如果线程在这个锁三份之一的时间内还有没完成业务逻辑，那么就为这把锁续命延长时间，在延长一定次数后，直接回滚，放弃本次操作</p>
<p>但是这样，为造成我们编写程序的复杂性，每次这样的业务逻辑都要写这么多的代码吗？所以引申出来了一个分布式redisson框架</p>
<h4 id="redisson优势"><a href="#redisson优势" class="headerlink" title="redisson优势"></a>redisson优势</h4><ul>
<li>redisson所有指令都通过lua脚本执行，redis支持lua脚本原子执行</li>
<li>rediss设置key默认时间为30s，如果一个客户端持有锁的时间超过了30秒呢？<ul>
<li>redison中有watchdog（监听器），在你获取锁后，每隔10秒后帮你把key的超时时间设为30s，一直续期</li>
<li>如果不想一直续期，可以不使用默认，设置过期时间，然后要设置回滚</li>
</ul>
</li>
<li>redisson的的监听器保证了没有死锁发生<ul>
<li>如果及其宕机了，他也就不会自动续期了，过期后其他线程就可以拿到锁</li>
</ul>
</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Redisson <span class="title">redisson</span> <span class="params">()</span> </span>{</span><br><span class="line">    Config cfg = <span class="keyword">new</span> Config();</span><br><span class="line">    <span class="comment">// 可以设置redis集群</span></span><br><span class="line">    cfg.useSingleServer().setAddress(<span class="string">"redis://localhost:6379"</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (Redisson) Redisson.create(cfg);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 添加事务，如果中间遇到卡段，一直在运行，在超过30秒后redisson释放锁并抛出异常，然后@Transactional检测到异常事务后回滚</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decuctStock</span><span class="params">()</span> </span>{</span><br><span class="line">        RLock stocklock = redisson.getLock(<span class="string">"stocklock"</span>);</span><br><span class="line">        String returnResult = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//设置加锁只有30秒，超过30秒则放弃</span></span><br><span class="line">            stocklock.lock(<span class="number">30</span>,TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">int</span> stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(<span class="string">"stock"</span>)));</span><br><span class="line">            <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(<span class="string">"stock"</span>, realStock + <span class="string">""</span>);</span><br><span class="line">                System.out.println(<span class="string">"扣减库存成功，剩余库存："</span> + realStock + <span class="string">"         卖出数量为："</span> + count.addAndGet(<span class="number">1</span>));</span><br><span class="line">                returnResult = <span class="string">"扣减库存成功"</span>;</span><br><span class="line"></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                System.out.println(<span class="string">"扣减库存失败，库存不足"</span>);</span><br><span class="line">                returnResult = <span class="string">"扣减库存失败，库存不足"</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (stocklock != <span class="keyword">null</span> &amp;&amp; stocklock.isHeldByCurrentThread()) {</span><br><span class="line">                stocklock.unlock();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> returnResult;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="集群压测-2"><a href="#集群压测-2" class="headerlink" title="集群压测"></a>集群压测</h4><ul>
<li>jmeter压测<ul>
<li>100个线程并发</li>
<li>延迟0秒</li>
<li>循环4次</li>
</ul>
</li>
<li>总库存为200</li>
<li>redis单机本地部署</li>
<li>三个服务集群</li>
<li>geteway（本地部署）轮询负载均衡</li>
<li>redisson分布式锁框架</li>
</ul>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210901162657634.png" alt="image-20210901162657634"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 第一台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">1</span>         卖出数量为：<span class="number">70</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">// 第二台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">0</span>         卖出数量为：<span class="number">60</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">// 第三台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">2</span>         卖出数量为：<span class="number">70</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">//总卖出数量为：70+60+70=200</span></span><br></pre></td></tr></tbody></table></figure>



<h1 id="redisson分布式锁的实现原理"><a href="#redisson分布式锁的实现原理" class="headerlink" title="redisson分布式锁的实现原理"></a>redisson分布式锁的实现原理</h1><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMS41MWN0by5jb20vaW1hZ2VzL2Jsb2cvMjAxOTA4LzExL2IwNWQzNDBkOTE2YzUyMjBlYmNmZTc0OTgwYmY2ZjIxLnBuZw?x-oss-process=image/format,png" alt="Redis如何实现高并发分布式锁？"></p>
<p>但是这个架构还是存在问题的，因为redis服务器是主从的架构，当在master节点设置锁之后，slave节点会立刻同步。但是如果刚在master节点设置上了锁，slave节点还没来得及设置，master节点就挂掉了。还是会产生上同样的问题，新的线程获得锁。</p>
<p>redisson有解决方案（redlock），但是解决方案存在争议</p>
<h1 id="redis分布式锁和zookeeper分布式锁"><a href="#redis分布式锁和zookeeper分布式锁" class="headerlink" title="redis分布式锁和zookeeper分布式锁"></a>redis分布式锁和zookeeper分布式锁</h1><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>redis实现分布式锁是AP高可用</p>
<p>redis在向主节点加锁后，可以直接返回给客户端，性能较高</p>
<p>redis适合在单机情况下，在主从模式下Redis作者antirez提出了RedLock算法</p>
<p>这个场景是假设有一个redis cluster，有5个redis master实例。然后执行如下步骤获取一把锁：</p>
<ul>
<li><p>获取当前时间戳，单位是毫秒</p>
</li>
<li><p>轮流尝试在每个master节点上创建锁，过期时间较短，一般就几十毫秒</p>
</li>
<li><p>尝试在大多数节点上建立一个锁，比如5个节点就要求是3个节点（n / 2 +1）</p>
</li>
<li><p>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了</p>
</li>
<li><p>要是锁建立失败了，那么就依次删除这个锁</p>
</li>
<li><p>只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁</p>
</li>
</ul>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/720994-20181209150457361-385299448.png" alt="img"></p>
<p>但是不推荐使用redlock，还有写bug。如果非要保证强一致行，可以考虑使用zookeeper，如果为了高可用，高性能，允许少量的数据不一致（这个可以通过后期log日志维护），可以使用redis。</p>
<h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><p>zookeeper实现分布式锁是CP强一致</p>
<p>zookeeper想主节点加锁后，会通知从节点，只有一半以上的节点都加锁成功后，才会返回给客户端</p>
<h1 id="redisson（redis）分布式锁和curator（zookeeper）分布式锁对比"><a href="#redisson（redis）分布式锁和curator（zookeeper）分布式锁对比" class="headerlink" title="redisson（redis）分布式锁和curator（zookeeper）分布式锁对比"></a>redisson（redis）分布式锁和curator（zookeeper）分布式锁对比</h1><p>通过jmeter压测发现，在同样的并发请求，redis本地单机，zookeeper本地单机的情况下，redis的300线程的200库存量用时平均在3秒左右，而zookeeper的300线程的200库存量用时平均在28秒左右。</p>
<p>可以明显看的出来，针对本次的300线程200库存，redis单机和zookeeper单机</p>
<table>
<thead>
<tr>
<th>对比</th>
<th>zookeeper</th>
<th>redis</th>
</tr>
</thead>
<tbody><tr>
<td>时间</td>
<td>28秒</td>
<td>3秒</td>
</tr>
<tr>
<td>CAP</td>
<td>CP</td>
<td>AP</td>
</tr>
<tr>
<td>性能</td>
<td>较低</td>
<td>高</td>
</tr>
<tr>
<td>可靠</td>
<td>高</td>
<td>较低</td>
</tr>
</tbody></table>
<h1 id="工具对比"><a href="#工具对比" class="headerlink" title="工具对比"></a>工具对比</h1><ol>
<li><p>redisTemplate是基于某个具体实现的再封装，比如说springBoot1.x时，具体实现是jedis；而到了springBoot2.x时，具体实现变成了lettuce。封装的好处就是隐藏了具体的实现，使调用更简单，但是有人测试过jedis效率要10-30倍的高于redisTemplate的执行效率，所以单从执行效率上来讲，jedis完爆redisTemplate。redisTemplate的好处就是基于springBoot自动装配的原理，使得整合redis时比较简单。</p>
</li>
<li><p>jedis作为老牌的redis客户端，采用同步阻塞式IO，采用线程池时是线程安全的。优点是简单、灵活、api全面，缺点是某些redis高级功能需要自己封装。</p>
</li>
<li><p>lettuce作为新式的redis客户端，基于netty采用异步非阻塞式IO，是线程安全的，优点是提供了很多redis高级功能，例如集群、哨兵、管道等，缺点是api抽象，学习成本高。lettuce好是好，但是jedis比他生得早。</p>
</li>
<li><p>redission作为redis的分布式客户端，同样基于netty采用异步非阻塞式IO，是线程安全的，优点是提供了很多redis的分布式操作和高级功能，缺点是api抽象，学习成本高</p>
</li>
</ol>
<p>面试题：</p>
<p>你们项目中在分布式中如何保证线程安全</p>
<p>zookeeper和redis如何选择</p>
<p><a href="https://zhuanlan.zhihu.com/p/106333054">https://zhuanlan.zhihu.com/p/106333054</a></p>
<p><a href="https://www.zhihu.com/question/300767410/answer/1698980571">https://www.zhihu.com/question/300767410/answer/1698980571</a></p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/belongtocode/article/details/102212078">https://blog.csdn.net/belongtocode/article/details/102212078</a></p>
<p><a href="https://www.cnblogs.com/moxiaotao/p/10829799.html">https://www.cnblogs.com/moxiaotao/p/10829799.html</a></p>
<p><a href="https://blog.csdn.net/qq_40925189/article/details/109580439">https://blog.csdn.net/qq_40925189/article/details/109580439</a></p>
</body></html>]]></content>
      <categories>
        <category>分布式</category>
        <category>分布式锁</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/0.html</url>
    <content><![CDATA[<html><head></head><body></body></html>]]></content>
  </entry>
  <entry>
    <title>MySQL进阶部分</title>
    <url>/353ffb0.html</url>
    <content><![CDATA[<html><head></head><body><ul>
<li><a href="#%E4%B8%80mysql%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D">一、MySQL的架构介绍</a><ul>
<li><a href="#1mysql%E7%AE%80%E4%BB%8B">1.MySql简介</a></li>
<li><a href="#2mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D">2.MySQL逻辑架构介绍</a><ul>
<li><a href="#1connectors">1.Connectors</a></li>
<li><a href="#2-management-serveices--utilities%EF%BC%9A">2 Management Serveices &amp; Utilities：</a></li>
<li><a href="#3-connection-pool-%E8%BF%9E%E6%8E%A5%E6%B1%A0">3 Connection Pool: 连接池</a></li>
<li><a href="#4-sql-interface-sql%E6%8E%A5%E5%8F%A3%E3%80%82">4 SQL Interface: SQL接口。</a></li>
<li><a href="#5-parser-%E8%A7%A3%E6%9E%90%E5%99%A8%E3%80%82">5 Parser: 解析器。</a></li>
<li><a href="#6-optimizer-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E3%80%82">6 Optimizer: 查询优化器。</a></li>
<li><a href="#7-cache%E5%92%8Cbuffer%EF%BC%9A-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E3%80%82">7 Cache和Buffer： 查询缓存。</a></li>
<li><a href="#8-%E3%80%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%8E%A5%E5%8F%A3">8 、存储引擎接口</a></li>
</ul>
</li>
<li><a href="#3mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">3.MySQL存储引擎</a><ul>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%EF%BC%9A">查看命令：</a></li>
<li><a href="#myisam%E5%92%8Cinnodb%E5%8C%BA%E5%88%AB%EF%BC%9A">MyISAM和InnoDB区别：</a></li>
</ul>
<span id="more"></span></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90">二、索引优化分析</a><ul>
<li><a href="#1%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B">1.索引简介</a><ul>
<li><a href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">是什么？</a></li>
<li><a href="#%E4%BC%98%E5%8A%BF%EF%BC%9A">优势：</a></li>
<li><a href="#%E5%8A%A3%E5%8A%BF%EF%BC%9A">劣势：</a></li>
<li><a href="#mysql%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB">mysql索引分类</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%EF%BC%9A">基本语法：</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8alter%E5%91%BD%E4%BB%A4%EF%BC%9A">使用Alter命令：</a></li>
<li><a href="#mysql%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%EF%BC%9A">mysql索引结构：</a></li>
<li><a href="#btree%EF%BC%9A">BTree：</a></li>
<li><a href="#btree">B+Tree</a></li>
<li><a href="#b%E6%A0%91%E7%B4%A2%E5%BC%95%EF%BC%9A">B树索引：</a></li>
<li><a href="#b%E6%A0%91%E7%B4%A2%E5%BC%95%EF%BC%9A-1">B+树索引：</a></li>
<li><a href="#%E5%85%B6%E4%B8%ADmyisam%E5%92%8Cinnodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E9%83%BD%E9%87%87%E7%94%A8b%E6%A0%91%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BD%86%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C">其中MyISAM和InnoDB存储引擎都采用B+树索引，但底层实现方式不同</a></li>
<li><a href="#hash%E7%B4%A2%E5%BC%95%EF%BC%9A">Hash索引：</a></li>
<li><a href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95">哪些情况需要创建索引</a></li>
<li><a href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8D%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95">哪些情况不要创建索引</a></li>
</ul>
</li>
<li><a href="#2%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">2.性能分析</a><ul>
<li><a href="#mysql-query-optimizer">MySQL Query Optimizer</a></li>
<li><a href="#mysql%E5%B8%B8%E8%A7%81%E7%93%B6%E9%A2%88">MySQL常见瓶颈:</a></li>
<li><a href="#explain">Explain</a><ul>
<li><a href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E6%9F%A5%E7%9C%8B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%89">是什么（查看执行计划）</a></li>
<li><a href="#%E6%80%8E%E4%B9%88%E7%8E%A9">怎么玩</a></li>
<li><a href="#%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%A1%E6%81%AF">执行计划包含的信息</a></li>
<li><a href="#%E5%90%84%E4%B8%AA%E5%AD%97%E6%AE%B5%E8%A7%A3%E9%87%8A">各个字段解释</a></li>
<li><a href="#id">id</a></li>
<li><a href="#select_type">select_type</a></li>
<li><a href="#table">table</a></li>
<li><a href="#type">type</a></li>
<li><a href="#possible_keys">possible_keys</a></li>
<li><a href="#key">key</a></li>
<li><a href="#key_len">key_len</a></li>
<li><a href="#ref">ref</a></li>
<li><a href="#rows">rows</a></li>
<li><a href="#extra">Extra</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96">3.索引优化</a><ul>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%EF%BC%88%E5%BA%94%E8%AF%A5%E9%81%BF%E5%85%8D%EF%BC%89">索引失效（应该避免）</a></li>
<li><a href="#%E4%B8%80%E8%88%AC%E6%80%A7%E5%BB%BA%E8%AE%AE">一般性建议</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89%E6%9F%A5%E8%AF%A2%E6%88%AA%E5%8F%96%E5%88%86%E6%9E%90">三、查询截取分析</a><ul>
<li><a href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96">查询优化</a><ul>
<li><a href="#order-by%E5%85%B3%E9%94%AE%E5%AD%97%E4%BC%98%E5%8C%96">order by关键字优化</a></li>
<li><a href="#%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5">优化策略</a></li>
<li><a href="#%E5%B0%8F%E6%80%BB%E7%BB%93">小总结:</a></li>
<li><a href="#group-by%E5%85%B3%E9%94%AE%E5%AD%97%E4%BC%98%E5%8C%96">GROUP BY关键字优化</a></li>
</ul>
</li>
<li><a href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97">慢查询日志</a><ul>
<li><a href="#%E6%98%AF%E4%BB%80%E4%B9%88">是什么</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7mysqldumpslow">日志分析工具mysqldumpslow</a></li>
</ul>
</li>
<li><a href="#%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E8%84%9A%E6%9C%AC">批量数据脚本</a><ul>
<li><a href="#%E5%BE%80%E8%A1%A8%E9%87%8C%E6%8F%92%E5%85%A51000w%E6%95%B0%E6%8D%AE">往表里插入1000W数据</a></li>
</ul>
</li>
<li><a href="#show-profiles">Show profiles</a><ul>
<li><a href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9A">是什么：</a></li>
<li><a href="#%E5%88%86%E6%9E%90%E6%AD%A5%E9%AA%A4">分析步骤:</a></li>
</ul>
</li>
<li><a href="#%E5%85%A8%E5%B1%80%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97">全局查询日志</a><ul>
<li><a href="#%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%BC%80%E5%90%AF%E8%BF%99%E4%B8%AA%E5%8A%9F%E8%83%BD%E3%80%82">永远不要在生产环境开启这个功能。</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9B%9Bmysql%E9%94%81%E6%9C%BA%E5%88%B6">四、MySQL锁机制</a><ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a><ul>
<li><a href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB">锁的分类</a><ul>
<li><a href="#%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%88%E8%AF%BB%E3%80%81%E5%86%99%EF%BC%89%E5%88%86%EF%BC%9A">从数据操作的类型（读、写）分：</a></li>
<li><a href="#%E4%BB%8E%E5%AF%B9%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E9%A2%97%E7%B2%92%E5%BA%A6%EF%BC%9A">从对数据操作的颗粒度：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%A1%A8%E9%94%81%EF%BC%88%E5%81%8F%E8%AF%BB%EF%BC%89">表锁（偏读）</a><ul>
<li><a href="#%E7%89%B9%E7%82%B9">特点</a></li>
<li><a href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90">案例分析</a><ul>
<li><a href="#%E5%BB%BA%E8%A1%A8sql">建表SQL</a></li>
<li><a href="#%E5%8A%A0%E8%AF%BB%E9%94%81">加读锁</a></li>
<li><a href="#%E5%8A%A0%E5%86%99%E9%94%81">加写锁</a></li>
</ul>
</li>
<li><a href="#%E6%A1%88%E4%BE%8B%E7%BB%93%E8%AE%BA">案例结论</a></li>
<li><a href="#%E8%A1%A8%E9%94%81%E5%88%86%E6%9E%90">表锁分析</a></li>
</ul>
</li>
<li><a href="#%E8%A1%8C%E9%94%81%EF%BC%88%E5%81%8F%E5%86%99%EF%BC%89">行锁（偏写）</a><ul>
<li><a href="#%E7%89%B9%E7%82%B9-1">特点</a></li>
<li><a href="#%E7%94%B1%E4%BA%8E%E8%A1%8C%E9%94%81%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%A4%8D%E4%B9%A0%E8%80%81%E7%9F%A5%E8%AF%86">由于行锁支持事务，复习老知识</a><ul>
<li><a href="#%E4%BA%8B%E5%8A%A1%EF%BC%88transation%EF%BC%89%E5%8F%8A%E5%85%B6acid%E5%B1%9E%E6%80%A7">事务（Transation）及其ACID属性</a></li>
<li><a href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98">并发事务处理带来的问题</a></li>
<li><a href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">事务隔离级别</a></li>
</ul>
</li>
<li><a href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-1">案例分析</a><ul>
<li><a href="#%E5%BB%BA%E8%A1%A8sql-1">建表SQL</a></li>
<li><a href="#%E8%A1%8C%E9%94%81%E5%AE%9A%E5%9F%BA%E6%9C%AC%E6%BC%94%E7%A4%BA">行锁定基本演示</a></li>
<li><a href="#%E6%97%A0%E7%B4%A2%E5%BC%95%E8%A1%8C%E9%94%81%E5%8D%87%E7%BA%A7%E4%B8%BA%E8%A1%A8%E9%94%81">无索引行锁升级为表锁</a></li>
<li><a href="#%E9%97%B4%E9%9A%99%E9%94%81%E5%8D%B1%E5%AE%B3">间隙锁危害</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%B8%B8%E8%80%83%E5%A6%82%E4%BD%95%E9%94%81%E5%AE%9A%E4%B8%80%E8%A1%8C">面试题：常考如何锁定一行</a></li>
</ul>
</li>
<li><a href="#%E6%A1%88%E4%BE%8B%E7%BB%93%E8%AE%BA-1">案例结论</a></li>
<li><a href="#%E8%A1%8C%E9%94%81%E5%88%86%E6%9E%90">行锁分析</a></li>
<li><a href="#%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE">优化建议</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%94%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">五、主从复制</a><ul>
<li><a href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">复制的基本原理</a><ul>
<li><a href="#%E4%B8%89%E5%A4%A7%E6%AD%A5%E9%AA%A4%EF%BC%9A">三大步骤：</a></li>
</ul>
</li>
<li><a href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99">复制的基本原则</a></li>
<li><a href="#%E5%A4%8D%E5%88%B6%E6%9C%80%E5%A4%A7%E9%97%AE%E9%A2%98">复制最大问题</a><ul>
<li><a href="#%E5%BB%B6%E6%97%B6">延时</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%AD%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">六、参考资料</a>  <pre><code>* [尚硅谷讲堂](#尚硅谷讲堂)  
* [图灵学院](#图灵学院)
</code></pre>
</li>
</ul>
<h2 id="一、MySQL的架构介绍"><a href="#一、MySQL的架构介绍" class="headerlink" title="一、MySQL的架构介绍"></a>一、MySQL的架构介绍</h2><h3 id="1-MySql简介"><a href="#1-MySql简介" class="headerlink" title="1.MySql简介"></a>1.MySql简介</h3><p>​        概述：<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/1.png"></p>
<h3 id="2-MySQL逻辑架构介绍"><a href="#2-MySQL逻辑架构介绍" class="headerlink" title="2.MySQL逻辑架构介绍"></a>2.MySQL逻辑架构介绍</h3><p>​        <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/2.png" alt="2"></p>
<p>​    <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/3.png" alt="2"></p>
<h5 id="1-Connectors"><a href="#1-Connectors" class="headerlink" title="1.Connectors"></a>1.Connectors</h5><p>指的是不同语言中与SQL的交互</p>
<h5 id="2-Management-Serveices-amp-Utilities："><a href="#2-Management-Serveices-amp-Utilities：" class="headerlink" title="2 Management Serveices &amp; Utilities："></a>2 Management Serveices &amp; Utilities：</h5><p>系统管理和控制工具</p>
<h5 id="3-Connection-Pool-连接池"><a href="#3-Connection-Pool-连接池" class="headerlink" title="3 Connection Pool: 连接池"></a>3 Connection Pool: 连接池</h5><p>管理缓冲用户连接，线程处理等需要缓存的需求。<br>负责监听对 MySQL Server 的各种请求，接收连接请求，转发所有连接请求到线程管理模块。每一个连接上 MySQL Server 的客户端请求都会被分配（或创建）一个连接线程为其单独服务。而连接线程的主要工作就是负责 MySQL Server 与客户端的通信，<br>接受客户端的命令请求，传递 Server 端的结果信息等。线程管理模块则负责管理维护这些连接线程。包括线程的创建，线程的 cache 等。</p>
<h5 id="4-SQL-Interface-SQL接口。"><a href="#4-SQL-Interface-SQL接口。" class="headerlink" title="4 SQL Interface: SQL接口。"></a>4 SQL Interface: SQL接口。</h5><p>接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface</p>
<h5 id="5-Parser-解析器。"><a href="#5-Parser-解析器。" class="headerlink" title="5 Parser: 解析器。"></a>5 Parser: 解析器。</h5><p>SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由Lex和YACC实现的，是一个很长的脚本。<br>在 MySQL中我们习惯将所有 Client 端发送给 Server 端的命令都称为 query ，在 MySQL Server 里面，连接线程接收到客户端的一个 Query 后，会直接将该 query 传递给专门负责将各种 Query 进行分类然后转发给各个对应的处理模块。<br>主要功能：<br>a . 将SQL语句进行语义和语法的分析，分解成数据结构，然后按照不同的操作类型进行分类，然后做出针对性的转发到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。<br>b.  如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的</p>
<h5 id="6-Optimizer-查询优化器。"><a href="#6-Optimizer-查询优化器。" class="headerlink" title="6 Optimizer: 查询优化器。"></a>6 Optimizer: 查询优化器。</h5><p>SQL语句在查询之前会使用查询优化器对查询进行优化。就是优化客户端请求的 query（sql语句） ，根据客户端请求的 query 语句，和数据库中的一些统计信息，在一系列算法的基础上进行分析，得出一个最优的策略，告诉后面的程序如何取得这个 query 语句的结果<br>他使用的是“选取-投影-联接”策略进行查询。<br>       用一个例子就可以理解： select uid,name from user where gender = 1;<br>       这个select 查询先根据where 语句进行选取，而不是先将表全部查询出来以后再进行gender过滤<br>       这个select查询先根据uid和name进行属性投影，而不是将属性全部取出以后再进行过滤<br>       将这两个查询条件联接起来生成最终查询结果</p>
<h5 id="7-Cache和Buffer：-查询缓存。"><a href="#7-Cache和Buffer：-查询缓存。" class="headerlink" title="7 Cache和Buffer： 查询缓存。"></a>7 Cache和Buffer： 查询缓存。</h5><p>他的主要功能是将客户端提交 给MySQL 的 Select 类 query 请求的返回结果集 cache 到内存中，与该 query 的一个 hash 值 做一个对应。该 Query 所取数据的基表发生任何数据的变化之后， MySQL 会自动使该 query 的Cache 失效。在读写比例非常高的应用系统中， Query Cache 对性能的提高是非常显著的。当然它对内存的消耗也是非常大的。<br>如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等</p>
<h5 id="8-、存储引擎接口"><a href="#8-、存储引擎接口" class="headerlink" title="8 、存储引擎接口"></a>8 、存储引擎接口</h5><p>存储引擎接口模块可以说是 MySQL 数据库中最有特色的一点了。目前各种数据库产品中，基本上只有 MySQL 可以实现其底层数据存储引擎的插件式管理。这个模块实际上只是 一个抽象类，但正是因为它成功地将各种数据处理高度抽象化，才成就了今天 MySQL 可插拔存储引擎的特色。<br>     从图2还可以看出，MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。<br>    注意：存储引擎是基于表的，而不是数据库。</p>
<h3 id="3-MySQL存储引擎"><a href="#3-MySQL存储引擎" class="headerlink" title="3.MySQL存储引擎"></a>3.MySQL存储引擎</h3><h4 id="查看命令："><a href="#查看命令：" class="headerlink" title="查看命令："></a>查看命令：</h4><p>​        <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/4.png" alt="2"></p>
<h4 id="MyISAM和InnoDB区别："><a href="#MyISAM和InnoDB区别：" class="headerlink" title="MyISAM和InnoDB区别："></a>MyISAM和InnoDB区别：</h4><p>​    <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/5.png" alt="2"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210629172838705.png" alt="image-20210629172838705"></p>
<h2 id="InnoDB四大特性"><a href="#InnoDB四大特性" class="headerlink" title="InnoDB四大特性"></a>InnoDB四大特性</h2><h4 id="1、插入缓冲（insert-buffer）"><a href="#1、插入缓冲（insert-buffer）" class="headerlink" title="1、插入缓冲（insert buffer）"></a>1、插入缓冲（insert buffer）</h4><p>插入缓冲（Insert Buffer/Change Buffer）：提升插入性能，change buffering是insert buffer的加强，insert buffer只针对insert有效，change buffering对insert、delete、update(delete+insert)、purge都有效</p>
<p>使用插入缓冲的条件：</p>
<ul>
<li><p>非聚集索引（辅助索引）</p>
</li>
<li><p>非唯一索引</p>
</li>
</ul>
<p>Change buffer是作为buffer pool中的一部分存在。<code>Innodb_change_buffering</code>参数缓存所对应的操作(update会被认为是delete+insert)：</p>
<ul>
<li><p><code>all</code>: 默认值，缓存insert, delete, purges操作</p>
</li>
<li><p><code>none</code>: 不缓存</p>
</li>
<li><p><code>inserts</code>: 缓存insert操作</p>
</li>
<li><p><code>deletes</code>: 缓存delete操作</p>
</li>
<li><p><code>changes</code>: 缓存insert和delete操作</p>
</li>
<li><p><code>purges</code>: 缓存后台执行的物理删除操作</p>
</li>
</ul>
<p><code>innodb_change_buffer_max_size</code>参数：控制使用的大小，默认25%，最大可设置50%，如果mysql实例中有大量的修改操作，可考虑增大该参数；</p>
<p>对满足插入缓存条件的插入，每一次的插入不是写到索引页中，而是：</p>
<ol>
<li><p>会先判断插入的非聚集索引页是否在缓冲池中，如果在直接插入；</p>
</li>
<li><p>如果不在，则先放到insert buffer中，再按照一定的频率进行合并操作，再写会磁盘；</p>
</li>
<li><p>通常可以将多个插入合并到一个操作中，目的是为了减少随机IO带来的性能损耗；</p>
</li>
</ol>
<p>这样通常能将多个插入合并到一个操作中，目的还是为了<strong>减少随机IO带来性能损耗</strong>。</p>
<p><strong>上面提过在一定频率下进行合并，那所谓的频率是什么条件</strong>？</p>
<ol>
<li><p>辅助索引页被读取到缓冲池中。正常的select先检查Insert Buffer是否有该非聚集索引页存在，若有则合并插入。</p>
</li>
<li><p>辅助索引页没有可用空间。空间小于1/32页的大小，则会强制合并操作。</p>
</li>
<li><p>Master Thread 每秒和每10秒的合并操作。</p>
</li>
</ol>
<p>insert buffer的数据结构是一颗B+树；</p>
<ul>
<li><p>全局只有一颗insert buffer B+树，负责对所有表的辅助索引进行insert buffer；</p>
</li>
<li><p>这颗B+树放在共享表空间中，试图通过独立表空间ibd文件恢复表中数据时，往往会导致check table失败，因为表中的辅助索引中的数据可能还在insert buffer中，也就是共享表空间中，所以ibd文件恢复后，还需要repair table操作来重建表上所有的辅助索引；</p>
</li>
</ul>
<h4 id="2、二次写（double-write）"><a href="#2、二次写（double-write）" class="headerlink" title="2、二次写（double write）"></a>2、二次写（double write）</h4><ol>
<li><p>doublewrite缓存位于系统表空间的存储区域，用来缓存innodb的数据页从innodb buffer pool中flush之后并写入到数据文件之前；</p>
</li>
<li><p>当操作系统或数据库进程在数据页写入磁盘的过程中崩溃，可以在doublewrite缓存中找到数据页的备份，用来执行crash恢复；</p>
</li>
<li><p>数据页写入到doublewrite缓存的动作所需要的io消耗要小于写入到数据文件的消耗，因为此写入操作会以一次大的连续块的方式写入；</p>
</li>
</ol>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20210627104446.png" alt="img"></p>
<p>从上图可知：</p>
<ol>
<li><p>内存中doublewrite buffer大小2M；物理磁盘上共享表空间中连续的128个页，也就是2个区（extent）大小同样为2M</p>
</li>
<li><p>对缓冲池脏页进行刷新时，不是直接写磁盘。流程： </p>
</li>
<li><p>通过memcpy()函数将脏页先复制到内存中的doublewrite buffer</p>
</li>
<li><p>通过doublewrite分两次，每次1M顺序的写入共享表空间的物理磁盘上。这个过程中，doublewrite页是连续的，因此这个过程是顺序的，所以开销并不大；</p>
</li>
<li><p>完成doublewrite页的写入后，再将doublewrite buffer中的页写入各个表空间文件中，此时写入是离散的，可能会较慢；</p>
</li>
<li><p>如果操作系统在第三步的过程中发生了崩溃，在恢复过程中，可以从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件中，再应用重做日志；</p>
</li>
</ol>
<h4 id="3、自适应hash索引（ahi）"><a href="#3、自适应hash索引（ahi）" class="headerlink" title="3、自适应hash索引（ahi）"></a>3、自适应hash索引（ahi）</h4><p>innodb存储引擎会监控对表上二级索引的查找，如果发现某二级索引被频繁访问，此索引成为热数据，建立hash索引以提升查询速度，此建立是自动建立哈希索引，故称为自适应哈希索引（adaptive hash index）。</p>
<p>该属性通过<code>innodb_adapitve_hash_index</code>开启，也可以通过<code>—skip-innodb_adaptive_hash_index</code>参数关闭</p>
<p>注意事项：</p>
<ul>
<li><p>自适应哈希索引会占用innodb buffer pool</p>
</li>
<li><p>只适合搜索等值（=）的查询，对于范围查找等操作，是不能使用的</p>
</li>
<li><p>极端情况下，自适应hash索引才有比较大的意义，可以降低逻辑读</p>
</li>
</ul>
<h4 id="4、预读-read-ahead"><a href="#4、预读-read-ahead" class="headerlink" title="4、预读(read ahead)"></a>4、预读(read ahead)</h4><p><strong>extent 定义</strong>：表空间（tablespace 中的一组 page）</p>
<p>InnoDB使用两种预读算法来提高I/O性能：线性预读（linear read-ahead）和随机预读（randomread-ahead）。</p>
<ul>
<li><p>线性预读：以extent为单位，将下一个extent提前读取到buffer pool中；</p>
</li>
<li><p>随机预读：以extent中的page为单位，将当前extent中的剩余的page提前读取到buffer pool中；</p>
</li>
</ul>
<p>线性预读一个重要参数：innodb_read_ahead_threshold，控制什么时间（访问extent中多少页的阈值）触发预读；</p>
<ul>
<li><p>默认：56，范围：0～64，值越高，访问模式检查越严格；</p>
</li>
<li><p>没有该变量之前，当访问到extent最后一个page时，innodb会决定是否将下一个extent放入到buffer pool中；</p>
</li>
</ul>
<p>随机预读说明：</p>
<ul>
<li><p>当同一个extent的一些page在buffer pool中发现时，innodb会将extent中剩余page一并读取到buffer pool中；</p>
</li>
<li><p>随机预读给innodb code带来一些不必要的复杂性，性能上也不稳定，在5.5版本已经废弃，如果启用，需要修改变量：innodb_random_read_ahead为ON；</p>
</li>
</ul>
<h2 id="二、索引优化分析"><a href="#二、索引优化分析" class="headerlink" title="二、索引优化分析"></a>二、索引优化分析</h2><h3 id="1-索引简介"><a href="#1-索引简介" class="headerlink" title="1.索引简介"></a>1.索引简介</h3><h5 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h5><p>MySQL官方对索引的定义为：索引(Index)是帮助MySQL高校获取数据的数据结构。可以得到索引的本质：索引是数据结构。可以简单理解为”排好序的快速查找数据结构”。</p>
<p>结论：数据本身之外,数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，<br>这样就可以在这些数据结构的基础上实现高级查找算法,这种数据结构就是索引。</p>
<p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以文件形式存储在硬盘上。</p>
<h5 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h5><p>通过索引列对数据进行排序，降低数据排序成本，降低了CPU的消耗</p>
<h5 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h5><p>1.实际上索引也是一张表，该表保存了主键和索引字段，并指向实体表的记录,所以索引列也是要占用空间的。</p>
<p>2.虽然索引大大提高了查询速度，同时却会降低更新表的速度,如果对表INSERT,UPDATE和DELETE。因为更新表时，MySQL不仅要不存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</p>
<p>3.索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立优秀的索引，或优化查询语句。</p>
<h5 id="mysql索引分类"><a href="#mysql索引分类" class="headerlink" title="mysql索引分类"></a>mysql索引分类</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">单值索引：即一个索引只包含单个列，一个表可以有多个单列索引</span><br><span class="line"></span><br><span class="line">唯一索引：索引列的值必须唯一，但允许有空值</span><br><span class="line"></span><br><span class="line">复合索引：即一个索引包含多个列</span><br></pre></td></tr></tbody></table></figure>

<h5 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">创建：</span><br><span class="line">1.CREATE [UNIQUE] INDEX  indexName ON mytable(columnname(length));</span><br><span class="line">	//如果是CHAR,VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定length。</span><br><span class="line">2.ALTER mytable ADD [UNIQUE]  INDEX [indexName] ON(columnname(length));</span><br><span class="line"></span><br><span class="line">删除：</span><br><span class="line">DROP INDEX [indexName] ON mytable;</span><br><span class="line"></span><br><span class="line">查看：</span><br><span class="line">SHOW INDEX FROM table_name\G</span><br></pre></td></tr></tbody></table></figure>

<h5 id="使用Alter命令："><a href="#使用Alter命令：" class="headerlink" title="使用Alter命令："></a>使用Alter命令：</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/6.png" alt="2"></p>
<h5 id="mysql索引结构："><a href="#mysql索引结构：" class="headerlink" title="mysql索引结构："></a>mysql索引结构：</h5><h5 id="BTree："><a href="#BTree：" class="headerlink" title="BTree："></a>BTree：</h5><p>B树（Balance Tree）是一种多路平衡查找树，他的<strong>每一个节点最多包含M个孩子，M就是B树的阶。</strong>M的大小取决于磁盘页的大小。</p>
<p><a href="https://www.bilibili.com/video/BV1UJ411J7CU?p=2&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1UJ411J7CU?p=2&amp;spm_id_from=pageDriver</a></p>
<p><a href="https://www.bilibili.com/video/BV1BK4y1X7Gp?from=search&amp;seid=1872408051532032494">https://www.bilibili.com/video/BV1BK4y1X7Gp?from=search&amp;seid=1872408051532032494</a></p>
<p><a href="https://blog.csdn.net/whoamiyang/article/details/51926985">https://blog.csdn.net/whoamiyang/article/details/51926985</a></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210629183227536.png" alt="image-20210629183227536"></p>
<p><strong>B-树就是B树，中间的横线不是减号，所以不要读成B减树。</strong></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/7.jpg" alt="2"></p>
<h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h5><p>一个m阶的B+树具有如下几个特征：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</span><br><span class="line"></span><br><span class="line">2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</span><br><span class="line"></span><br><span class="line">3.每个父节点的元素都同时存在于子节点中，是子节点中的最大（或最小）元素。</span><br><span class="line"></span><br><span class="line">4.根节点的最大元素是整个B+树的最大元素。</span><br><span class="line"></span><br><span class="line">5.由于父节点的元素都包含在子节点，因此所有叶子节点包括了全部的元素信息。</span><br><span class="line"></span><br><span class="line">6.每个叶子节点都带有指向下一个节点的指针，形成一个有序链表。</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/8.png" alt="2"></p>
<h5 id="B树索引："><a href="#B树索引：" class="headerlink" title="B树索引："></a>B树索引：</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/9.jpg" alt="2"></p>
<h5 id="B-树索引："><a href="#B-树索引：" class="headerlink" title="B+树索引："></a>B+树索引：</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/10.jpg" alt="2"></p>
<h5 id="其中MyISAM和InnoDB存储引擎都采用B-树索引，但底层实现方式不同"><a href="#其中MyISAM和InnoDB存储引擎都采用B-树索引，但底层实现方式不同" class="headerlink" title="其中MyISAM和InnoDB存储引擎都采用B+树索引，但底层实现方式不同"></a>其中MyISAM和InnoDB存储引擎都采用B+树索引，但底层实现方式不同</h5><p>InnoDB实现方式：其中叶子节点存储数据和键值即是原表中数据（聚集索引）</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/11.jpg" alt="2"></p>
<p>MyISAM实现方式：其中叶子节点存储键值和数据表中对应数据的物理地址（非聚集索引）</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/12.jpg" alt="2"></p>
<h5 id="Hash索引："><a href="#Hash索引：" class="headerlink" title="Hash索引："></a>Hash索引：</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1.只能使用=或&lt;=&gt;操作符的等式比较</span><br><span class="line"></span><br><span class="line">2.优化器不能使用hash索引来加速order by操作</span><br><span class="line"></span><br><span class="line">3.mysql不能确定在两个值之间大约有多少行。如果将一个myisam表改为hash索引的memory表，会影响一些查询的执行效率。</span><br><span class="line"></span><br><span class="line">4.只能使用整个关键字来搜索一行</span><br></pre></td></tr></tbody></table></figure>

<p> hash index是基于哈希表实现的，只有精确匹配索引所有列的查询才会生效。对于每一行数据，存储引擎都会对所有的索引列计算一个hash code,并将的有的hash code存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/13.jpg" alt="2"></p>
<h5 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1.主键自动建立唯一索引</span><br><span class="line"></span><br><span class="line">2.频繁作为查询的条件的字段应该创建索引</span><br><span class="line"></span><br><span class="line">3.查询中与其他表关联的字段，外键关系建立索引</span><br><span class="line"></span><br><span class="line">4.频繁更新的字段不适合创建索引</span><br><span class="line"></span><br><span class="line">5.Where条件里用不到的字段不创建索引</span><br><span class="line"></span><br><span class="line">6.单间/组合索引的选择问题，who？（在高并发下倾向创建组合索引）</span><br><span class="line"></span><br><span class="line">7.查询中排序的字段，排序字段若通过索引去访问将大大提高排序的速度</span><br><span class="line"></span><br><span class="line">8.查询中统计或者分组字段</span><br></pre></td></tr></tbody></table></figure>

<h5 id="哪些情况不要创建索引"><a href="#哪些情况不要创建索引" class="headerlink" title="哪些情况不要创建索引"></a>哪些情况不要创建索引</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1.表记录太少</span><br><span class="line"></span><br><span class="line">2.经常增删改的表</span><br><span class="line"></span><br><span class="line">3.数据重复且分布平均的表字段，因此应该只为经常查询和经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</span><br></pre></td></tr></tbody></table></figure>



<h3 id="2-性能分析"><a href="#2-性能分析" class="headerlink" title="2.性能分析"></a>2.性能分析</h3><h5 id="MySQL-Query-Optimizer"><a href="#MySQL-Query-Optimizer" class="headerlink" title="MySQL Query Optimizer"></a>MySQL Query Optimizer</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/14.png" alt="2"></p>
<h5 id="MySQL常见瓶颈"><a href="#MySQL常见瓶颈" class="headerlink" title="MySQL常见瓶颈:"></a>MySQL常见瓶颈:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">CPU:CPU在饱和的时候一般发生在数据装入在内存或从磁盘上读取数据时候</span><br><span class="line"></span><br><span class="line">IO:磁盘I/O瓶颈发生在装入数据远大于内存容量时</span><br><span class="line"></span><br><span class="line">服务器硬件的性能瓶颈：top,free,iostat和vmstat来查看系统的性能状态</span><br></pre></td></tr></tbody></table></figure>



<h4 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h4><h5 id="是什么（查看执行计划）"><a href="#是什么（查看执行计划）" class="headerlink" title="是什么（查看执行计划）"></a>是什么（查看执行计划）</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">使用EXPLAIN关键字可以模拟优化器执行SQL语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是结构的性能瓶颈</span><br></pre></td></tr></tbody></table></figure>

<h5 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Explain+SQL语句</span><br></pre></td></tr></tbody></table></figure>

<h5 id="执行计划包含的信息"><a href="#执行计划包含的信息" class="headerlink" title="执行计划包含的信息"></a>执行计划包含的信息</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/15.png" alt="2"></p>
<h5 id="各个字段解释"><a href="#各个字段解释" class="headerlink" title="各个字段解释"></a>各个字段解释</h5><h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序<br>三种情况<br>id相同，执行顺序由上至下</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/16.png" alt="2"></p>
<p>id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/17.png" alt="2"></p>
<p>id相同不同，同时存在</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/18.png" alt="2"></p>
<h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h5><p>有哪些：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/19.png" alt="2"></p>
<p>查询的类型，主要用于区别普通查询、联合查询、子查询等的复杂查询</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1.SIMPLE：简单的select查询，查询中不包含子查询或者UNION</span><br><span class="line"></span><br><span class="line">2.PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记为</span><br><span class="line"></span><br><span class="line">3.SUBQUERY：在SELECT或者WHERE列表中包含了子查询</span><br><span class="line"></span><br><span class="line">4.DERIVED：在FROM列表中包含的子查询被标记为DERIVED（衍生）MySQL会递归执行这些子查询，把结果放						在临时表里。</span><br><span class="line"></span><br><span class="line">5.UNION：若第二个SELECT出现在UNION之后，则被标记为UNION;若UNION包含在FROM子句的子查询中，外					层SELECT将被标记为：DERIVED</span><br><span class="line"></span><br><span class="line">6.UNION RESULT：从UNION表获取结果的SELECT</span><br></pre></td></tr></tbody></table></figure>



<h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><p>显示这一行的数据是关于哪张表的</p>
<h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>显示查询使用了何种类型<br>从最好到最差依次是：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">system&gt;con st&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，这个也可以忽略不计</span><br><span class="line"></span><br><span class="line">const：表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很			快。如将主键至于where列表中，MySQL就能将该查询转换为一个常量</span><br><span class="line"></span><br><span class="line">eq_ref：唯一性索引，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描</span><br><span class="line"></span><br><span class="line">ref：非唯一索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的		行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</span><br><span class="line"></span><br><span class="line">range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引一般就是在你的where语句中				出现了between、&lt;、&gt;、in等的查询这种范围扫描索引扫描比全表扫描要好，因为他只需要开始索引的				某一点，而结束语另一点，不用扫描全部索引</span><br><span class="line"></span><br><span class="line">index：Full Index Scan,index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据		文件小。（也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）</span><br><span class="line"></span><br><span class="line">all：FullTable Scan,将遍历全表以找到匹配的行</span><br></pre></td></tr></tbody></table></figure>

<h5 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h5><p>显示可能应用在这张表中的索引,一个或多个。查询涉及的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p>
<h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><p>实际使用的索引。如果为null则没有使用索引</p>
<h5 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h5><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好key_len显示的值为索引最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</p>
<h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h5><p>显示索引那一列被使用了，如果可能的话，是一个常数。那些列或常量被用于查找索引列上的值</p>
<h5 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h5><p>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数</p>
<h5 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h5><p>包含不适合在其他列中显示但十分重要的额外信息</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1.Using filesort：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。</span><br><span class="line">MySQL中无法利用索引完成排序操作成为“文件排序”</span><br><span class="line"></span><br><span class="line">2.Using temporary：使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序order by 和分组查询 group by</span><br><span class="line"></span><br><span class="line">3.USING index：表示相应的select操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！</span><br><span class="line">如果同时出现using where，表明索引被用来执行索引键值的查找；</span><br><span class="line">如果没有同时出现using where，表面索引用来读取数据而非执行查找动作。</span><br></pre></td></tr></tbody></table></figure>

<p>覆盖索引（Covering Index）：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20.png" alt="2"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">4.Using where：表面使用了where过滤</span><br><span class="line"></span><br><span class="line">5.using join buffer：使用了连接缓存</span><br><span class="line"></span><br><span class="line">6.impossible where：where子句的值总是false，不能用来获取任何元组</span><br><span class="line"></span><br><span class="line">7.select tables optimized away：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者</span><br><span class="line">对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，</span><br><span class="line">查询执行计划生成的阶段即完成优化。</span><br><span class="line"></span><br><span class="line">8.distinct：优化distinct，在找到第一匹配的元组后即停止找同样值的工作</span><br></pre></td></tr></tbody></table></figure>



<h3 id="3-索引优化"><a href="#3-索引优化" class="headerlink" title="3.索引优化"></a>3.索引优化</h3><h5 id="索引失效（应该避免）"><a href="#索引失效（应该避免）" class="headerlink" title="索引失效（应该避免）"></a>索引失效（应该避免）</h5><p>1.全值匹配我最爱</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/21.png" alt="2"></p>
<p>2.最佳左前缀法则</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/22.png" alt="2"></p>
<p>3.不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/23.png" alt="2"></p>
<p>4.存储引擎不能使用索引中范围条件右边的列</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/24.png" alt="2"></p>
<p>5.尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select*</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/26.png" alt="2"></p>
<p><img src="MySQL%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86-img/27.png" alt="2"></p>
<p>6.mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/28.png" alt="2"></p>
<p>7.is null,is not null 也无法使用索引</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/29.png" alt="2"></p>
<p>8.like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/30.png" alt="2"></p>
<p>​    建立全文索引：<a href="https://blog.csdn.net/Samdy_Chan/article/details/78138420">https://blog.csdn.net/Samdy_Chan/article/details/78138420</a></p>
<p>如果要使用全值匹配，，但是又不想要索引失效，则对要匹配的值和要筛选的值建立索引，要符合索引覆盖。</p>
<p>9.字符串不加单引号索引失效</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/31.png" alt="2"></p>
<p>10.少用or,用它连接时会索引失效</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/32.png" alt="2"></p>
<p>11.小总结</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/33.png" alt="2"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/34.png" alt="2"></p>
<h4 id="一般性建议"><a href="#一般性建议" class="headerlink" title="一般性建议"></a>一般性建议</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">对于单键索引，尽量选择针对当前query过滤性更好的索引</span><br><span class="line"></span><br><span class="line">在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</span><br><span class="line"></span><br><span class="line">在选择组合索引的时候，尽量选择可以能包含当前query中的where子句中更多字段的索引</span><br><span class="line"></span><br><span class="line">尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</span><br></pre></td></tr></tbody></table></figure>







<h3 id="4-索引下推"><a href="#4-索引下推" class="headerlink" title="4.索引下推"></a>4.索引下推</h3><p><a href="https://blog.csdn.net/sinat_29774479/article/details/103470244">https://blog.csdn.net/sinat_29774479/article/details/103470244</a></p>
<h3 id="为什么范围查找索引回失效，后续索引回失效"><a href="#为什么范围查找索引回失效，后续索引回失效" class="headerlink" title="为什么范围查找索引回失效，后续索引回失效"></a>为什么范围查找索引回失效，后续索引回失效</h3><p>作者：Limit<br>链接：<a href="https://www.zhihu.com/question/304037770/answer/1287557228">https://www.zhihu.com/question/304037770/answer/1287557228</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>假设 表T1有字段a,b,c,d,e，其中a是主键，除e为varchar其余为int类型，并创建了一个联合索引idx_t1_bcd(b,c,d)，然后b、c、d三列作为联合索引。Tip:基于InnoDB存储引擎。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/v2-3d8cde8ac15ee65c6e7f0554246b2f97_720w.jpg" alt="img"><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/v2-3d8cde8ac15ee65c6e7f0554246b2f97_720w.jpg" alt="img">T1表</p>
<p>联合索引：<strong>联合索引的所有索引列都出现在索引数上，并依次比较三列的大小。</strong></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/v2-9dab07a4adc00c794f80e91bc0289e36_720w.jpg" alt="img"><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/v2-9dab07a4adc00c794f80e91bc0289e36_720w.jpg" alt="img">联合索引B+树的结构</p>
<p>先看T1表，他的主键暂且我们将它设为整型自增的（PS：为什么是整型自增），InnoDB会使用主键索引在B+树维护索引和数据文件，<strong>然后我们创建了一个联合索引（b，c，d）也会生成一个索引树</strong>，同样是B+树的结构，<strong>只不过它的data部分存储的是联合索引所在行的主键值</strong>（上图叶子节点紫色背景部分）</p>
<p>对于联合索引来说只不过比单值索引多了几列，而这些索引列全都出现在索引树上。对于联合索引，存储引擎会首先根据第一个索引列排序，如上图我们可以单看第一个索引列，如，1 1 5 12 13…他是单调递增的；如果第一列相等则再根据第二列排序，依次类推就构成了上图的索引树，上图中的1 1 4 ，1 1 5以及13 12 4,13 16 1,13 16 5就可以说明这种情况。</p>
<p><strong>联合索引的查找方式</strong></p>
<p>当我们的SQL语言可以应用到索引的时候，比如</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">select * from T1 where b = 12 and c = 14 and d = 3;  </span><br></pre></td></tr></tbody></table></figure>

<p>也就是T1表中a列为4的这条记录。存储引擎首先从根节点（一般常驻内存）开始查找，<strong>第一个索引的第一个索引列为1,12大于1，第二个索引的第一个索引列为56,12小于56，于是从这俩索引的中间读到下一个节点的磁盘文件地址</strong>，从磁盘上Load这个节点，通常伴随一次磁盘IO，然后在内存里去查找。当Load叶子节点的第二个节点时又是一次磁盘IO，比较第一个元素，b=12,c=14,d=3完全符合，于是找到该索引下的data元素即ID值，再从主键索引树上找到最终数据。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/v2-60d787835b462e2ee2151ddce8340002_720w.jpg" alt="img"><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/v2-60d787835b462e2ee2151ddce8340002_720w.jpg" alt="img"></p>
<h2 id="三、查询截取分析"><a href="#三、查询截取分析" class="headerlink" title="三、查询截取分析"></a>三、查询截取分析</h2><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><p>永远小表驱动大表，类似嵌套循环Nested Loop</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/35.png" alt="2"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/36.png" alt="2"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/37.png" alt="2"></p>
<h5 id="order-by关键字优化"><a href="#order-by关键字优化" class="headerlink" title="order by关键字优化"></a>order by关键字优化</h5><p>ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序</p>
<p>尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀</p>
<p>如果不在索引列上，filesort有两种算法：<br>mysql就要启动双路排序和单路排序</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">双路排序</span><br><span class="line">1.MySQL4.1之前是使用双路排序，字面意思是两次扫描磁盘，最终得到数据。</span><br><span class="line">读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据传输</span><br><span class="line">2.从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。</span><br><span class="line">取一批数据，要对磁盘进行两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二张改进的算法，就是单路排序。</span><br><span class="line"></span><br><span class="line">单路排序</span><br><span class="line">从磁盘读取查询需要的所有列，按照orderby列在buffer对它们进行排序，然后扫描排序后的列表进行输出，</span><br><span class="line">它的效率更快一些，避免了第二次读取数据，并且把随机IO变成顺序IO，但是它会使用更多的空间，</span><br><span class="line">因为它把每一行都保存在内存中了。</span><br><span class="line"></span><br><span class="line">结论及引申出的问题</span><br><span class="line">由于单路是后出来的，总体而言好过双路</span><br><span class="line">但是用单路有问题</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/38.png" alt="2"></p>
<h5 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h5><p>增大sort_buffer_size参数的设置</p>
<p>增大max_length_for_sort_data参数的设置</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/39.png" alt="2"></p>
<h5 id="小总结"><a href="#小总结" class="headerlink" title="小总结:"></a>小总结:</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/40.png" alt="2"></p>
<h5 id="GROUP-BY关键字优化"><a href="#GROUP-BY关键字优化" class="headerlink" title="GROUP BY关键字优化"></a>GROUP BY关键字优化</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">groupby实质是先排序后进行分组，遵照索引建的最佳左前缀</span><br><span class="line"></span><br><span class="line">当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置</span><br><span class="line"></span><br><span class="line">where高于having,能写在where限定的条件就不要去having限定了。</span><br></pre></td></tr></tbody></table></figure>



<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><h5 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/41.png" alt="2"></p>
<h5 id="日志分析工具mysqldumpslow"><a href="#日志分析工具mysqldumpslow" class="headerlink" title="日志分析工具mysqldumpslow"></a>日志分析工具mysqldumpslow</h5><p>查看mysqldumpshow的帮助信息</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/42.png" alt="2"></p>
<h3 id="批量数据脚本"><a href="#批量数据脚本" class="headerlink" title="批量数据脚本"></a>批量数据脚本</h3><h5 id="往表里插入1000W数据"><a href="#往表里插入1000W数据" class="headerlink" title="往表里插入1000W数据"></a>往表里插入1000W数据</h5><p>1.建表</p>
<p>2.设置参数log_trust_function_createors</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/43.png" alt="2"></p>
<p>3创建函数保证每条数据都不同</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/44.png" alt="2"></p>
<p>​    随机产生字符串</p>
<p>​    随机产生部门编号</p>
<p>4.创建存储过程</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/45.png" alt="2"></p>
<p>​    创建往emp表中插入数据的存储过程</p>
<p>​    创建往dept表中插入数据的存储过程</p>
<p>5.调用存储过程</p>
<h3 id="Show-profiles"><a href="#Show-profiles" class="headerlink" title="Show profiles"></a>Show profiles</h3><h5 id="是什么："><a href="#是什么：" class="headerlink" title="是什么："></a>是什么：</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优测量</span><br></pre></td></tr></tbody></table></figure>

<p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p>
<h5 id="分析步骤"><a href="#分析步骤" class="headerlink" title="分析步骤:"></a>分析步骤:</h5><p>1.是否支持，看看当前的SQL版本是否支持</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/46.png" alt="2"></p>
<p>2.开启功能，默认是关闭，使用前需要开启</p>
<p>3.运行SQL</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">select * from emp group by id%10 limit 150000</span><br></pre></td></tr></tbody></table></figure>

<p>4.查看结果，show profiles;</p>
<p>5.诊断SQL，show profile cpu,block io for query 上一步前面的问题SQL 数字号码；</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/47.png" alt="2"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/48.png" alt="2"></p>
<p>6.日常开发需要注意的结论</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">converting HEAP to MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。</span><br><span class="line"></span><br><span class="line">Creating tmp table 创建临时表</span><br><span class="line"></span><br><span class="line">Copying to tmp table on disk 把内存中临时表复制到磁盘，危险！！！</span><br><span class="line"></span><br><span class="line">locked</span><br></pre></td></tr></tbody></table></figure>







<h3 id="全局查询日志"><a href="#全局查询日志" class="headerlink" title="全局查询日志"></a>全局查询日志</h3><p>配置启用</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/49.png" alt="2"></p>
<p>编码启用</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/50.png" alt="2"></p>
<h5 id="永远不要在生产环境开启这个功能。"><a href="#永远不要在生产环境开启这个功能。" class="headerlink" title="永远不要在生产环境开启这个功能。"></a>永远不要在生产环境开启这个功能。</h5><h2 id="四、MySQL锁机制"><a href="#四、MySQL锁机制" class="headerlink" title="四、MySQL锁机制"></a>四、MySQL锁机制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><a href="https://blog.csdn.net/qq_44766883/article/details/105879308">https://blog.csdn.net/qq_44766883/article/details/105879308</a></p>
<h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><h5 id="从数据操作的类型（读、写）分："><a href="#从数据操作的类型（读、写）分：" class="headerlink" title="从数据操作的类型（读、写）分："></a>从数据操作的类型（读、写）分：</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响</span><br><span class="line"></span><br><span class="line">写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="从对数据操作的颗粒度："><a href="#从对数据操作的颗粒度：" class="headerlink" title="从对数据操作的颗粒度："></a>从对数据操作的颗粒度：</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">表锁</span><br><span class="line"></span><br><span class="line">行锁</span><br></pre></td></tr></tbody></table></figure>

<p>从程度上划分：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">悲观锁</span><br><span class="line"></span><br><span class="line">乐观锁</span><br></pre></td></tr></tbody></table></figure>



<h3 id="表锁（偏读）"><a href="#表锁（偏读）" class="headerlink" title="表锁（偏读）"></a>表锁（偏读）</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">偏向MyISAM存储引擎，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率最高，并发最低</span><br></pre></td></tr></tbody></table></figure>

<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><h5 id="建表SQL"><a href="#建表SQL" class="headerlink" title="建表SQL"></a>建表SQL</h5><p><img src="MySQL%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86-img/51.png" alt="2"></p>
<h5 id="加读锁"><a href="#加读锁" class="headerlink" title="加读锁"></a>加读锁</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/52.png" alt="2"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/53.png" alt="2"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/54.png" alt="2"></p>
<h5 id="加写锁"><a href="#加写锁" class="headerlink" title="加写锁"></a>加写锁</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/55.png" alt="2"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/56.png" alt="2"></p>
<h4 id="案例结论"><a href="#案例结论" class="headerlink" title="案例结论"></a>案例结论</h4><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/57.png" alt="2"></p>
<h4 id="表锁分析"><a href="#表锁分析" class="headerlink" title="表锁分析"></a>表锁分析</h4><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/58.png" alt="2"></p>
<h3 id="行锁（偏写）"><a href="#行锁（偏写）" class="headerlink" title="行锁（偏写）"></a>行锁（偏写）</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</span><br><span class="line"></span><br><span class="line">InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）;二是采用了行级锁</span><br></pre></td></tr></tbody></table></figure>



<h4 id="由于行锁支持事务，复习老知识"><a href="#由于行锁支持事务，复习老知识" class="headerlink" title="由于行锁支持事务，复习老知识"></a>由于行锁支持事务，复习老知识</h4><h5 id="事务（Transation）及其ACID属性"><a href="#事务（Transation）及其ACID属性" class="headerlink" title="事务（Transation）及其ACID属性"></a>事务（Transation）及其ACID属性</h5><h5 id="并发事务处理带来的问题"><a href="#并发事务处理带来的问题" class="headerlink" title="并发事务处理带来的问题"></a>并发事务处理带来的问题</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">脏读:（Dirty Reads）：事务A读到了事务B已修改但尚未提交的数据，还在这个数据基础上做了操作，此时，如果						B事务回滚，A读取的数据无效，不符合一致性要求。</span><br><span class="line">不可重复读（Non-Repeatable Reads）：事务A读取到事务B已经提交的数据,不符合隔离性</span><br><span class="line">幻读（Phantom Reads）:事务A读取到事务B新增的数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">脏读和幻读的区别：脏读是事务B修改了数据，幻读是事务B新增了数据.</span><br></pre></td></tr></tbody></table></figure>



<h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/59.png" alt="2"></p>
<h4 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h4><h5 id="建表SQL-1"><a href="#建表SQL-1" class="headerlink" title="建表SQL"></a>建表SQL</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/60.png" alt="2"></p>
<h5 id="行锁定基本演示"><a href="#行锁定基本演示" class="headerlink" title="行锁定基本演示"></a>行锁定基本演示</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/61.png" alt="2"></p>
<h5 id="无索引行锁升级为表锁"><a href="#无索引行锁升级为表锁" class="headerlink" title="无索引行锁升级为表锁"></a>无索引行锁升级为表锁</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">varchar  不用 ' '  导致系统自动转换类型, 行锁变表锁</span><br></pre></td></tr></tbody></table></figure>

<h5 id="间隙锁危害"><a href="#间隙锁危害" class="headerlink" title="间隙锁危害"></a>间隙锁危害</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/62.png" alt="2"></p>
<h5 id="面试题：常考如何锁定一行"><a href="#面试题：常考如何锁定一行" class="headerlink" title="面试题：常考如何锁定一行"></a>面试题：常考如何锁定一行</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/63.png" alt="2"></p>
<h4 id="案例结论-1"><a href="#案例结论-1" class="headerlink" title="案例结论"></a>案例结论</h4><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/64.png" alt="2"></p>
<h4 id="行锁分析"><a href="#行锁分析" class="headerlink" title="行锁分析"></a>行锁分析</h4><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/65.png" alt="2"></p>
<h4 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</span><br><span class="line">合理设计索引，尽量缩小锁的范围</span><br><span class="line">尽可能较少检索条件，避免间隙锁</span><br><span class="line">尽量控制事务大小，减少锁定资源量和时间长度</span><br><span class="line">尽可能低级别事务隔离</span><br></pre></td></tr></tbody></table></figure>





<h2 id="五、主从复制"><a href="#五、主从复制" class="headerlink" title="五、主从复制"></a>五、主从复制</h2><h3 id="复制的基本原理"><a href="#复制的基本原理" class="headerlink" title="复制的基本原理"></a>复制的基本原理</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">slave会从master读取binlog来进行数据同步</span><br></pre></td></tr></tbody></table></figure>

<h5 id="三大步骤："><a href="#三大步骤：" class="headerlink" title="三大步骤："></a>三大步骤：</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志时间，binary log events</span><br><span class="line"></span><br><span class="line">slave将master的binary log ebents拷贝到它的中继日志（relay log</span><br><span class="line"></span><br><span class="line">slave重做中继日志中的时间，将改变应用到自己的数据库中。MySQL复制是异步的且串行化的</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/66.png" alt="2"></p>
<h3 id="复制的基本原则"><a href="#复制的基本原则" class="headerlink" title="复制的基本原则"></a>复制的基本原则</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">每个slave只有一个master</span><br><span class="line"></span><br><span class="line">每个slave只能有一个唯一的服务器ID</span><br><span class="line"></span><br><span class="line">每个master可以有多个salve</span><br></pre></td></tr></tbody></table></figure>



<h3 id="复制最大问题"><a href="#复制最大问题" class="headerlink" title="复制最大问题"></a>复制最大问题</h3><h5 id="延时"><a href="#延时" class="headerlink" title="延时"></a>延时</h5><h2 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h2><h5 id="哔哩哔哩尚硅谷讲堂"><a href="#哔哩哔哩尚硅谷讲堂" class="headerlink" title="哔哩哔哩尚硅谷讲堂"></a>哔哩哔哩尚硅谷讲堂</h5><h5 id="哔哩哔哩图灵学院"><a href="#哔哩哔哩图灵学院" class="headerlink" title="哔哩哔哩图灵学院"></a>哔哩哔哩图灵学院</h5><p><strong>github：java2020</strong></p>
</body></html>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础部分</title>
    <url>/220c1acb.html</url>
    <content><![CDATA[<html><head></head><body><ul>
<li><a href="#%E4%B8%80%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E5%BA%93">一、为什么要学习数据库</a></li>
<li><a href="#%E4%BA%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">二、数据库的相关概念</a></li>
<li><a href="#%E4%B8%89%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E7%89%B9%E7%82%B9">三、数据库存储数据的特点</a></li>
<li><a href="#%E5%9B%9B%E5%88%9D%E5%A7%8BMySQL">四、初始MySQL</a></li>
<li><a href="#%E4%BA%94DQL%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0">五、DQL语言的学习</a></li>
<li><a href="#%E5%85%ADDML%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0">六、DML语言的学习 </a></li>
<li><a href="#%E4%B8%83DDL%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0">七、DDL语言的学习</a></li>
<li><a href="#%E5%85%ABTCL%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0">八、TCL语言的学习</a></li>
<li><a href="#%E4%B9%9D%E8%A7%86%E5%9B%BE%E7%9A%84%E8%AE%B2%E8%A7%A3">九、视图的讲解</a></li>
<li><a href="#%E5%8D%81%E5%8F%98%E9%87%8F">十、变量</a></li>
<li><a href="#%E5%8D%81%E4%B8%80%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0">十一、存储过程和函数</a></li>
<li><a href="#%E5%8D%81%E4%BA%8C%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84">十二、流程控制结构</a></li>
<li><a href="#%E5%8D%81%E4%B8%89%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F">十三、数据库三大范式</a><span id="more"></span></li>
</ul>
<h2 id="一、为什么要学习数据库"><a href="#一、为什么要学习数据库" class="headerlink" title="一、为什么要学习数据库"></a>一、为什么要学习数据库</h2><p>数据库的好处<br>    1.持久化数据到本地<br>    2.可以实现结构化查询，方便管理</p>
<h2 id="二、数据库的相关概念"><a href="#二、数据库的相关概念" class="headerlink" title="二、数据库的相关概念"></a>二、数据库的相关概念</h2><p>​    1、DB：数据库，保存一组有组织的数据的容器<br>​    2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据<br>​    3、SQL:结构化查询语言，用于和DBMS通信的语言</p>
<h2 id="三、数据库存储数据的特点"><a href="#三、数据库存储数据的特点" class="headerlink" title="三、数据库存储数据的特点"></a>三、数据库存储数据的特点</h2><p>​    1、将数据放到表中，表再放到库中<br>​    2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。<br>​    3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。<br>​    4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”<br>​    5、表中的数据是按行存储的，每一行类似于java中的“对象”。</p>
<h2 id="四、初始MySQL"><a href="#四、初始MySQL" class="headerlink" title="四、初始MySQL"></a>四、初始MySQL</h2><h3 id="MySQL产品的介绍"><a href="#MySQL产品的介绍" class="headerlink" title="MySQL产品的介绍"></a>MySQL产品的介绍</h3><h3 id="MySQL产品的安装"><a href="#MySQL产品的安装" class="headerlink" title="MySQL产品的安装"></a>MySQL产品的安装</h3><h3 id="MySQL服务的启动和停止"><a href="#MySQL服务的启动和停止" class="headerlink" title="MySQL服务的启动和停止"></a>MySQL服务的启动和停止</h3><p>​    方式一：计算机——右击管理——服务<br>​    方式二：通过管理员身份运行<br>​    net start 服务名（启动服务）<br>​    net stop 服务名（停止服务）</p>
<h3 id="MySQL服务的登录和退出"><a href="#MySQL服务的登录和退出" class="headerlink" title="MySQL服务的登录和退出"></a>MySQL服务的登录和退出</h3><p>​    方式一：通过mysql自带的客户端<br>​    只限于root用户</p>
<p>​    方式二：通过windows自带的客户端<br>​    登录：<br>​        mysql 【-h主机名 -P端口号 】-u用户名 -p密码</p>
<p>​    退出：<br>​        exit或ctrl+C</p>
<h3 id="MySQL的常见命令和语法规范"><a href="#MySQL的常见命令和语法规范" class="headerlink" title="MySQL的常见命令和语法规范"></a>MySQL的常见命令和语法规范</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1.查看当前所有的数据库</span><br><span class="line">show databases;</span><br><span class="line">2.打开指定的库</span><br><span class="line">use 库名</span><br><span class="line">3.查看当前库的所有表</span><br><span class="line">show tables;</span><br><span class="line">4.查看其它库的所有表</span><br><span class="line">show tables from 库名;</span><br><span class="line">5.创建表</span><br><span class="line">create table 表名(</span><br><span class="line"></span><br><span class="line">​	列名 列类型,</span><br><span class="line">​	列名 列类型，</span><br><span class="line">​	。。。</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">6.查看表结构</span><br><span class="line">desc 表名;</span><br><span class="line"></span><br><span class="line">7.查看服务器的版本</span><br><span class="line">方式一：登录到mysql服务端</span><br><span class="line">select version();</span><br><span class="line">方式二：没有登录到mysql服务端</span><br><span class="line">mysql --version</span><br><span class="line">或</span><br><span class="line">mysql --V</span><br><span class="line"></span><br><span class="line">MySQL的语法规范</span><br><span class="line">	1.不区分大小写,但建议关键字大写，表名、列名小写</span><br><span class="line">	2.每条命令最好用分号结尾</span><br><span class="line">	3.每条命令根据需要，可以进行缩进 或换行</span><br><span class="line">	4.注释</span><br><span class="line">		单行注释：#注释文字</span><br><span class="line">		单行注释：-- 注释文字</span><br><span class="line">		多行注释：/* 注释文字  */</span><br><span class="line">	</span><br><span class="line">	</span><br></pre></td></tr></tbody></table></figure>



<h2 id="五、DQL语言的学习"><a href="#五、DQL语言的学习" class="headerlink" title="五、DQL语言的学习"></a>五、DQL语言的学习</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h4 id="SQL的语言分类"><a href="#SQL的语言分类" class="headerlink" title="SQL的语言分类"></a>SQL的语言分类</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">DQL（Data Query Language）：数据查询语言</span><br><span class="line">		select </span><br><span class="line">	DML(Data Manipulate Language):数据操作语言</span><br><span class="line">		insert 、update、delete</span><br><span class="line">	DDL（Data Define Languge）：数据定义语言</span><br><span class="line">		create、drop、alter</span><br><span class="line">	TCL（Transaction Control Language）：事务控制语言</span><br><span class="line">		commit、rollback</span><br></pre></td></tr></tbody></table></figure>

<h4 id="SQL的常见命令"><a href="#SQL的常见命令" class="headerlink" title="SQL的常见命令"></a>SQL的常见命令</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">show databases； 查看所有的数据库</span><br><span class="line">use 库名； 打开指定 的库</span><br><span class="line">show tables ; 显示库中的所有表</span><br><span class="line">show tables from 库名;显示指定库中的所有表</span><br><span class="line">create table 表名(</span><br><span class="line">	字段名 字段类型,	</span><br><span class="line">	字段名 字段类型</span><br><span class="line">); 创建表</span><br><span class="line"></span><br><span class="line">desc 表名; 查看指定表的结构</span><br><span class="line">select * from 表名;显示表中的所有数据</span><br></pre></td></tr></tbody></table></figure>



<h3 id="进阶1：基础查询"><a href="#进阶1：基础查询" class="headerlink" title="进阶1：基础查询"></a>进阶1：基础查询</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">	SELECT 要查询的东西</span><br><span class="line">	【FROM 表名】;</span><br></pre></td></tr></tbody></table></figure>

<pre><code>类似于Java中 :System.out.println(要打印的东西);
特点：
①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在
② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数
</code></pre>
<h3 id="进阶2：条件查询"><a href="#进阶2：条件查询" class="headerlink" title="进阶2：条件查询"></a>进阶2：条件查询</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">条件查询：根据条件过滤原始表的数据，查询到想要的数据</span><br><span class="line">	语法：</span><br><span class="line">	select </span><br><span class="line">		要查询的字段|表达式|常量值|函数</span><br><span class="line">	from </span><br><span class="line">		表</span><br><span class="line">	where </span><br><span class="line">		条件 ;</span><br></pre></td></tr></tbody></table></figure>



<pre><code>分类：
一、条件表达式
    示例：salary&gt;10000
    条件运算符：
    &gt; &lt; &gt;= &lt;= = != &lt;&gt;

二、逻辑表达式
示例：salary&gt;10000 &amp;&amp; salary&lt;20000

逻辑运算符：

    and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false
    or(||)：两个条件只要有一个成立，结果为true，否则为false
    not(!)：如果条件成立，则not后为false，否则为true

三、模糊查询
示例：last_name like 'a%'
</code></pre>
<h3 id="进阶3：排序查询"><a href="#进阶3：排序查询" class="headerlink" title="进阶3：排序查询"></a>进阶3：排序查询</h3><pre><code>语法：
select
    要查询的东西
from
    表
where 
    条件

order by 排序的字段|表达式|函数|别名 【asc|desc】
</code></pre>
<p>​    </p>
<h3 id="进阶4：常见函数"><a href="#进阶4：常见函数" class="headerlink" title="进阶4：常见函数"></a>进阶4：常见函数</h3><h4 id="一、单行函数"><a href="#一、单行函数" class="headerlink" title="一、单行函数"></a>一、单行函数</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">​	1、字符函数</span><br><span class="line">​		concat拼接</span><br><span class="line">​		substr截取子串</span><br><span class="line">​		upper转换成大写</span><br><span class="line">​		lower转换成小写</span><br><span class="line">​		trim去前后指定的空格和字符</span><br><span class="line">​		ltrim去左边空格</span><br><span class="line">​		rtrim去右边空格</span><br><span class="line">​		replace替换</span><br><span class="line">​		lpad左填充</span><br><span class="line">​		rpad右填充</span><br><span class="line">​		instr返回子串第一次出现的索引</span><br><span class="line">​		length 获取字节个数</span><br><span class="line">​		</span><br><span class="line">	2、数学函数</span><br><span class="line">		round 四舍五入</span><br><span class="line">		rand 随机数</span><br><span class="line">		floor向下取整</span><br><span class="line">		ceil向上取整</span><br><span class="line">		mod取余</span><br><span class="line">		truncate截断</span><br><span class="line">	3、日期函数</span><br><span class="line">		now当前系统日期+时间</span><br><span class="line">		curdate当前系统日期</span><br><span class="line">		curtime当前系统时间</span><br><span class="line">		str_to_date 将字符转换成日期</span><br><span class="line">		date_format将日期转换成字符</span><br><span class="line">	4、流程控制函数</span><br><span class="line">		if 处理双分支</span><br><span class="line">		case语句 处理多分支</span><br><span class="line">			情况1：处理等值判断</span><br><span class="line">			情况2：处理条件判断</span><br><span class="line">	5、其他函数</span><br><span class="line">		version版本</span><br><span class="line">		database当前库</span><br><span class="line">		user当前连接用户</span><br></pre></td></tr></tbody></table></figure>

<p>​    </p>
<h4 id="二、分组函数"><a href="#二、分组函数" class="headerlink" title="二、分组函数"></a>二、分组函数</h4><pre><code>    sum 求和
    max 最大值
    min 最小值
    avg 平均值
    count 计数

    特点：
    1、以上五个分组函数都忽略null值，除了count(*)
    2、sum和avg一般用于处理数值型
        max、min、count可以处理任何数据类型
    3、都可以搭配distinct使用，用于统计去重后的结果
    4、count的参数可以支持：
        字段、*、常量值，一般放1

       建议使用 count(*)
</code></pre>
<h3 id="进阶5：分组查询"><a href="#进阶5：分组查询" class="headerlink" title="进阶5：分组查询"></a>进阶5：分组查询</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">	select 查询的字段，分组函数</span><br><span class="line">	from 表</span><br><span class="line">	group by 分组的字段</span><br></pre></td></tr></tbody></table></figure>

<pre><code>特点：
1、可以按单个字段分组
2、和分组函数一同查询的字段最好是分组后的字段！！！！
3、分组筛选
            针对的表        位置                    关键字
分组前筛选：    原始表            group by的前面            where
分组后筛选：    分组后的结果集        group by的后面         having

4、可以按多个字段分组，字段之间用逗号隔开
5、可以支持排序
6、having后可以支持别名
</code></pre>
<h3 id="进阶6：多表连接查询"><a href="#进阶6：多表连接查询" class="headerlink" title="进阶6：多表连接查询"></a>进阶6：多表连接查询</h3><pre><code>笛卡尔乘积：如果连接条件省略或无效则会出现
解决办法：添加上连接条件
</code></pre>
<h4 id="一、传统模式下的连接-：等值连接——非等值连接"><a href="#一、传统模式下的连接-：等值连接——非等值连接" class="headerlink" title="一、传统模式下的连接 ：等值连接——非等值连接"></a>一、传统模式下的连接 ：等值连接——非等值连接</h4><pre><code>1.等值连接的结果 = 多个表的交集
2.n表连接，至少需要n-1个连接条件
3.多个表不分主次，没有顺序要求
4.一般为表起别名，提高阅读性和性能
</code></pre>
<h4 id="二、sql99语法：通过join关键字实现连接"><a href="#二、sql99语法：通过join关键字实现连接" class="headerlink" title="二、sql99语法：通过join关键字实现连接"></a>二、sql99语法：通过join关键字实现连接</h4><pre><code>含义：1999年推出的sql语法
支持：
等值连接、非等值连接 （内连接）
外连接
交叉连接

语法：

select 字段，...
from 表1
【inner|left outer|right outer|cross】join 表2 on  连接条件
【inner|left outer|right outer|cross】join 表3 on  连接条件
【where 筛选条件】
【group by 分组字段】
【having 分组后的筛选条件】
【order by 排序的字段或表达式】

好处：语句上，连接条件和筛选条件实现了分离，简洁明了！
</code></pre>
<h4 id="三、自连接"><a href="#三、自连接" class="headerlink" title="三、自连接"></a>三、自连接</h4><h5 id="案例：查询员工名和直接上级的名称"><a href="#案例：查询员工名和直接上级的名称" class="headerlink" title="案例：查询员工名和直接上级的名称"></a>案例：查询员工名和直接上级的名称</h5><h5 id="sql99"><a href="#sql99" class="headerlink" title="sql99"></a>sql99</h5><pre><code>SELECT e.last_name,m.last_name
FROM employees e
JOIN employees m 
ON e.`manager_id`=m.`employee_id`;
</code></pre>
<h5 id="sql92"><a href="#sql92" class="headerlink" title="sql92"></a>sql92</h5><pre><code>SELECT e.last_name,m.last_name
FROM employees e,employees m 
WHERE e.`manager_id`=m.`employee_id`;
</code></pre>
<h3 id="进阶7：子查询"><a href="#进阶7：子查询" class="headerlink" title="进阶7：子查询"></a>进阶7：子查询</h3><p>含义：</p>
<pre><code>一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询
在外面的查询语句，称为主查询或外查询
</code></pre>
<p>特点：</p>
<pre><code>1、子查询都放在小括号内
2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧
3、子查询优先于主查询执行，主查询使用了子查询的执行结果
4、子查询根据查询结果的行数不同分为以下两类：
① 单行子查询
    结果集只有一行
    一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= 
    非法使用子查询的情况：
    a、子查询的结果为一组值
    b、子查询的结果为空
    
② 多行子查询
    结果集有多行
    一般搭配多行操作符使用：any、all、in、not in
    in： 属于子查询结果中的任意一个就行
    any和all往往可以用其他查询代替
</code></pre>
<h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><h5 id="1-标量子查询★"><a href="#1-标量子查询★" class="headerlink" title="1.标量子查询★"></a>1.标量子查询★</h5><h5 id="案例1：谁的工资比-Abel-高"><a href="#案例1：谁的工资比-Abel-高" class="headerlink" title="案例1：谁的工资比 Abel 高?"></a>案例1：谁的工资比 Abel 高?</h5><pre><code>①查询Abel的工资
SELECT salary
FROM employees
WHERE last_name = 'Abel'

②查询员工的信息，满足 salary&gt;①结果
SELECT *
FROM employees
WHERE salary&gt;(

    SELECT salary
    FROM employees
    WHERE last_name = 'Abel'

);  
</code></pre>
<h5 id="案例2：返回job-id与141号员工相同，salary比143号员工多的员工-姓名，job-id-和工资"><a href="#案例2：返回job-id与141号员工相同，salary比143号员工多的员工-姓名，job-id-和工资" class="headerlink" title="案例2：返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资"></a>案例2：返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资</h5><pre><code>①查询141号员工的job_id
SELECT job_id
FROM employees
WHERE employee_id = 141

②查询143号员工的salary
SELECT salary
FROM employees
WHERE employee_id = 143

③查询员工的姓名，job_id 和工资，要求job_id=①并且salary&gt;②

SELECT last_name,job_id,salary
FROM employees
WHERE job_id = (
    SELECT job_id
    FROM employees
    WHERE employee_id = 141
) AND salary&gt;(
    SELECT salary
    FROM employees
    WHERE employee_id = 143

);
</code></pre>
<h5 id="2-列子查询（多行子查询）★"><a href="#2-列子查询（多行子查询）★" class="headerlink" title="2.列子查询（多行子查询）★"></a>2.列子查询（多行子查询）★</h5><h5 id="案例1：返回其它工种中比job-id为‘IT-PROG’工种任一工资低的员工的员工号、姓名、job-id-以及salary"><a href="#案例1：返回其它工种中比job-id为‘IT-PROG’工种任一工资低的员工的员工号、姓名、job-id-以及salary" class="headerlink" title="案例1：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary"></a>案例1：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary</h5><pre><code>①查询job_id为‘IT_PROG’部门任一工资

SELECT DISTINCT salary
FROM employees
WHERE job_id = 'IT_PROG'

②查询员工号、姓名、job_id 以及salary，salary&lt;(①)的任意一个
SELECT last_name,employee_id,job_id,salary
FROM employees
WHERE salary&lt;ANY(
    SELECT DISTINCT salary
    FROM employees
    WHERE job_id = 'IT_PROG'

) AND job_id&lt;&gt;'IT_PROG';

或
SELECT last_name,employee_id,job_id,salary
FROM employees
WHERE salary&lt;(
    SELECT MAX(salary)
    FROM employees
    WHERE job_id = 'IT_PROG'

) AND job_id&lt;&gt;'IT_PROG';
</code></pre>
<h5 id="3、行子查询（结果集一行多列或多行多列）"><a href="#3、行子查询（结果集一行多列或多行多列）" class="headerlink" title="3、行子查询（结果集一行多列或多行多列）"></a>3、行子查询（结果集一行多列或多行多列）</h5><h5 id="案例：查询员工编号最小并且工资最高的员工信息"><a href="#案例：查询员工编号最小并且工资最高的员工信息" class="headerlink" title="案例：查询员工编号最小并且工资最高的员工信息"></a>案例：查询员工编号最小并且工资最高的员工信息</h5><pre><code>SELECT * 
FROM employees
WHERE (employee_id,salary)=(
    SELECT MIN(employee_id),MAX(salary)
    FROM employees
);
</code></pre>
<h4 id="二、select后面"><a href="#二、select后面" class="headerlink" title="二、select后面"></a>二、select后面</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">仅仅支持标量子查询</span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure>

<h4 id="案例：查询每个部门的员工个数"><a href="#案例：查询每个部门的员工个数" class="headerlink" title="案例：查询每个部门的员工个数"></a>案例：查询每个部门的员工个数</h4><p>案例：查询每个部门的员工个数</p>
<pre><code>SELECT d.*,(

    SELECT COUNT(*)
    FROM employees e
    WHERE e.department_id = d.`department_id`
 ) 个数
 FROM departments d;
</code></pre>
<h4 id="三、exists后面（相关子查询）"><a href="#三、exists后面（相关子查询）" class="headerlink" title="三、exists后面（相关子查询）"></a>三、exists后面（相关子查询）</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">语法：</span><br><span class="line">exists(完整的查询语句)</span><br><span class="line">结果：</span><br><span class="line">1或0</span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure>



<pre><code>SELECT EXISTS(SELECT employee_id FROM employees WHERE salary=300000);
</code></pre>
<h3 id="进阶8：分页查询"><a href="#进阶8：分页查询" class="headerlink" title="进阶8：分页查询"></a>进阶8：分页查询</h3><p>应用场景：</p>
<pre><code>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句
</code></pre>
<p>语法：</p>
<pre><code>select 字段|表达式,...
from 表
【where 条件】
【group by 分组字段】
【having 条件】
【order by 排序的字段】
limit 【起始的条目索引，】条目数;
</code></pre>
<p>特点：</p>
<pre><code>1.起始条目索引从0开始

2.limit子句放在查询语句的最后

3.公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage
假如:
每页显示条目数sizePerPage
要显示的页数 page
</code></pre>
<h3 id="进阶9：联合查询"><a href="#进阶9：联合查询" class="headerlink" title="进阶9：联合查询"></a>进阶9：联合查询</h3><p>引入：<br>    union 联合、合并</p>
<p>语法：</p>
<pre><code>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】
select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】
select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】
.....
select 字段|常量|表达式|函数 【from 表】 【where 条件】
</code></pre>
<p>特点：</p>
<pre><code>1、多条查询语句的查询的列数必须是一致的
2、多条查询语句的查询的列的类型几乎相同
3、union代表去重，union all代表不去重
</code></pre>
<h2 id="六、DML语言的学习"><a href="#六、DML语言的学习" class="headerlink" title="六、DML语言的学习"></a>六、DML语言的学习</h2><h3 id="插入语句"><a href="#插入语句" class="headerlink" title="插入语句"></a>插入语句</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">	insert into 表名(字段名，...)</span><br><span class="line">	values(值1，...);</span><br></pre></td></tr></tbody></table></figure>

<p>特点：</p>
<pre><code>1、字段类型和值类型一致或兼容，而且一一对应
2、可以为空的字段，可以不用插入值，或用null填充
3、不可以为空的字段，必须插入值
4、字段个数和值的个数必须一致
5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致
</code></pre>
<h3 id="修改语句"><a href="#修改语句" class="headerlink" title="修改语句"></a>修改语句</h3><pre><code>修改单表语法：
update 表名 set 字段=新值,字段=新值
【where 条件】
修改多表语法：
update 表1 别名1,表2 别名2
set 字段=新值，字段=新值
where 连接条件
and 筛选条件
</code></pre>
<h3 id="删除语句"><a href="#删除语句" class="headerlink" title="删除语句"></a>删除语句</h3><h4 id="方式1：delete语句"><a href="#方式1：delete语句" class="headerlink" title="方式1：delete语句"></a>方式1：delete语句</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">单表的删除： ★</span><br><span class="line">	delete from 表名 【where 筛选条件】</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">多表的删除：</span><br><span class="line">	delete 别名1，别名2</span><br><span class="line">	from 表1 别名1，表2 别名2</span><br><span class="line">	where 连接条件</span><br><span class="line">	and 筛选条件;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="方式2：truncate语句"><a href="#方式2：truncate语句" class="headerlink" title="方式2：truncate语句"></a>方式2：truncate语句</h4><pre><code>truncate table 表名
</code></pre>
<h4 id="两种方式的区别【面试题】"><a href="#两种方式的区别【面试题】" class="headerlink" title="两种方式的区别【面试题】"></a>两种方式的区别【面试题】</h4><pre><code>1.truncate不能加where条件，而delete可以加where条件
2.truncate的效率高一丢丢
3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始
    delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始
4.truncate删除不能回滚，delete删除可以回滚
</code></pre>
<h2 id="七、DDL语言的学习"><a href="#七、DDL语言的学习" class="headerlink" title="七、DDL语言的学习"></a>七、DDL语言的学习</h2><h3 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h3><h4 id="库的管理："><a href="#库的管理：" class="headerlink" title="库的管理："></a>库的管理：</h4><pre><code>一、创建库
create database 库名
二、删除库
drop database 库名
</code></pre>
<h4 id="表的管理："><a href="#表的管理：" class="headerlink" title="表的管理："></a>表的管理：</h4><h5 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1.创建表"></a>1.创建表</h5><pre><code>CREATE TABLE IF NOT EXISTS stuinfo(
    stuId INT,
    stuName VARCHAR(20),
    gender CHAR,
    bornDate DATETIME
);
DESC studentinfo;
</code></pre>
<h5 id="2-修改表-alter"><a href="#2-修改表-alter" class="headerlink" title="2.修改表 alter"></a>2.修改表 alter</h5><pre><code>语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;

①修改字段名
ALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;

②修改表名
ALTER TABLE stuinfo RENAME [TO]  studentinfo;

③修改字段类型和列级约束
ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;

④添加字段
ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;

⑤删除字段
ALTER TABLE studentinfo DROP COLUMN email;
</code></pre>
<p>​    </p>
<h5 id="3-删除表"><a href="#3-删除表" class="headerlink" title="3.删除表"></a>3.删除表</h5><pre><code>DROP TABLE [IF EXISTS] studentinfo;
</code></pre>
<h5 id="4-复制表"><a href="#4-复制表" class="headerlink" title="4.复制表"></a>4.复制表</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1.仅仅复制表的结构</span><br><span class="line">	CREATE TABLE 新表名 LIKE 旧表名;</span><br><span class="line"></span><br><span class="line">2.复制表的结构+数据</span><br><span class="line">	CREATE TABLE 新表名 </span><br><span class="line">	SELECT * FROM 旧表名;</span><br><span class="line"></span><br><span class="line">3.只复制部分数据</span><br><span class="line">	CREATE TABLE 新表名</span><br><span class="line">	SELECT id,au_name</span><br><span class="line">	FROM 旧表名 </span><br><span class="line">	WHERE nation='中国';</span><br><span class="line">	</span><br><span class="line">4.仅仅复制某些字段</span><br><span class="line">	CREATE TABLE 新表名 </span><br><span class="line">	SELECT id,au_name</span><br><span class="line">	FROM 旧表名</span><br><span class="line">	WHERE 0;</span><br></pre></td></tr></tbody></table></figure>



<h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><pre><code>整型：      Tinyint 1个字节
        Smallint 2个字节
        Mediumint 3个字节
        Int、Integer 4个字节
        Bigint   8个字节
特点：
① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字
② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值
③ 如果不设置长度，会有默认的长度
长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！

小数：
    分类：
    1.浮点型
    float(M,D)
    double(M,D)
    2.定点型
    dec(M，D)
    decimal(M,D)
    
    特点：
    
    ①
    M：整数部位+小数部位
    D：小数部位
    如果超过范围，则插入临界值
    
    ②
    M和D都可以省略
    如果是decimal，则M默认为10，D默认为0
    如果是float和double，则会根据插入的数值的精度来决定精度
    
    ③定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用

字符型：
特点：
        写法            M的意思                            特点            空间的耗费        效率
char    char(M)        最大的字符数，可以省略，默认为1    固定长度的字符        比较耗费           高
varchar varchar(M)    最大的字符数，不可以省略        可变长度的字符            比较节省          低


日期型：
分类：
    date只保存日期
    time 只保存时间
    year只保存年
    
    datetime保存日期+时间
    timestamp保存日期+时间
特点：
            字节        范围                      时区等的影响
datetime    8        1000——9999                      不受
timestamp    4        1970-2038                        受
</code></pre>
<p>​    </p>
<h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><pre><code>NOT NULL
DEFAULT
UNIQUE
CHECK
PRIMARY KEY
FOREIGN KEY
分类：六大约束
    NOT NULL：非空，用于保证该字段的值不能为空
    比如姓名、学号等
    DEFAULT:默认，用于保证该字段有默认值
    比如性别
    PRIMARY KEY:主键，用于保证该字段的值具有唯一性，并且非空
    比如学号、员工编号等
    UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为空
    比如座位号
    CHECK:检查约束【mysql中不支持】
    比如年龄、性别
    FOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值
        在从表添加外键约束，用于引用主表中某列的值
    比如学生表的专业编号，员工表的部门编号，员工表的工种编号
</code></pre>
<p>​    </p>
<pre><code>添加约束的时机：
        1.创建表时
        2.修改表时
        
约束的添加分类：
    列级约束：
            六大约束语法上都支持，但外键约束没有效果
    表级约束：
            除了非空、默认，其他的都支持
</code></pre>
<p>​            </p>
<h5 id="主键和唯一的大对比："><a href="#主键和唯一的大对比：" class="headerlink" title="主键和唯一的大对比："></a>主键和唯一的大对比：</h5><pre><code>        保证唯一性  是否允许为空    一个表中可以有多少个   是否允许组合
    主键    √            ×                至多有1个           √，但不推荐
    唯一    √            √                可以有多个          √，但不推荐
外键：
    1、要求在从表设置外键关系
    2、从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求
    3、主表的关联列必须是一个key（一般是主键或唯一）
    4、插入数据时，先插入主表，再插入从表
        删除数据时，先删除从表，再删除主表
</code></pre>
<p>​    </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">查看stuinfo中的所有索引，包括主键、外键、唯一</span><br><span class="line">SHOW INDEX FROM stuinfo;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-添加表级约束"><a href="#2-添加表级约束" class="headerlink" title="2.添加表级约束"></a>2.添加表级约束</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">语法：在各个字段的最下面</span><br><span class="line"> 【constraint 约束名】 约束类型(字段名) </span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure>

<pre><code>DROP TABLE IF EXISTS stuinfo;
CREATE TABLE stuinfo(
    id INT,
    stuname VARCHAR(20),
    gender CHAR(1),
    seat INT,
    age INT,
    majorid INT,
CONSTRAINT pk PRIMARY KEY(id),#主键
CONSTRAINT uq UNIQUE(seat),#唯一键
CONSTRAINT ck CHECK(gender ='男' OR gender  = '女'),#检查
CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键
);
</code></pre>
<h5 id="二、修改表时添加约束"><a href="#二、修改表时添加约束" class="headerlink" title="二、修改表时添加约束"></a>二、修改表时添加约束</h5><pre><code>1、添加列级约束
alter table 表名 modify column 字段名 字段类型 新约束;

2、添加表级约束
alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;    */
    1.添加非空约束
    ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;
    2.添加默认约束
    ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;
3.添加主键
    ①列级约束
    ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;
    ②表级约束
    ALTER TABLE stuinfo ADD PRIMARY KEY(id);
    
4.添加唯一
①列级约束
ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;
②表级约束
ALTER TABLE stuinfo ADD UNIQUE(seat);

5.添加外键
ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); 
</code></pre>
<p>​    </p>
<h5 id="三、修改表时删除约束"><a href="#三、修改表时删除约束" class="headerlink" title="三、修改表时删除约束"></a>三、修改表时删除约束</h5><pre><code>1.删除非空约束
ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;

2.删除默认约束
ALTER TABLE stuinfo MODIFY COLUMN age INT ;

3.删除主键
ALTER TABLE stuinfo DROP PRIMARY KEY;

4.删除唯一
ALTER TABLE stuinfo DROP INDEX seat;

5.删除外键
ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;

SHOW INDEX FROM stuinfo;
</code></pre>
<p>​    </p>
<h5 id="标识列"><a href="#标识列" class="headerlink" title="标识列"></a>标识列</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line">又称为自增长列</span><br><span class="line">含义：可以不用手动的插入值，系统提供默认的序列值</span><br><span class="line">	特点：</span><br><span class="line">	1、标识列必须和主键搭配吗？不一定，但要求是一个key</span><br><span class="line">	2、一个表可以有几个标识列？至多一个！</span><br><span class="line">	3、标识列的类型只能是数值型</span><br><span class="line">	4、标识列可以通过 SET auto_increment_increment=3;设置步长</span><br><span class="line">		可以通过 手动插入值，设置起始值</span><br><span class="line"></span><br><span class="line">​	</span><br><span class="line">​	*/</span><br></pre></td></tr></tbody></table></figure>






<h2 id="八、TCL语言的学习"><a href="#八、TCL语言的学习" class="headerlink" title="八、TCL语言的学习"></a>八、TCL语言的学习</h2><h3 id="事务和事务处理"><a href="#事务和事务处理" class="headerlink" title="事务和事务处理"></a>事务和事务处理</h3><h4 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h4><h5 id="含义"><a href="#含义" class="headerlink" title="含义:"></a>含义:</h5><p>​    通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">（ACID）</span><br><span class="line">	原子性：要么都执行，要么都回滚</span><br><span class="line">	一致性：保证数据的状态操作前和操作后保持一致</span><br><span class="line">	隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰</span><br><span class="line">	持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改</span><br></pre></td></tr></tbody></table></figure>

<h5 id="相关步骤："><a href="#相关步骤：" class="headerlink" title="相关步骤："></a>相关步骤：</h5><pre><code>1、开启事务
2、编写事务的一组逻辑操作单元（多条sql语句）
3、提交事务或回滚事务
</code></pre>
<h5 id="事务的分类："><a href="#事务的分类：" class="headerlink" title="事务的分类："></a>事务的分类：</h5><pre><code>一、隐式事务，没有明显的开启和结束事务的标志
比如
insert、update、delete语句本身就是一个事务

二、显式事务，具有明显的开启和结束事务的标志
        1、开启事务
            取消自动提交事务的功能

        2、编写事务的一组逻辑操作单元（多条sql语句）
            insert
            update
            delete
    
        3、提交事务或回滚事务
</code></pre>
<h5 id="使用到的关键字："><a href="#使用到的关键字：" class="headerlink" title="使用到的关键字："></a>使用到的关键字：</h5><pre><code>set autocommit=0;
start transaction;
commit;
rollback;

savepoint  断点
commit to 断点
rollback to 断点
</code></pre>
<h5 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别:"></a>事务的隔离级别:</h5><h5 id="事务并发问题如何发生？"><a href="#事务并发问题如何发生？" class="headerlink" title="事务并发问题如何发生？"></a>事务并发问题如何发生？</h5><pre><code>当多个事务同时操作同一个数据库的相同数据时
</code></pre>
<h5 id="事务的并发问题有哪些？"><a href="#事务的并发问题有哪些？" class="headerlink" title="事务的并发问题有哪些？"></a>事务的并发问题有哪些？</h5><pre><code>脏读：一个事务读取到了另外一个事务未提交的数据
不可重复读：同一个事务中，多次读取到的数据不一致
幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据
</code></pre>
<h5 id="如何避免事务的并发问题？"><a href="#如何避免事务的并发问题？" class="headerlink" title="如何避免事务的并发问题？"></a>如何避免事务的并发问题？</h5><pre><code>通过设置事务的隔离级别
1、READ UNCOMMITTED
2、READ COMMITTED 可以避免脏读
3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读
4、SERIALIZABLE可以避免脏读、不可重复读和幻读

    事务的隔离级别：
                  脏读        不可重复读    幻读
read uncommitted：√                √        √
read committed：  ×                √        √
repeatable read： ×                ×        √
serializable      ×             ×       ×
</code></pre>
<p>​<br>    mysql中默认 第三个隔离级别 repeatable read<br>    oracle中默认第二个隔离级别 read committed</p>
<pre><code>设置隔离级别：
set session|global  transaction isolation level 隔离级别名;

查看隔离级别：
select @@tx_isolation;
</code></pre>
<h2 id="九、视图的讲解"><a href="#九、视图的讲解" class="headerlink" title="九、视图的讲解"></a>九、视图的讲解</h2><h4 id="含义："><a href="#含义：" class="headerlink" title="含义："></a>含义：</h4><p>​    理解成一张虚拟的表</p>
<h4 id="视图和表的区别："><a href="#视图和表的区别：" class="headerlink" title="视图和表的区别："></a>视图和表的区别：</h4><pre><code>    使用方式    占用物理空间

视图    完全相同    不占用，仅仅保存的是sql逻辑

表    完全相同    占用
</code></pre>
<h4 id="视图的好处："><a href="#视图的好处：" class="headerlink" title="视图的好处："></a>视图的好处：</h4><pre><code>1、sql语句提高重用性，效率高
2、和表实现了分离，提高了安全性
</code></pre>
<h3 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">	CREATE VIEW  视图名</span><br><span class="line">	AS</span><br><span class="line">	查询语句;</span><br></pre></td></tr></tbody></table></figure>



<pre><code>例如：1.查询姓名中包含a字符的员工名、部门名和工种信息
①创建
CREATE VIEW myv1
AS

SELECT last_name,department_name,job_title
FROM employees e
JOIN departments d ON e.department_id  = d.department_id
JOIN jobs j ON j.job_id  = e.job_id;

②使用
SELECT * FROM myv1 WHERE last_name LIKE '%a%';
</code></pre>
<p>​    </p>
<h3 id="视图的增删改查"><a href="#视图的增删改查" class="headerlink" title="视图的增删改查"></a>视图的增删改查</h3><pre><code>1、查看视图的数据 ★
SELECT * FROM my_v4;
SELECT * FROM my_v1 WHERE last_name='Partners';

2、插入视图的数据
INSERT INTO my_v4(last_name,department_id) VALUES('虚竹',90);

3、修改视图的数据
UPDATE my_v4 SET last_name ='梦姑' WHERE last_name='虚竹';

4、删除视图的数据
DELETE FROM my_v4;
</code></pre>
<p>​    </p>
<h3 id="某些视图不能更新"><a href="#某些视图不能更新" class="headerlink" title="某些视图不能更新"></a>某些视图不能更新</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all</span><br><span class="line">	常量视图</span><br><span class="line">	Select中包含子查询</span><br><span class="line">	join</span><br><span class="line">	from一个不能更新的视图</span><br><span class="line">	where子句的子查询引用了from子句中的表</span><br></pre></td></tr></tbody></table></figure>



<h3 id="视图逻辑的更新"><a href="#视图逻辑的更新" class="headerlink" title="视图逻辑的更新"></a>视图逻辑的更新</h3><pre><code>方式一：
    CREATE OR REPLACE VIEW test_v7
    AS
    SELECT last_name FROM employees
    WHERE employee_id&gt;100;
    
方式二:
ALTER VIEW test_v7
AS
SELECT employee_id FROM employees;

SELECT * FROM test_v7;
</code></pre>
<h3 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">DROP VIEW test_v1,test_v2,test_v3;</span><br></pre></td></tr></tbody></table></figure>



<h3 id="视图结构的查看"><a href="#视图结构的查看" class="headerlink" title="视图结构的查看"></a>视图结构的查看</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">DESC test_v7;</span><br><span class="line">	SHOW CREATE VIEW test_v7;</span><br></pre></td></tr></tbody></table></figure>





<h2 id="十、变量"><a href="#十、变量" class="headerlink" title="十、变量"></a>十、变量</h2><h3 id="一、全局变量"><a href="#一、全局变量" class="headerlink" title="一、全局变量"></a>一、全局变量</h3><h5 id="作用域：针对于所有会话（连接）有效，但不能跨重启"><a href="#作用域：针对于所有会话（连接）有效，但不能跨重启" class="headerlink" title="作用域：针对于所有会话（连接）有效，但不能跨重启"></a>作用域：针对于所有会话（连接）有效，但不能跨重启</h5><pre><code>查看所有全局变量
SHOW GLOBAL VARIABLES;
查看满足条件的部分系统变量
SHOW GLOBAL VARIABLES LIKE '%char%';
查看指定的系统变量的值
SELECT @@global.autocommit;
为某个系统变量赋值
SET @@global.autocommit=0;
SET GLOBAL autocommit=0;
</code></pre>
<h3 id="二、会话变量"><a href="#二、会话变量" class="headerlink" title="二、会话变量"></a>二、会话变量</h3><h5 id="作用域：针对于当前会话（连接）有效"><a href="#作用域：针对于当前会话（连接）有效" class="headerlink" title="作用域：针对于当前会话（连接）有效"></a>作用域：针对于当前会话（连接）有效</h5><pre><code>查看所有会话变量
SHOW SESSION VARIABLES;
查看满足条件的部分会话变量
SHOW SESSION VARIABLES LIKE '%char%';
查看指定的会话变量的值
SELECT @@autocommit;
SELECT @@session.tx_isolation;
为某个会话变量赋值
SET @@session.tx_isolation='read-uncommitted';
SET SESSION tx_isolation='read-committed';
</code></pre>
<h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><h4 id="一、用户变量"><a href="#一、用户变量" class="headerlink" title="一、用户变量"></a>一、用户变量</h4><h5 id="声明并初始化："><a href="#声明并初始化：" class="headerlink" title="声明并初始化："></a>声明并初始化：</h5><pre><code>SET @变量名=值;
SET @变量名:=值;
SELECT @变量名:=值;
</code></pre>
<h5 id="赋值："><a href="#赋值：" class="headerlink" title="赋值："></a>赋值：</h5><pre><code>方式一：一般用于赋简单的值
SET 变量名=值;
SET 变量名:=值;
SELECT 变量名:=值;


方式二：一般用于赋表 中的字段值
SELECT 字段名或表达式 INTO 变量
FROM 表;
</code></pre>
<h5 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h5><pre><code>select @变量名;
</code></pre>
<h4 id="二、局部变量"><a href="#二、局部变量" class="headerlink" title="二、局部变量"></a>二、局部变量</h4><h5 id="声明："><a href="#声明：" class="headerlink" title="声明："></a>声明：</h5><pre><code>declare 变量名 类型 【default 值】;
</code></pre>
<h5 id="赋值：-1"><a href="#赋值：-1" class="headerlink" title="赋值："></a>赋值：</h5><pre><code>方式一：一般用于赋简单的值
SET 变量名=值;
SET 变量名:=值;
SELECT 变量名:=值;


方式二：一般用于赋表 中的字段值
SELECT 字段名或表达式 INTO 变量
FROM 表;
</code></pre>
<h5 id="使用：-1"><a href="#使用：-1" class="headerlink" title="使用："></a>使用：</h5><pre><code>select 变量名
</code></pre>
<h5 id="二者的区别："><a href="#二者的区别：" class="headerlink" title="二者的区别："></a>二者的区别：</h5><pre><code>            作用域                定义位置            语法
用户变量    当前会话        会话的任何地方            加@符号，不用指定类型  
局部变量    定义它的BEGIN END中     BEGIN END的第一句话    一般不用加@,需要指定类型
</code></pre>
<h2 id="十一、存储过程和函数"><a href="#十一、存储过程和函数" class="headerlink" title="十一、存储过程和函数"></a>十一、存储过程和函数</h2><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><h4 id="含义：一组经过预先编译的sql语句的集合"><a href="#含义：一组经过预先编译的sql语句的集合" class="headerlink" title="含义：一组经过预先编译的sql语句的集合"></a>含义：一组经过预先编译的sql语句的集合</h4><h5 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h5><pre><code>1、提高了sql语句的重用性，减少了开发程序员的压力
2、提高了效率
3、减少了传输次数
</code></pre>
<h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><pre><code>1、无返回无参
2、仅仅带in类型，无返回有参
3、仅仅带out类型，有返回无参
4、既带in又带out，有返回有参
5、带inout，有返回有参
注意：in、out、inout都可以在一个存储过程中带多个
</code></pre>
<h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><pre><code>create procedure 存储过程名(in|out|inout 参数名  参数类型,...)
begin
    存储过程体

end
</code></pre>
<h5 id="类似于方法："><a href="#类似于方法：" class="headerlink" title="类似于方法："></a>类似于方法：</h5><pre><code>修饰符 返回类型 方法名(参数类型 参数名,...){

    方法体;
}
</code></pre>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><pre><code>1、需要设置新的结束标记
delimiter 新的结束标记
示例：
delimiter $

CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)
BEGIN
    sql语句1;
    sql语句2;

END $

2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end

3、参数前面的符号的意思
in:该参数只能作为输入 （该参数不能做返回值）
out：该参数只能作为输出（该参数只能做返回值）
inout：既能做输入又能做输出
</code></pre>
<h4 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h4><p>​    </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">call 存储过程名(实参列表)</span><br></pre></td></tr></tbody></table></figure>



<h5 id="案例：-1"><a href="#案例：-1" class="headerlink" title="案例："></a>案例：</h5><pre><code>1.创建带in模式参数的存储过程
案例1：创建存储过程实现 根据女神名，查询对应的男神信息

CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))
DELIMITER $
BEGIN
    SELECT bo.*
    FROM boys bo
    RIGHT JOIN beauty b ON bo.id = b.boyfriend_id
    WHERE b.name=beautyName;
END $

调用
CALL myp2('柳岩')$
</code></pre>
<p>​<br>​<br>​<br>    案例2 ：创建存储过程实现，用户是否登录成功</p>
<pre><code>CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))
BEGIN
    DECLARE result INT DEFAULT 0;#声明并初始化
    
    SELECT COUNT(*) INTO result#赋值
    FROM admin
    WHERE admin.username = username
    AND admin.password = PASSWORD;
    
    SELECT IF(result&gt;0,'成功','失败');#使用
END $

#调用
CALL myp3('张飞','8888')$
</code></pre>
<h4 id="三、删除存储过程"><a href="#三、删除存储过程" class="headerlink" title="三、删除存储过程"></a>三、删除存储过程</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">语法：drop procedure 存储过程名</span><br><span class="line">		DROP PROCEDURE p1;</span><br></pre></td></tr></tbody></table></figure>



<h4 id="四、查看存储过程的信息"><a href="#四、查看存储过程的信息" class="headerlink" title="四、查看存储过程的信息"></a>四、查看存储过程的信息</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">DESC myp2;×//错误</span><br><span class="line">SHOW CREATE PROCEDURE  myp2;</span><br></pre></td></tr></tbody></table></figure>



<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h4><p>学过的函数：LENGTH、SUBSTR、CONCAT等<br>语法：</p>
<pre><code>CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型
BEGIN
    函数体

END
</code></pre>
<h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">SELECT 函数名（实参列表）</span><br></pre></td></tr></tbody></table></figure>



<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><pre><code>案例1：根据部门名，返回该部门的平均工资
CREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLE
BEGIN
    DECLARE sal DOUBLE ;
    SELECT AVG(salary) INTO sal
    FROM employees e
    JOIN departments d ON e.department_id = d.department_id
    WHERE d.department_name=deptName;
    RETURN sal;
END $

SELECT myf3('IT')$
</code></pre>
<h5 id="函数和存储过程的区别"><a href="#函数和存储过程的区别" class="headerlink" title="函数和存储过程的区别"></a>函数和存储过程的区别</h5><pre><code>        关键字        调用语法    返回值            应用场景
函数        FUNCTION    SELECT 函数()    只能是一个        一般用于查询结果为一个值并返回时，当有返回值而                                                        且仅仅一个
存储过程    PROCEDURE    CALL 存储过程()    可以有0个或多个        一般用于更新
</code></pre>
<h2 id="十二、流程控制结构"><a href="#十二、流程控制结构" class="headerlink" title="十二、流程控制结构"></a>十二、流程控制结构</h2><h3 id="一、if函数"><a href="#一、if函数" class="headerlink" title="一、if函数"></a>一、if函数</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">语法：if(条件，值1，值2)</span><br></pre></td></tr></tbody></table></figure>


<p>​    特点：可以用在任何位置</p>
<h3 id="二、case语句"><a href="#二、case语句" class="headerlink" title="二、case语句"></a>二、case语句</h3><h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><pre><code>情况一：类似于switch
case 表达式
when 值1 then 结果1或语句1(如果是语句，需要加分号) 
when 值2 then 结果2或语句2(如果是语句，需要加分号)
...
else 结果n或语句n(如果是语句，需要加分号)
end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）

情况二：类似于多重if
case 
when 条件1 then 结果1或语句1(如果是语句，需要加分号) 
when 条件2 then 结果2或语句2(如果是语句，需要加分号)
...
else 结果n或语句n(如果是语句，需要加分号)
end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）
</code></pre>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>​    可以用在任何位置</p>
<h3 id="三、if-elseif语句"><a href="#三、if-elseif语句" class="headerlink" title="三、if elseif语句"></a>三、if elseif语句</h3><h5 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h5><pre><code>if 情况1 then 语句1;
elseif 情况2 then 语句2;
...
else 语句n;
end if;
</code></pre>
<h5 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h5><p>​    只能用在begin end中！！！！！！！！！！！！！！！</p>
<p>三者比较：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">				应用场合</span><br><span class="line">if函数			简单双分支</span><br><span class="line">case结构		等值判断 的多分支</span><br><span class="line">if结构		区间判断 的多分支</span><br></pre></td></tr></tbody></table></figure>



<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>语法：</p>
<pre><code>【标签：】WHILE 循环条件  DO
    循环体
END WHILE 【标签】;
</code></pre>
<p>特点：</p>
<pre><code>只能放在BEGIN END里面

如果要搭配leave跳转语句，需要使用标签，否则可以不用标签

leave类似于java中的break语句，跳出所在循环！！！
</code></pre>
<h5 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h5><pre><code>/*一、已知表stringcontent
    其中字段：
    id 自增长
    content varchar(20)
向该表插入指定个数的，随机的字符串
*/
DROP TABLE IF EXISTS stringcontent;
CREATE TABLE stringcontent(
    id INT PRIMARY KEY AUTO_INCREMENT,
    content VARCHAR(20)
    
);
DELIMITER $
CREATE PROCEDURE test_randstr_insert(IN insertCount INT)
BEGIN
    DECLARE i INT DEFAULT 1;
    DECLARE str VARCHAR(26) DEFAULT 'abcdefghijklmnopqrstuvwxyz';
    DECLARE startIndex INT;#代表初始索引
    DECLARE len INT;#代表截取的字符长度
    WHILE i&lt;=insertcount DO
        SET startIndex=FLOOR(RAND()*26+1);#代表初始索引，随机范围1-26
        SET len=FLOOR(RAND()*(20-startIndex+1)+1);#代表截取长度，随机范围1-（20-startIndex+1）
        INSERT INTO stringcontent(content) VALUES(SUBSTR(str,startIndex,len));
        SET i=i+1;
    END WHILE;

END $

CALL test_randstr_insert(10)$
</code></pre>
<h2 id="十三、数据库三大范式"><a href="#十三、数据库三大范式" class="headerlink" title="十三、数据库三大范式"></a>十三、数据库三大范式</h2><p> </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">  	  1NF:字段不可再分,原子性。  </span><br><span class="line">     2NF:满足第二范式( 2NF )必须先满足第一范式( 1NF )。 一个表只能说明一个事物。非主键属性必须完全依赖于主键属性。  </span><br><span class="line">     3NF:满足第三范式( 3NF ) 必须先满足第二范式( 2NF ) 。每 列都与主键有直接关系,不存在传递依赖。 任何非主属性不依赖于其它 非主属性。</span><br></pre></td></tr></tbody></table></figure>



<p>参考：</p>
<h5 id="哔哩哔哩尚硅谷讲堂"><a href="#哔哩哔哩尚硅谷讲堂" class="headerlink" title="哔哩哔哩尚硅谷讲堂"></a>哔哩哔哩尚硅谷讲堂</h5><h5 id="哔哩哔哩图灵学院"><a href="#哔哩哔哩图灵学院" class="headerlink" title="哔哩哔哩图灵学院"></a>哔哩哔哩图灵学院</h5><p><strong>github：java2020</strong></p>
</body></html>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>基本排序算法</title>
    <url>/981a96f7.html</url>
    <content><![CDATA[<html><head></head><body><table>
<thead>
<tr>
<th>排序类型</th>
<th>平均情况</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>辅助空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>直接插入排序</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>折半插入排序</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(n^1.3)</td>
<td>O(nlogn)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(n²)</td>
<td>O(nlog₂n)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(k)</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n²)</td>
<td>O(n+k)</td>
<td>(不)稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(d(n+k))</td>
<td>O(d(n+k))</td>
<td>O(d(n+kd))</td>
<td>O(n+kd)</td>
<td>稳定</td>
</tr>
</tbody></table>
<span id="more"></span>

<p>推荐文章：<a href="https://www.cnblogs.com/morethink/p/8419151.html#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">https://www.cnblogs.com/morethink/p/8419151.html#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F</a></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>原理：从第一个数开始，连续两个数取最大的那个数，然后最大的数和后面的数进行对比，在一轮循环后最大的数一定冒泡到最后，然后下一轮冒泡，最后的数就不用参与（因为最后的数经过冒泡后一定是这一轮最大的）、</p>
<p>实现：</p>
<ol>
<li>for循环，因为是当前数和下一个数比较，最后一个数没有下一个，所以一共进行length - 1轮</li>
<li>每一次比较的都是前面没有排好的数字（0到（长度-经过排序的轮数也就是i）</li>
<li>如果当前数比后面的数大，进行交换</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaoPaoSort</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> arr[] = {<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">9</span>};</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) {</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="优化冒泡排序"><a href="#优化冒泡排序" class="headerlink" title="优化冒泡排序"></a>优化冒泡排序</h3><p>当数组中已经是有序数据，或者经过冒泡后已经使上面的数据变得有序，那么上面的程序还是会继续进行下去，进行无意义的比较</p>
<p>当一个数组变的有序的时候，那么在第二次比较的过程中一定不会发生交换，而数组无序的时候，在进行冒泡的时候一定会发生至少一次比较交换。</p>
<p>可以设置一个变量，来标记当前数组是否已经有序。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/java-interview/bubble.gif" alt="img"></p>
<p>实现：</p>
<ol>
<li><p>在冒泡排序的基础上，添加一个标志位flag</p>
</li>
<li><p>在第一个for循环中初始化</p>
</li>
<li><p>在第二个for循环全部结束后判断是否发生了交换，如果为发生交换则数组已经有序，跳出循环</p>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/26 18:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaoPaoSortPlus</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> arr[] = {-<span class="number">1</span>, -<span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span> , <span class="number">5</span>, <span class="number">8</span>};</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) {</span><br><span class="line">            flag=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) {</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                }</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (flag){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意：</strong></p>
<p>必须把flag=true放到第一次for循环内部，在没一轮冒泡前都要对flag进行一次初始化，因为可能经过上一轮数组已经变得有序，此时发生了交换flag = false，如果不对flag进行初始化，那么在下一轮之后一直都是false，就算已经排序好了未发生交换也不能跳出循环。</p>
<hr>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>原理：选择一轮中最小的那个数据，然后把最小的数据放到最开始的位置，这样在每一轮循环完毕后数组前面的数一定是本次循环中最小的那个数。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/java-interview/28749720-90304278-7503-11e7-9bc8-e3b56539d8bf.gif" alt="img"></p>
<p>实现：</p>
<ol>
<li>定义本轮循环开始的初始位置下标min（因为min个前面数字一定是最小的且已经是有序的）</li>
<li>for循环，因为是当前数和下一个数比较，最后一个数没有下一个，所以一共进行length - 1轮</li>
<li>获取当前开始下标i，min = i</li>
<li>for循环，初始值为i + 1，（自身和自身比较没有意义），循环到最后</li>
<li>如果中间有数据比minValue（arr[min]）小，拿到这个下标j，min = j</li>
<li>在一轮循环结束后，交换min和本轮开始的最初下标i的位置，使本轮循环的最小数放到最前的位置</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/26 21:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] arr = {<span class="number">8</span>, -<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">9</span>};</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        <span class="keyword">int</span> minValue;<span class="comment">//这个变量可有可无，如果没有可以用arr[min]代替，用少许空间换少许时间，没有太大影响</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) {</span><br><span class="line">            min = i;</span><br><span class="line">            minValue = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) {</span><br><span class="line">                <span class="keyword">if</span> (minValue &gt; arr[j]) {</span><br><span class="line">                    min = j;</span><br><span class="line">                    minValue = arr[j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (min != i) {</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[min];</span><br><span class="line">                arr[min] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>和冒泡排序对比：</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>原理</th>
<th>实现</th>
<th>交换次数</th>
<th>核心</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>最大值放最后，每一轮最后的数一定是所有数里面最大的，数值对比后立马发生交换，最大的继续和下面的数比较</td>
<td>第一个数和后面的数比较，如果第一个数大则交换位置，大的数继续和下一位数比较一直到length-i；</td>
<td>每一轮比较都有可能发生(length-i-1)次交换</td>
<td>第i轮一定是，length-i个数里面最大的，最后i个数一定是整体有序</td>
</tr>
<tr>
<td>选择排序</td>
<td>最小值放最前，每一轮的第一个数一定是所有数里面最小的，数值对比后，记录最小值，在一轮结束后，最小值和开始的arr[i]交换</td>
<td>从i开始，选择最小的数，记录最小数的下标，一直到length；在一轮循环结束后，交换i和最小数的下标，把最小的数放在最前面；</td>
<td>在没一轮结束后，发生一次交换</td>
<td>第i轮一定是，ength-i个数里面最小 的，前面i个一定是整体有序</td>
</tr>
</tbody></table>
<hr>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>原理：从第i个数开始，对前面的数进行比较，如果前面的数比arr[i]大则前面的数后移（或交换位置），继续和前面的数比较，直到前面的一位数小于arr[i]，这样保证了每一轮前i个数是从小到大有序的，只需要给i这个数选择一个合适的位置</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/java-interview/28749729-ca072084-7503-11e7-881c-92aa915ce369.gif" alt="img"></p>
<p>实现：</p>
<ol>
<li>for循环从1开始到length，（如果发生比较次数都为lentth-1，无论是从0开始还是从1开始都可以实现算法，以为是和前面的发生比较，所以从1开始更好，如果和后面的发生比较，从0开始更好）</li>
<li>因为第一轮从1开始，第二次for循环从i开始，和前面的i发生比较，如果前面的值大于当前值，发生交换</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/26 21:32</span></span><br><span class="line"><span class="comment"> * 通过交换实现插入排序，类似于冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSortWithExchange</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> arr[] = {<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">9</span>};</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> ; j--) {</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j -<span class="number">1</span>]) {</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                    arr[j - <span class="number">1</span>] = temp;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实现：</p>
<ol>
<li>for循环从1开始到length，（如果发生比较次数都为lentth-1，无论是从0开始还是从1开始都可以实现算法，以为是和前面的发生比较，所以从1开始更好，如果和后面的发生比较，从0开始更好）</li>
<li>因为第一轮从1开始，第二次for循环从i开始，和前面的i发生比较，如果前面的值大于当前值，发生较大的值向后移，最后结束的时候才交换位置</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/26 21:42</span></span><br><span class="line"><span class="comment"> * 后移但是不交换，最后才发生交换，类似选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSortWithInsert</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> arr[] = {<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">9</span>};</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        <span class="keyword">int</span> minValue;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) {</span><br><span class="line">            min = i;</span><br><span class="line">            minValue = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> ; j--) {</span><br><span class="line">                <span class="keyword">if</span> (minValue &lt;  arr[j - <span class="number">1</span>]) {</span><br><span class="line">                   arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">                   min -- ;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            arr[min] = minValue;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<table>
<thead>
<tr>
<th>算法</th>
<th>原理</th>
<th>实现</th>
<th>交换次数</th>
<th>核心</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>最大值放最后，每一轮最后的数一定是<strong>所有数里面最大</strong>的，数值对比后立马发生交换，最大的继续和下面的数比较</td>
<td>第一个数和后面的数比较，如果第一个数大则交换位置，大的数继续和下一位数比较一直到length-i；</td>
<td>每一轮比较都有可能发生(length-i-1)次交换</td>
<td>第i轮一定是，length-i个数里面最大的，最后i个数一定是<strong>整体有序</strong></td>
<td></td>
</tr>
<tr>
<td>选择排序</td>
<td>最小值放最前，每一轮的第一个数一定是<strong>所有数里面最小</strong>的，数值对比后，记录最小值，在一轮结束后，最小值和开始的arr[i]交换</td>
<td>从i开始，选择最小的数，记录最小数的下标，一直到length；在一轮循环结束后，交换i和最小数的下标，把最小的数放在最前面；</td>
<td>在没一轮结束后，发生一次交换</td>
<td>第i轮一定是，ength-i个数里面最小 的，前面i个一定是<strong>整体有序</strong></td>
<td></td>
</tr>
<tr>
<td>插入排序</td>
<td>最小值放全面卖弄，每一轮第一个数一定是<strong>本轮数最小</strong>的</td>
<td></td>
<td>不确定</td>
<td>从i开始，保证i前面的数是<strong>本轮有序</strong>的，最小的值向前移动</td>
<td></td>
</tr>
</tbody></table>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>原理：希尔排序是插入排序的升级版，对于插入排序而言如果数组已经是有序的那么时间复杂度为O（N），找需要经历一次循环就可以，而希尔排序，就会分批次尽可能的让数组有序，</p>
<p>实现：</p>
<ol>
<li>对数组划分步长，进行for循环每次的步长为数组总长度的1/2，直到步长小于0</li>
<li>对插入排序的直接使用，知识插入排序的步长为1，而希尔排序的步长是动态变化的</li>
<li>for循环，以步长为开始，步长后的第一个数开始比较</li>
<li>while循环，当前位置大于一个步长且与前面对此，minValue &lt; arr[min - grap]，则之前打的数后移</li>
<li>在一轮驯化结束后，把较小的数放回步长开始的位置</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSortWithInsert</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> arr[] = {<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">9</span>};</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        <span class="keyword">int</span> minValue;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> grap = arr.length / <span class="number">2</span>; grap &gt; <span class="number">0</span>; grap /= <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = grap; i &lt; arr.length; i++) {</span><br><span class="line">                min = i;</span><br><span class="line">                minValue = arr[i];</span><br><span class="line">                <span class="keyword">while</span> (min &gt;= grap &amp;&amp; minValue &lt; arr[min - grap]) {</span><br><span class="line">                    arr[min] = arr[min - grap];</span><br><span class="line">                    min -= grap;</span><br><span class="line">                }</span><br><span class="line">                arr[min] = minValue;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>原理：快速排序就是使用分治算法把一个序列分成为两个子序列。</p>
<ol>
<li>从数列中挑出一个原色，称为“基准”</li>
<li>重新排序数列，所有比基准值小的元素排在基准面前，所有比基准大的元素摆在基准后面（相同的数可以放到任何一边）。在分区结束后，基准就处于数列的中间位置</li>
<li>递归的把小于基准元素的子数列和大于基准元素的子数列排序。</li>
</ol>
<p>（左右）双指针，从右端开始，如果右端值大于基准值，则右指针向左移动（保证右边的值大于基准值），如果发现右端值小于基准值，则把左指针值放在右指针位置；如果左端的值小于基准值，则左指针向右移动，如果左端的值大于基准值，则把右指针值放到左指针位置；</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuiteSort</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] arr = {<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">9</span>};</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] sort = sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(sort));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high) {</span><br><span class="line">        <span class="keyword">if</span> (low &gt;= high) {</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        }</span><br><span class="line">		<span class="comment">//低位指针和高位指针要保存起来，在最后递归调用的时候需要这两个指针</span></span><br><span class="line">        <span class="keyword">int</span> left = low;</span><br><span class="line">        <span class="keyword">int</span> right = high;</span><br><span class="line">        <span class="keyword">int</span> temp = a[left];</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 当left小于right的时候，才进行移位操作</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= temp) {</span><br><span class="line">                right--;</span><br><span class="line">            }</span><br><span class="line">            a[left] = a[right];</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= temp) {</span><br><span class="line">                left++;</span><br><span class="line">            }</span><br><span class="line">            a[right] = a[left];</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        a[left] = temp;</span><br><span class="line">        sort(a, low, left - <span class="number">1</span>);</span><br><span class="line">        sort(a, left + <span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>原理：先将数组拆分知道不能拆分为两个为止（也就是最小是两个数为一组），然后对两个数排序，在一次合并</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergerSort</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] arr = {<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">9</span>};</span><br><span class="line">        MergerSort mergerSort = <span class="keyword">new</span> MergerSort();</span><br><span class="line">        <span class="keyword">int</span>[] sort = mergerSort.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(sort));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) {</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (high &lt;= low) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        sort(arr, low, mid);</span><br><span class="line">        sort(arr, mid + <span class="number">1</span>, high);</span><br><span class="line">        merge(arr, low, mid, high);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = low;</span><br><span class="line">        <span class="keyword">int</span> right = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt;= high; i++) {</span><br><span class="line">            aux[i] = arr[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt;= high; i++) {</span><br><span class="line">            <span class="keyword">if</span> (left &gt; mid) {</span><br><span class="line">                arr[i] = aux[right++];</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (right &gt; high) {</span><br><span class="line">                arr[i] = aux[left++];</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (aux[right] &lt; aux[left]) {</span><br><span class="line">                arr[i] = aux[right++];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                arr[i] = aux[left++];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>原理：将所有带比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从低位开始，一次进行一次排序。这样从最低位一直到最高位排序完成后，数列就变成有序数列</p>
<p>实现：</p>
<ol>
<li>取得数组中的最大数，获取位数</li>
<li>arr为原始数组，从最低位开始去每个位组成radix长度</li>
<li>对radix进行计数排序</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/28 22:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">radixSort</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] arr = {<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">362</span>};</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] sort = sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(sort));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) {</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) {</span><br><span class="line">                max = arr[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> maxDigit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((max /= <span class="number">10</span>) &gt; <span class="number">0</span>) {</span><br><span class="line">            maxDigit++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        <span class="keyword">int</span>[] bktLen = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">//存储桶中存放的数量</span></span><br><span class="line">        <span class="keyword">int</span> base = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++) {</span><br><span class="line">            bktLen = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) {</span><br><span class="line">                <span class="keyword">int</span> bktValue = (value / base) % <span class="number">10</span>;</span><br><span class="line">                buckets[bktValue][bktLen[bktValue]++] = value;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; buckets.length; j++) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bktLen[j]; k++) {</span><br><span class="line">                    arr[index++] = buckets[j][k];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            base *= <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h2 id="java中arrys-sort的实现"><a href="#java中arrys-sort的实现" class="headerlink" title="java中arrys.sort的实现"></a>java中arrys.sort的实现</h2><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210803112615693.png" alt="image-20210803112615693" style="zoom: 50%;">





<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210803143429250.png" alt="image-20210803143429250" style="zoom: 67%;">

<p>核心算法是由插入排序算法完成了，如果长度大于32则将数组拆分为小的连续序列，然后对连续序列进行合并</p>
<p>在小规模的数据排序算法中，O(n^2)的排序算法并不一定比O（nlogn）的排序算法执行时间长。对于小数据量的排序，选择了比较简单，不需要递归的插入排序算法。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210803143828200.png" alt="image-20210803143828200"></p>
<h2 id="说一个常用的稳定的排序算法和适用场景"><a href="#说一个常用的稳定的排序算法和适用场景" class="headerlink" title="说一个常用的稳定的排序算法和适用场景"></a>说一个常用的稳定的排序算法和适用场景</h2><p>稳定的排序算法：冒泡排序、插入排序、归并排序、基数排序</p>
<p>基数排序适用于对时间、字符串这些数据（能够分割出独立的位，而且位之间具有明显的递进关系，且位之间的范围不是太大）</p>
<h2 id="时间复杂度为nlog2n的排序算法有哪些"><a href="#时间复杂度为nlog2n的排序算法有哪些" class="headerlink" title="时间复杂度为nlog2n的排序算法有哪些"></a>时间复杂度为nlog2n的排序算法有哪些</h2><p>归并、快排、堆排</p>
</body></html>]]></content>
      <categories>
        <category>算法</category>
        <category>基本排序算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 11. 旋转数组的最小数字</title>
    <url>/3d94766b.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组&nbsp;[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>] 为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] 的一个旋转，该数组的最小值为<span class="number">1</span>。&nbsp;&nbsp;</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h2 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h2><p>毫无算法可言</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> min = numbers[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numbers.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (min &gt; numbers[i]){</span><br><span class="line">            min = numbers[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="二分求解"><a href="#二分求解" class="headerlink" title="二分求解"></a>二分求解</h3><p>什么？二分只能用于有序？那我是不是要把数组排列为有序？</p>
<p>二分不仅仅是只能用于有序，难道部分有序不行吗？</p>
</body></html>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 10- II. 青蛙跳台阶问题</title>
    <url>/ee60b5f6.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">一只青蛙一次可以跳上<span class="number">1</span>级台阶，也可以跳上<span class="number">2</span>级台阶。求该青蛙跳上一个 n&nbsp;级的台阶总共有多少种跳法。</span><br><span class="line"></span><br><span class="line">答案需要取模 <span class="number">1e9</span>+<span class="number">7</span>（<span class="number">1000000007</span>），如计算初始结果为：<span class="number">1000000008</span>，请返回 <span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">7</span></span><br><span class="line">输出：<span class="number">21</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">0</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= n &lt;= <span class="number">100</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>寻找之间的关系：</p>
<p>n=1 输出：1  </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{1}</span><br></pre></td></tr></tbody></table></figure>

<p>n=2 输出：2</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">最后一次跳了一阶台阶{1，1}</span><br><span class="line">最后一次跳了两阶台阶{2}</span><br></pre></td></tr></tbody></table></figure>

<p>n=3 输出：3</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">最后一次跳了一阶台阶{1，1，1}，{2,1}</span><br><span class="line">最后一次跳了两阶台阶{1,2}</span><br></pre></td></tr></tbody></table></figure>

<p>n=4 输出：5</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">最后一次跳了一阶台阶{1，1，1，1}，{2,1,1}，{1,2，1}</span><br><span class="line">最后一次跳了两阶台阶{1,1,2}，{2,2}</span><br></pre></td></tr></tbody></table></figure>

<p>用<code>数学思想</code>推导：</p>
<p>最后一次跳了一阶台阶，这类方法一共有f（n-1）种；</p>
<p>最后一次跳了两阶台阶，这类方法一共有f（n-2）</p>
<p>可以推出来:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">n阶台阶的次数 = 最后一次跳了一阶台阶 + 最后一次跳了两阶台阶</span><br><span class="line">f(n)=f(n−1)+f(n−2)</span><br></pre></td></tr></tbody></table></figure>



<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="记忆化递归法"><a href="#记忆化递归法" class="headerlink" title="记忆化递归法"></a>记忆化递归法</h3><p>看到这样的题目首先想到了汉诺塔问题和斐波那契数列，递归实现</p>
<p>和斐波那契数列的记忆化递归类似，主要就是求出推到公式</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (n &lt; <span class="number">2</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">int</span>[] memorization = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            memorization[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            memorization[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> numWays(n, memorization);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] memorization)</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (n &lt; <span class="number">2</span> || memorization[n] &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">return</span> memorization[n];</span><br><span class="line">            }</span><br><span class="line">            memorization[n] = (numWays(n - <span class="number">1</span>, memorization) + numWays(n - <span class="number">2</span>, memorization)) % <span class="number">1000000007</span>;</span><br><span class="line">            <span class="keyword">return</span> memorization[n];</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>不从f（n）开始，而是从f（1）和f（2）开始，逐渐累加</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">f(n + 1) = f(n) + f(n - 1)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{ </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">         <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, sum ;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">             sum = (a + b)  % <span class="number">1000000007</span>;</span><br><span class="line">             a = b;</span><br><span class="line">             b = sum;</span><br><span class="line">         }</span><br><span class="line">         <span class="keyword">return</span> a;</span><br><span class="line">     }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 10- I. 斐波那契数列</title>
    <url>/7eea4da1.html</url>
    <content><![CDATA[<html><head></head><body><h2 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</span><br><span class="line"></span><br><span class="line">F(0) = 0,&nbsp; &nbsp;F(1)&nbsp;= 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br><span class="line">斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</span><br><span class="line"></span><br><span class="line">答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span><br><span class="line"></span><br><span class="line">&nbsp;</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br><span class="line">&nbsp;</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">0 &lt;= n &lt;= 100</span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>

<p>这是一个典型的递归问题，但是递归算法往往不是最优的</p>
<h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>原理：把 f(n)f(n) 问题的计算拆分成 f(n-1)f(n−1) 和 f(n-2)f(n−2) 两个子问题的计算，并递归，以 f(0) 和 f(1)为终止条件。</p>
<p>缺点：</p>
<ol>
<li>有大量的重复的递归计算</li>
<li>递归一直嵌套，效率比较低</li>
</ol>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/25e913ab8d7a22bb017669e4a097cf51d10861f365002f2d8556ee7a64464cd8-Picture0.png" alt="Picture0.png" style="zoom:50%;">

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//1.0版本 递归版本</span></span><br><span class="line">  <span class="comment">// leetcode：超出时间限制</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//2.0版本 递归版本</span></span><br><span class="line"><span class="comment">// leetcode：超出时间限制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibV2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="记忆化递归法"><a href="#记忆化递归法" class="headerlink" title="记忆化递归法"></a>记忆化递归法</h3><p>原理：在递归算法的基础上，新建一个长度为n的数组，用于在递归是存储f(0)至 f(n)的数字值，重复遇到某数字则直接从数组取用，避免了重复的递归计算。</p>
<p>缺点：</p>
<ol>
<li>递归一直嵌套，效率比较低</li>
<li>记忆化存储需要使用O（N）的额外空间</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//3.0版本 记忆化递归</span></span><br><span class="line"><span class="comment">// 解决递归版本中的重复计算递归的值</span></span><br><span class="line"><span class="comment">// leetcode：超出时间限制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibV3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] memorization = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    memorization[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    memorization[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> myFibonacci(n, memorization);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myFibonacci</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] memorization)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span> || memorization[n] &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> memorization[n];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (myFibonacci(n - <span class="number">1</span>, memorization) + myFibonacci(n - <span class="number">2</span>, memorization))%<span class="number">1000000007</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>原理：以斐波那契数列性质 f(n + 1) = f(n) + f(n - 1)为转移方程。</p>
<p>递归算法是一种倒序进行，直接进行 f(n)的计算，在 f(n)的计算过程中进行递归，求解f(n - 1)和f(n - 2)的值，而且递归算法本身就不适合大数据量的计算容易造成栈移出</p>
<p>而动态规划怎事从f(0)开始，逐渐求解f(n)的过程</p>
<p>从计算效率、空间复杂度上看，动态规划是本题的最佳解法。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/f653118d5c80fc44dde284c9b9c4f2d2115916f0123e384733526279f9b23302-Picture1.png" alt="img"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 4.0版本 动态规划</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// leetcode：超出40%提交</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibV4</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span> , b = <span class="number">1</span> , sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="comment">// 每次求解最新的数，舍弃之前的数据</span></span><br><span class="line">        sum = (a + b)%<span class="number">1000000007</span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = sum;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>





<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//5.0版本 动态规划</span></span><br><span class="line"><span class="comment">// 解决动态规划重复计算问题</span></span><br><span class="line"><span class="comment">// leetcode：超出40%提交</span></span><br><span class="line"><span class="comment">// 这种没有太大的意义，因为动态规划算法没有重复的值得计算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibV5</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] memorization = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    memorization[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    memorization[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) {</span><br><span class="line">        memorization[i] = (memorization[i-<span class="number">1</span>] + memorization[i - <span class="number">2</span>])%<span class="number">1000000007</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> memorization[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 09. 用两个栈实现队列</title>
    <url>/6fda8efa.html</url>
    <content><![CDATA[<html><head></head><body><h4 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead&nbsp;操作返回 -<span class="number">1</span> )</span><br><span class="line"></span><br><span class="line">&nbsp;</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[<span class="string">"CQueue"</span>,<span class="string">"appendTail"</span>,<span class="string">"deleteHead"</span>,<span class="string">"deleteHead"</span>]</span><br><span class="line">[[],[<span class="number">3</span>],[],[]]</span><br><span class="line">输出：[<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">3</span>,-<span class="number">1</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[<span class="string">"CQueue"</span>,<span class="string">"deleteHead"</span>,<span class="string">"appendTail"</span>,<span class="string">"appendTail"</span>,<span class="string">"deleteHead"</span>,<span class="string">"deleteHead"</span>]</span><br><span class="line">[[],[],[<span class="number">5</span>],[<span class="number">2</span>],[],[]]</span><br><span class="line">输出：[<span class="keyword">null</span>,-<span class="number">1</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= values &lt;= <span class="number">10000</span></span><br><span class="line">最多会对&nbsp;appendTail、deleteHead 进行&nbsp;<span class="number">10000</span>&nbsp;次调用</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>



<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>{</span><br><span class="line">    Deque&lt;Integer&gt; stack1 ;</span><br><span class="line">    Deque&lt;Integer&gt; stack2 ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        stack1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()){</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()){</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()){</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 07. 重建二叉树</title>
    <url>/73d0ff75.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</span><br><span class="line"></span><br><span class="line">假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</span><br><span class="line"></span><br><span class="line">Input: preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>], inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">Input: preorder = [-<span class="number">1</span>], inorder = [-<span class="number">1</span>]</span><br><span class="line">Output: [-<span class="number">1</span>]</span><br><span class="line">&nbsp;</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= 节点个数 &lt;= <span class="number">5000</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/tree.jpg" alt="img"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="先按照题目自己构建一个二叉树，不考虑代码实现"><a href="#先按照题目自己构建一个二叉树，不考虑代码实现" class="headerlink" title="先按照题目自己构建一个二叉树，不考虑代码实现"></a>先按照题目自己构建一个二叉树，不考虑代码实现</h3><p>前序遍历：preorder = [3,9,20,15,7]</p>
<p> 中序遍历：inorder = [9,3,15,20,7]</p>
<ol>
<li>前序遍历一定能够确定3是根节点</li>
<li>这样在中序遍历中，3左边的值一定是这个根节点的左子树，3右边的值一定是根的右子树</li>
<li>3左边只有一个数9，说明这个数的左子树只有一个是9</li>
<li>3的右子树有三个值，（15,20,7），然后在看前序遍历，前序遍历中的（20,15,7）一定是根的右子树，所以20一定是3的右孩子</li>
<li>然后在看中序遍历，20是右孩子的根节点，那么15一定是20的左孩子，7一定是20的右孩子</li>
<li>最后代入前序遍历验证</li>
<li>正确</li>
</ol>
<p>所以一个前序一定能确定一个根，然后在结合后续一定能确定根的左右孩子，这样在去前序遍历和中序遍历中对比，那么一定能构建一个二叉树</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>不要看下面代码感觉挺多的，其实很简单就是一个递归的过程，只是传递的参数多，然后一行放不下了而已</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) { val = x; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>{</span><br><span class="line">        <span class="comment">//构建map结构是因为，在每次在中序数组中中查找当前根节点都要遍历一次，这样可以避免遍历，直接拿到当前根节点的index</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; indexMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = inorder.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            indexMap.put(inorder[i], i);</span><br><span class="line">        }</span><br><span class="line">        TreeNode root = buildTree(preorder, <span class="number">0</span>, length - <span class="number">1</span>, inorder, <span class="number">0</span>, length - <span class="number">1</span>, indexMap);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preorderStart, <span class="keyword">int</span> preorderEnd, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inorderStart, <span class="keyword">int</span> inorderEnd, HashMap&lt;Integer, Integer&gt; indexMap)</span> </span>{</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (preorderStart &gt; preorderEnd) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//先找出根节点</span></span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[preorderStart];</span><br><span class="line">        <span class="comment">//然后在中序遍历中找到根节点的位置，之前一定是根节点的左子树，之后一定是根节点的右子树</span></span><br><span class="line">        <span class="comment">//构建树的根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="comment">//如果左节点的长度为零，说明这个就是根节点，且没有子节点，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (preorderStart == preorderEnd) {</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//拿到根节点在中序遍历数组的索引</span></span><br><span class="line">            <span class="keyword">int</span> rootIndex = indexMap.get(rootVal);</span><br><span class="line">            <span class="comment">//拿到根节点的索引后，可以在前序遍历中拿到根节点左孩子的数量（最后一个节点的index），和右孩子的数量（）</span></span><br><span class="line">            <span class="comment">// 然后就需要对，根节点的左子树部分进行构建</span></span><br><span class="line">            <span class="comment">// 需要找到左子树中对应的前序遍历和中序遍历，分别对应的数组的位置</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1. 前序遍历的数组还是这个数组</span></span><br><span class="line"><span class="comment">             * 2. 左子树中在前序遍历数组的开始索引：preorderStart + 1，根节点左边的第一个节点就是左子树的第一个索引位置</span></span><br><span class="line"><span class="comment">             * 3. 左子树中在前序遍历数组结束的索引：preorderStart + (rootIndex - inorderStart)，</span></span><br><span class="line"><span class="comment">             *  根节点 + 在中序遍历中根节点距离开始节点的位置  = 根节点 + （在中序遍历中根节点的索引 - 在中序遍历中开始的索引）</span></span><br><span class="line"><span class="comment">             * 4. 中序遍历数组还是这个数组</span></span><br><span class="line"><span class="comment">             * 5. 左子树中在中序遍历数组的开始索引：inorderStart，中序遍历数组中的开始位置</span></span><br><span class="line"><span class="comment">             * 6. 左子树中在中序遍历数组结束的索引：rootIndex - 1，根节点索引位置减一</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            TreeNode leftNode = buildTree(preorder, preorderStart + <span class="number">1</span>, preorderStart + (rootIndex - inorderStart),</span><br><span class="line">                    inorder, inorderStart, rootIndex - <span class="number">1</span>, indexMap);</span><br><span class="line">            <span class="comment">//需要找到右子树中对应的前序遍历和中序遍历，分别对应的数组的位置</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1. 前序遍历的数组还是这个数组</span></span><br><span class="line"><span class="comment">             * 2. 右子树中在前序遍历数组的开始索引：preorderEnd - (inorderEnd - rootIndex) + 1，</span></span><br><span class="line"><span class="comment">             * 前序遍历数组的末尾索引 - 右子树数的数量 + 1  = 前序遍历数组的末尾索引 - （中序遍历末尾位置 - 中序遍历根节点的索引 ） + 1</span></span><br><span class="line"><span class="comment">             * 3. 右子树中在前序遍历数组结束的索引：preorderEnd，</span></span><br><span class="line"><span class="comment">             * 4. 中序遍历数组还是这个数组</span></span><br><span class="line"><span class="comment">             * 5. 右子树中在中序遍历数组的开始索引：rootIndex + 1，根节点索引位置加一</span></span><br><span class="line"><span class="comment">             * 6. 右子树中在中序遍历数组结束的索引：inorderEnd，</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            TreeNode rightNode = buildTree(preorder, preorderEnd - (inorderEnd - rootIndex) + <span class="number">1</span>, preorderEnd,</span><br><span class="line">                    inorder, rootIndex + <span class="number">1</span>, inorderEnd, indexMap);</span><br><span class="line">            root.left = leftNode;</span><br><span class="line">            root.right = rightNode;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//    public class TreeNode {</span></span><br><span class="line"><span class="comment">//        int val;</span></span><br><span class="line"><span class="comment">//        TreeNode left;</span></span><br><span class="line"><span class="comment">//        TreeNode right;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        TreeNode(int x) {</span></span><br><span class="line"><span class="comment">//            val = x;</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>重点有一个地方：</p>
<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><h3 id="二叉树的前序、中序、后序遍历"><a href="#二叉树的前序、中序、后序遍历" class="headerlink" title="二叉树的前序、中序、后序遍历"></a>二叉树的前序、中序、后序遍历</h3><h3 id="小学数学加减法"><a href="#小学数学加减法" class="headerlink" title="小学数学加减法"></a>小学数学加减法</h3><p><strong>求左子树中在前序遍历数组结束的索引</strong>和<strong>右子树中在前序遍历数组的开始索引</strong></p>
<p>这里为什么有的地方加一，有的地方不加一，而有的地方需要减一</p>
<p>这个是在算法中经常会遇到的问题：</p>
<p>其实还是小学数学：</p>
<p>请听题：</p>
<p>一个有六棵树分别叫，0号，1号 ，2号，3号，4号，5号</p>
<ol>
<li><p>5号和2号<strong>间有几颗树</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="number">5</span> - <span class="number">2</span>) - <span class="number">1</span> = <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>2号树向右<strong>移动几次</strong>能到达5号树的位置</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">5</span> - <span class="number">2</span> = <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>5号树向右移动两次是第几颗树</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="number">5</span> - <span class="number">2</span>) + <span class="number">1</span> = <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>

<p>因为索引是从0开始的，所以引号加1，如果索引不是从零开始的直接间就可以了</p>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>两个数之间的差值，为小的数向大的数移动的次数</li>
<li>如果要求两个数之间的数字数量，需要差值减一</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 06. 从尾到头打印链表</title>
    <url>/8c70c103.html</url>
    <content><![CDATA[<html><head></head><body><h2 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</span><br><span class="line"></span><br><span class="line">&nbsp;</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：head = [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br><span class="line">&nbsp;</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line">0 &lt;= 链表长度 &lt;= 10000</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>

<p>原理：</p>
<p>链表只有一个头结点，想要到尾结点只能从头开始遍历</p>
<h3 id="辅助空间"><a href="#辅助空间" class="headerlink" title="辅助空间"></a>辅助空间</h3><p>声明一个辅助空间，先遍历一遍确定辅助空间的大小，然后对辅助空间倒序打印</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) { val = x; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) {</span><br><span class="line">       ListNode first = head;</span><br><span class="line">		 <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">		 <span class="keyword">while</span>(head != <span class="keyword">null</span>) {</span><br><span class="line">			head = head.next;</span><br><span class="line">			len ++;</span><br><span class="line">		 }</span><br><span class="line">		 <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">		 <span class="keyword">while</span>(first != <span class="keyword">null</span>) {</span><br><span class="line">			 len--;</span><br><span class="line">			 array[len] = first.val;</span><br><span class="line">			 first = first.next;</span><br><span class="line">		}</span><br><span class="line">		 <span class="keyword">return</span> array;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 05. 替换空格</title>
    <url>/baec5e48.html</url>
    <content><![CDATA[<html><head></head><body><h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">请实现一个函数，把字符串 s 中的每个空格替换成"%20"。</span><br><span class="line"></span><br><span class="line">&nbsp;</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s = "We are happy."</span><br><span class="line">输出："We%20are%20happy."</span><br><span class="line">&nbsp;</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line">0 &lt;= s 的长度 &lt;= 10000</span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>



<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		 </span><br><span class="line">		 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line"></span><br><span class="line">			 str.append(String.valueOf(s.charAt(i)).equals(<span class="string">" "</span>) ? <span class="string">"%20"</span> : s.charAt(i));</span><br><span class="line">		}</span><br><span class="line">		 <span class="keyword">return</span> str.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 04. 二维数组中的查找</title>
    <url>/58b0f60b.html</url>
    <content><![CDATA[<html><head></head><body><h2 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</span><br><span class="line"></span><br><span class="line">&nbsp;</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">现有矩阵 matrix 如下：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target&nbsp;=&nbsp;5，返回&nbsp;true。</span><br><span class="line"></span><br><span class="line">给定&nbsp;target&nbsp;=&nbsp;20，返回&nbsp;false。</span><br><span class="line"></span><br><span class="line">&nbsp;</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line">0 &lt;= n &lt;= 1000</span><br><span class="line"></span><br><span class="line">0 &lt;= m &lt;= 1000</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>

<h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>直接利用for循环查找</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArrayV1</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) {</span><br><span class="line">            <span class="keyword">if</span> (target == matrix[i][j]){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="二叉搜索法"><a href="#二叉搜索法" class="headerlink" title="二叉搜索法"></a>二叉搜索法</h3><p><code>每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序</code></p>
<p>根据本题的题目描述，这个数组是一个有序递增的数组，可以把数组转化为图的形式，类似于二叉搜索树</p>
<img src="https://pic.leetcode-cn.com/6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png" alt="Picture1.png" style="zoom:50%;">



<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArrayV2</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">       <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) {</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       }</span><br><span class="line">    	<span class="comment">// 从左上角开始</span></span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> j = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">while</span> (i &lt; matrix.length &amp;&amp; j &gt;= <span class="number">0</span>) {</span><br><span class="line">           <span class="comment">// 如果相等则找到了目标值</span></span><br><span class="line">           <span class="keyword">if</span> (matrix[i][j] == target) {</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           } <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; matrix[i][j]) {</span><br><span class="line">               <span class="comment">// 目标值比较大，则向下查找</span></span><br><span class="line">               i++;</span><br><span class="line">           } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 目标值比较小，则向左查找</span></span><br><span class="line">               j--;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>



<h2 id=""><a href="#" class="headerlink" title=""></a></h2></body></html>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 03. 数组中重复的数字</title>
    <url>/7e9ab8a.html</url>
    <content><![CDATA[<html><head></head><body><h2 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">找出数组中重复的数字。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line">2 &lt;= n &lt;= 100000</span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>

<h3 id="哈希表（set）"><a href="#哈希表（set）" class="headerlink" title="哈希表（set）"></a>哈希表（set）</h3><p>hashset中数组的唯一性，当hash表中不能在添加的时候，表示有重复数据，返回</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 利用hash</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findRepeatNumberV1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">      Set&lt;Integer&gt; integers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) {</span><br><span class="line">          <span class="keyword">if</span> (!integers.add(num)) {</span><br><span class="line">              <span class="keyword">return</span> num;</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="原地交换"><a href="#原地交换" class="headerlink" title="原地交换"></a>原地交换</h3><p>这个是针对本题目的特殊性</p>
<p> <code>nums 里的所有数字都在 0～n-1</code></p>
<p>也就是说，所有的数字在数组中都能找到他以该数组为索引的位置，而不会造成数组下标越界，所以可以建立索引和值得映射</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/1618146573-bOieFQ-Picture0.png" alt="Picture0.png" style="zoom:50%;">

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findRepeatNumberV2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ) {</span><br><span class="line">           <span class="comment">// 注意：只有在第一个数放到了正确的位置才i++，对第二个数照对应的值</span></span><br><span class="line">           <span class="keyword">if</span> (nums[i] == i) {</span><br><span class="line">               i++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           }</span><br><span class="line">           <span class="comment">// 这个是跳出循环的条件，如果这个值和要替换的目标值说明两个值发生了重复</span></span><br><span class="line">           <span class="keyword">if</span> (nums[i] == nums[nums[i]]) {</span><br><span class="line">               <span class="keyword">return</span> nums[i];</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">           nums[i] = nums[temp];</span><br><span class="line">           nums[temp] = temp;</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findRepeatNumberV3</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">        <span class="comment">// 这里使用的事while循环，更容易直观理解</span></span><br><span class="line">        <span class="comment">// 当这个数的值和索引下标不对应的时候，一直为当前值寻找对应的位置</span></span><br><span class="line">        <span class="keyword">while</span> (i != nums[i]){</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[nums[i]]){</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            }</span><br><span class="line">            temp = nums[i];</span><br><span class="line">            nums[i] = nums[temp];</span><br><span class="line">            nums[temp] = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper分布式锁</title>
    <url>/ecd467f2.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>为了保证数据的一致性，在一些业务处理中都会选择加锁来保证数据的一致性。在单机模式下我们通常选择使用synchronized等这种JAVA提供好的jvm锁来实现，但是在集群和分布式情况下，这种jvm级别的锁式无法满足我们的需求，因为一个服务部署在多台服务器上，这些服务器上的jvm是无法通讯的，所以我们需要一种方案来解决分布式情况下数据一致性。</p>
<p>在互联网公司，基本上企业内部都会有自己的一套分布式锁开发框架</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式锁一般有三种实现方式：</p>
<ol>
<li>数据库乐观锁</li>
<li>基于redis实现分布式锁</li>
<li>基于zooKeeper实习哪分布式锁</li>
</ol>
<p>本次讲着重介绍zooKeeper实现分布式锁，和与数据库和redis实习分布式锁的对比。</p>
<h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><p>zookeeper的分布式锁主要是依据临时节点和事件监听机制来完成的</p>
<h1 id="curator框架实现zookeeper分布式锁"><a href="#curator框架实现zookeeper分布式锁" class="headerlink" title="curator框架实现zookeeper分布式锁"></a>curator框架实现zookeeper分布式锁</h1><p>前提：需要搭建起zookeeper基础架构，并且使用gateway网关做负载均衡</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorConfig</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value("${spring.cloud.zookeeper.connect-string}")</span></span><br><span class="line">    <span class="keyword">private</span> String zookeeperConnectionString;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = "start")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CuratorFramework <span class="title">curatorFramework</span><span class="params">()</span></span>{</span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> CuratorFrameworkFactory.newClient(zookeeperConnectionString, retryPolicy);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> CuratorFramework curatorFramework;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">curatorDecuctStock</span><span class="params">()</span> </span>{</span><br><span class="line">       String returnResult = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">       InterProcessMutex interProcessMutex = <span class="keyword">new</span> InterProcessMutex(curatorFramework, <span class="string">"/stockLock"</span>);</span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">           interProcessMutex.acquire();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(<span class="string">"stock"</span>)));</span><br><span class="line">           <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) {</span><br><span class="line">               <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">               stringRedisTemplate.opsForValue().set(<span class="string">"stock"</span>, realStock + <span class="string">""</span>);</span><br><span class="line">               System.out.println(<span class="string">"扣减库存成功，剩余库存："</span> + realStock + <span class="string">"         卖出数量为："</span> + count.addAndGet(<span class="number">1</span>));</span><br><span class="line">               returnResult = <span class="string">"扣减库存成功"</span>;</span><br><span class="line">           } <span class="keyword">else</span> {</span><br><span class="line">               System.out.println(<span class="string">"扣减库存失败，库存不足"</span>);</span><br><span class="line">               returnResult = <span class="string">"扣减库存失败，库存不足"</span>;</span><br><span class="line">           }</span><br><span class="line">       } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       }<span class="keyword">finally</span> {</span><br><span class="line">           <span class="keyword">try</span> {</span><br><span class="line">               interProcessMutex.release();</span><br><span class="line">           } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> returnResult;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>





<h3 id="集群压测"><a href="#集群压测" class="headerlink" title="集群压测"></a>集群压测</h3><ul>
<li>jmeter压测<ul>
<li>100个线程并发</li>
<li>延迟0秒</li>
<li>循环4次</li>
</ul>
</li>
<li>总库存为200</li>
<li>redis单机本地部署</li>
<li>三个服务集群</li>
<li>geteway（本地部署）轮询负载均衡</li>
<li>zookeeper做分布式锁（本地单机）</li>
</ul>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210901220545870.png" alt="image-20210901220545870"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 第一台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">1</span>         卖出数量为：<span class="number">67</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">// 第二台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">0</span>         卖出数量为：<span class="number">67</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">// 第三台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">2</span>         卖出数量为：<span class="number">66</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">//总卖出数量为：67+67+66=200</span></span><br></pre></td></tr></tbody></table></figure>



<h1 id="redisson（redis）分布式锁和curator（zookeeper）分布式锁对比"><a href="#redisson（redis）分布式锁和curator（zookeeper）分布式锁对比" class="headerlink" title="redisson（redis）分布式锁和curator（zookeeper）分布式锁对比"></a>redisson（redis）分布式锁和curator（zookeeper）分布式锁对比</h1><p>通过jmeter压测发现，在同样的并发请求，redis本地单机，zookeeper本地单机的情况下，redis的300线程的200库存量用时平均在3秒左右，而zookeeper的300线程的200库存量用时平均在28秒左右。</p>
<p>可以明显看的出来，针对本次的300线程200库存，redis单机和zookeeper单机</p>
<table>
<thead>
<tr>
<th>对比</th>
<th>zookeeper</th>
<th>redis</th>
</tr>
</thead>
<tbody><tr>
<td>时间</td>
<td>28秒</td>
<td>3秒</td>
</tr>
<tr>
<td>CAP</td>
<td>CP</td>
<td>AP</td>
</tr>
<tr>
<td>性能</td>
<td>较低</td>
<td>高</td>
</tr>
<tr>
<td>可靠</td>
<td>高</td>
<td>较低</td>
</tr>
</tbody></table>
<p> 参考：</p>
<p><a href="https://blog.csdn.net/java_66666/article/details/81015302">https://blog.csdn.net/java_66666/article/details/81015302</a></p>
</body></html>]]></content>
      <categories>
        <category>分布式</category>
        <category>分布式锁</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装redis集群</title>
    <url>/a988d1a2.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h1><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker  pull  redis:5.0.5</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902175726397.png" alt="image-20210902175726397"></p>
<h1 id="创建redis容器"><a href="#创建redis容器" class="headerlink" title="创建redis容器"></a>创建redis容器</h1><p>创建三个 redis 容器：</p>
<ul>
<li>redis-node1：6380</li>
<li>redis-node2：6381</li>
<li>redis-node3：6382</li>
</ul>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">docker create --name redis-node1 --net host -v /data/redis-data/node1:/data redis:5.0.5 --cluster-enabled yes --cluster-config-file nodes-node-1.conf --port 6380</span><br><span class="line"></span><br><span class="line">docker create --name redis-node2 --net host -v /data/redis-data/node2:/data redis:5.0.5 --cluster-enabled yes --cluster-config-file nodes-node-2.conf --port 6381</span><br><span class="line"></span><br><span class="line">docker create --name redis-node3 --net host -v /data/redis-data/node3:/data redis:5.0.5 --cluster-enabled yes --cluster-config-file nodes-node-3.conf --port 6382</span><br></pre></td></tr></tbody></table></figure>

<h1 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h1><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker start redis-node1 redis-node2 redis-node3</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902175954106.png" alt="image-20210902175954106"></p>
<p>执行完运行命令后检查一下容器的启动情况：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20200531105644785.png" alt="img"></p>
<p>如上提示的是权限问题，我们尝试修改一下权限：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">chmod -R  777 /data</span><br></pre></td></tr></tbody></table></figure>

<p>启动成功后如下图所示：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20200531115746286.png" alt="img"></p>
<h1 id="组建群组"><a href="#组建群组" class="headerlink" title="组建群组"></a>组建群组</h1><p> <code>--net</code> 网络类型为 <code>host</code></p>
<p><strong>Docker</strong>在使用<code>host模式</code>下创建的容器是没有自己独立的网络命名空间的，是跟物理机共享一个网络空间，进而可以共享物理机的所有<strong>端口与IP</strong>，这样就可以让公共网络直接访问容器了</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 组建集群,10.211.55.4为当前物理机的ip地址</span></span><br><span class="line"></span><br><span class="line">redis-cli --cluster create 10.211.55.4:6379 10.211.55.4:6380 10.211.55.4:6381 --cluster-replicas 0</span><br></pre></td></tr></tbody></table></figure>

<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20200531141853380.png" alt="img" style="zoom: 50%;">



<h2 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h2><h3 id="Waiting-for-the-cluster-to-join"><a href="#Waiting-for-the-cluster-to-join" class="headerlink" title="Waiting for the cluster to join"></a>Waiting for the cluster to join</h3><p>到这一步后一直在等待，无法进行到下一步</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>我在搭建的时候用的阿里云，启动有端口限制，redis集群在通讯的时候还需要开始一个通讯端口，通讯端口地址：reids端口号+10000</p>
<p>例如：redis端口号为6380，那么不仅要开启6380端口，还有开启16380端口</p>
<p>所以在阿里云控制台安全组中开启<code>16380/16381</code>后，没有在一直等待</p>
<h1 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h1><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">root@CentOS7:/data# redis-cli</span><br><span class="line">127.0.0.1:6379&gt; cluster nodes</span><br><span class="line">72c291c32815194b64d1f6d0fdf771f5cc04e14a 10.211.55.4:6380@16380 master - 0 1590905997358 2 connected 5461-10922</span><br><span class="line">6a595b67bbff15c94e5874c2d2cd556d6a6a6c17 10.211.55.4:6381@16381 master - 0 1590905998362 3 connected 10923-16383</span><br><span class="line">4e3dbdc8f835dcbc38291c88f08165ee51d53d3d 10.211.55.4:6379@16379 myself,master - 0 1590905997000 1 connected 0-5460</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="打印不了集群信息"><a href="#打印不了集群信息" class="headerlink" title="打印不了集群信息"></a>打印不了集群信息</h3><p>在查看cluster的时候显示没有权限</p>
<p>使用下面的命令</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">redis-cli -h 10.211.55.4 -p 6381 </span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">root@CentOS7:/data# redis-cli -h 10.211.55.4 -p 6381 </span><br><span class="line">127.0.0.1:6379&gt; cluster nodes</span><br><span class="line">72c291c32815194b64d1f6d0fdf771f5cc04e14a 10.211.55.4:6380@16380 master - 0 1590905997358 2 connected 5461-10922</span><br><span class="line">6a595b67bbff15c94e5874c2d2cd556d6a6a6c17 10.211.55.4:6381@16381 master - 0 1590905998362 3 connected 10923-16383</span><br><span class="line">4e3dbdc8f835dcbc38291c88f08165ee51d53d3d 10.211.55.4:6379@16379 myself,master - 0 1590905997000 1 connected 0-5460</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></tbody></table></figure>



<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902221725956.png" alt="image-20210902221725956"></p>
<h3 id="外部连接访问不到或者连接上一会就报错断开"><a href="#外部连接访问不到或者连接上一会就报错断开" class="headerlink" title="外部连接访问不到或者连接上一会就报错断开"></a>外部连接访问不到或者连接上一会就报错断开</h3><h4 id="发现原因"><a href="#发现原因" class="headerlink" title="发现原因"></a>发现原因</h4><p>因为我发现，操作的时候总有一个redsi的主节点，显示的是非外网的ip地址，而是本地的物理ip地址</p>
<p>查看ip地址</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></tbody></table></figure>

<p>docker0 开头的 docker ip 地址<br>eth0 开头的宿主机ip</p>
<p>我发现总有一个是用的宿主机的ip，但是阿里云服务器提供的ip地址又不是这个</p>
<h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">vim  /data/redis-data/node1/nodes-node-1.conf </span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210903090624390.png" alt="image-20210903090624390"></p>
<p>然后把ip地址全部改成外网的ip地址</p>
<h1 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h1><p>参考文章：</p>
<p><a href="https://www.cnblogs.com/niceyoo/p/13011626.html">https://www.cnblogs.com/niceyoo/p/13011626.html</a></p>
</body></html>]]></content>
      <categories>
        <category>redis</category>
        <category>redis集群</category>
      </categories>
      <tags>
        <tag>redis集群</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper基础</title>
    <url>/88815d0a.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="什么是zookeeper"><a href="#什么是zookeeper" class="headerlink" title="什么是zookeeper"></a>什么是zookeeper</h1><p>zookeeper是一个分布式协调框架，主要用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。</p>
<span id="more"></span>

<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><p><img src="https://img-blog.csdn.net/201807121434154?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmFfNjY2NjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>每个子目录如NameService都被称为zNode（目录节点），和文件系统一样，我们能够自由的增减、删除zNode，在一个znode下增加、删除子znode，唯一的不同在于znode是可以存储数据的。</p>
<h2 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h2><p>有四种类型的znode：</p>
<ul>
<li>PERSISTENT(持久化目录节点)<ul>
<li>客户端与zookeeper断开连接后，该节点依旧存在</li>
</ul>
</li>
<li>PERSISTENT_SEQUENTIAL(持久化顺序编号目录节点)<ul>
<li>客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</li>
</ul>
</li>
<li><strong>EPHEMERAL-临时目录节点</strong><ul>
<li>客户端与zookeeper断开连接后，该节点被删除</li>
</ul>
</li>
<li><strong>EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点</strong><ul>
<li>客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</li>
</ul>
</li>
</ul>
<p> 参考：</p>
<p><a href="https://blog.csdn.net/java_66666/article/details/81015302">https://blog.csdn.net/java_66666/article/details/81015302</a></p>
</body></html>]]></content>
      <categories>
        <category>分布式</category>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>netty基础-3</title>
    <url>/de7d93c3.html</url>
    <content><![CDATA[<html><head></head><body><h1 id="Google-Protobuf"><a href="#Google-Protobuf" class="headerlink" title="Google Protobuf"></a>Google Protobuf</h1><h2 id="编码和解码的基本介绍"><a href="#编码和解码的基本介绍" class="headerlink" title="编码和解码的基本介绍"></a>编码和解码的基本介绍</h2><ol>
<li>编写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送数据时就需要编码，接收数据时就需要解码[示意图]</li>
<li><code>codec</code>（编解码器）的组成部分有两个：<code>decoder</code>（解码器）和 <code>encoder</code>（编码器）。<code>encoder</code> 负责把业务数据转换成字节码数据，<code>decoder</code> 负责把字节码数据转换成业务数据</li>
</ol>
<span id="more"></span>

<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0001.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0001.png" alt="img"></a></p>
<h2 id="Netty-本身的编码解码的机制和问题分析"><a href="#Netty-本身的编码解码的机制和问题分析" class="headerlink" title="Netty 本身的编码解码的机制和问题分析"></a>Netty 本身的编码解码的机制和问题分析</h2><ol>
<li><p><code>Netty</code> 自身提供了一些 <code>codec</code>(编解码器)</p>
</li>
<li><p><code>Netty</code>提供的编码器</p>
<ul>
<li><code>StringEncoder</code>：对字符串数据进行编码。</li>
<li><code>ObjectEncoder</code>：对Java对象进行编码。</li>
</ul>
</li>
<li><p><code>Netty</code>提供的解码器</p>
<ul>
<li><code>StringDecoder</code>,对字符串数据进行解码</li>
<li><code>ObjectDecoder</code>，对 Java 对象进行解码</li>
</ul>
</li>
<li><p><code>Netty</code>本身自带的<code>ObjectDecoder</code>和<code>ObjectEncoder</code>可以用来实现<code>POJO</code>对象或各种业务对象的编码和解码，底层使用的仍是Java序列化技术,而Java序列化技术本身效率就不高，存在如下问题</p>
<ul>
<li>无法跨语言</li>
<li>序列化后的体积太大，是二进制编码的5倍多。</li>
<li>序列化性能太低</li>
</ul>
</li>
<li><p>引出新的解决方案[<code>Google</code> 的 <code>Protobuf</code>]</p>
</li>
</ol>
<h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><ol>
<li><code>Protobuf</code> 基本介绍和使用示意图</li>
<li><code>Protobuf</code> 是 <code>Google</code> 发布的开源项目，全称 <code>Google Protocol Buffers</code>，是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 <code>RPC</code> [远程过程调用 <code>remote procedure call</code> ]数据交换格式。目前很多公司 从<code>http + json 转向tcp + protobuf</code>，效率会更高。</li>
<li>参考文档：<a href="https://developers.google.com/protocol-buffers/docs/proto">https://developers.google.com/protocol-buffers/docs/proto</a> 语言指南</li>
<li><code>Protobuf</code> 是以 <code>message</code> 的方式来管理数据的.</li>
<li>支持跨平台、跨语言，即[客户端和服务器端可以是不同的语言编写的]（支持目前绝大多数语言，例如 <code>C++</code>、<code>C#</code>、<code>Java</code>、<code>python</code> 等）</li>
<li>高性能，高可靠性</li>
<li>使用 <code>protobuf</code> 编译器能自动生成代码，<code>Protobuf</code> 是将类的定义使用 <code>.proto</code> 文件进行描述。说明，在 <code>idea</code> 中编写 <code>.proto</code> 文件时，会自动提示是否下载 <code>.ptoto</code> 编写插件.可以让语法高亮。</li>
<li>然后通过 <code>protoc.exe</code> 编译器根据 <code>.proto</code> 自动生成 <code>.java</code> 文件</li>
<li><code>protobuf</code> 使用示意图</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0002.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0002.png" alt="img"></a></p>
<h2 id="Protobuf-快速入门实例"><a href="#Protobuf-快速入门实例" class="headerlink" title="Protobuf 快速入门实例"></a>Protobuf 快速入门实例</h2><p>编写程序，使用 <code>Protobuf</code> 完成如下功能</p>
<ol>
<li>客户端可以发送一个 <code>StudentPoJo</code> 对象到服务器(通过 <code>Protobuf</code> 编码)</li>
<li>服务端能接收 <code>StudentPoJo</code> 对象，并显示信息(通过 <code>Protobuf</code> 解码)</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">CODE</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;3.6.1&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Student-proto"><a href="#Student-proto" class="headerlink" title="Student.proto"></a>Student.proto</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">PROTOBUF</span><br><span class="line">syntax = "proto3"; //版本</span><br><span class="line">option java_outer_classname = "StudentPOJO";//生成的外部类名，同时也是文件名</span><br><span class="line">//protobuf 使用message 管理数据</span><br><span class="line">message Student { //会在 StudentPOJO 外部类生成一个内部类 Student， 他是真正发送的POJO对象</span><br><span class="line">    int32 id = 1; // Student 类中有 一个属性 名字为 id 类型为int32(protobuf类型) 1表示属性序号，不是值</span><br><span class="line">    string name = 2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>编译<br>protoc.exe –java_out=.Student.proto<br>将生成的 StudentPOJO 放入到项目使用</p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0003.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0003.png" alt="img"></a></p>
<p>生成的StudentPOJO代码太长就不贴在这里了</p>
<h3 id="NettyServer"><a href="#NettyServer" class="headerlink" title="NettyServer"></a>NettyServer</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.codec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.protobuf.ProtobufDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建BossGroup 和 WorkerGroup</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. 创建两个线程组 bossGroup 和 workerGroup</span></span><br><span class="line">        <span class="comment">//2. bossGroup 只是处理连接请求 , 真正的和客户端业务处理，会交给 workerGroup完成</span></span><br><span class="line">        <span class="comment">//3. 两个都是无限循环</span></span><br><span class="line">        <span class="comment">//4. bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数</span></span><br><span class="line">        <span class="comment">//   默认实际 cpu核数 * 2</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//创建服务器端的启动对象，配置参数</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用链式编程来进行设置</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup) <span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">//使用NioSocketChannel 作为服务器的通道实现</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) <span class="comment">// 设置线程队列得到连接个数</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>) <span class="comment">//设置保持活动连接状态</span></span><br><span class="line"><span class="comment">//                    .handler(null) // 该 handler对应 bossGroup , childHandler 对应 workerGroup</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {<span class="comment">//创建一个通道初始化对象(匿名对象)</span></span><br><span class="line">                        <span class="comment">//给pipeline 设置处理器</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//在pipeline加入ProtoBufDecoder</span></span><br><span class="line">                            <span class="comment">//指定对哪种对象进行解码</span></span><br><span class="line">                            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> ProtobufDecoder(StudentPOJO.Student.getDefaultInstance()));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        }</span><br><span class="line">                    }); <span class="comment">// 给我们的workerGroup 的 EventLoop 对应的管道设置处理器</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">".....服务器 is ready..."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绑定一个端口并且同步, 生成了一个 ChannelFuture 对象</span></span><br><span class="line">            <span class="comment">//启动服务器(并绑定端口)</span></span><br><span class="line">            ChannelFuture cf = bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给cf 注册监听器，监控我们关心的事件</span></span><br><span class="line"></span><br><span class="line">            cf.addListener(<span class="keyword">new</span> ChannelFutureListener() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                    <span class="keyword">if</span> (cf.isSuccess()) {</span><br><span class="line">                        System.out.println(<span class="string">"监听端口 6668 成功"</span>);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        System.out.println(<span class="string">"监听端口 6668 失败"</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="NettyServerHandler"><a href="#NettyServerHandler" class="headerlink" title="NettyServerHandler"></a>NettyServerHandler</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.codec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明</span></span><br><span class="line"><span class="comment">1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范)</span></span><br><span class="line"><span class="comment">2. 这时我们自定义一个Handler , 才能称为一个handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//public class NettyServerHandler extends ChannelInboundHandlerAdapter {</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">StudentPOJO</span>.<span class="title">Student</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span></span><br><span class="line"><span class="comment">    2. Object msg: 就是客户端发送的数据 默认Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, StudentPOJO.Student msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取从客户端发送的StudentPojo.Student</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"客户端发送的数据 id="</span> + msg.getId() + <span class="string">" 名字="</span> + msg.getName());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//writeAndFlush 是 write + flush</span></span><br><span class="line">        <span class="comment">//将数据写入到缓存，并刷新</span></span><br><span class="line">        <span class="comment">//一般讲，我们对这个发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello, 客户端~(&gt;^ω^&lt;)喵1"</span>, CharsetUtil.UTF_8));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常, 一般是需要关闭通道</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="NettyClient"><a href="#NettyClient" class="headerlink" title="NettyClient"></a>NettyClient</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.codec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.protobuf.ProtobufEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            <span class="comment">//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(group) <span class="comment">//设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel.class) <span class="comment">// 设置客户端通道的实现类(反射)</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//在pipeline中加入 ProtoBufEncoder</span></span><br><span class="line">                            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> ProtobufEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyClientHandler()); <span class="comment">//加入自己的处理器</span></span><br><span class="line">                        }</span><br><span class="line">                    });</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"客户端 ok.."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动客户端去连接服务器端</span></span><br><span class="line">            <span class="comment">//关于 ChannelFuture 要分析，涉及到netty的异步模型</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//给关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line"></span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="NettyClientHandler"><a href="#NettyClientHandler" class="headerlink" title="NettyClientHandler"></a>NettyClientHandler</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.codec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通道就绪就会触发该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发生一个Student 对象到服务器</span></span><br><span class="line"></span><br><span class="line">        StudentPOJO.Student student = StudentPOJO.Student.newBuilder().setId(<span class="number">4</span>).setName(<span class="string">"智多星 吴用"</span>).build();</span><br><span class="line">        <span class="comment">//Teacher , Member ,Message</span></span><br><span class="line">        ctx.writeAndFlush(student);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通道有读取事件时，会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">"服务器回复的消息:"</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">"服务器的地址： "</span>+ ctx.channel().remoteAddress());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Protobuf-快速入门实例-2"><a href="#Protobuf-快速入门实例-2" class="headerlink" title="Protobuf 快速入门实例 2"></a>Protobuf 快速入门实例 2</h2><ol>
<li>编写程序，使用 <code>Protobuf</code> 完成如下功能</li>
<li>客户端可以随机发送 <code>StudentPoJo</code> / <code>WorkerPoJo</code> 对象到服务器(通过 <code>Protobuf</code> 编码)</li>
<li>服务端能接收 <code>StudentPoJo</code> / <code>WorkerPoJo</code> 对象(需要判断是哪种类型)，并显示信息(通过 <code>Protobuf</code> 解码)</li>
</ol>
<h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a>proto</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">PROTOBUF</span><br><span class="line">syntax = "proto3";</span><br><span class="line">option optimize_for = SPEED; // 加快解析</span><br><span class="line">option java_package="com.atguigu.netty.codec2";   //指定生成到哪个包下</span><br><span class="line">option java_outer_classname="MyDataInfo"; // 外部类名, 文件名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">1.protobuf 可以使用message 管理其他的message。最终决定使用哪一个message作为传输对象</span><br><span class="line">2.假设你某个项目需要传输20个对象，你不可能新建20个proto文件吧。此时你就可以</span><br><span class="line">在一个文件里定义20个message，最后再用一个总的message（比方说这里的MyMessage）</span><br><span class="line">来决定在实际传输时真正需要传输哪一个对象</span><br><span class="line">3.因为你实际传输的时候大部分情况传输的都是一个对象，所以下面用oneof进行了限制</span><br><span class="line">4.是否可以传多个对象呢？我个人认为是可以的，比如可以通过map(目前我也不太了解proto的语法)</span><br><span class="line"> */</span><br><span class="line">message MyMessage {</span><br><span class="line"></span><br><span class="line">    //定义一个枚举类型,DataType如果是0则表示一个Student对象实例，DataType这个名称自定义</span><br><span class="line">    enum DataType {</span><br><span class="line">        StudentType = 0; //在proto3 要求enum的编号从0开始</span><br><span class="line">        WorkerType = 1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //用data_type 来标识传的是哪一个枚举类型，这里才真正开始定义MyMessage的数据类型</span><br><span class="line">    DataType data_type = 1;  //所有后面的数字都只是编号而已</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    1.oneof关键字 表示每次枚举类型进行传输时，限制最多只能传输一个对象。</span><br><span class="line">    dataBody名称也是自定义的</span><br><span class="line">    2.为什么这里的序号是2呢？因为上面DataType data_type = 1  占了第一个序号了</span><br><span class="line">    3.MyMessage里真正出现的类型只有两个</span><br><span class="line">      ①DataType类型</span><br><span class="line">      ②Student类型或者Worker类型（这两个在真正传输的时候只会有一个出现）</span><br><span class="line">    */</span><br><span class="line">    oneof dataBody {</span><br><span class="line">        Student student = 2;  //注意这后面的数字也都只是编号而已</span><br><span class="line">        Worker worker = 3;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message Student {</span><br><span class="line">    int32 id = 1;//Student类的属性</span><br><span class="line">    string name = 2; //</span><br><span class="line">}</span><br><span class="line">message Worker {</span><br><span class="line">    string name=1;</span><br><span class="line">    int32 age=2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="NettyServer-1"><a href="#NettyServer-1" class="headerlink" title="NettyServer"></a>NettyServer</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.codec2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.codec.StudentPOJO;</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.protobuf.ProtobufDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//创建服务器端的启动对象，配置参数</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用链式编程来进行设置</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup) <span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">//使用NioSocketChannel 作为服务器的通道实现</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) <span class="comment">// 设置线程队列得到连接个数</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>) <span class="comment">//设置保持活动连接状态</span></span><br><span class="line"><span class="comment">//                    .handler(null) // 该 handler对应 bossGroup , childHandler 对应 workerGroup</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {<span class="comment">//创建一个通道初始化对象(匿名对象)</span></span><br><span class="line">                        <span class="comment">//给pipeline 设置处理器</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//在pipeline加入ProtoBufDecoder</span></span><br><span class="line">                            <span class="comment">//指定对哪种对象进行解码</span></span><br><span class="line">                            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> ProtobufDecoder(MyDataInfo.MyMessage.getDefaultInstance()));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        }</span><br><span class="line">                    }); <span class="comment">// 给我们的workerGroup 的 EventLoop 对应的管道设置处理器</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">".....服务器 is ready..."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绑定一个端口并且同步, 生成了一个 ChannelFuture 对象</span></span><br><span class="line">            <span class="comment">//启动服务器(并绑定端口)</span></span><br><span class="line">            ChannelFuture cf = bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给cf 注册监听器，监控我们关心的事件</span></span><br><span class="line"></span><br><span class="line">            cf.addListener(<span class="keyword">new</span> ChannelFutureListener() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                    <span class="keyword">if</span> (cf.isSuccess()) {</span><br><span class="line">                        System.out.println(<span class="string">"监听端口 6668 成功"</span>);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        System.out.println(<span class="string">"监听端口 6668 失败"</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="NettyServerHandler-1"><a href="#NettyServerHandler-1" class="headerlink" title="NettyServerHandler"></a>NettyServerHandler</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.codec2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.codec.StudentPOJO;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//public class NettyServerHandler extends ChannelInboundHandlerAdapter {</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MyDataInfo</span>.<span class="title">MyMessage</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span></span><br><span class="line"><span class="comment">    2. Object msg: 就是客户端发送的数据 默认Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MyDataInfo.MyMessage msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据dataType 来显示不同的信息</span></span><br><span class="line"></span><br><span class="line">        MyDataInfo.MyMessage.DataType dataType = msg.getDataType();</span><br><span class="line">        <span class="keyword">if</span>(dataType == MyDataInfo.MyMessage.DataType.StudentType) {</span><br><span class="line"></span><br><span class="line">            MyDataInfo.Student student = msg.getStudent();</span><br><span class="line">            System.out.println(<span class="string">"学生id="</span> + student.getId() + <span class="string">" 学生名字="</span> + student.getName());</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(dataType == MyDataInfo.MyMessage.DataType.WorkerType) {</span><br><span class="line">            MyDataInfo.Worker worker = msg.getWorker();</span><br><span class="line">            System.out.println(<span class="string">"工人的名字="</span> + worker.getName() + <span class="string">" 年龄="</span> + worker.getAge());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            System.out.println(<span class="string">"传输的类型不正确"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//writeAndFlush 是 write + flush</span></span><br><span class="line">        <span class="comment">//将数据写入到缓存，并刷新</span></span><br><span class="line">        <span class="comment">//一般讲，我们对这个发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"hello, 客户端~(&gt;^ω^&lt;)喵1"</span>, CharsetUtil.UTF_8));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常, 一般是需要关闭通道</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="NettyClient-1"><a href="#NettyClient-1" class="headerlink" title="NettyClient"></a>NettyClient</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.codec2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.protobuf.ProtobufEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            <span class="comment">//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(group) <span class="comment">//设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel.class) <span class="comment">// 设置客户端通道的实现类(反射)</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//在pipeline中加入 ProtoBufEncoder</span></span><br><span class="line">                            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> ProtobufEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyClientHandler()); <span class="comment">//加入自己的处理器</span></span><br><span class="line">                        }</span><br><span class="line">                    });</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"客户端 ok.."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动客户端去连接服务器端</span></span><br><span class="line">            <span class="comment">//关于 ChannelFuture 要分析，涉及到netty的异步模型</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//给关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line"></span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="NettyClientHandler-1"><a href="#NettyClientHandler-1" class="headerlink" title="NettyClientHandler"></a>NettyClientHandler</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.codec2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.codec.StudentPOJO;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通道就绪就会触发该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//随机的发送Student 或者 Workder 对象</span></span><br><span class="line">        <span class="keyword">int</span> random = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">        MyDataInfo.MyMessage myMessage = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == random) { <span class="comment">//发送Student 对象</span></span><br><span class="line"></span><br><span class="line">            myMessage = MyDataInfo.MyMessage.newBuilder().setDataType(MyDataInfo.MyMessage.DataType.StudentType).setStudent(MyDataInfo.Student.newBuilder().setId(<span class="number">5</span>).setName(<span class="string">"玉麒麟 卢俊义"</span>).build()).build();</span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// 发送一个Worker 对象</span></span><br><span class="line"></span><br><span class="line">            myMessage = MyDataInfo.MyMessage.newBuilder().setDataType(MyDataInfo.MyMessage.DataType.WorkerType).setWorker(MyDataInfo.Worker.newBuilder().setAge(<span class="number">20</span>).setName(<span class="string">"老李"</span>).build()).build();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(myMessage);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通道有读取事件时，会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">"服务器回复的消息:"</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">"服务器的地址： "</span>+ ctx.channel().remoteAddress());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Netty-编解码器和-Handler-调用机制"><a href="#Netty-编解码器和-Handler-调用机制" class="headerlink" title="Netty 编解码器和 Handler 调用机制"></a>Netty 编解码器和 Handler 调用机制</h1><h2 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h2><ol>
<li><code>Netty</code> 的组件设计：<code>Netty</code> 的主要组件有 <code>Channel</code>、<code>EventLoop</code>、<code>ChannelFuture</code>、<code>ChannelHandler</code>、<code>ChannelPipe</code> 等</li>
<li><code>ChannelHandler</code> 充当了处理入站和出站数据的应用程序逻辑的容器。例如，实现 <code>ChannelInboundHandler</code> 接口（或 <code>ChannelInboundHandlerAdapter</code>），你就可以接收入站事件和数据，这些数据会被业务逻辑处理。当要给客户端发送响应时，也可以从 <code>ChannelInboundHandler</code> 冲刷数据。业务逻辑通常写在一个或者多个 <code>ChannelInboundHandler</code> 中。<code>ChannelOutboundHandler</code> 原理一样，只不过它是用来处理出站数据的</li>
<li><code>ChannelPipeline</code> 提供了 <code>ChannelHandler</code> 链的容器。以客户端应用程序为例，如果事件的运动方向是从客户端到服务端的，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过 <code>pipeline</code> 中的一系列 <code>ChannelOutboundHandler</code>，并被这些 <code>Handler</code> 处理，反之则称为入站的</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0004.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0004.png" alt="img"></a></p>
<blockquote>
<p>出站，入站如果搞不清楚，看下面的<strong>Netty的handler链的调用机制</strong>，通过一个例子和图讲清楚</p>
</blockquote>
<h2 id="编码解码器"><a href="#编码解码器" class="headerlink" title="编码解码器"></a>编码解码器</h2><ol>
<li>当 <code>Netty</code> 发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如 <code>java</code> 对象）；如果是出站消息，它会被编码成字节。</li>
<li><code>Netty</code> 提供一系列实用的编解码器，他们都实现了 <code>ChannelInboundHadnler</code> 或者 <code>ChannelOutboundHandler</code> 接口。在这些类中，<code>channelRead</code> 方法已经被重写了。以入站为例，对于每个从入站 <code>Channel</code> 读取的消息，这个方法会被调用。随后，它将调用由解码器所提供的 <code>decode()</code> 方法进行解码，并将已经解码的字节转发给 <code>ChannelPipeline</code> 中的下一个 <code>ChannelInboundHandler</code>。</li>
</ol>
<h2 id="解码器-ByteToMessageDecoder"><a href="#解码器-ByteToMessageDecoder" class="headerlink" title="解码器 - ByteToMessageDecoder"></a>解码器 - ByteToMessageDecoder</h2><ol>
<li>关系继承图</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0005.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0005.png" alt="img"></a></p>
<ol>
<li>由于不可能知道远程节点是否会一次性发送一个完整的信息，<code>tcp</code> 有可能出现粘包拆包的问题，这个类会对入站数据进行缓冲，直到它准备好被处理.【后面有说TCP的粘包和拆包问题】</li>
<li>一个关于 <code>ByteToMessageDecoder</code> 实例分析</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0006.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0006.png" alt="img"></a></p>
<h2 id="Netty的handler链的调用机制"><a href="#Netty的handler链的调用机制" class="headerlink" title="Netty的handler链的调用机制"></a>Netty的handler链的调用机制</h2><p>实例要求:</p>
<ol>
<li>使用自定义的编码器和解码器来说明 <code>Netty</code> 的 <code>handler</code> 调用机制<br>客户端发送 <code>long</code> -&gt; 服务器<br>服务端发送 <code>long</code> -&gt; 客户端</li>
</ol>
<blockquote>
<p>读者可以看下这个图，带着这个图去看下面的例子。</p>
</blockquote>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0007.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0007.png" alt="img"></a></p>
<h3 id="MyServer"><a href="#MyServer" class="headerlink" title="MyServer"></a>MyServer</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(<span class="keyword">new</span> MyServerInitializer()); <span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyServerInitializer"><a href="#MyServerInitializer" class="headerlink" title="MyServerInitializer"></a>MyServerInitializer</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();<span class="comment">//一会下断点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//入站的handler进行解码 MyByteToLongDecoder</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyByteToLongDecoder());</span><br><span class="line">        <span class="comment">//出站的handler进行编码</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyLongToByteEncoder());</span><br><span class="line">        <span class="comment">//自定义的handler 处理业务逻辑</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">        System.out.println(<span class="string">"xx"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyServerHandler"><a href="#MyServerHandler" class="headerlink" title="MyServerHandler"></a>MyServerHandler</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Long</span>&gt; </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Long msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"从客户端"</span> + ctx.channel().remoteAddress() + <span class="string">" 读取到long "</span> + msg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给客户端发送一个long</span></span><br><span class="line">        ctx.writeAndFlush(<span class="number">98765L</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyClient"><a href="#MyClient" class="headerlink" title="MyClient"></a>MyClient</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span>  Exception</span>{</span><br><span class="line"></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group).channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> MyClientInitializer()); <span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">"localhost"</span>, <span class="number">7000</span>).sync();</span><br><span class="line"></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyClientInitializer"><a href="#MyClientInitializer" class="headerlink" title="MyClientInitializer"></a>MyClientInitializer</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入一个出站的handler 对数据进行一个编码</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyLongToByteEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这时一个入站的解码器(入站handler )</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyByteToLongDecoder());</span><br><span class="line">        <span class="comment">//加入一个自定义的handler ， 处理业务</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyClientHandler());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyClientHandler"><a href="#MyClientHandler" class="headerlink" title="MyClientHandler"></a>MyClientHandler</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span>  <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Long</span>&gt; </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Long msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器的ip="</span> + ctx.channel().remoteAddress());</span><br><span class="line">        System.out.println(<span class="string">"收到服务器消息="</span> + msg);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写channelActive 发送数据</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(<span class="string">"MyClientHandler 发送数据"</span>);</span><br><span class="line">        <span class="comment">//ctx.writeAndFlush(Unpooled.copiedBuffer(""))</span></span><br><span class="line">        ctx.writeAndFlush(<span class="number">123456L</span>); <span class="comment">//发送的是一个long</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyByteToLongDecoder"><a href="#MyByteToLongDecoder" class="headerlink" title="MyByteToLongDecoder"></a>MyByteToLongDecoder</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyByteToLongDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * decode 会根据接收的数据，被调用多次, 直到确定没有新的元素被添加到list</span></span><br><span class="line"><span class="comment">     * , 或者是ByteBuf 没有更多的可读字节为止</span></span><br><span class="line"><span class="comment">     * 如果list out 不为空，就会将list的内容传递给下一个 channelinboundhandler处理,</span></span><br><span class="line"><span class="comment">     * 该处理器的方法也会被调用多次</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 入站的 ByteBuf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out List 集合，将解码后的数据传给下一个handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"MyByteToLongDecoder 被调用"</span>);</span><br><span class="line">        <span class="comment">//因为 long 8个字节, 需要判断有8个字节，才能读取一个long</span></span><br><span class="line">        <span class="keyword">if</span>(in.readableBytes() &gt;= <span class="number">8</span>) {</span><br><span class="line">            out.add(in.readLong());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyLongToByteEncoder"><a href="#MyLongToByteEncoder" class="headerlink" title="MyLongToByteEncoder"></a>MyLongToByteEncoder</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.MessageToByteEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLongToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Long</span>&gt; </span>{</span><br><span class="line">    <span class="comment">//编码方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Long msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"MyLongToByteEncoder encode 被调用"</span>);</span><br><span class="line">        System.out.println(<span class="string">"msg="</span> + msg);</span><br><span class="line">        out.writeLong(msg);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0008.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0008.png" alt="img"></a><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0009.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0009.png" alt="img"></a></p>
<h3 id="出站入站"><a href="#出站入站" class="headerlink" title="出站入站"></a>出站入站</h3><p>关于出站入站，很多人可能有点迷糊<br>1）客户端有出站入站，服务端也有出站入站<br>2）以客户端为例，如果有服务端传送的数据到达客户端，那么对于客户端来说就是入站；<br>如果客户端传送数据到服务端，那么对于客户端来说就是出站；<br>同理，对于服务端来说，也是一样的，有数据来就是入站，有数据输出就是出站<br>3）为什么服务端和客户端的Serverhandler都是继承<code>SimpleChannelInboundHandler</code>，而没有<code>ChannelOutboundHandler</code>出站类？<br>实际上当我们在handler中调用ctx.writeAndFlush()方法后，就会将数据交给ChannelOutboundHandler进行出站处理，只是我们没有去定义出站类而已，若有需求可以自己去实现ChannelOutboundHandler出站类<br>4）总结就是客户端和服务端都有出站和入站的操作<br><strong>服务端发数据给客户端：</strong>服务端—&gt;出站—&gt;Socket通道—&gt;入站—&gt;客户端</p>
<p> <strong>客户端发数据给服务端：</strong>客户端—&gt;出站—&gt;Socket通道—&gt;入站—&gt;服务端</p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0007.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0007.png" alt="img"></a></p>
<blockquote>
<p>下面是Netty官方源码给的图，我个人觉的不是太好理解，上面的图好理解一些</p>
</blockquote>
<p><a href="https://imlql.cn/post/image/chapter08_05.png"><img src="https://imlql.cn/post/image/chapter08_05.png" alt="img"></a></p>
<h2 id="ByteToMessageDecoder的小细节"><a href="#ByteToMessageDecoder的小细节" class="headerlink" title="ByteToMessageDecoder的小细节"></a>ByteToMessageDecoder的小细节</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span>  <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Long</span>&gt; </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Long msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器的ip="</span> + ctx.channel().remoteAddress());</span><br><span class="line">        System.out.println(<span class="string">"收到服务器消息="</span> + msg);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写channelActive 发送数据</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(<span class="string">"MyClientHandler 发送数据"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分析</span></span><br><span class="line">        <span class="comment">//1. "abcdabcdabcdabcd" 是 16个字节</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"abcdabcdabcdabcd"</span>,CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyByteToLongDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * decode 会根据接收的数据，被调用多次, 直到确定没有新的元素被添加到list</span></span><br><span class="line"><span class="comment">     * , 或者是ByteBuf 没有更多的可读字节为止</span></span><br><span class="line"><span class="comment">     * 如果list out 不为空，就会将list的内容传递给下一个 channelinboundhandler处理,</span></span><br><span class="line"><span class="comment">     * 该处理器的方法也会被调用多次</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 入站的 ByteBuf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out List 集合，将解码后的数据传给下一个handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"MyByteToLongDecoder 被调用"</span>);</span><br><span class="line">        <span class="comment">//因为 long 8个字节, 需要判断有8个字节，才能读取一个long</span></span><br><span class="line">        <span class="keyword">if</span>(in.readableBytes() &gt;= <span class="number">8</span>) {</span><br><span class="line">            out.add(in.readLong());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>由于发送的字符串是16字节，根据上面注释说的内容，decode会被调用两次</li>
</ol>
<p>如下图验证结果：</p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0010.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0010.png" alt="img"></a></p>
<ol>
<li><p>同时又引出了一个小问题</p>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0011.png" alt="img"></p>
<p>当我们<code>MyClientHandler</code>传一个Long时，会调用我们的<code>MyLongToByteEncoder</code>的编码器。那么控制台就会打印这样一句话：<strong>MyLongToByteEncoder encode 被调用</strong>。但是这里并没有调用编码器，这是为什么呢？</p>
<ol>
<li><code>MyClientHandler</code>这个处理器的后一个处理器是<code>MyLongToByteEncoder</code></li>
<li><code>MyLongToByteEncoder</code>的父类是<code>MessageToByteEncoder</code>，在<code>MessageToByteEncoder</code>中有下面的一个方法</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ByteBuf buf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//这里会判断当前msg 是不是应该处理的类型，如果是就处理，不是就跳过encode</span></span><br><span class="line">            <span class="keyword">if</span> (acceptOutboundMessage(msg)) {</span><br><span class="line">                <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">                I cast = (I) msg;</span><br><span class="line">                buf = allocateBuffer(ctx, cast, preferDirect);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    encode(ctx, cast, buf);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    ReferenceCountUtil.release(cast);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (buf.isReadable()) {</span><br><span class="line">                    ctx.write(buf, promise);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    buf.release();</span><br><span class="line">                    ctx.write(Unpooled.EMPTY_BUFFER, promise);</span><br><span class="line">                }</span><br><span class="line">                buf = <span class="keyword">null</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                ctx.write(msg, promise);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (EncoderException e) {</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EncoderException(e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (buf != <span class="keyword">null</span>) {</span><br><span class="line">                buf.release();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<ol>
<li>当我们以这样的形式发送数据</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"abcdabcdabcdabcd"</span>,CharsetUtil.UTF_8));</span><br></pre></td></tr></tbody></table></figure>

<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0012.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0012.png" alt="img"></a></p>
<p>这两个类型并不匹配，也就不会走编码器。因此我们编写 Encoder 是要注意传入的数据类型和处理的数据类型一致</p>
<p><strong>结论：</strong></p>
<ul>
<li>不论解码器 <code>handler</code> 还是编码器 <code>handler</code> 即接收的消息类型必须与待处理的消息类型一致，否则该 <code>handler</code> 不会被执行</li>
<li>在解码器进行数据解码时，需要判断缓存区（<code>ByteBuf</code>）的数据是否足够，否则接收到的结果会期望结果可能不一致。</li>
</ul>
<h2 id="解码器-ReplayingDecoder"><a href="#解码器-ReplayingDecoder" class="headerlink" title="解码器 - ReplayingDecoder"></a>解码器 - ReplayingDecoder</h2><ol>
<li><code>public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder</code></li>
<li><code>ReplayingDecoder</code> 扩展了 <code>ByteToMessageDecoder</code> 类，使用这个类，我们不必调用 <code>readableBytes()</code> 方法，也就不用判断还有没有足够的数据来读取。参数 <code>S</code> 指定了用户状态管理的类型，其中 <code>Void</code> 代表不需要状态管理</li>
<li>应用实例：使用 <code>ReplayingDecoder</code> 编写解码器，对前面的案例进行简化[案例演示]</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ReplayingDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyByteToLongDecoder2</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(<span class="string">"MyByteToLongDecoder2 被调用"</span>);</span><br><span class="line">        <span class="comment">//在 ReplayingDecoder 不需要判断数据是否足够读取，内部会进行处理判断</span></span><br><span class="line">        out.add(in.readLong());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>```<br>ReplayingDecoder<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">   使用方便，但它也有一些局限性：</span><br><span class="line"></span><br><span class="line">   - 并不是所有的 `ByteBuf` 操作都被支持，如果调用了一个不被支持的方法，将会抛出一个 `UnsupportedOperationException`。</span><br><span class="line">   - `ReplayingDecoder` 在某些情况下可能稍慢于 `ByteToMessageDecoder`，例如网络缓慢并且消息格式复杂时，消息会被拆成了多个碎片，速度变慢</span><br><span class="line"></span><br><span class="line">## 其它编解码器</span><br><span class="line"></span><br><span class="line">[![img](https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0013.png)](https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0013.png)</span><br><span class="line"></span><br><span class="line">1. `LineBasedFrameDecoder`：这个类在 `Netty` 内部也有使用，它使用行尾控制字符（\n或者\r\n）作为分隔符来解析数据。</span><br><span class="line">2. `DelimiterBasedFrameDecoder`：使用自定义的特殊字符作为消息的分隔符。</span><br><span class="line">3. `HttpObjectDecoder`：一个 `HTTP` 数据的解码器</span><br><span class="line">4. `LengthFieldBasedFrameDecoder`：通过指定长度来标识整包消息，这样就可以自动的处理黏包和半包消息。</span><br><span class="line"></span><br><span class="line">## Log4j 整合到 Netty</span><br><span class="line"></span><br><span class="line">1. 在 `Maven` 中添加对 `Log4j` 的依赖在 `pom.xml`</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
XML<dependency>
 <groupid>log4j</groupid>
 <artifactid>log4j</artifactid>
 <version>1.2.17</version>
</dependency>
<dependency>
 <groupid>org.slf4j</groupid>
 <artifactid>slf4j-api</artifactid>
 <version>1.7.25</version>
</dependency>
<dependency>
 <groupid>org.slf4j</groupid>
 <artifactid>slf4j-log4j12</artifactid>
 <version>1.7.25</version>
 <scope>test</scope>
</dependency>
<dependency>
 <groupid>org.slf4j</groupid>
 <artifactid>slf4j-simple</artifactid>
 <version>1.7.25</version>
 <scope>test</scope>
</dependency>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. 配置 `Log4j`，在 `resources/log4j.properties`</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
PROPERTIES
log4j.rootLogger=DEBUG,stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=[%p]%C{1}-%m%n
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. 演示整合</span><br><span class="line"></span><br><span class="line">[![img](https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0014.jpg)](https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0014.jpg)</span><br><span class="line"></span><br><span class="line"># TCP 粘包和拆包及解决方案</span><br><span class="line"></span><br><span class="line">## TCP 粘包和拆包基本介绍</span><br><span class="line"></span><br><span class="line">1. `TCP` 是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的 `socket`，因此，发送端为了将多个发给接收端的包，更有效的发给对方，使用了优化方法（`Nagle` 算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难于分辨出完整的数据包了，因为面向流的通信是无消息保护边界的</span><br><span class="line">2. 由于 `TCP` 无消息保护边界,需要在接收端处理消息边界问题，也就是我们所说的粘包、拆包问题,看一张图</span><br><span class="line">3. `TCP` 粘包、拆包图解</span><br><span class="line"></span><br><span class="line">[![img](https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0015.png)](https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0015.png)</span><br><span class="line"></span><br><span class="line">假设客户端分别发送了两个数据包 `D1` 和 `D2` 给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下四种情况：</span><br><span class="line"></span><br><span class="line">1. 服务端分两次读取到了两个独立的数据包，分别是 `D1` 和 `D2`，没有粘包和拆包</span><br><span class="line">2. 服务端一次接受到了两个数据包，`D1` 和 `D2` 粘合在一起，称之为 `TCP` 粘包</span><br><span class="line">3. 服务端分两次读取到了数据包，第一次读取到了完整的 `D1` 包和 `D2` 包的部分内容，第二次读取到了 `D2` 包的剩余内容，这称之为 `TCP` 拆包</span><br><span class="line">4. 服务端分两次读取到了数据包，第一次读取到了 `D1` 包的部分内容 `D1_1`，第二次读取到了 `D1` 包的剩余部分内容 `D1_2` 和完整的 `D2` 包。</span><br><span class="line"></span><br><span class="line">## TCP 粘包和拆包现象实例</span><br><span class="line"></span><br><span class="line">在编写 `Netty` 程序时，如果没有做处理，就会发生粘包和拆包的问题</span><br><span class="line"></span><br><span class="line">看一个具体的实例：</span><br><span class="line"></span><br><span class="line">### MyServer</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">package com.atguigu.netty.tcp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import io.netty.bootstrap.ServerBootstrap;</span><br><span class="line">import io.netty.channel.ChannelFuture;</span><br><span class="line">import io.netty.channel.EventLoopGroup;</span><br><span class="line">import io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line">import io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line">public class MyServer {</span><br><span class="line">    public static void main(String[] args) throws Exception{</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = new NioEventLoopGroup(1);</span><br><span class="line">        EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = new ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(new MyServerInitializer()); //自定义一个初始化类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(7000).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        }finally {</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="MyServerInitializer-1"><a href="#MyServerInitializer-1" class="headerlink" title="MyServerInitializer"></a>MyServerInitializer</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.tcp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyServerHandler-1"><a href="#MyServerHandler-1" class="headerlink" title="MyServerHandler"></a>MyServerHandler</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt;</span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//cause.printStackTrace();</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[msg.readableBytes()];</span><br><span class="line">        msg.readBytes(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将buffer转成字符串</span></span><br><span class="line">        String message = <span class="keyword">new</span> String(buffer, Charset.forName(<span class="string">"utf-8"</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器接收到数据 "</span> + message);</span><br><span class="line">        System.out.println(<span class="string">"服务器接收到消息量="</span> + (++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务器回送数据给客户端, 回送一个随机id ,</span></span><br><span class="line">        ByteBuf responseByteBuf = Unpooled.copiedBuffer(UUID.randomUUID().toString() + <span class="string">" "</span>, Charset.forName(<span class="string">"utf-8"</span>));</span><br><span class="line">        ctx.writeAndFlush(responseByteBuf);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyClient-1"><a href="#MyClient-1" class="headerlink" title="MyClient"></a>MyClient</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.tcp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span>  Exception</span>{</span><br><span class="line"></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group).channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> MyClientInitializer()); <span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">"localhost"</span>, <span class="number">7000</span>).sync();</span><br><span class="line"></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyClientInitializer-1"><a href="#MyClientInitializer-1" class="headerlink" title="MyClientInitializer"></a>MyClientInitializer</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyClientHandler());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyClientHandler-1"><a href="#MyClientHandler-1" class="headerlink" title="MyClientHandler"></a>MyClientHandler</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//使用客户端发送10条数据 hello,server 编号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; <span class="number">10</span>; ++i) {</span><br><span class="line">            ByteBuf buffer = Unpooled.copiedBuffer(<span class="string">"hello,server "</span> + i, Charset.forName(<span class="string">"utf-8"</span>));</span><br><span class="line">            ctx.writeAndFlush(buffer);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[msg.readableBytes()];</span><br><span class="line">        msg.readBytes(buffer);</span><br><span class="line"></span><br><span class="line">        String message = <span class="keyword">new</span> String(buffer, Charset.forName(<span class="string">"utf-8"</span>));</span><br><span class="line">        System.out.println(<span class="string">"客户端接收到消息="</span> + message);</span><br><span class="line">        System.out.println(<span class="string">"客户端接收消息数量="</span> + (++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3><p><strong>第一次运行：</strong></p>
<p><strong>Client</strong></p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0016.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0016.png" alt="img"></a></p>
<p><strong>Server</strong></p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0017.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0017.png" alt="img"></a></p>
<p><strong>第二次运行：</strong></p>
<p><strong>Client</strong></p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0018.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0018.png" alt="img"></a></p>
<p><strong>Server</strong></p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0019.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0019.png" alt="img"></a></p>
<p>可以看到第一次运行时，服务器一次性将10个数据都接收了，第二次运行时分六次接收的，这就很形象的看出了TCP的粘包现象。</p>
<h2 id="TCP-粘包和拆包解决方案"><a href="#TCP-粘包和拆包解决方案" class="headerlink" title="TCP 粘包和拆包解决方案"></a>TCP 粘包和拆包解决方案</h2><ol>
<li>常用方案：使用自定义协议+编解码器来解决</li>
<li>关键就是要解决服务器端每次读取数据长度的问题，这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的 <code>TCP</code> 粘包、拆包。</li>
</ol>
<p><strong>看一个具体的实例</strong></p>
<ol>
<li>要求客户端发送 <code>5</code> 个 <code>Message</code> 对象，客户端每次发送一个 <code>Message</code> 对象</li>
<li>服务器端每次接收一个 <code>Message</code>，分 <code>5</code> 次进行解码，每读取到一个 <code>Message</code>，会回复一个 <code>Message</code> 对象给客户端。</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0020.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0020.png" alt="img"></a></p>
<h3 id="MessageProtocol"><a href="#MessageProtocol" class="headerlink" title="MessageProtocol"></a>MessageProtocol</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//协议包</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProtocol</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len; <span class="comment">//关键</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLen</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLen</span><span class="params">(<span class="keyword">int</span> len)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.len = len;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getContent() {</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(<span class="keyword">byte</span>[] content)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyServer-1"><a href="#MyServer-1" class="headerlink" title="MyServer"></a>MyServer</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(<span class="keyword">new</span> MyServerInitializer()); <span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyServerInitializer-2"><a href="#MyServerInitializer-2" class="headerlink" title="MyServerInitializer"></a>MyServerInitializer</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageDecoder());<span class="comment">//解码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageEncoder());<span class="comment">//编码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyServerHandler-2"><a href="#MyServerHandler-2" class="headerlink" title="MyServerHandler"></a>MyServerHandler</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理业务的handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MessageProtocol</span>&gt;</span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//cause.printStackTrace();</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收到数据，并处理</span></span><br><span class="line">        <span class="keyword">int</span> len = msg.getLen();</span><br><span class="line">        <span class="keyword">byte</span>[] content = msg.getContent();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器接收到信息如下"</span>);</span><br><span class="line">        System.out.println(<span class="string">"长度="</span> + len);</span><br><span class="line">        System.out.println(<span class="string">"内容="</span> + <span class="keyword">new</span> String(content, Charset.forName(<span class="string">"utf-8"</span>)));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器接收到消息包数量="</span> + (++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回复消息</span></span><br><span class="line">        System.out.println(<span class="string">"服务端开始回复消息------"</span>);</span><br><span class="line">        String responseContent = UUID.randomUUID().toString();</span><br><span class="line">        <span class="keyword">int</span> responseLen = responseContent.getBytes(<span class="string">"utf-8"</span>).length;</span><br><span class="line">        <span class="keyword">byte</span>[]  responseContent2 = responseContent.getBytes(<span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="comment">//构建一个协议包</span></span><br><span class="line">        MessageProtocol messageProtocol = <span class="keyword">new</span> MessageProtocol();</span><br><span class="line">        messageProtocol.setLen(responseLen);</span><br><span class="line">        messageProtocol.setContent(responseContent2);</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(messageProtocol);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyClient-2"><a href="#MyClient-2" class="headerlink" title="MyClient"></a>MyClient</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span>  Exception</span>{</span><br><span class="line"></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group).channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> MyClientInitializer()); <span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">"localhost"</span>, <span class="number">7000</span>).sync();</span><br><span class="line"></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyClientInitializer-2"><a href="#MyClientInitializer-2" class="headerlink" title="MyClientInitializer"></a>MyClientInitializer</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageEncoder()); <span class="comment">//加入编码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageDecoder()); <span class="comment">//加入解码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyClientHandler());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyClientHandler-2"><a href="#MyClientHandler-2" class="headerlink" title="MyClientHandler"></a>MyClientHandler</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MessageProtocol</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//使用客户端发送10条数据 "今天天气冷，吃火锅" 编号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++) {</span><br><span class="line">            String mes = <span class="string">"今天天气冷，吃火锅"</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] content = mes.getBytes(Charset.forName(<span class="string">"utf-8"</span>));</span><br><span class="line">            <span class="keyword">int</span> length = mes.getBytes(Charset.forName(<span class="string">"utf-8"</span>)).length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建协议包对象</span></span><br><span class="line">            MessageProtocol messageProtocol = <span class="keyword">new</span> MessageProtocol();</span><br><span class="line">            messageProtocol.setLen(length);</span><br><span class="line">            messageProtocol.setContent(content);</span><br><span class="line">            ctx.writeAndFlush(messageProtocol);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = msg.getLen();</span><br><span class="line">        <span class="keyword">byte</span>[] content = msg.getContent();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"客户端接收到消息如下"</span>);</span><br><span class="line">        System.out.println(<span class="string">"长度="</span> + len);</span><br><span class="line">        System.out.println(<span class="string">"内容="</span> + <span class="keyword">new</span> String(content, Charset.forName(<span class="string">"utf-8"</span>)));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"客户端接收消息数量="</span> + (++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(<span class="string">"异常消息="</span> + cause.getMessage());</span><br><span class="line">        ctx.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyMessageDecoder"><a href="#MyMessageDecoder" class="headerlink" title="MyMessageDecoder"></a>MyMessageDecoder</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ReplayingDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"MyMessageDecoder decode 被调用"</span>);</span><br><span class="line">        <span class="comment">//需要将得到二进制字节码-&gt; MessageProtocol 数据包(对象)</span></span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] content = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装成 MessageProtocol 对象，放入 out， 传递下一个handler业务处理</span></span><br><span class="line">        MessageProtocol messageProtocol = <span class="keyword">new</span> MessageProtocol();</span><br><span class="line">        messageProtocol.setLen(length);</span><br><span class="line">        messageProtocol.setContent(content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放入out传给下一个hanlder进行处理</span></span><br><span class="line">        out.add(messageProtocol);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyMessageEncoder"><a href="#MyMessageEncoder" class="headerlink" title="MyMessageEncoder"></a>MyMessageEncoder</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.MessageToByteEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">MessageProtocol</span>&gt; </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, MessageProtocol msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(<span class="string">"MyMessageEncoder encode 方法被调用"</span>);</span><br><span class="line">        out.writeInt(msg.getLen());</span><br><span class="line">        out.writeBytes(msg.getContent());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h3><p><strong>Client输出</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">MyMessageEncoder encode 方法被调用</span><br><span class="line">MyMessageEncoder encode 方法被调用</span><br><span class="line">MyMessageEncoder encode 方法被调用</span><br><span class="line">MyMessageEncoder encode 方法被调用</span><br><span class="line">MyMessageEncoder encode 方法被调用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是客户端开始一个一个的收到服务端的回复</span></span><br><span class="line">MyMessageDecoder decode 被调用</span><br><span class="line">客户端接收到消息如下</span><br><span class="line">长度=<span class="number">36</span></span><br><span class="line">内容=1b5286dd-0fc2-4f62-9bf7-d5fad84179b5</span><br><span class="line">客户端接收消息数量=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyMessageDecoder decode 被调用</span><br><span class="line">客户端接收到消息如下</span><br><span class="line">长度=<span class="number">36</span></span><br><span class="line">内容=653d18cb-ab72-<span class="number">4163</span>-8b95-09c94ecac873</span><br><span class="line">客户端接收消息数量=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyMessageDecoder decode 被调用</span><br><span class="line">客户端接收到消息如下</span><br><span class="line">长度=<span class="number">36</span></span><br><span class="line">内容=3be6e403-91bb-<span class="number">4437</span>-ada8-6cdb9eb7ef00</span><br><span class="line">客户端接收消息数量=<span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyMessageDecoder decode 被调用</span><br><span class="line">客户端接收到消息如下</span><br><span class="line">长度=<span class="number">36</span></span><br><span class="line">内容=94c8f306-fd9c-455a-956c-16698ce4150b</span><br><span class="line">客户端接收消息数量=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyMessageDecoder decode 被调用</span><br><span class="line">客户端接收到消息如下</span><br><span class="line">长度=<span class="number">36</span></span><br><span class="line">内容=7890de9c-0fa2-<span class="number">4317</span>-8de1-1d464315fa1b</span><br><span class="line">客户端接收消息数量=<span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>Server输出</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">MyMessageDecoder decode 被调用</span><br><span class="line">服务器接收到信息如下</span><br><span class="line">长度=<span class="number">27</span></span><br><span class="line">内容=今天天气冷，吃火锅</span><br><span class="line">服务器接收到消息包数量=<span class="number">1</span></span><br><span class="line">服务端开始回复消息------</span><br><span class="line">MyMessageEncoder encode 方法被调用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyMessageDecoder decode 被调用</span><br><span class="line">服务器接收到信息如下</span><br><span class="line">长度=<span class="number">27</span></span><br><span class="line">内容=今天天气冷，吃火锅</span><br><span class="line">服务器接收到消息包数量=<span class="number">2</span></span><br><span class="line">服务端开始回复消息------</span><br><span class="line">MyMessageEncoder encode 方法被调用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyMessageDecoder decode 被调用</span><br><span class="line">服务器接收到信息如下</span><br><span class="line">长度=<span class="number">27</span></span><br><span class="line">内容=今天天气冷，吃火锅</span><br><span class="line">服务器接收到消息包数量=<span class="number">3</span></span><br><span class="line">服务端开始回复消息------</span><br><span class="line">MyMessageEncoder encode 方法被调用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyMessageDecoder decode 被调用</span><br><span class="line">服务器接收到信息如下</span><br><span class="line">长度=<span class="number">27</span></span><br><span class="line">内容=今天天气冷，吃火锅</span><br><span class="line">服务器接收到消息包数量=<span class="number">4</span></span><br><span class="line">服务端开始回复消息------</span><br><span class="line">MyMessageEncoder encode 方法被调用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyMessageDecoder decode 被调用</span><br><span class="line">服务器接收到信息如下</span><br><span class="line">长度=<span class="number">27</span></span><br><span class="line">内容=今天天气冷，吃火锅</span><br><span class="line">服务器接收到消息包数量=<span class="number">5</span></span><br><span class="line">服务端开始回复消息------</span><br><span class="line">MyMessageEncoder encode 方法被调用</span><br></pre></td></tr></tbody></table></figure>

<p>无论运行几次，Server都是分5次接收的，这样就解决了TCP粘包问题。</p>
<h1 id="用-Netty-自己实现简单的RPC"><a href="#用-Netty-自己实现简单的RPC" class="headerlink" title="用 Netty 自己实现简单的RPC"></a>用 Netty 自己实现简单的RPC</h1><h2 id="RPC-基本介绍"><a href="#RPC-基本介绍" class="headerlink" title="RPC 基本介绍"></a>RPC 基本介绍</h2><ol>
<li><code>RPC（Remote Procedure Call）</code>—远程过程调用，是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程</li>
<li>两个或多个应用程序都分布在不同的服务器上，它们之间的调用都像是本地方法调用一样(如图)</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0021.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0021.png" alt="img"></a></p>
<p>过程：</p>
<ol>
<li><p>调用者(<code>Caller</code>)，调用远程API(<code>Remote API</code>)</p>
</li>
<li><p>调用远程API会通过一个RPC代理(<code>RpcProxy</code>)</p>
</li>
<li><p>RPC代理再去调用<code>RpcInvoker</code>(这个是PRC的调用者)</p>
</li>
<li><p><code>RpcInvoker</code>通过RPC连接器(<code>RpcConnector</code>)</p>
</li>
<li><p>RPC连接器用两台机器规定好的PRC协议(<code>RpcProtocol</code>)把数据进行编码</p>
</li>
<li><p>接着RPC连接器通过RpcChannel通道发送到对方的PRC接收器(RpcAcceptor)</p>
</li>
<li><p>PRC接收器通过PRC协议进行解码拿到数据</p>
</li>
<li><p>然后将数据传给<code>RpcProcessor</code></p>
</li>
<li><p><code>RpcProcessor</code>再传给<code>RpcInvoker</code></p>
</li>
<li><p><code>RpcInvoker</code>调用<code>Remote API</code></p>
</li>
<li><p>最后推给被调用者(Callee)</p>
</li>
<li><p>常见的 <code>RPC</code> 框架有：比较知名的如阿里的 <code>Dubbo</code>、<code>Google</code> 的 <code>gRPC</code>、<code>Go</code> 语言的 <code>rpcx</code>、<code>Apache</code> 的 <code>thrift</code>，<code>Spring</code> 旗下的 <code>SpringCloud</code>。</p>
</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0022.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0022.png" alt="img"></a></p>
<h2 id="我们的RPC-调用流程图"><a href="#我们的RPC-调用流程图" class="headerlink" title="我们的RPC 调用流程图"></a>我们的RPC 调用流程图</h2><p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0023.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0023.png" alt="img"></a></p>
<p><strong>RPC 调用流程说明</strong></p>
<ol>
<li>服务消费方（<code>client</code>）以本地调用方式调用服务</li>
<li><code>client stub</code> 接收到调用后负责将方法、参数等封装成能够进行网络传输的消息体</li>
<li><code>client stub</code> 将消息进行编码并发送到服务端</li>
<li><code>server stub</code> 收到消息后进行解码</li>
<li><code>server stub</code> 根据解码结果调用本地的服务</li>
<li>本地服务执行并将结果返回给 <code>server stub</code></li>
<li><code>server stub</code> 将返回导入结果进行编码并发送至消费方</li>
<li><code>client stub</code> 接收到消息并进行解码</li>
<li>服务消费方（<code>client</code>）得到结果</li>
</ol>
<p>小结：<code>RPC</code> 的目标就是将 <code>2 - 8</code> 这些步骤都封装起来，用户无需关心这些细节，可以像调用本地方法一样即可完成远程服务调用</p>
<h2 id="己实现-Dubbo-RPC（基于-Netty）"><a href="#己实现-Dubbo-RPC（基于-Netty）" class="headerlink" title="己实现 Dubbo RPC（基于 Netty）"></a>己实现 Dubbo RPC（基于 Netty）</h2><h3 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h3><ol>
<li><code>Dubbo</code> 底层使用了 <code>Netty</code> 作为网络通讯框架，要求用 <code>Netty</code> 实现一个简单的 <code>RPC</code> 框架</li>
<li>模仿 <code>Dubbo</code>，消费者和提供者约定接口和协议，消费者远程调用提供者的服务，提供者返回一个字符串，消费者打印提供者返回的数据。底层网络通信使用 <code>Netty 4.1.20</code></li>
</ol>
<h3 id="设计说明"><a href="#设计说明" class="headerlink" title="设计说明"></a>设计说明</h3><ol>
<li>创建一个接口，定义抽象方法。用于消费者和提供者之间的约定。</li>
<li>创建一个提供者，该类需要监听消费者的请求，并按照约定返回数据。</li>
<li>创建一个消费者，该类需要透明的调用自己不存在的方法，内部需要使用 <code>Netty</code> 请求提供者返回数据</li>
<li>开发的分析图</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0024.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0024.png" alt="img"></a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="封装的RPC"><a href="#封装的RPC" class="headerlink" title="封装的RPC"></a>封装的RPC</h4><blockquote>
<p>可以把这块代码理解成封装的dubbo</p>
</blockquote>
<h5 id="NettyServer-2"><a href="#NettyServer-2" class="headerlink" title="NettyServer"></a>NettyServer</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.dubborpc.netty;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">(String hostName, <span class="keyword">int</span> port)</span> </span>{</span><br><span class="line">        startServer0(hostName,port);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，完成对NettyServer的初始化和启动</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startServer0</span><span class="params">(String hostname, <span class="keyword">int</span> port)</span> </span>{</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {</span><br><span class="line">                                      <span class="meta">@Override</span></span><br><span class="line">                                      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                                          ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                                          pipeline.addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                                          pipeline.addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                                          pipeline.addLast(<span class="keyword">new</span> NettyServerHandler()); <span class="comment">//业务处理器</span></span><br><span class="line"></span><br><span class="line">                                      }</span><br><span class="line">                                  }</span><br><span class="line"></span><br><span class="line">                    );</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(hostname, port).sync();</span><br><span class="line">            System.out.println(<span class="string">"服务提供方开始提供服务~~"</span>);</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        }<span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">finally</span> {</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="NettyServerHandler-2"><a href="#NettyServerHandler-2" class="headerlink" title="NettyServerHandler"></a>NettyServerHandler</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.dubborpc.netty;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.dubborpc.customer.ClientBootstrap;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.dubborpc.provider.HelloServiceImpl;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器这边handler比较简单</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(<span class="string">"---服务端开始收到来自客户单的消息---"</span>);</span><br><span class="line">        <span class="comment">//获取客户端发送的消息，并调用服务</span></span><br><span class="line">        System.out.println(<span class="string">"原始消息："</span> + msg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         1.客户端在调用服务器的api 时，我们需要定义一个协议，比如我们要求 每次发消息是都</span></span><br><span class="line"><span class="comment">         必须以某个字符串开头 "HelloService#hello#你好"</span></span><br><span class="line"><span class="comment">         2.Dubbo注册在Zookeeper里时，这种就是类的全路径字符串，你用IDEA的zookeeper插件</span></span><br><span class="line"><span class="comment">         就可以清楚地看到</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(msg.toString().startsWith(ClientBootstrap.providerName)) {</span><br><span class="line"></span><br><span class="line">            String result = <span class="keyword">new</span> HelloServiceImpl().hello(msg.toString().substring(msg.toString().lastIndexOf(<span class="string">"#"</span>) + <span class="number">1</span>));</span><br><span class="line">            ctx.writeAndFlush(result);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="NettyClientHandler-2"><a href="#NettyClientHandler-2" class="headerlink" title="NettyClientHandler"></a>NettyClientHandler</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.dubborpc.netty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ChannelHandlerContext context;<span class="comment">//上下文</span></span><br><span class="line">    <span class="keyword">private</span> String result; <span class="comment">//返回的结果</span></span><br><span class="line">    <span class="keyword">private</span> String para; <span class="comment">//客户端调用方法时，传入的参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//与服务器的连接创建后，就会被调用, 这个方法是第一个被调用(1)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(<span class="string">" channelActive 被调用  "</span>);</span><br><span class="line">        context = ctx; <span class="comment">//因为我们在其它方法会使用到 ctx</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收到服务器的数据后，调用方法 (4)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(<span class="string">" channelRead 被调用  "</span>);</span><br><span class="line">        result = msg.toString();</span><br><span class="line">        notify(); <span class="comment">//唤醒等待的线程</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ctx.close();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被代理对象调用, 发送数据给服务器，-&gt; wait -&gt; 等待被唤醒(channelRead) -&gt; 返回结果 (3)-》5</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(<span class="string">" call1 被调用  "</span>);</span><br><span class="line">        context.writeAndFlush(para);</span><br><span class="line">        <span class="comment">//进行wait</span></span><br><span class="line">        wait(); <span class="comment">//等待channelRead 方法获取到服务器的结果后，唤醒</span></span><br><span class="line">        System.out.println(<span class="string">" call2 被调用  "</span>);</span><br><span class="line">        <span class="keyword">return</span>  result; <span class="comment">//服务方返回的结果</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//(2)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPara</span><span class="params">(String para)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">" setPara  "</span>);</span><br><span class="line">        <span class="keyword">this</span>.para = para;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="NettyClient-2"><a href="#NettyClient-2" class="headerlink" title="NettyClient"></a>NettyClient</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.dubborpc.netty;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NettyClientHandler client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写方法使用代理模式，获取一个代理对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; serivceClass, <span class="keyword">final</span> String providerName)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class&lt;?&gt;[]{serivceClass}, (proxy, method, args) -&gt; {</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"(proxy, method, args) 进入...."</span> + (++count) + <span class="string">" 次"</span>);</span><br><span class="line">                    <span class="comment">//{}  部分的代码，客户端每调用一次 hello, 就会进入到该代码</span></span><br><span class="line">                    <span class="keyword">if</span> (client == <span class="keyword">null</span>) {</span><br><span class="line">                        initClient();</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//设置要发给服务器端的信息</span></span><br><span class="line">                    <span class="comment">//providerName：协议头，args[0]：就是客户端要发送给服务端的数据</span></span><br><span class="line">                    client.setPara(providerName + args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">return</span> executor.submit(client).get();</span><br><span class="line"></span><br><span class="line">                });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化客户端</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span> </span>{</span><br><span class="line">        client = <span class="keyword">new</span> NettyClientHandler();</span><br><span class="line">        <span class="comment">//创建EventLoopGroup</span></span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                .handler(</span><br><span class="line">                        <span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                                ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                                pipeline.addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                                pipeline.addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                                pipeline.addLast(client);</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">7000</span>).sync();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.dubborpc.publicinterface;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个是接口，是服务提供方和 服务消费方都需要</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String mes)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="服务端-provider"><a href="#服务端-provider" class="headerlink" title="服务端(provider)"></a>服务端(provider)</h4><h5 id="HelloServiceImpl"><a href="#HelloServiceImpl" class="headerlink" title="HelloServiceImpl"></a>HelloServiceImpl</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.dubborpc.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.dubborpc.publicinterface.HelloService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当有消费方调用该方法时， 就返回一个结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String mes)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"收到客户端消息="</span> + mes);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//根据mes 返回不同的结果</span></span><br><span class="line">        <span class="keyword">if</span>(mes != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"你好客户端, 我已经收到你的消息。消息为：["</span> + mes + <span class="string">"] ，第"</span> + (++count) + <span class="string">" 次 \n"</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"你好客户端, 我已经收到你的消息 "</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="ServerBootstrap"><a href="#ServerBootstrap" class="headerlink" title="ServerBootstrap"></a>ServerBootstrap</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.dubborpc.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.dubborpc.netty.NettyServer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ServerBootstrap 会启动一个服务提供者，就是 NettyServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerBootstrap</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代码代填..</span></span><br><span class="line">        NettyServer.startServer(<span class="string">"127.0.0.1"</span>, <span class="number">7000</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="客户端-消费者"><a href="#客户端-消费者" class="headerlink" title="客户端(消费者)"></a>客户端(消费者)</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.dubborpc.customer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.dubborpc.netty.NettyClient;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.dubborpc.publicinterface.HelloService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientBootstrap</span> </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里定义协议头</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String providerName = <span class="string">"HelloService#hello#"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception</span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个消费者</span></span><br><span class="line">        NettyClient customer = <span class="keyword">new</span> NettyClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        HelloService service = (HelloService) customer.getBean(HelloService.class, providerName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;; ) {</span><br><span class="line">            Thread.sleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line">            <span class="comment">//通过代理对象调用服务提供者的方法(服务)</span></span><br><span class="line">            String res = service.hello(<span class="string">"你好 dubbo~"</span>);</span><br><span class="line">            System.out.println(<span class="string">"调用的结果 res= "</span> + res);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h3><ol>
<li><code>ClientBootstrap#main</code>发起调用</li>
<li>走到下面这一行代码后</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">HelloService service = (HelloService) customer.getBean(HelloService.class, providerName);</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><p>调用<code>NettyClient#getBean</code>，在此方法里与服务端建立链接。</p>
</li>
<li><p>于是就执行<code>NettyClientHandler#channelActive</code></p>
</li>
<li><p>接着回到<code>NettyClient#getBean</code>调用<code>NettyClientHandler#setPara</code>，调用完之后再回到<code>NettyClient#getBean</code>，用线程池提交任务</p>
</li>
<li><p>因为用线程池提交了任务，就准备执行<code>NettyClientHandler#call</code>线程任务</p>
</li>
<li><p>在<code>NettyClientHandler#call</code>中发送数据给服务提供者</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">context.writeAndFlush(para);</span><br></pre></td></tr></tbody></table></figure>

<p>由于还没收到服务提供者的数据结果，所以wait住</p>
</li>
<li><p>来到了服务提供者这边，从Socket通道中收到了数据，所以执行<code>NettyServerHandler#channelRead</code>，然后因为此方法中执行了</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">String result = new HelloServiceImpl().hello(msg.toString().substring(msg.toString().lastIndexOf("#") + 1));</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>就去<code>HelloServiceImpl#hello</code>中执行业务逻辑，返回数据给<code>NettyServerHandler#channelRead</code>，<code>NettyServerHandler#channelRead</code>再把数据发给客户端</p>
</li>
<li><p><code>NettyClientHandler#channelRead</code>收到服务提供者发来的数据，唤醒之前wait的线程</p>
</li>
<li><p>所以之前wait的线程从<code>NettyClientHandler#call</code>苏醒，返回result给<code>NettyClient#getBean</code></p>
</li>
<li><p><code>NettyClient#getBean</code>get()到数据，<code>ClientBootstrap#main</code>中的此函数调用返回，得到服务端提供的数据。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">String res = service.hello("你好 dubbo~");</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p>13.至此，一次RPC调用结束。</p>
<h3 id="效果-3"><a href="#效果-3" class="headerlink" title="效果"></a>效果</h3><p><strong>ClientBootstrap打印</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">(proxy, method, args) 进入...<span class="number">.1</span> 次</span><br><span class="line"> setPara  </span><br><span class="line"> channelActive 被调用  </span><br><span class="line"> call1 被调用  </span><br><span class="line"> channelRead 被调用  </span><br><span class="line"> call2 被调用  </span><br><span class="line">调用的结果 res= 你好客户端, 我已经收到你的消息。消息为：[你好 dubbo~] ，第<span class="number">1</span> 次 </span><br><span class="line"></span><br><span class="line">(proxy, method, args) 进入...<span class="number">.2</span> 次</span><br><span class="line"> setPara  </span><br><span class="line"> call1 被调用  </span><br><span class="line"> channelRead 被调用  </span><br><span class="line"> call2 被调用  </span><br><span class="line">调用的结果 res= 你好客户端, 我已经收到你的消息。消息为：[你好 dubbo~] ，第<span class="number">2</span> 次 </span><br><span class="line"></span><br><span class="line">(proxy, method, args) 进入...<span class="number">.3</span> 次</span><br><span class="line"> setPara  </span><br><span class="line"> call1 被调用  </span><br><span class="line"> channelRead 被调用  </span><br><span class="line"> call2 被调用  </span><br><span class="line">调用的结果 res= 你好客户端, 我已经收到你的消息。消息为：[你好 dubbo~] ，第<span class="number">3</span> 次 </span><br><span class="line"></span><br><span class="line">(proxy, method, args) 进入...<span class="number">.4</span> 次</span><br><span class="line"> setPara  </span><br><span class="line"> call1 被调用  </span><br><span class="line"> channelRead 被调用  </span><br><span class="line"> call2 被调用  </span><br><span class="line">调用的结果 res= 你好客户端, 我已经收到你的消息。消息为：[你好 dubbo~] ，第<span class="number">4</span> 次 </span><br><span class="line"></span><br><span class="line">(proxy, method, args) 进入...<span class="number">.5</span> 次</span><br><span class="line"> setPara  </span><br><span class="line"> call1 被调用  </span><br><span class="line"> channelRead 被调用  </span><br><span class="line"> call2 被调用  </span><br><span class="line">调用的结果 res= 你好客户端, 我已经收到你的消息。消息为：[你好 dubbo~] ，第<span class="number">5</span> 次 </span><br></pre></td></tr></tbody></table></figure>

<p><strong>ServerBootstrap打印</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">服务提供方开始提供服务~~</span><br><span class="line">---服务端开始收到来自客户单的消息---</span><br><span class="line">原始消息：HelloService#hello#你好 dubbo~</span><br><span class="line">收到客户端消息=你好 dubbo~</span><br><span class="line"></span><br><span class="line">---服务端开始收到来自客户单的消息---</span><br><span class="line">原始消息：HelloService#hello#你好 dubbo~</span><br><span class="line">收到客户端消息=你好 dubbo~</span><br><span class="line"></span><br><span class="line">---服务端开始收到来自客户单的消息---</span><br><span class="line">原始消息：HelloService#hello#你好 dubbo~</span><br><span class="line">收到客户端消息=你好 dubbo~</span><br><span class="line"></span><br><span class="line">---服务端开始收到来自客户单的消息---</span><br><span class="line">原始消息：HelloService#hello#你好 dubbo~</span><br><span class="line">收到客户端消息=你好 dubbo~</span><br><span class="line"></span><br><span class="line">---服务端开始收到来自客户单的消息---</span><br><span class="line">原始消息：HelloService#hello#你好 dubbo~</span><br><span class="line">收到客户端消息=你好 dubbo~</span><br></pre></td></tr></tbody></table></figure>



<p>参考：</p>
<p><strong>视频：</strong><a href="https://www.bilibili.com/video/BV1DJ411m7NR?from=search&amp;seid=7455267981675039441">https://www.bilibili.com/video/BV1DJ411m7NR?from=search&amp;seid=7455267981675039441</a></p>
<p><strong>文章链接:</strong> <a href="https://imlql.cn/post/3f9283e7.html">https://imlql.cn/post/3f9283e7.html</a></p>
</body></html>]]></content>
      <categories>
        <category>计算机网络</category>
        <category>netty</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/0.html</url>
    <content><![CDATA[<html><head></head><body></body></html>]]></content>
  </entry>
</search>
