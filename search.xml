<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>redis分布式锁</title>
    <url>/e2ee4148.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>为了保证数据的一致性，在一些业务处理中都会选择加锁来保证数据的一致性。在单机模式下我们通常选择使用synchronized等这种JAVA提供好的jvm锁来实现，但是在集群和分布式情况下，这种jvm级别的锁式无法满足我们的需求，因为一个服务部署在多台服务器上，这些服务器上的jvm是无法通讯的，所以我们需要一种方案来解决分布式情况下数据一致性。</p>
<p>在互联网公司，基本上企业内部都会有自己的一套分布式锁开发框架</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式锁一般有三种实现方式：</p>
<ol>
<li>数据库乐观锁</li>
<li>基于redis实现分布式锁</li>
<li>基于zooKeeper实习哪分布式锁</li>
</ol>
<p>本次讲着重介绍redis实现分布式锁，和与数据库和zooKeeper实习分布式锁的对比。</p>
<h1 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h1><p>为了保证分布式锁的<code>可用</code>，我们至少要保证锁的实现同时满足以下四个条件：</p>
<ol>
<li>互斥性。在任意时刻，只能有一个客户端持有锁</li>
<li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁</li>
<li>具有容错性。只要大部分的redis节点正常运行，客户端就可以加锁和解锁</li>
<li>解铃还须系铃人。加锁和解锁的对象必须是同一个客户端，客户端不能把别人加的锁给解了。</li>
</ol>
<h1 id="redis锁演变过程"><a href="#redis锁演变过程" class="headerlink" title="redis锁演变过程"></a>redis锁演变过程</h1><p>redis本地部署</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Dserver.port=<span class="number">8082</span></span><br></pre></td></tr></table></figure>

<p>Dashboard复制项目后不同端口号运行</p>
<h2 id="单机不安全"><a href="#单机不安全" class="headerlink" title="单机不安全"></a>单机不安全</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  String <span class="title">decuctStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 从redis中拿到stock的数量</span></span><br><span class="line">    <span class="keyword">int</span> stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>)));</span><br><span class="line">    <span class="comment">// stock数量大于零的时候才进行扣减</span></span><br><span class="line">    <span class="keyword">if</span> (stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, realStock + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;扣减库存成功，剩余库存：&quot;</span> + realStock + <span class="string">&quot;         卖出数量为：&quot;</span> + count.addAndGet(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;扣减库存成功&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扣减库存失败，库存不足&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;扣减库存失败，库存不足&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在高并发情况下，这种写法肯定会导致超卖现象。假如有3个线程同时从redis中读取stock数据，假如这个时候均为200，然后同时判断都大于零，然后进入减库存操作，都减去一，这个时候在写入数据，那么这个时候三个线程下订单结果库存才减了一；</p>
<ul>
<li><p>jmeter压测</p>
<ul>
<li>100个线程并发</li>
<li>延迟0秒</li>
<li>循环三次</li>
</ul>
</li>
<li><p>总库存为200</p>
</li>
</ul>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210901095800868.png" alt="image-20210901095800868" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">扣减库存成功，剩余库存：<span class="number">199</span>         卖出数量为：<span class="number">1</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">198</span>         卖出数量为：<span class="number">2</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">197</span>         卖出数量为：<span class="number">3</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">196</span>         卖出数量为：<span class="number">4</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">196</span>         卖出数量为：<span class="number">5</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">196</span>         卖出数量为：<span class="number">6</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">195</span>         卖出数量为：<span class="number">7</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">195</span>         卖出数量为：<span class="number">8</span></span><br><span class="line">.....</span><br><span class="line">扣减库存成功，剩余库存：<span class="number">2</span>         卖出数量为：<span class="number">257</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">1</span>         卖出数量为：<span class="number">258</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">0</span>         卖出数量为：<span class="number">259</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line">扣减库存失败，库存不足</span><br></pre></td></tr></table></figure>



<h2 id="单机安全"><a href="#单机安全" class="headerlink" title="单机安全"></a>单机安全</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  String <span class="title">decuctStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从redis中拿到stock的数量</span></span><br><span class="line">    <span class="keyword">int</span> stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>)));</span><br><span class="line">    <span class="comment">// stock数量大于零的时候才进行扣减</span></span><br><span class="line">    <span class="keyword">if</span> (stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, realStock + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;扣减库存成功，剩余库存：&quot;</span> + realStock + <span class="string">&quot;         卖出数量为：&quot;</span> + count.addAndGet(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;扣减库存成功&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扣减库存失败，库存不足&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;扣减库存失败，库存不足&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单机压测"><a href="#单机压测" class="headerlink" title="单机压测"></a>单机压测</h3><ul>
<li><p>jmeter压测</p>
<ul>
<li>100个线程并发</li>
<li>延迟0秒</li>
<li>循环三次</li>
</ul>
</li>
<li><p>总库存为200</p>
</li>
<li><p>redis单机本地部署</p>
</li>
</ul>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210901100029412.png" alt="image-20210901100029412" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">扣减库存成功，剩余库存：<span class="number">199</span>         卖出数量为：<span class="number">1</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">198</span>         卖出数量为：<span class="number">2</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">197</span>         卖出数量为：<span class="number">3</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">196</span>         卖出数量为：<span class="number">4</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">扣减库存成功，剩余库存：<span class="number">3</span>         卖出数量为：<span class="number">197</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">2</span>         卖出数量为：<span class="number">198</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">1</span>         卖出数量为：<span class="number">199</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">0</span>         卖出数量为：<span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>加入synchronized后能保证单机的数据一致性，但是当这个服务是集群部署的时候，加上负载均衡，jvm级别的锁不能保证线程安全</p>
<h3 id="集群压测"><a href="#集群压测" class="headerlink" title="集群压测"></a>集群压测</h3><ul>
<li>jmeter压测<ul>
<li>100个线程并发</li>
<li>延迟0秒</li>
<li>循环4次</li>
</ul>
</li>
<li>总库存为200</li>
<li>redis单机本地部署</li>
<li>三个服务集群</li>
<li>geteway（本地部署）轮询负载均衡</li>
</ul>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210901104535887.png" alt="image-20210901104535887" style="zoom:50%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">0</span>         卖出数量为：<span class="number">122</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">// 第二台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">0</span>         卖出数量为：<span class="number">115</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">// 第三台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">0</span>         卖出数量为：<span class="number">95</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line">    </span><br><span class="line"><span class="comment">//总卖出数量为：122+115+95=332</span></span><br></pre></td></tr></table></figure>



<p>优势：单机情况下能够保证数据一致性</p>
<p>劣势：不能保证在分布式情况下的数据一致性</p>
<h2 id="集群安全之redis的SETNX实现"><a href="#集群安全之redis的SETNX实现" class="headerlink" title="集群安全之redis的SETNX实现"></a>集群安全之redis的SETNX实现</h2><p>redis是原子性，可以使用redis api的setnx方法解决。把所有的线程并行请求转为redis中的串行请求。</p>
<p>Redis Setnx（<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists） 命令在指定的 key 不存在时，为 key 设置指定的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; EXISTS job                # job 不存在</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETNX job &quot;programmer&quot;    # job 设置成功</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SETNX job &quot;code-farmer&quot;   # 尝试覆盖 job ，失败</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GET job                   # 没有被覆盖</span><br><span class="line">&quot;programmer&quot;</span><br></pre></td></tr></table></figure>



<p>思想：</p>
<p>所有请求先去到redis中设置相同的key，只有设置成功的那个线程才能执行下面的业务逻辑，当业务逻辑执行完成后删除key，然后其他线程能够再次拿到key，执行。</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="集群压测-1"><a href="#集群压测-1" class="headerlink" title="集群压测"></a>集群压测</h4><ul>
<li>jmeter压测<ul>
<li>100个线程并发</li>
<li>延迟0秒</li>
<li>循环4次</li>
</ul>
</li>
<li>总库存为200</li>
<li>redis单机本地部署</li>
<li>三个服务集群</li>
<li>geteway（本地部署）轮询负载均衡</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  String <span class="title">decuctStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//当先线程设置redis锁</span></span><br><span class="line">       Boolean isExist = stringRedisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;stocklock&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">       <span class="comment">// 如果没有拿到锁，怎返回，或者不断重试</span></span><br><span class="line">       <span class="keyword">if</span> (isExist != <span class="keyword">null</span> &amp;&amp; !isExist)&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">50</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> decuctStock();</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isExist == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;程序错误&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 从redis中拿到stock的数量</span></span><br><span class="line">       <span class="keyword">int</span> stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>)));</span><br><span class="line">       <span class="comment">// stock数量大于零的时候才进行扣减</span></span><br><span class="line">       <span class="keyword">if</span> (stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">           stringRedisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, realStock + <span class="string">&quot;&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;扣减库存成功，剩余库存：&quot;</span> + realStock + <span class="string">&quot;         卖出数量为：&quot;</span> + count.addAndGet(<span class="number">1</span>));</span><br><span class="line">           <span class="comment">// 删除锁</span></span><br><span class="line">           stringRedisTemplate.delete(<span class="string">&quot;stocklock&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;扣减库存成功&quot;</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           stringRedisTemplate.delete(<span class="string">&quot;stocklock&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;扣减库存失败，库存不足&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;扣减库存失败，库存不足&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210901111405543.png" alt="image-20210901111405543" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">0</span>         卖出数量为：<span class="number">94</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">// 第二台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">1</span>         卖出数量为：<span class="number">60</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">// 第三台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">9</span>         卖出数量为：<span class="number">46</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">//总卖出数量为：94+60+46=200</span></span><br></pre></td></tr></table></figure>

<p>总卖出数量为200，符合我们的预期</p>
<h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><p> 这样看来我们的程序是不是达到了分布式锁的目的，在分布式条件下，我们的库存和我们预想的情况下一样。但是我们在看一下上面保证分布式情况下的可靠性条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">为了保证分布式锁的`可用`，我们至少要保证锁的实现同时满足以下四个条件：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 互斥性。在任意时刻，只能有一个客户端持有锁</span><br><span class="line"><span class="number">2.</span> 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁</span><br><span class="line"><span class="number">3.</span> 具有容错性。只要大部分的redis节点正常运行，客户端就可以加锁和解锁</span><br><span class="line"><span class="number">4.</span> 解铃还须系铃人。加锁和解锁的对象必须是同一个客户端，客户端不能把别人加的锁给解了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>互斥性问题解决了，然后看我的程序会不会发生死锁</strong></p>
<p><strong>如果在运行的过程中，突然一台机器宕机会发生什么</strong></p>
<p>为了模拟上述情况，更改代码，主要在删除stocklock前，设置一个长时间的休眠，方便我们能够宕机一个服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public  String decuctStock() &#123;</span><br><span class="line">       //当先线程设置redis锁</span><br><span class="line">       Boolean isExist = stringRedisTemplate.opsForValue().setIfAbsent(&quot;stocklock&quot;, &quot;stocklock&quot;);</span><br><span class="line">       // 如果没有拿到锁，怎返回，或者不断重试</span><br><span class="line">       if (isExist != null &amp;&amp; !isExist)&#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               Thread.sleep(50);</span><br><span class="line">           &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           return decuctStock();</span><br><span class="line">       &#125;else if (isExist == null)&#123;</span><br><span class="line">           return &quot;程序错误&quot;;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // 从redis中拿到stock的数量</span><br><span class="line">       int stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(&quot;stock&quot;)));</span><br><span class="line">       // stock数量大于零的时候才进行扣减</span><br><span class="line">       if (stock &gt; 0)&#123;</span><br><span class="line">           int realStock = stock - 1;</span><br><span class="line">           stringRedisTemplate.opsForValue().set(&quot;stock&quot;, realStock + &quot;&quot;);</span><br><span class="line">           System.out.println(&quot;扣减库存成功，剩余库存：&quot; + realStock + &quot;         卖出数量为：&quot; + count.addAndGet(1));</span><br><span class="line">           // 删除锁</span><br><span class="line">           try &#123;</span><br><span class="line">               Thread.sleep(3000);</span><br><span class="line">           &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           stringRedisTemplate.delete(&quot;stocklock&quot;);</span><br><span class="line">           return &quot;扣减库存成功&quot;;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           // 删除锁</span><br><span class="line">           try &#123;</span><br><span class="line">               Thread.sleep(3000);</span><br><span class="line">           &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           stringRedisTemplate.delete(&quot;stocklock&quot;);</span><br><span class="line">           System.out.println(&quot;扣减库存失败，库存不足&quot;);</span><br><span class="line">           return &quot;扣减库存失败，库存不足&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">199</span>         卖出数量为：<span class="number">1</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">195</span>         卖出数量为：<span class="number">2</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">193</span>         卖出数量为：<span class="number">3</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">192</span>         卖出数量为：<span class="number">4</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">188</span>         卖出数量为：<span class="number">5</span></span><br><span class="line"><span class="comment">// 第二台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">197</span>         卖出数量为：<span class="number">1</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">194</span>         卖出数量为：<span class="number">2</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">191</span>         卖出数量为：<span class="number">3</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">189</span>         卖出数量为：<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">198</span>         卖出数量为：<span class="number">1</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">196</span>         卖出数量为：<span class="number">2</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">190</span>         卖出数量为：<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在运行过程中把第一台服务器停止，然后整个项目陷入一直死锁状态，控制台没有打印</span></span><br></pre></td></tr></table></figure>

<p>查看redis中的key，发现stocklock存在，说明刚刚在停止第一台服务器的时候，这个key没有删除，所以造成了整个项目的死锁</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210901142008719.png" alt="image-20210901142008719"></p>
<h3 id="改进一"><a href="#改进一" class="headerlink" title="改进一"></a>改进一</h3><p>基础版的主要问题是如果一个客户端在持有锁的过程中因为种种问题，没有主动解锁，那么整个项目将发生死锁。</p>
<p>所以在改进一种可以设置一个超时时间，如果客户端在持有锁的过程中宕机，那么可以等待过了超时时间后，解除死锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置锁的时候，添加一个超时时间</span></span><br><span class="line">Boolean isExist = stringRedisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;stocklock&quot;</span>, <span class="string">&quot;stocklock&quot;</span>,<span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210901144358811.png" alt="image-20210901144358811"></p>
<p>这样即时一个服务在持有锁的情况下宕机了，没有即时删除key，仍有一个过期时间，在过期时间到了后，整个项目仍然可以正常运行。</p>
<h3 id="改进二"><a href="#改进二" class="headerlink" title="改进二"></a>改进二</h3><p>着看改进一就没有问题了吗，如果在程序运行过程中，一个程序因为未知原因（cpu卡顿，业务逻辑卡顿，业务逻辑中的网络卡顿等等），在过期时间内还没有运行完成，然后这个时候key过期了。这个时候就想当与锁释放了，然后第二个线程就拿到了锁，然后线程进来了，然后在第二个线程运行过程中，第一个线程删除了这个key，这个时候删除了就是第二个线程的key，然后如果整个项目这样一直迭代，那么肯定会出现大量的超卖现象。</p>
<p>之前的方案：</p>
<ul>
<li>可以保证互斥性</li>
<li>可以保证不能发生死锁</li>
<li>但是不能保证解铃还须系铃人</li>
</ul>
<p>第一个线程把第二个线程的锁释放了。</p>
<p>所以，再次改进，然后想到了CAS中的ABA问题，CAS的解决方案是添加了一个线程id，这个线程在一个jvm中是唯一的，在改变值的时候不仅要判断值是否想当，还需要判断这个线程id是否相等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">decuctStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当先线程设置redis锁</span></span><br><span class="line">        <span class="comment">// 在这只value的时候，添加了额一个uuid，保证唯一性，只有当前线程能够释放</span></span><br><span class="line">        String clientUuid =  UUID.randomUUID().toString();</span><br><span class="line">        Boolean isExist = stringRedisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;stocklock&quot;</span>, clientUuid,<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 如果没有拿到锁，怎返回，或者不断重试</span></span><br><span class="line">        <span class="keyword">if</span> (isExist != <span class="keyword">null</span> &amp;&amp; !isExist) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> decuctStock();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isExist == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;程序错误&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从redis中拿到stock的数量</span></span><br><span class="line">        <span class="keyword">int</span> stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>)));</span><br><span class="line">        <span class="comment">// stock数量大于零的时候才进行扣减</span></span><br><span class="line">        <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, realStock + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;扣减库存成功，剩余库存：&quot;</span> + realStock + <span class="string">&quot;         卖出数量为：&quot;</span> + count.addAndGet(<span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 删除锁</span></span><br><span class="line">            <span class="keyword">if</span> (clientUuid.equals(stringRedisTemplate.opsForValue().get(<span class="string">&quot;stocklock&quot;</span>)) )&#123;</span><br><span class="line">                stringRedisTemplate.delete(<span class="string">&quot;stocklock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;扣减库存成功&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除锁</span></span><br><span class="line">            <span class="keyword">if</span> (clientUuid.equals(stringRedisTemplate.opsForValue().get(<span class="string">&quot;stocklock&quot;</span>)) )&#123;</span><br><span class="line">                stringRedisTemplate.delete(<span class="string">&quot;stocklock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;扣减库存失败，库存不足&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;扣减库存失败，库存不足&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是这样真的能够解决了吗，如果是在判断这两个值相等后，这个缓存时间过期了，然后第二个线程拿到了这个锁，然后在执行的过程中，第一个线程删除了这把锁。</p>
<p>这样不是还有上述问题。</p>
<p>所以我们必须要保证删除锁的过程中的原子性：</p>
<h4 id="lua脚本"><a href="#lua脚本" class="headerlink" title="lua脚本"></a>lua脚本</h4><p>一下lua脚本不确定是否正确：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> key = <span class="string">&quot;rate.limit:&quot;</span> .. KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> expire_time = ARGV[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> is_exists = redis.call(<span class="string">&quot;EXISTS&quot;</span>, key)</span><br><span class="line"><span class="keyword">if</span> is_exists == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> redis.call(<span class="string">&quot;INCR&quot;</span>, key) &gt; limit <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">&quot;SET&quot;</span>, key, <span class="number">1</span>)</span><br><span class="line">    redis.call(<span class="string">&quot;EXPIRE&quot;</span>, key, expire_time)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">accessLimit</span><span class="params">(String ip, <span class="keyword">int</span> limit, <span class="keyword">int</span> timeout, Jedis connection)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    List&lt;String&gt; keys = Collections.singletonList(ip);</span><br><span class="line">    List&lt;String&gt; argv = Arrays.asList(String.valueOf(limit), String.valueOf(timeout));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> == (<span class="keyword">long</span>) connection.eval(loadScriptString(<span class="string">&quot;script.lua&quot;</span>), keys, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载Lua代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">loadScriptString</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Reader reader = <span class="keyword">new</span> InputStreamReader(Client.class.getClassLoader().getResourceAsStream(fileName));</span><br><span class="line">    <span class="keyword">return</span> CharStreams.toString(reader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>lua脚本能够保证redis执行的原子性</p>
<p>这样能够解决解铃还须系铃人问题，但是还有一个问题没有解决，那么就是<strong>如果程序运行时间超过了设定的过期时间</strong>，第二个线程拿到了这个锁，虽然第一个线程不能删除第二个删除的锁，但是第一个线程可以修改这个库存值，这样还是会造成一个超卖问题。</p>
<p>存在问题：</p>
<ol>
<li>非高可用</li>
<li>不支持阻塞和非阻塞</li>
</ol>
<h3 id="改进三"><a href="#改进三" class="headerlink" title="改进三"></a>改进三</h3><p>这个可以设置一个监听线程，如果线程在这个锁三份之一的时间内还有没完成业务逻辑，那么就为这把锁续命延长时间，在延长一定次数后，直接回滚，放弃本次操作</p>
<p>但是这样，为造成我们编写程序的复杂性，每次这样的业务逻辑都要写这么多的代码吗？所以引申出来了一个分布式redisson框架</p>
<h4 id="redisson优势"><a href="#redisson优势" class="headerlink" title="redisson优势"></a>redisson优势</h4><ul>
<li>redisson所有指令都通过lua脚本执行，redis支持lua脚本原子执行</li>
<li>rediss设置key默认时间为30s，如果一个客户端持有锁的时间超过了30秒呢？<ul>
<li>redison中有watchdog（监听器），在你获取锁后，每隔10秒后帮你把key的超时时间设为30s，一直续期</li>
<li>如果不想一直续期，可以不使用默认，设置过期时间，然后要设置回滚</li>
</ul>
</li>
<li>redisson的的监听器保证了没有死锁发生<ul>
<li>如果及其宕机了，他也就不会自动续期了，过期后其他线程就可以拿到锁</li>
</ul>
</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Redisson <span class="title">redisson</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Config cfg = <span class="keyword">new</span> Config();</span><br><span class="line">    <span class="comment">// 可以设置redis集群</span></span><br><span class="line">    cfg.useSingleServer().setAddress(<span class="string">&quot;redis://localhost:6379&quot;</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (Redisson) Redisson.create(cfg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 添加事务，如果中间遇到卡段，一直在运行，在超过30秒后redisson释放锁并抛出异常，然后@Transactional检测到异常事务后回滚</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decuctStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RLock stocklock = redisson.getLock(<span class="string">&quot;stocklock&quot;</span>);</span><br><span class="line">        String returnResult = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//设置加锁只有30秒，超过30秒则放弃</span></span><br><span class="line">            stocklock.lock(<span class="number">30</span>,TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">int</span> stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>)));</span><br><span class="line">            <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, realStock + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;扣减库存成功，剩余库存：&quot;</span> + realStock + <span class="string">&quot;         卖出数量为：&quot;</span> + count.addAndGet(<span class="number">1</span>));</span><br><span class="line">                returnResult = <span class="string">&quot;扣减库存成功&quot;</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;扣减库存失败，库存不足&quot;</span>);</span><br><span class="line">                returnResult = <span class="string">&quot;扣减库存失败，库存不足&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (stocklock != <span class="keyword">null</span> &amp;&amp; stocklock.isHeldByCurrentThread()) &#123;</span><br><span class="line">                stocklock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> returnResult;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="集群压测-2"><a href="#集群压测-2" class="headerlink" title="集群压测"></a>集群压测</h4><ul>
<li>jmeter压测<ul>
<li>100个线程并发</li>
<li>延迟0秒</li>
<li>循环4次</li>
</ul>
</li>
<li>总库存为200</li>
<li>redis单机本地部署</li>
<li>三个服务集群</li>
<li>geteway（本地部署）轮询负载均衡</li>
<li>redisson分布式锁框架</li>
</ul>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210901162657634.png" alt="image-20210901162657634"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">1</span>         卖出数量为：<span class="number">70</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">// 第二台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">0</span>         卖出数量为：<span class="number">60</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">// 第三台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">2</span>         卖出数量为：<span class="number">70</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">//总卖出数量为：70+60+70=200</span></span><br></pre></td></tr></table></figure>



<h1 id="redisson分布式锁的实现原理"><a href="#redisson分布式锁的实现原理" class="headerlink" title="redisson分布式锁的实现原理"></a>redisson分布式锁的实现原理</h1><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMS41MWN0by5jb20vaW1hZ2VzL2Jsb2cvMjAxOTA4LzExL2IwNWQzNDBkOTE2YzUyMjBlYmNmZTc0OTgwYmY2ZjIxLnBuZw?x-oss-process=image/format,png" alt="Redis如何实现高并发分布式锁？"></p>
<p>但是这个架构还是存在问题的，因为redis服务器是主从的架构，当在master节点设置锁之后，slave节点会立刻同步。但是如果刚在master节点设置上了锁，slave节点还没来得及设置，master节点就挂掉了。还是会产生上同样的问题，新的线程获得锁。</p>
<p>redisson有解决方案（redlock），但是解决方案存在争议</p>
<h1 id="redis分布式锁和zookeeper分布式锁"><a href="#redis分布式锁和zookeeper分布式锁" class="headerlink" title="redis分布式锁和zookeeper分布式锁"></a>redis分布式锁和zookeeper分布式锁</h1><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>redis实现分布式锁是AP高可用</p>
<p>redis在向主节点加锁后，可以直接返回给客户端，性能较高</p>
<p>redis适合在单机情况下，在主从模式下Redis作者antirez提出了RedLock算法</p>
<p>这个场景是假设有一个redis cluster，有5个redis master实例。然后执行如下步骤获取一把锁：</p>
<ul>
<li><p>获取当前时间戳，单位是毫秒</p>
</li>
<li><p>轮流尝试在每个master节点上创建锁，过期时间较短，一般就几十毫秒</p>
</li>
<li><p>尝试在大多数节点上建立一个锁，比如5个节点就要求是3个节点（n / 2 +1）</p>
</li>
<li><p>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了</p>
</li>
<li><p>要是锁建立失败了，那么就依次删除这个锁</p>
</li>
<li><p>只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁</p>
</li>
</ul>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/720994-20181209150457361-385299448.png" alt="img"></p>
<p>但是不推荐使用redlock，还有写bug。如果非要保证强一致行，可以考虑使用zookeeper，如果为了高可用，高性能，允许少量的数据不一致（这个可以通过后期log日志维护），可以使用redis。</p>
<h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><p>zookeeper实现分布式锁是CP强一致</p>
<p>zookeeper想主节点加锁后，会通知从节点，只有一半以上的节点都加锁成功后，才会返回给客户端</p>
<h1 id="redisson（redis）分布式锁和curator（zookeeper）分布式锁对比"><a href="#redisson（redis）分布式锁和curator（zookeeper）分布式锁对比" class="headerlink" title="redisson（redis）分布式锁和curator（zookeeper）分布式锁对比"></a>redisson（redis）分布式锁和curator（zookeeper）分布式锁对比</h1><p>通过jmeter压测发现，在同样的并发请求，redis本地单机，zookeeper本地单机的情况下，redis的300线程的200库存量用时平均在3秒左右，而zookeeper的300线程的200库存量用时平均在28秒左右。</p>
<p>可以明显看的出来，针对本次的300线程200库存，redis单机和zookeeper单机</p>
<table>
<thead>
<tr>
<th>对比</th>
<th>zookeeper</th>
<th>redis</th>
</tr>
</thead>
<tbody><tr>
<td>时间</td>
<td>28秒</td>
<td>3秒</td>
</tr>
<tr>
<td>CAP</td>
<td>CP</td>
<td>AP</td>
</tr>
<tr>
<td>性能</td>
<td>较低</td>
<td>高</td>
</tr>
<tr>
<td>可靠</td>
<td>高</td>
<td>较低</td>
</tr>
</tbody></table>
<h1 id="工具对比"><a href="#工具对比" class="headerlink" title="工具对比"></a>工具对比</h1><ol>
<li><p>redisTemplate是基于某个具体实现的再封装，比如说springBoot1.x时，具体实现是jedis；而到了springBoot2.x时，具体实现变成了lettuce。封装的好处就是隐藏了具体的实现，使调用更简单，但是有人测试过jedis效率要10-30倍的高于redisTemplate的执行效率，所以单从执行效率上来讲，jedis完爆redisTemplate。redisTemplate的好处就是基于springBoot自动装配的原理，使得整合redis时比较简单。</p>
</li>
<li><p>jedis作为老牌的redis客户端，采用同步阻塞式IO，采用线程池时是线程安全的。优点是简单、灵活、api全面，缺点是某些redis高级功能需要自己封装。</p>
</li>
<li><p>lettuce作为新式的redis客户端，基于netty采用异步非阻塞式IO，是线程安全的，优点是提供了很多redis高级功能，例如集群、哨兵、管道等，缺点是api抽象，学习成本高。lettuce好是好，但是jedis比他生得早。</p>
</li>
<li><p>redission作为redis的分布式客户端，同样基于netty采用异步非阻塞式IO，是线程安全的，优点是提供了很多redis的分布式操作和高级功能，缺点是api抽象，学习成本高</p>
</li>
</ol>
<p>面试题：</p>
<p>你们项目中在分布式中如何保证线程安全</p>
<p>zookeeper和redis如何选择</p>
<p><a href="https://zhuanlan.zhihu.com/p/106333054">https://zhuanlan.zhihu.com/p/106333054</a></p>
<p><a href="https://www.zhihu.com/question/300767410/answer/1698980571">https://www.zhihu.com/question/300767410/answer/1698980571</a></p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/belongtocode/article/details/102212078">https://blog.csdn.net/belongtocode/article/details/102212078</a></p>
<p><a href="https://www.cnblogs.com/moxiaotao/p/10829799.html">https://www.cnblogs.com/moxiaotao/p/10829799.html</a></p>
<p><a href="https://blog.csdn.net/qq_40925189/article/details/109580439">https://blog.csdn.net/qq_40925189/article/details/109580439</a></p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>分布式锁</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>源码级别理解java拆箱装箱过程</title>
    <url>/2134a338.html</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>知道字节码吗，字节码都有哪些？比较下面代码<code>x == y</code>都经过了哪些过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">interview</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer x = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line">        System.out.println(x == y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确答案：</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>通过idea的工具jClasslib插件查看main方法的code，发现：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210913142135732.png" alt="image-20210913142135732"></p>
<ol>
<li>然后我们去Integer中查看Valueof和intValue方法</li>
</ol>
<h2 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.valueOf(parseInt(s, <span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里调用了</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="comment">// 如果在缓存里面，这从这个缓存数组中取出值（这个值是integer对象）</span></span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Integer的内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义最小值为-128</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="comment">// 定义一个缓存数组</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="comment">// high 的默认值为127</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        <span class="comment">// 从vm中拿到high的数值，这个数值可以通过vm参数配置</span></span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果拿到了这个值，说明进行了vm配置</span></span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 把这个值转化为int类型</span></span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                <span class="comment">// 这个值得最小值要大于等于127</span></span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                <span class="comment">// 这个值得最大值是2147483518，也就是整个cache数组的长度为Integer的最大值</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        high = h;</span><br><span class="line">		<span class="comment">// 定义cache数组的长度</span></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="comment">// 为这个cache填充值，这些都是Integer对象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="comment">// 断言这个值得最大值大于等于127</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 私有化构造方法，jvm级别单例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="intValue"><a href="#intValue" class="headerlink" title="intValue"></a>intValue</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回了int类型的一个值value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个vlaue在创建Integer对象的时候</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="comment">// 在一步调用了new Integer()的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>在创建一个integer的对象的时候，回调用valueOf方法<ol>
<li>valueOf方法回去调用IntegerCache中的一个值<ol>
<li>IntegerCache<ol>
<li>如果没被初始化，则优先从jvm参数中读取值进行初始化</li>
<li>如果初始化过了则直接拿到值，直接就返回了</li>
</ol>
</li>
<li>然后调用new Integer(i)方法</li>
</ol>
</li>
</ol>
</li>
<li>然后把这个对象放入栈中的局部变量表</li>
<li>然后判断的时候，调用intValue方法，然后int类型的值</li>
<li>两个int类型的值进行判断</li>
</ol>
]]></content>
      <categories>
        <category>jvm</category>
        <category>jvm杂篇</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>前端编译器和后端编译器</title>
    <url>/dd88deb1.html</url>
    <content><![CDATA[<p>本文章转载于：<a href="https://blog.csdn.net/qq_20009015/article/details/105190415">https://blog.csdn.net/qq_20009015/article/details/105190415</a></p>
<h1 id="前端编译器："><a href="#前端编译器：" class="headerlink" title="前端编译器："></a>前端编译器：</h1><p><strong>将java文件编译成class文件的编译器。</strong><br><strong>java很多提高效率和友好度的语法糖都是依赖前端编译器实现的。</strong><br><strong>javac就是一个典型的前端编译器。</strong></p>
<h2 id="执行过程如下："><a href="#执行过程如下：" class="headerlink" title="执行过程如下："></a>执行过程如下：</h2><ol>
<li><p>准备阶段：<br>初始化插入式注解处理器</p>
</li>
<li><p>解析与填充符号表阶段：<br>词法 语法分析，将源代码转变为标记集合，构建抽象语法树<br>填充符号表，产生符号地址和符号信息。</p>
</li>
<li><p>插入式注解处理器的执行阶段：<br>会影响javac的行为，比如说添加一些编译期的校验等。</p>
</li>
<li><p>分析与字节码的生成：<br>检查静态信息，数据流检查，解语法糖，字节码生成</p>
</li>
</ol>
<h3 id="词法解析："><a href="#词法解析：" class="headerlink" title="词法解析："></a>词法解析：</h3><p>将源代码的字符流转为标记(token)集合的过程，token是编译时的最小单位，关键字 变量名 运算符等都可以作为标记。</p>
<h3 id="语法分析："><a href="#语法分析：" class="headerlink" title="语法分析："></a>语法分析：</h3><p>根据标记序列构造抽象语法树，抽象语法树是一种描述程序代码语法结构的树形表示，树的每一个节点代表程序代码中的一个语法结构，比如说<br>包，类型，修饰符，运算符等。</p>
<p>生成语法树之后，后续的操作都是对语法树进行操作。</p>
<h3 id="填充符号表："><a href="#填充符号表：" class="headerlink" title="填充符号表："></a>填充符号表：</h3><p>符号表是一组符号地址和符号信息构成的数据结构，当对符号名进行地址分配时，符号表是地址分配的直接依据。</p>
<h3 id="注解处理器："><a href="#注解处理器：" class="headerlink" title="注解处理器："></a>注解处理器：</h3><p>jdk5 时候提出了注解，原本设计上和普通java代码一样， 是程序运行期间发挥作用。但是在jdk6之后，设计了一组 插入式注解处理器的api，<br>可以提前至编译期对代码中的特定注解进行处理，当这些插件工作时，允许读取修改 添加抽象语法树中的任意元素。<br>如果插入式注解处理器对语法树进行过修改，那么编译器就会重新回到解析以及填充符号表的阶段。<br>比如说lombok的实现原理，就是通过插入式注解处理器来在编译期对特定的注解处理，生成get set方法等。</p>
<h3 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成"></a>语义分析与字节码生成</h3><p>抽象语法树能表示一个结构正确的代码，但是无法保证代码是符合逻辑的。<br>语义分析则是对结构上正确的程序进行检查，比如说类型检查，控制流检查，数据流检查。<br>比如说 int a=1; bool b=true; char c=a+b; 这种 ，就可以在语义分阶段被检查出来，<br>在IDE上看到报红下划线的错误，就是语义分析得出来的结果。</p>
<h2 id="检查主要有："><a href="#检查主要有：" class="headerlink" title="检查主要有："></a>检查主要有：</h2><ol>
<li>标注检查<br>检查类型是否匹配，变量使用前是否声明等</li>
<li>数据和控制流分析<br>检查局部变量使用前是否赋值<br>方法的每条路径是否都有返回值<br>所有必检异常是否都被处理了</li>
</ol>
<h3 id="解语法糖："><a href="#解语法糖：" class="headerlink" title="解语法糖："></a>解语法糖：</h3><p>语法糖，在计算机语言中添加某种语法，对编译和功能没影响，但是更方便程序员使用该语言。<br>java常见的语法糖有泛型，变长参数，自动装箱拆箱，等等，java虚拟机其实并不支持这些语法，这些语法会在编译期被还原回原始的样子。<br>泛型 obejct ，变长参数 数组参数， 自动装箱 拆箱 integer.valueof() 等</p>
<h3 id="字节码生成；"><a href="#字节码生成；" class="headerlink" title="字节码生成；"></a>字节码生成；</h3><p>将之前步骤所生成的信息，语法树 符号表等 转化成字节码指令。<br>除此之外，添加实例构造器()方法和 ()方法，这个动作是将{}里面的代码块都收集起来 放到()方法里面<br>或者将static{} 里面的代码都收集汇集到一起 放到()方法里面去。</p>
<h2 id="java语法糖"><a href="#java语法糖" class="headerlink" title="java语法糖"></a>java语法糖</h2><p>语法糖是编程语言提高的一种能提高效率 或者减少编码出错机会的语法，由前端编译器进行解语法糖还原。</p>
<h3 id="泛型："><a href="#泛型：" class="headerlink" title="泛型："></a>泛型：</h3><p>java的泛型也是语法糖，实现方式叫类型擦除式泛型，编译期后就会被还原。<br>而C#使用的是具现化式泛型，这种泛型在源码里面，编译后，运行期 都是切实存在的<br>比如说List 和List 就是两个不同的类型，在运行时生成，都有各自的类型数据和虚方法表。<br>但是在java的泛型，只在程序源码中存在，在编译后的字节码文件中，都已经被还原为原来的裸类型，并在使用的地方加入了强制类型转换。<br>对于java来说，List和List在运行期就是同一个类型。</p>
<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><p>1.性能低于具现式的泛型，因为擦除式泛型不支持基本类型 比如说int long ，要使用的时候就必须是要Intger Long<br>会造成不必要的拆箱装箱操作。<br>2.很多功能不支持，比如说创建泛型对象 new E()，判断一个实例是否属于泛型类型 xx instanceof E ,这些在C#中都支持。</p>
<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><p>3.运行时无法获取到类型信息，运行时要用到类型，就只能自己传入一个class类型作为参数进去。<br>4.泛型无法重载，比如说List 和List 无法作为方法重载的参数，<br>会被认为同一个参数类型List ，方法重载是静态分派，以静态类型判断走哪个方法，泛型擦除之后就无法判断了。</p>
<p>1.兼容jdk1.5以前的代码<br>2.不需要修改虚拟机，只需要新增javac编译器做个转换，影响范围小。</p>
<h2 id="泛型历史："><a href="#泛型历史：" class="headerlink" title="泛型历史："></a>泛型历史：</h2><p>设计成擦除式泛型是因为要兼容以前的jdk1.5之前无泛型的代码，也就是以前没有的限制不能以后突然冒出来。<br>比如说没有泛型之前，一个ArrayList列表，里面同时可以放interger又可以放String, 编译运行都不会报错。<br>现在的ArrayList 则必须指定里面元素类型了。<br>如果要兼容以前的，那么这个T 就必须是属于可有可无的，在编译期就会被擦除，变成ArrayListt，这样就和以前的一样了。<br>试想，如果T必须存在，那么以前的那种 一个ArrayList列表，里面同时可以放interger又可以放String的代码，如何自处？ T到底是什么类型？</p>
<p>解决方法有两种，一个另起炉灶搞一套新的支持泛型的容器，另一个就是像现在的java这样。<br>c#使用了第一种方案，所以有两套容器，支持泛型的容器和老容器。<br>如果java也使用第一种方案，就会出现ArrayList，ArrayList 两套容器， 采用第二种方案之后，现在这两个容器其实是同一个。<br>比如说 ArrayList a 在编译之后就变成了ArrayList ，这个也就是裸类型，但是在元素方法的地方 加上了强制类型转换<br>（integer)a.get(0);</p>
<h3 id="自动装箱-拆箱"><a href="#自动装箱-拆箱" class="headerlink" title="自动装箱/拆箱"></a>自动装箱/拆箱</h3><p>将基本类型转为包装类型叫装箱，包装类型转基本类型叫拆箱。<br>Integer a=123;<br>其实发生了自动装箱，编译后是Integer a=Integer.valueof(123);</p>
<p>条件编译：<br>if条件为常量时候，必定为false的那段代码注定不会执行，会在编译器被消除掉。</p>
<p>插入式注解处理器：<br>lombok就是使用的插入式注解处理器实现的动态加get set方法。</p>
<p>插入式器的抽象类为javax.annotation.processing.AbstractProcessor。<br>子类必选实现process() ,这是javac编译器在执行注解处理器代码时候要调用的。<br>（javac编译器本身也是用java写的。）</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SupportedAnnotationType(&quot;*&quot;)</span> <span class="comment">//表示要支持的注解 *表示所有</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion(SourceVesion.RELESASE_6)</span> <span class="comment">//支持的jdk版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameCheckProccessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>.init(processingEnv);</span><br><span class="line"><span class="comment">//processingEnv 是注解处理器框架提供的一个上下文环境 要创建新的代码，向编译器输出信息 等都需要用到这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations,RoundEnvironment roundEnv)</span></span>&#123;</span><br><span class="line"><span class="comment">//annotations为要处理的注解集合</span></span><br><span class="line"><span class="comment">// roundEnv为该轮次的抽象语法树节点</span></span><br><span class="line"><span class="comment">//返回值为true 告诉编译器自己有改动语法树 需要重新解析</span></span><br><span class="line"><span class="comment">//返回false 则不需要</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对 roundEnv.getRootElements()进行循环遍历，查找自己要的节点 ，比如说 方法 ，类，字段 等。</span></span><br><span class="line"><span class="comment">// processingEnv的getMassager()方法可以返回一个Massager对象，该对象上有用于向编译器输出信息的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比如说输出警告，massager.printMessage(Waring,&quot;xxx &quot;,e); e为当前元素elements</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk提供了一个抽象类，ElementScannerX X为jdk版本号， 继承这个类，可以以Visitor模式来访问抽象语法树上的元素。</span></span><br><span class="line">比如说</span><br><span class="line"><span class="keyword">for</span>(Element e: roundEnv.getRootElements())&#123;</span><br><span class="line">XXXXElementScanner6(e); <span class="comment">//XXXXElementScanner6为抽象类ElementScannerX的实现子类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ElementScannerX的抽象方法有用于访问类的visitType(TypeElemt e ,void p);<br>访问方法的 visitExecutable(ExecutableElemt e ,void p ); 方法变量的 visitVariable(VariableElemt e ,void p );</p>
<h1 id="后端编译器："><a href="#后端编译器：" class="headerlink" title="后端编译器："></a>后端编译器：</h1><p><strong>将Class文件编译为与本地机器上可以识别的二进制指令的编译器。</strong><br><strong>主要有解释执行的解释器和编译执行的编译器。</strong></p>
<p><strong>目前主流的虚拟机都是解释器和编译器并存的运行架构，解释器和编译器各有优势。</strong></p>
<p>当程序需要迅速启动时，解释器可以先发挥作用，省去编译的时间，立即运行。</p>
<p>当程序启动后，随着时间推移，编译器发挥作用，将越来越多的的代码编译成本地代码，获得更高的执行效率。</p>
<p>解释器使用内存比编译器略小，解释一行执行一行，而编译器需要将代码都编译成本地指令之后才执行。</p>
<p>解释器还可以充当编译器激进优化失败之后的备用方案。</p>
<p>hotspot虚拟机中有两个即时编译器，分别是客户端编译器和服务端编译器。</p>
<p>一般都是混合使用， -Xint 命令 强制使用解释器， java -Xcomp 优先使用编译器，编译无法进行的时候使用解释器。</p>
<p>即时编译需要占用程序运行时间，要编译出优化程度越高的代码，花费的时间就越长。</p>
<p>而且解释器需要采集性能监控信息给编译器，这对解释器效率也会有影响。</p>
<p>为了均衡在程序的启动响应速度和运行效率之间达成平衡，引入了分层编译的策略。</p>
<p>第0层，纯解释执行，而且解释器不开性能监控</p>
<p>第1层，使用客户端编译器将代码编译成本地代码，使用简单稳定的优化，不开启性能监控</p>
<p>第2层，使用客户端编译器，开启方法回边统计次数统计等有限的性能监控。</p>
<p>第3层，使用客户端编译器，开启方法回表统计次数和分支跳转，虚方法调用版本等性能监控</p>
<p>第4层，使用服务端编译器，使用更长时间的编译优化，根据性能监控进行进行激进不可靠的优化。</p>
<p>以上5层，在运行期间，虚拟机会根据运行参数和版本 进行调整。<br>实现分层编译之后，解释器 客户端编译器和服务端编译器 就可以都用上，客户端编译器获得更快的编译速度，服务端编译器获取更<br>优化的编译代码，解释执行时也不需要性能监控。 服务端编译器采用高复杂度的优化算法的时候，客户端编译器可以先用简单优化来为<br>它争取更多的时间。</p>
<p>编译对象与触发条件<br>会被即时编译器编译的代码是热点代码，热点代码是指<br>1.被多次调用的方法<br>2.被多次执行的循环体。</p>
<p>这两种情况下，编译的对象都是整个方法体。<br>如果是循环体触发的即时编译，叫栈上替换编译请求，这种编译方式，编译发生在方法执行过程中，叫栈上替换，<br>即方法的栈帧还在栈上，方法就被替换了。</p>
<p>那么如何知道代码是热点代码，就需要热点探测。<br>热点探测有两种：<br>1.基于采样的热点探测<br>周期性统计各个线程所在栈顶的方法出现的频率，如果某个方法经常出现在栈顶，说明经常被调用，就是热点方法。<br>优点是实现较简单，缺点是统计可能不准，会受线程阻塞影响等。</p>
<p>2.基于计数器的热点探测<br>为每个方法都建立一个计数器，统计方法的执行次数，一段时间内超过某个阈值就认为是热点方法，默认是10000次。<br>如果时间到了未到达阈值，就会将计数器减半，这个动作是在垃圾收集的时候顺便进行的，也可以通过设置命令-XX: -useCounterDecay<br>来关闭热度衰减，这样计数器调用的就是绝对次数，时间长了大部分代码都会被编译成本地代码。<br>-XX：CounterHalfLifeTime 设置半衰周的时间 单位为秒。</p>
<p>hotspot为每个方法建立了方法调用计数器和回边计数器（统计内部循环执行的代码）。 流程如下：<br>java方法入口，判断是否有已编译的版本，如果有，执行编译后的本地代码版本。<br>如果没有，那么方法调用计数器+1， 判断两个计数器之和是否超过阈值，<br>是，向编译器提交编译请求，然后用解释器执行，并不会等到编译器编译完成。<br>否，则直接用解释器执行。</p>
<p>回边计数器统计方法中循环体执行的次数。字节码上遇到控制流向后跳转的指令就叫回边，但是空循环不是回边，因为是自己跳自己，并没有向后跳。</p>
<p>当解释器遇到一个回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有的话，就会优先执行已编译的版本，<br>否则的话 回边指数器+1，然后判断两个计数器之和 是否满足阈值，如果满足，那么提交一个栈上替换编译请求，然后调小回边计数器的值以便当前继续在解释器中执行，然后使用调用解释器执行。这样的话，等到编译器编译好了，就可以使用编译版本执行了。</p>
<p>与方法调用计数器不同，回边计数器没有计数器衰减的过程，如果回边计数器满了，会把方法调用计数器也调满，这样下次就会触发标准编译过程。</p>
<p>编译过程：<br>无论方法调用产生的标准编译还是栈上替换编译请求，虚拟机在编译还没完成之前，都是用的解释器执行，后台有个编译线程，进行编译工作。<br>编译有三阶段：<br>一阶段：将字节码转为高级中间码，与目标机器指令集无关，这部分完成基础优化 如方法内联，常量传播等，特别是方法内联，是后续很多优化的基础。<br>二阶段：转为低级中间码，与目标指令集相关，这部分会完成空值检查消除，范围检查消除等<br>三阶段：寄存器分配，机器码生成。</p>
<p>提前编译器：<br>即时编译是在程序运行时将字节码编译成本地码，会占用用户程序的时间，提前编译是提前就将字节码编译成本地机器码。<br>优点就是不需要在运行时再去编译了。<br>但是缺点也很明显，缺少了运行时的性能数据采集支持，编译出来的代码优化程度不高，而且提前编译，会极大的延长启动时间。<br>提前编译也通常要求程序不能在外部动态加载新的字节码。</p>
<p>提前编译器有两种：<br>1.和c/c++一样，在程序运行之前就把程序代码翻译成机器码。<br>2.将原本即时编译器在运行时要做的编译工作提前做好并保存起来，下次运行到这部分代码，则可以直接使用，也叫编译缓存。</p>
<p>第一种，解决即时编译器要占用程序运行时间和运算资源。缺点就是增大了启动时间，在启动程序阶段就要将全部字节码编译成本地机器码。<br>第二种，本质上是给即时编译器做缓存，也叫动态提前编译或者即时编译缓存，这种提前编译的代码因为不能采用激进优化，性能要低于即时编译。</p>
<p>即时编译的优点：<br>1.性能分析<br>在运行过程中可以获取到信息，比如说某个抽象类通常是什么类型，条件判断通知会走哪个分支，方法调用使用哪个版本 等等<br>这些数据在静态分析是无法得到，但是在运行时就可以发现它们有非常明显的偏好性，那么就可以针对性的激进优化。</p>
<p>2.激进优化<br>即时编译的时候提供的性能信息 ，可以支持一些正确性很大但是无法保证绝对正确的优化，如果失败了就采用解释器兜底。<br>但是提前编译无法使用这种优化，必须保证百分百正确。<br>比如说在java中，大部分方法都是虚方法，只有静态方法 私有方法 构造方法不是虚方法， 如果java虚拟机遇到虚方法就去查方法表的话，就会很慢了。通常会通过类继承关系来做去虚拟化，这样可以保证虚方法也可以内联，进而可以优化。</p>
<p>3.链接时优化<br>在提前编译，静态编译是将不同的类库进行分别编译 优化。<br>但是在即时编译器中，所有的类都已经加载到了内存里面，可以关联优化，比如说调用某个库的方法，也可以进行方法内联等。</p>
<p>版权声明：本文为CSDN博主「公众号:程序员与王子喵 欢迎关注」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_20009015/article/details/105190415">https://blog.csdn.net/qq_20009015/article/details/105190415</a></p>
]]></content>
      <categories>
        <category>jvm</category>
        <category>jvm理论</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm基础3之性能监控与调优篇</title>
    <url>/6197d47a.html</url>
    <content><![CDATA[<h1 id="jvm基础3"><a href="#jvm基础3" class="headerlink" title="jvm基础3"></a>jvm基础3</h1><span id="more"></span>

<h1 id="1-概述篇"><a href="#1-概述篇" class="headerlink" title="1. 概述篇"></a>1. 概述篇</h1><h2 id="1-1-大厂面试题"><a href="#1-1-大厂面试题" class="headerlink" title="1.1. 大厂面试题"></a>1.1. 大厂面试题</h2><blockquote>
<p>支付宝：</p>
<p>支付宝三面：JVM 性能调优都做了什么？</p>
<p>小米：</p>
<p>有做过 JVM 内存优化吗？</p>
<p>从 SQL、JVM、架构、数据库四个方面讲讲优化思路</p>
<p>蚂蚁金服：</p>
<p>JVM 的编译优化</p>
<p>jvm 性能调优都做了什么</p>
<p>JVM 诊断调优工具用过哪些？</p>
<p>二面：jvm 怎样调优，堆内存、栈空间设置多少合适</p>
<p>三面：JVM 相关的分析工具使用过的有哪些？具体的性能调优步骤如何</p>
<p>阿里：</p>
<p>如何进行 JVM 调优？有哪些方法？</p>
<p>如何理解内存泄漏问题？有哪些情况会导致内存泄漏？如何解决？</p>
<p>字节跳动：</p>
<p>三面：JVM 如何调优、参数怎么调？</p>
<p>拼多多：</p>
<p>从 SQL、JVM、架构、数据库四个方面讲讲优化思路</p>
<p>京东：</p>
<p>JVM 诊断调优工具用过哪些？</p>
<p>每秒几十万并发的秒杀系统为什么会频繁发生 GC？</p>
<p>日均百万级交易系统如何优化 JVM？</p>
<p>线上生产系统 OOM 如何监控及定位与解决？</p>
<p>高并发系统如何基于 G1 垃圾回收器优化性能？</p>
</blockquote>
<h2 id="1-2-背景说明"><a href="#1-2-背景说明" class="headerlink" title="1.2. 背景说明"></a>1.2. 背景说明</h2><p><strong>生产环境中的问题</strong></p>
<ul>
<li>生产环境发生了内存溢出该如何处理？</li>
<li>生产环境应该给服务器分配多少内存合适？</li>
<li>如何对垃圾回收器的性能进行调优？</li>
<li>生产环境 CPU 负载飙高该如何处理？</li>
<li>生产环境应该给应用分配多少线程合适？</li>
<li>不加 log，如何确定请求是否执行了某一行代码？</li>
<li>不加 log，如何实时查看某个方法的入参与返回值？</li>
</ul>
<p><strong>为什么要调优</strong></p>
<ul>
<li>防止出现 OOM</li>
<li>解决 OOM</li>
<li>减少 Full GC 出现的频率</li>
</ul>
<p><strong>不同阶段的考虑</strong></p>
<ul>
<li>上线前</li>
<li>项目运行阶段</li>
<li>线上出现 OOM</li>
</ul>
<h2 id="1-3-调优概述"><a href="#1-3-调优概述" class="headerlink" title="1.3. 调优概述"></a>1.3. 调优概述</h2><p><strong>监控的依据</strong></p>
<ul>
<li>运行日志</li>
<li>异常堆栈</li>
<li>GC 日志</li>
<li>线程快照</li>
<li>堆转储快照</li>
</ul>
<p><strong>调优的大方向</strong></p>
<ul>
<li>合理地编写代码</li>
<li>充分并合理的使用硬件资源</li>
<li>合理地进行 JVM 调优</li>
</ul>
<h2 id="1-4-性能优化的步骤"><a href="#1-4-性能优化的步骤" class="headerlink" title="1.4. 性能优化的步骤"></a>1.4. 性能优化的步骤</h2><p><strong>第 1 步：性能监控</strong></p>
<ul>
<li>GC 频繁</li>
<li>cpu load 过高</li>
<li>OOM</li>
<li>内存泄露</li>
<li>死锁</li>
<li>程序响应时间较长</li>
</ul>
<p><strong>第 2 步：性能分析</strong></p>
<ul>
<li>打印 GC 日志，通过 GCviewer 或者 <a href="http://gceasy.io/">http://gceasy.io</a> 来分析异常信息</li>
<li>灵活运用命令行工具、jstack、jmap、jinfo 等</li>
<li>dump 出堆文件，使用内存分析工具分析文件</li>
<li>使用阿里 Arthas、jconsole、JVisualVM 来实时查看 JVM 状态</li>
<li>jstack 查看堆栈信息</li>
</ul>
<p><strong>第 3 步：性能调优</strong></p>
<ul>
<li>适当增加内存，根据业务背景选择垃圾回收器</li>
<li>优化代码，控制内存使用</li>
<li>增加机器，分散节点压力</li>
<li>合理设置线程池线程数量</li>
<li>使用中间件提高程序效率，比如缓存、消息队列等</li>
<li>其他……</li>
</ul>
<h2 id="1-5-性能评价-测试指标"><a href="#1-5-性能评价-测试指标" class="headerlink" title="1.5. 性能评价/测试指标"></a>1.5. 性能评价/测试指标</h2><p><strong>停顿时间（或响应时间）</strong></p>
<p>提交请求和返回该请求的响应之间使用的时间，一般比较关注平均响应时间。常用操作的响应时间列表：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>响应时间</th>
</tr>
</thead>
<tbody><tr>
<td>打开一个站点</td>
<td>几秒</td>
</tr>
<tr>
<td>数据库查询一条记录（有索引）</td>
<td>十几毫秒</td>
</tr>
<tr>
<td>机械磁盘一次寻址定位</td>
<td>4 毫秒</td>
</tr>
<tr>
<td>从机械磁盘顺序读取 1M 数据</td>
<td>2 毫秒</td>
</tr>
<tr>
<td>从 SSD 磁盘顺序读取 1M 数据</td>
<td>0.3 毫秒</td>
</tr>
<tr>
<td>从远程分布式换成 Redis 读取一个数据</td>
<td>0.5 毫秒</td>
</tr>
<tr>
<td>从内存读取 1M 数据</td>
<td>十几微妙</td>
</tr>
<tr>
<td>Java 程序本地方法调用</td>
<td>几微妙</td>
</tr>
<tr>
<td>网络传输 2Kb 数据</td>
<td>1 微妙</td>
</tr>
</tbody></table>
<p>在垃圾回收环节中：</p>
<ul>
<li>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</li>
<li>-XX:MaxGCPauseMillis</li>
</ul>
<p><strong>吞吐量</strong></p>
<ul>
<li>对单位时间内完成的工作量（请求）的量度</li>
<li>在 GC 中：运行用户代码的事件占总运行时间的比例（总运行时间：程序的运行时间+内存回收的时间）</li>
<li>吞吐量为 1-1/(1+n)，其中-XX::GCTimeRatio=n</li>
</ul>
<p><strong>并发数</strong></p>
<ul>
<li>同一时刻，对服务器有实际交互的请求数</li>
</ul>
<p><strong>内存占用</strong></p>
<ul>
<li>Java 堆区所占的内存大小</li>
</ul>
<p><strong>相互间的关系</strong></p>
<p>以高速公路通行状况为例</p>
<ul>
<li>吞吐量：每天通过高速公路收费站的车辆的数据</li>
<li>并发数：高速公路上正在行驶的车辆的数目</li>
<li>响应时间：车速</li>
</ul>
<h1 id="2-JVM-监控及诊断工具-命令行篇"><a href="#2-JVM-监控及诊断工具-命令行篇" class="headerlink" title="2. JVM 监控及诊断工具-命令行篇"></a>2. JVM 监控及诊断工具-命令行篇</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1. 概述"></a>2.1. 概述</h2><p>性能诊断是软件工程师在日常工作中需要经常面对和解决的问题，在用户体验至上的今天，解决好应用的性能问题能带来非常大的收益。</p>
<p>Java 作为最流行的编程语言之一，其应用性能诊断一直受到业界广泛关注。可能造成 Java 应用出现性能问题的因素非常多，例如线程控制、磁盘读写、数据库访问、网络 I/O、垃圾收集等。想要定位这些问题，一款优秀的性能诊断工具必不可少。</p>
<p>体会 1：使用数据说明问题，使用知识分析问题，使用工具处理问题。</p>
<p>体会 2：无监控、不调优！</p>
<p><strong>简单命令行工具</strong></p>
<p>在我们刚接触 java 学习的时候，大家肯定最先了解的两个命令就是 javac，java，那么除此之外，还有没有其他的命令可以供我们使用呢？</p>
<p>我们进入到安装 jdk 的 bin 目录，发现还有一系列辅助工具。这些辅助工具用来获取目标 JVM 不同方面、不同层次的信息，帮助开发人员很好地解决 Java 应用程序的一些疑难杂症。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5b7c5d239e4da192ba65edb0800055c5.png" alt="image-20210504195803526"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fa3c5e41cbf999d261bcf32851731565.png" alt="image-20210504195836342"></p>
<p>官方源码地址：<a href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools">http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools</a></p>
<h2 id="2-2-jps：查看正在运行的-Java-进程"><a href="#2-2-jps：查看正在运行的-Java-进程" class="headerlink" title="2.2. jps：查看正在运行的 Java 进程"></a>2.2. jps：查看正在运行的 Java 进程</h2><p>jps(Java Process Status)：显示指定系统内所有的 HotSpot 虚拟机进程（查看虚拟机进程信息），可用于查询正在运行的虚拟机进程。</p>
<p>说明：对于本地虚拟机进程来说，进程的本地虚拟机 ID 与操作系统的进程 ID 是一致的，是唯一的。</p>
<p>基本使用语法为：jps [options] [hostid]</p>
<p>我们还可以通过追加参数，来打印额外的信息。</p>
<p><strong>options 参数</strong></p>
<ul>
<li>-q：仅仅显示 LVMID（local virtual machine id），即本地虚拟机唯一 id。不显示主类的名称等</li>
<li>-l：输出应用程序主类的全类名 或 如果进程执行的是 jar 包，则输出 jar 完整路径</li>
<li>-m：输出虚拟机进程启动时传递给主类 main()的参数</li>
<li>-v：列出虚拟机进程启动时的 JVM 参数。比如：-Xms20m -Xmx50m 是启动程序指定的 jvm 参数。</li>
</ul>
<p>说明：以上参数可以综合使用。</p>
<p>补充：如果某 Java 进程关闭了默认开启的 UsePerfData 参数（即使用参数-XX：-UsePerfData），那么 jps 命令（以及下面介绍的 jstat）将无法探知该 Java 进程。</p>
<p><strong>hostid 参数</strong></p>
<p>RMI 注册表中注册的主机名。如果想要远程监控主机上的 java 程序，需要安装 jstatd。</p>
<p>对于具有更严格的安全实践的网络场所而言，可能使用一个自定义的策略文件来显示对特定的可信主机或网络的访问，尽管这种技术容易受到 IP 地址欺诈攻击。</p>
<p>如果安全问题无法使用一个定制的策略文件来处理，那么最安全的操作是不运行 jstatd 服务器，而是在本地使用 jstat 和 jps 工具。</p>
<h2 id="2-3-jstat：查看-JVM-统计信息"><a href="#2-3-jstat：查看-JVM-统计信息" class="headerlink" title="2.3. jstat：查看 JVM 统计信息"></a>2.3. jstat：查看 JVM 统计信息</h2><p>jstat（JVM Statistics Monitoring Tool）：用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT 编译等运行数据。在没有 GUI 图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。常用于检测垃圾回收问题以及内存泄漏问题。</p>
<p>官方文档：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html</a></p>
<p>基本使用语法为：jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]</p>
<p>查看命令相关参数：jstat-h 或 jstat-help</p>
<p>其中 vmid 是进程 id 号，也就是 jps 之后看到的前面的号码，如下：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/83dddc874824b88d7fd03dab2b3889f1.png" alt="image-20210504201703222"></p>
<p><strong>option 参数</strong></p>
<p>选项 option 可以由以下值构成。</p>
<p>类装载相关的：</p>
<ul>
<li>-class：显示 ClassLoader 的相关信息：类的装载、卸载数量、总空间、类装载所消耗的时间等</li>
</ul>
<p>垃圾回收相关的：</p>
<ul>
<li>-gc：显示与 GC 相关的堆信息。包括 Eden 区、两个 Survivor 区、老年代、永久代等的容量、已用空间、GC 时间合计等信息。</li>
<li>-gccapacity：显示内容与-gc 基本相同，但输出主要关注 Java 堆各个区域使用到的最大、最小空间。</li>
<li>-gcutil：显示内容与-gc 基本相同，但输出主要关注已使用空间占总空间的百分比。</li>
<li>-gccause：与-gcutil 功能一样，但是会额外输出导致最后一次或当前正在发生的 GC 产生的原因。</li>
<li>-gcnew：显示新生代 GC 状况</li>
<li>-gcnewcapacity：显示内容与-gcnew 基本相同，输出主要关注使用到的最大、最小空间</li>
<li>-geold：显示老年代 GC 状况</li>
<li>-gcoldcapacity：显示内容与-gcold 基本相同，输出主要关注使用到的最大、最小空间</li>
<li>-gcpermcapacity：显示永久代使用到的最大、最小空间。</li>
</ul>
<p>JIT 相关的：</p>
<ul>
<li>-compiler：显示 JIT 编译器编译过的方法、耗时等信息</li>
<li>-printcompilation：输出已经被 JIT 编译的方法</li>
</ul>
<p><strong>jstat -class</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9f2cea8b0a9b1bc47c10281b5c140cc4.png" alt="img"></p>
<p><strong>jstat -compiler</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4e11a07ce9b8ff2f73ba5585e11e1da3.png" alt="img"></p>
<p><strong>jstat -printcompilation</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2a2553eef35293d28ef095feee3bb3b7.png" alt="img"></p>
<p><strong>jstat -gc</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6ea2aa6665c49b4bd35d46152dd2f1aa.png" alt="img"></p>
<p><strong>jstat -gccapacity</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/be1dbc9fb1100c4ab76fdf802171c000.png" alt="img"></p>
<p><strong>jstat -gcutil</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/527f347102e0f48036f4e643103a735f.png" alt="img"></p>
<p><strong>jstat -gccause</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2e5d220a3ceb094b3d6aee8b46867942.png" alt="img"></p>
<p><strong>jstat -gcnew</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/766a9d8c98c1add9ff60f001fcbe552b.png" alt="img"></p>
<p><strong>jstat -gcnewcapacity</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d26356900de541c149df9c00852245a1.png" alt="img"></p>
<p><strong>jstat -gcold</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/64f18adec84996fec58edf7052440610.png" alt="img"></p>
<p><strong>jstat -gcoldcapacity</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/52bf3b50ba4a48247742caa0aa30be7e.png" alt="img"></p>
<p><strong>jstat -t</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/61a5c6b9c421ba9ec38db1f132ef4161.png" alt="img"></p>
<p><strong>jstat -t -h</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/73a294c043f770940daa6a501c1e8d2c.png" alt="img"></p>
<table>
<thead>
<tr>
<th>表头</th>
<th>含义（字节）</th>
</tr>
</thead>
<tbody><tr>
<td>EC</td>
<td>Eden 区的大小</td>
</tr>
<tr>
<td>EU</td>
<td>Eden 区已使用的大小</td>
</tr>
<tr>
<td>S0C</td>
<td>幸存者 0 区的大小</td>
</tr>
<tr>
<td>S1C</td>
<td>幸存者 1 区的大小</td>
</tr>
<tr>
<td>S0U</td>
<td>幸存者 0 区已使用的大小</td>
</tr>
<tr>
<td>S1U</td>
<td>幸存者 1 区已使用的大小</td>
</tr>
<tr>
<td>MC</td>
<td>元空间的大小</td>
</tr>
<tr>
<td>MU</td>
<td>元空间已使用的大小</td>
</tr>
<tr>
<td>OC</td>
<td>老年代的大小</td>
</tr>
<tr>
<td>OU</td>
<td>老年代已使用的大小</td>
</tr>
<tr>
<td>CCSC</td>
<td>压缩类空间的大小</td>
</tr>
<tr>
<td>CCSU</td>
<td>压缩类空间已使用的大小</td>
</tr>
<tr>
<td>YGC</td>
<td>从应用程序启动到采样时 young gc 的次数</td>
</tr>
<tr>
<td>YGCT</td>
<td>从应用程序启动到采样时 young gc 消耗时间（秒）</td>
</tr>
<tr>
<td>FGC</td>
<td>从应用程序启动到采样时 full gc 的次数</td>
</tr>
<tr>
<td>FGCT</td>
<td>从应用程序启动到采样时的 full gc 的消耗时间（秒）</td>
</tr>
<tr>
<td>GCT</td>
<td>从应用程序启动到采样时 gc 的总时间</td>
</tr>
</tbody></table>
<p><strong>interval 参数：</strong> 用于指定输出统计数据的周期，单位为毫秒。即：查询间隔</p>
<p><strong>count 参数：</strong> 用于指定查询的总次数</p>
<p><strong>-t 参数：</strong> 可以在输出信息前加上一个 Timestamp 列，显示程序的运行时间。单位：秒</p>
<p><strong>-h 参数：</strong> 可以在周期性数据输出时，输出多少行数据后输出一个表头信息</p>
<p><strong>补充：</strong> jstat 还可以用来判断是否出现内存泄漏。</p>
<p>第 1 步：在长时间运行的 Java 程序中，我们可以运行 jstat 命令连续获取多行性能数据，并取这几行数据中 OU 列（即已占用的老年代内存）的最小值。</p>
<p>第 2 步：然后，我们每隔一段较长的时间重复一次上述操作，来获得多组 OU 最小值。如果这些值呈上涨趋势，则说明该 Java 程序的老年代内存已使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏。</p>
<h2 id="2-4-jinfo：实时查看和修改-JVM-配置参数"><a href="#2-4-jinfo：实时查看和修改-JVM-配置参数" class="headerlink" title="2.4. jinfo：实时查看和修改 JVM 配置参数"></a>2.4. jinfo：实时查看和修改 JVM 配置参数</h2><p>jinfo(Configuration Info for Java)：查看虚拟机配置参数信息，也可用于调整虚拟机的配置参数。在很多情况卡，Java 应用程序不会指定所有的 Java 虚拟机参数。而此时，开发人员可能不知道某一个具体的 Java 虚拟机参数的默认值。在这种情况下，可能需要通过查找文档获取某个参数的默认值。这个查找过程可能是非常艰难的。但有了 jinfo 工具，开发人员可以很方便地找到 Java 虚拟机参数的当前值。</p>
<p>基本使用语法为：jinfo [options] pid</p>
<p>说明：java 进程 ID 必须要加上</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>选项说明</th>
</tr>
</thead>
<tbody><tr>
<td>no option</td>
<td>输出全部的参数和系统属性</td>
</tr>
<tr>
<td>-flag name</td>
<td>输出对应名称的参数</td>
</tr>
<tr>
<td>-flag [+-]name</td>
<td>开启或者关闭对应名称的参数 只有被标记为 manageable 的参数才可以被动态修改</td>
</tr>
<tr>
<td>-flag name=value</td>
<td>设定对应名称的参数</td>
</tr>
<tr>
<td>-flags</td>
<td>输出全部的参数</td>
</tr>
<tr>
<td>-sysprops</td>
<td>输出系统属性</td>
</tr>
</tbody></table>
<p><strong>jinfo -sysprops</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; jinfo -sysprops</span><br><span class="line">jboss.modules.system.pkgs = com.intellij.rt</span><br><span class="line">java.vendor = Oracle Corporation</span><br><span class="line">sun.java.launcher = SUN_STANDARD</span><br><span class="line">sun.management.compiler = HotSpot 64-Bit Tiered Compilers</span><br><span class="line">catalina.useNaming = true</span><br><span class="line">os.name = Windows 10</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>jinfo -flags</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; jinfo -flags 25592</span><br><span class="line">Non-default VM flags: -XX:CICompilerCount=4 -XX:InitialHeapSize=333447168 -XX:MaxHeapSize=5324668928 -XX:MaxNewSize=1774714880 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=111149056 -XX:OldSize=222298112 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br><span class="line">Command line:  -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:8040,suspend=y,server=n -Drebel.base=C:\Users\Vector\.jrebel -Drebel.env.ide.plugin.version=2021.1.2 -Drebel.env.ide.version=2020.3.3 -Drebel.env.ide.product=IU -Drebel.env.ide=intellij -Drebel.notification.url=http://localhost:7976 -agentpath:C:\Users\Vector\AppData\Roaming\JetBrains\IntelliJIdea2020.3\plugins\jr-ide-idea\lib\jrebel6\lib\jrebel64.dll -Dmaven.home=D:\eclipse\env\maven -Didea.modules.paths.file=C:\Users\Vector\AppData\Local\JetBrains\IntelliJIdea2020.3\Maven\idea-projects-state-596682c7.properties -Dclassworlds.conf=C:\Users\Vector\AppData\Local\Temp\idea-6755-mvn.conf -Dmaven.ext.class.path=D:\IDEA\plugins\maven\lib\maven-event-listener.jar -javaagent:D:\IDEA\plugins\java\lib\rt\debugger-agent.jar -Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure>

<p><strong>jinfo -flag</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; jinfo -flag UseParallelGC 25592</span><br><span class="line">-XX:+UseParallelGC</span><br><span class="line"></span><br><span class="line">&gt; jinfo -flag UseG1GC 25592</span><br><span class="line">-XX:-UseG1GC</span><br></pre></td></tr></table></figure>

<p><strong>jinfo -flag name</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; jinfo -flag UseParallelGC 25592</span><br><span class="line">-XX:+UseParallelGC</span><br><span class="line"></span><br><span class="line">&gt; jinfo -flag UseG1GC 25592</span><br><span class="line">-XX:-UseG1GC</span><br></pre></td></tr></table></figure>

<p><strong>jinfo -flag [+-]name</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; jinfo -flag +PrintGCDetails 25592</span><br><span class="line">&gt; jinfo -flag PrintGCDetails 25592</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line"></span><br><span class="line">&gt; jinfo -flag -PrintGCDetails 25592</span><br><span class="line">&gt; jinfo -flag PrintGCDetails 25592</span><br><span class="line">-XX:-PrintGCDetails</span><br></pre></td></tr></table></figure>

<p>拓展：</p>
<ul>
<li><p>java -XX:+PrintFlagsInitial 查看所有 JVM 参数启动的初始值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Global flags]</span><br><span class="line">     intx ActiveProcessorCount                      = -1                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizeDecrementScaleFactor          = 4                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizeMajorGCDecayTimeScale         = 10                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePausePolicy                   = 0                                   &#123;product&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><p>java -XX:+PrintFlagsFinal 查看所有 JVM 参数的最终值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Global flags]</span><br><span class="line">     intx ActiveProcessorCount                      = -1                                  &#123;product&#125;</span><br><span class="line">...</span><br><span class="line">     intx CICompilerCount                          := 4                                   &#123;product&#125;</span><br><span class="line">    uintx InitialHeapSize                          := 333447168                           &#123;product&#125;</span><br><span class="line">    uintx MaxHeapSize                              := 1029701632                          &#123;product&#125;</span><br><span class="line">    uintx MaxNewSize                               := 1774714880                          &#123;product&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>java -XX:+PrintCommandLineFlags 查看哪些已经被用户或者 JVM 设置过的详细的 XX 参数的名称和值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:InitialHeapSize=332790016 -XX:MaxHeapSize=5324640256 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-5-jmap：导出内存映像文件-amp-内存使用情况"><a href="#2-5-jmap：导出内存映像文件-amp-内存使用情况" class="headerlink" title="2.5. jmap：导出内存映像文件&amp;内存使用情况"></a>2.5. jmap：导出内存映像文件&amp;内存使用情况</h2><p>jmap（JVM Memory Map）：作用一方面是获取 dump 文件（堆转储快照文件，二进制文件），它还可以获取目标 Java 进程的内存相关信息，包括 Java 堆各区域的使用情况、堆中对象的统计信息、类加载信息等。开发人员可以在控制台中输入命令“jmap -help”查阅 jmap 工具的具体使用方式和一些标准选项配置。</p>
<p>官方帮助文档：<a href="https://docs.oracle.com/en/java/javase/11/tools/jmap.html">https://docs.oracle.com/en/java/javase/11/tools/jmap.html</a></p>
<p>基本使用语法为：</p>
<ul>
<li>jmap [option] <pid></li>
<li>jmap [option] &lt;executable <core></li>
<li>jmap [option] [server_id@] <remote server IP or hostname></li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-dump</td>
<td>生成 dump 文件（Java 堆转储快照），-dump:live 只保存堆中的存活对象</td>
</tr>
<tr>
<td>-heap</td>
<td>输出整个堆空间的详细信息，包括 GC 的使用、堆配置信息，以及内存的使用信息等</td>
</tr>
<tr>
<td>-histo</td>
<td>输出堆空间中对象的统计信息，包括类、实例数量和合计容量，-histo:live 只统计堆中的存活对象</td>
</tr>
<tr>
<td>-J <flag></td>
<td>传递参数给 jmap 启动的 jvm</td>
</tr>
<tr>
<td>-finalizerinfo</td>
<td>显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象，仅 linux/solaris 平台有效</td>
</tr>
<tr>
<td>-permstat</td>
<td>以 ClassLoader 为统计口径输出永久代的内存状态信息，仅 linux/solaris 平台有效</td>
</tr>
<tr>
<td>-F</td>
<td>当虚拟机进程对-dump 选项没有任何响应时，强制执行生成 dump 文件，仅 linux/solaris 平台有效</td>
</tr>
</tbody></table>
<p>说明：这些参数和 linux 下输入显示的命令多少会有不同，包括也受 jdk 版本的影响。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; jmap -dump:format=b,file=&lt;filename.hprof&gt; &lt;pid&gt;&gt; jmap -dump:live,format=b,file=&lt;filename.hprof&gt; &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<p>由于 jmap 将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，jmap 需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。也就是说，由 jmap 导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。</p>
<p>举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么:live 选项将无法探知到这些对象。</p>
<p>另外，如果某个线程长时间无法跑到安全点，jmap 将一直等下去。与前面讲的 jstat 则不同，垃圾回收器会主动将 jstat 所需要的摘要数据保存至固定位置之中，而 jstat 只需直接读取即可。</p>
<h2 id="2-6-jhat：JDK-自带堆分析工具"><a href="#2-6-jhat：JDK-自带堆分析工具" class="headerlink" title="2.6. jhat：JDK 自带堆分析工具"></a>2.6. jhat：JDK 自带堆分析工具</h2><p>jhat(JVM Heap Analysis Tool)：Sun JDK 提供的 jhat 命令与 jmap 命令搭配使用，用于分析 jmap 生成的 heap dump 文件（堆转储快照）。jhat 内置了一个微型的 HTTP/HTML 服务器，生成 dump 文件的分析结果后，用户可以在浏览器中查看分析结果（分析虚拟机转储快照信息）。</p>
<p>使用了 jhat 命令，就启动了一个 http 服务，端口是 7000，即 <a href="http://localhost:7000/%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E5%88%86%E6%9E%90%E3%80%82">http://localhost:7000/，就可以在浏览器里分析。</a></p>
<p>说明：jhat 命令在 JDK9、JDK10 中已经被删除，官方建议用 VisualVM 代替。</p>
<p>基本适用语法：jhat <option> <dumpfile></p>
<table>
<thead>
<tr>
<th>option 参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-stack false ｜ true</td>
<td>关闭｜打开对象分配调用栈跟踪</td>
</tr>
<tr>
<td>-refs false ｜ true</td>
<td>关闭｜打开对象引用跟踪</td>
</tr>
<tr>
<td>-port port-number</td>
<td>设置 jhat HTTP Server 的端口号，默认 7000</td>
</tr>
<tr>
<td>-exclude exclude-file</td>
<td>执行对象查询时需要排除的数据成员</td>
</tr>
<tr>
<td>-baseline exclude-file</td>
<td>指定一个基准堆转储</td>
</tr>
<tr>
<td>-debug int</td>
<td>设置 debug 级别</td>
</tr>
<tr>
<td>-version</td>
<td>启动后显示版本信息就退出</td>
</tr>
<tr>
<td>-J <flag></td>
<td>传入启动参数，比如-J-Xmx512m</td>
</tr>
</tbody></table>
<h2 id="2-7-jstack：打印-JVM-中线程快照"><a href="#2-7-jstack：打印-JVM-中线程快照" class="headerlink" title="2.7. jstack：打印 JVM 中线程快照"></a>2.7. jstack：打印 JVM 中线程快照</h2><p>jstack（JVM Stack Trace）：用于生成虚拟机指定进程当前时刻的线程快照（虚拟机堆栈跟踪）。线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合。</p>
<p>生成线程快照的作用：可用于定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等问题。这些都是导致线程长时间停顿的常见原因。当线程出现停顿时，就可以用 jstack 显示各个线程调用的堆栈情况。</p>
<p>官方帮助文档：<a href="https://docs.oracle.com/en/java/javase/11/tools/jstack.html">https://docs.oracle.com/en/java/javase/11/tools/jstack.html</a></p>
<p>在 thread dump 中，要留意下面几种状态</p>
<ul>
<li>死锁，Deadlock（重点关注）</li>
<li>等待资源，Waiting on condition（重点关注）</li>
<li>等待获取监视器，Waiting on monitor entry（重点关注）</li>
<li>阻塞，Blocked（重点关注）</li>
<li>执行中，Runnable</li>
<li>暂停，Suspended</li>
<li>对象等待中，Object.wait() 或 TIMED＿WAITING</li>
<li>停止，Parked</li>
</ul>
<table>
<thead>
<tr>
<th>option 参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-F</td>
<td>当正常输出的请求不被响应时，强制输出线程堆栈</td>
</tr>
<tr>
<td>-l</td>
<td>除堆栈外，显示关于锁的附加信息</td>
</tr>
<tr>
<td>-m</td>
<td>如果调用本地方法的话，可以显示 C/C++的堆栈</td>
</tr>
</tbody></table>
<h2 id="2-8-jcmd：多功能命令行"><a href="#2-8-jcmd：多功能命令行" class="headerlink" title="2.8. jcmd：多功能命令行"></a>2.8. jcmd：多功能命令行</h2><p>在 JDK 1.7 以后，新增了一个命令行工具 jcmd。它是一个多功能的工具，可以用来实现前面除了 jstat 之外所有命令的功能。比如：用它来导出堆、内存使用、查看 Java 进程、导出线程信息、执行 GC、JVM 运行时间等。</p>
<p>官方帮助文档：<a href="https://docs.oracle.com/en/java/javase/11/tools/jcmd.html">https://docs.oracle.com/en/java/javase/11/tools/jcmd.html</a></p>
<p>jcmd 拥有 jmap 的大部分功能，并且在 Oracle 的官方网站上也推荐使用 jcmd 命令代 jmap 命令</p>
<p><strong>jcmd -l：</strong>列出所有的 JVM 进程</p>
<p><strong>jcmd 进程号 help：</strong>针对指定的进程，列出支持的所有具体命令</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f3507ac3e24d40625f6c3d54c25c743b.png" alt="image-20210504213044819"></p>
<p><strong>jcmd 进程号 具体命令：</strong>显示指定进程的指令命令的数据</p>
<ul>
<li>Thread.print 可以替换 jstack 指令</li>
<li>GC.class_histogram 可以替换 jmap 中的-histo 操作</li>
<li>GC.heap_dump 可以替换 jmap 中的-dump 操作</li>
<li>GC.run 可以查看 GC 的执行情况</li>
<li>VM.uptime 可以查看程序的总执行时间，可以替换 jstat 指令中的-t 操作</li>
<li>VM.system_properties 可以替换 jinfo -sysprops 进程 id</li>
<li>VM.flags 可以获取 JVM 的配置参数信息</li>
</ul>
<h2 id="2-9-jstatd：远程主机信息收集"><a href="#2-9-jstatd：远程主机信息收集" class="headerlink" title="2.9. jstatd：远程主机信息收集"></a>2.9. jstatd：远程主机信息收集</h2><p>之前的指令只涉及到监控本机的 Java 应用程序，而在这些工具中，一些监控工具也支持对远程计算机的监控（如 jps、jstat）。为了启用远程监控，则需要配合使用 jstatd 工具。命令 jstatd 是一个 RMI 服务端程序，它的作用相当于代理服务器，建立本地计算机与远程监控工具的通信。jstatd 服务器将本机的 Java 应用程序信息传递到远程计算机。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2225de448c4af005aa0f72e84bba5e57.png" alt="image-20210504213301077"></p>
<h1 id="3-JVM-监控及诊断工具-GUI-篇"><a href="#3-JVM-监控及诊断工具-GUI-篇" class="headerlink" title="3. JVM 监控及诊断工具-GUI 篇"></a>3. JVM 监控及诊断工具-GUI 篇</h1><h2 id="3-1-工具概述"><a href="#3-1-工具概述" class="headerlink" title="3.1. 工具概述"></a>3.1. 工具概述</h2><p>使用上一章命令行工具或组合能帮您获取目标 Java 应用性能相关的基础信息，但它们存在下列局限：</p>
<ul>
<li>1．无法获取方法级别的分析数据，如方法间的调用关系、各方法的调用次数和调用时间等（这对定位应用性能瓶颈至关重要）。</li>
<li>2．要求用户登录到目标 Java 应用所在的宿主机上，使用起来不是很方便。</li>
<li>3．分析数据通过终端输出，结果展示不够直观。</li>
</ul>
<p>为此，JDK 提供了一些内存泄漏的分析工具，如 jconsole，jvisualvm 等，用于辅助开发人员定位问题，但是这些工具很多时候并不足以满足快速定位的需求。所以这里我们介绍的工具相对多一些、丰富一些。</p>
<p><strong>JDK 自带的工具</strong></p>
<ul>
<li>jconsole：JDK 自带的可视化监控工具。查看 Java 应用程序的运行概况、监控堆信息、永久区（或元空间）使用情况、类加载情况等</li>
<li>Visual VM：Visual VM 是一个工具，它提供了一个可视界面，用于查看 Java 虚拟机上运行的基于 Java 技术的应用程序的详细信息。</li>
<li>JMC：Java Mission Control，内置 Java Flight Recorder。能够以极低的性能开销收集 Java 虚拟机的性能数据。</li>
</ul>
<p><strong>第三方工具</strong></p>
<ul>
<li>MAT：MAT（Memory Analyzer Tool）是基于 Eclipse 的内存分析工具，是一个快速、功能丰富的 Java heap 分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</li>
<li>JProfiler：商业软件，需要付费。功能强大。</li>
</ul>
<h2 id="3-2-JConsole"><a href="#3-2-JConsole" class="headerlink" title="3.2. JConsole"></a>3.2. JConsole</h2><p>jconsole：从 Java5 开始，在 JDK 中自带的 java 监控和管理控制台。用于对 JVM 中内存、线程和类等的监控，是一个基于 JMX（java management extensions）的 GUI 性能监控工具。</p>
<p>官方地址：<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html">https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2a3da9e0684da25f3603859309a31002.png" alt="image-20210505141631635"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/01d1c91e8a41137321af9334a383eeda.png" alt="image-20210505141726143"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fd74276fd1dd7e4542994d1da5768bff.png" alt="image-20210505141924211"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c590dbcfb21edbf73f9b7a4d4e342cb7.png" alt="image-20210505141950000"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0394d3dec7f075f88d1321565e4b0c40.png" alt="image-20210505142050157"></p>
<h2 id="3-3-Visual-VM"><a href="#3-3-Visual-VM" class="headerlink" title="3.3. Visual VM"></a>3.3. Visual VM</h2><p>Visual VM 是一个功能强大的多合一故障诊断和性能监控的可视化工具。它集成了多个 JDK 命令行工具，使用 Visual VM 可用于显示虚拟机进程及进程的配置和环境信息（jps，jinfo），监视应用程序的 CPU、GC、堆、方法区及线程的信息（jstat、jstack）等，甚至代替 JConsole。在 JDK 6 Update 7 以后，Visual VM 便作为 JDK 的一部分发布（VisualVM 在 JDK／bin 目录下）即：它完全免费。</p>
<p><strong>主要功能：</strong></p>
<ul>
<li>1.生成/读取堆内存/线程快照</li>
<li>2.查看 JVM 参数和系统属性</li>
<li>3.查看运行中的虚拟机进程</li>
<li>4.程序资源的实时监控</li>
<li>5.JMX 代理连接、远程环境监控、CPU 分析和内存分析</li>
</ul>
<p>官方地址：<a href="https://visualvm.github.io/index.html">https://visualvm.github.io/index.html</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5778843e25883aed6ee8591e7f57465a.png" alt="image-20210505143844282"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/750e766290dd3ce1c31bece436870f96.png" alt="image-20210505144716064"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/43a8b0745532825ab4a262a953aa5ffd.png" alt="image-20210505144805307"></p>
<h2 id="3-4-Eclipse-MAT"><a href="#3-4-Eclipse-MAT" class="headerlink" title="3.4. Eclipse MAT"></a>3.4. Eclipse MAT</h2><p>MAT（Memory Analyzer Tool）工具是一款功能强大的 Java 堆内存分析器。可以用于查找内存泄漏以及查看内存消耗情况。MAT 是基于 Eclipse 开发的，不仅可以单独使用，还可以作为插件的形式嵌入在 Eclipse 中使用。是一款免费的性能分析工具，使用起来非常方便。</p>
<p>MAT 可以分析 heap dump 文件。在进行内存分析时，只要获得了反映当前设备内存映像的 hprof 文件，通过 MAT 打开就可以直观地看到当前的内存信息。一般说来，这些内存信息包含：</p>
<ul>
<li>所有的对象信息，包括对象实例、成员变量、存储于栈中的基本类型值和存储于堆中的其他对象的引用值。</li>
<li>所有的类信息，包括 classloader、类名称、父类、静态变量等</li>
<li>GCRoot 到所有的这些对象的引用路径</li>
<li>线程信息，包括线程的调用栈及此线程的线程局部变量（TLS）</li>
</ul>
<p>MAT 不是一个万能工具，它并不能处理所有类型的堆存储文件。但是比较主流的厂家和格式，例如 Sun，HP，SAP 所采用的 HPROF 二进制堆存储文件，以及 IBM 的 PHD 堆存储文件等都能被很好的解析。</p>
<p>最吸引人的还是能够快速为开发人员生成内存泄漏报表，方便定位问题和分析问题。虽然 MAT 有如此强大的功能，但是内存分析也没有简单到一键完成的程度，很多内存问题还是需要我们从 MAT 展现给我们的信息当中通过经验和直觉来判断才能发现。</p>
<p>官方地址： <a href="https://www.eclipse.org/mat/downloads.php">https://www.eclipse.org/mat/downloads.php</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/23d0ea8c73c4e7fb57f47fba7ee39f3f.png" alt="image-20210505145708567"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e5dad78d08ba1aee3a9583c33d83c53f.png" alt="image-20210505145826442"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b25b5cb539c1d5622f4855dffb1fd21e.png" alt="image-20210505145945951"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0e41893c02f420e50d36c59acf3021b6.png" alt="image-20210505150039376"></p>
<h2 id="3-5-JProfiler"><a href="#3-5-JProfiler" class="headerlink" title="3.5. JProfiler"></a>3.5. JProfiler</h2><p>在运行 Java 的时候有时候想测试运行时占用内存情况，这时候就需要使用测试工具查看了。在 eclipse 里面有 Eclipse Memory Analyzer tool（MAT）插件可以测试，而在 IDEA 中也有这么一个插件，就是 JProfiler。JProfiler 是由 ej-technologies 公司开发的一款 Java 应用性能诊断工具。功能强大，但是收费。</p>
<p><strong>特点：</strong></p>
<ul>
<li>使用方便、界面操作友好（简单且强大）</li>
<li>对被分析的应用影响小（提供模板）</li>
<li>CPU，Thread，Memory 分析功能尤其强大</li>
<li>支持对 jdbc，noSql，jsp，servlet，socket 等进行分析</li>
<li>支持多种模式（离线，在线）的分析</li>
<li>支持监控本地、远程的 JVM</li>
<li>跨平台，拥有多种操作系统的安装版本</li>
</ul>
<p><strong>主要功能：</strong></p>
<ul>
<li>1-方法调用：对方法调用的分析可以帮助您了解应用程序正在做什么，并找到提高其性能的方法</li>
<li>2-内存分配：通过分析堆上对象、引用链和垃圾收集能帮您修复内存泄露问题，优化内存使用</li>
<li>3-线程和锁：JProfiler 提供多种针对线程和锁的分析视图助您发现多线程问题</li>
<li>4-高级子系统：许多性能问题都发生在更高的语义级别上。例如，对于 JDBC 调用，您可能希望找出执行最慢的 SQL 语句。JProfiler 支持对这些子系统进行集成分析</li>
</ul>
<p>官网地址：<a href="https://www.ej-technologies.com/products/jprofiler/overview.html">https://www.ej-technologies.com/products/jprofiler/overview.html</a></p>
<p><strong>数据采集方式：</strong></p>
<p>JProfier 数据采集方式分为两种：Sampling（样本采集）和 Instrumentation（重构模式）</p>
<p><strong>Instrumentation</strong>：这是 JProfiler 全功能模式。在 class 加载之前，JProfier 把相关功能代码写入到需要分析的 class 的 bytecode 中，对正在运行的 jvm 有一定影响。</p>
<ul>
<li>优点：功能强大。在此设置中，调用堆栈信息是准确的。</li>
<li>缺点：若要分析的 class 较多，则对应用的性能影响较大，CPU 开销可能很高（取决于 Filter 的控制）。因此使用此模式一般配合 Filter 使用，只对特定的类或包进行分析</li>
</ul>
<p><strong>Sampling</strong>：类似于样本统计，每隔一定时间（5ms）将每个线程栈中方法栈中的信息统计出来。</p>
<ul>
<li>优点：对 CPU 的开销非常低，对应用影响小（即使你不配置任何 Filter）</li>
<li>缺点：一些数据／特性不能提供（例如：方法的调用次数、执行时间）</li>
</ul>
<p>注：JProfiler 本身没有指出数据的采集类型，这里的采集类型是针对方法调用的采集类型。因为 JProfiler 的绝大多数核心功能都依赖方法调用采集的数据，所以可以直接认为是 JProfiler 的数据采集类型。</p>
<p><strong>遥感监测 Telemetries</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b385d959623a0684d1a40700f4bc1243.png" alt="image-20210505164521410"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/aa57ab4a3183801e003546c177ab64ee.png" alt="image-20210505164907312"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/75200c0d6aeaaade33422d40bd64beb3.png" alt="image-20210505164815324"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6342c78f10e0c8d96243ae69c280c742.png" alt="image-20210505164945192"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/eda04270592f6cf5cc53f6300f9f084a.png" alt="image-20210505165010529"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/944971c96b35f20aa4073a39ee8f678e.png" alt="image-20210505165128212"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/983f44592d93befafdb1818ea9fb7603.png" alt="image-20210505165249919"></p>
<p><strong>内存视图 Live Memory</strong></p>
<p>Live memory 内存剖析：class／class instance 的相关信息。例如对象的个数，大小，对象创建的方法执行栈，对象创建的热点。</p>
<ul>
<li><strong>所有对象 All Objects</strong>：显示所有加载的类的列表和在堆上分配的实例数。只有 Java 1.5（JVMTI）才会显示此视图。</li>
<li><strong>记录对象 Record Objects</strong>：查看特定时间段对象的分配，并记录分配的调用堆栈。</li>
<li><strong>分配访问树 Allocation Call Tree</strong>：显示一棵请求树或者方法、类、包或对已选择类有带注释的分配信息的 J2EE 组件。</li>
<li><strong>分配热点 Allocation Hot Spots</strong>：显示一个列表，包括方法、类、包或分配已选类的 J2EE 组件。你可以标注当前值并且显示差异值。对于每个热点都可以显示它的跟踪记录树。</li>
<li><strong>类追踪器 Class Tracker</strong>：类跟踪视图可以包含任意数量的图表，显示选定的类和包的实例与时间。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/49b08570bc68a4ccb1b76c610001160e.png" alt="image-20210505164554298"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/12e4a0779da98da28310602aa727fe77.png" alt="image-20210505165519790"></p>
<p><strong>堆遍历 heap walker</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ffb0632996afc5ab68554c918c6ba5c5.png" alt="image-20210505165710620"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9328465f8078d485d713866676fedddd.png" alt="image-20210505165823201"></p>
<p><strong>cpu 视图 cpu views</strong></p>
<p>JProfiler 提供不同的方法来记录访问树以优化性能和细节。线程或者线程组以及线程状况可以被所有的视图选择。所有的视图都可以聚集到方法、类、包或 J2EE 组件等不同层上。</p>
<ul>
<li><strong>访问树 Call Tree</strong>：显示一个积累的自顶向下的树，树中包含所有在 JVM 中已记录的访问队列。JDBC，JMS 和 JNDI 服务请求都被注释在请求树中。请求树可以根据 Servlet 和 JSP 对 URL 的不同需要进行拆分。</li>
<li><strong>热点 Hot Spots</strong>：显示消耗时间最多的方法的列表。对每个热点都能够显示回溯树。该热点可以按照方法请求，JDBC，JMS 和 JNDI 服务请求以及按照 URL 请求来进行计算。</li>
<li><strong>访问图 Call Graph</strong>：显示一个从已选方法、类、包或 J2EE 组件开始的访问队列的图。</li>
<li><strong>方法统计 Method Statistis</strong>：显示一段时间内记录的方法的调用时间细节。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2d40f4905776b879b96ea26323b5437e.png" alt="image-20210505170055722"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/054ba6962384453984936f4dc2fe5f64.png" alt="image-20210505170141278"></p>
<p><strong>线程视图 threads</strong></p>
<p>JProfiler 通过对线程历史的监控判断其运行状态，并监控是否有线程阻塞产生，还能将一个线程所管理的方法以树状形式呈现。对线程剖析。</p>
<ul>
<li><strong>线程历史 Thread History</strong>：显示一个与线程活动和线程状态在一起的活动时间表。</li>
<li><strong>线程监控 Thread Monitor</strong>：显示一个列表，包括所有的活动线程以及它们目前的活动状况。</li>
<li><strong>线程转储 Thread Dumps</strong>：显示所有线程的堆栈跟踪。</li>
</ul>
<p>线程分析主要关心三个方面：</p>
<ul>
<li>1．web 容器的线程最大数。比如：Tomcat 的线程容量应该略大于最大并发数。</li>
<li>2．线程阻塞</li>
<li>3．线程死锁</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/18074c3907f5b0b197cd88802897a758.png" alt="image-20210505170739972"></p>
<p><strong>监控和锁 Monitors ＆Locks</strong></p>
<p>所有线程持有锁的情况以及锁的信息。观察 JVM 的内部线程并查看状态：</p>
<ul>
<li><strong>死锁探测图表 Current Locking Graph</strong>：显示 JVM 中的当前死锁图表。</li>
<li><strong>目前使用的监测器 Current Monitors</strong>：显示目前使用的监测器并且包括它们的关联线程。</li>
<li><strong>锁定历史图表 Locking History Graph</strong>：显示记录在 JVM 中的锁定历史。</li>
<li><strong>历史检测记录 Monitor History</strong>：显示重大的等待事件和阻塞事件的历史记录。</li>
<li><strong>监控器使用统计 Monitor Usage Statistics</strong>：显示分组监测，线程和监测类的统计监测数据</li>
</ul>
<h2 id="3-6-Arthas"><a href="#3-6-Arthas" class="headerlink" title="3.6. Arthas"></a>3.6. Arthas</h2><p>上述工具都必须在服务端项目进程中配置相关的监控参数，然后工具通过远程连接到项目进程，获取相关的数据。这样就会带来一些不便，比如线上环境的网络是隔离的，本地的监控工具根本连不上线上环境。并且类似于 Jprofiler 这样的商业工具，是需要付费的。</p>
<p>那么有没有一款工具不需要远程连接，也不需要配置监控参数，同时也提供了丰富的性能监控数据呢？</p>
<p>阿里巴巴开源的性能分析神器 Arthas 应运而生。</p>
<p>Arthas 是 Alibaba 开源的 Java 诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪 Java 代码；实时监控 JVM 状态。Arthas 支持 JDK 6 ＋，支持 Linux／Mac／Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。当你遇到以下类似问题而束手无策时，Arthas 可以帮助你解决：</p>
<ul>
<li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li>
<li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li>
<li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li>
<li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li>
<li>是否有一个全局视角来查看系统的运行状况？</li>
<li>有什么办法可以监控到 JVM 的实时运行状态？</li>
<li>怎么快速定位应用的热点，生成火焰图？</li>
</ul>
<p>官方地址：<a href="https://arthas.aliyun.com/doc/quick-start.html">https://arthas.aliyun.com/doc/quick-start.html</a></p>
<p>安装方式：如果速度较慢，可以尝试国内的码云 Gitee 下载。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://io/arthas/arthas-boot.jar</span><br><span class="line">wget https://arthas/gitee/io/arthas-boot.jar</span><br></pre></td></tr></table></figure>

<p>Arthas 只是一个 java 程序，所以可以直接用 java -jar 运行。</p>
<p>除了在命令行查看外，Arthas 目前还支持 Web Console。在成功启动连接进程之后就已经自动启动,可以直接访问 <a href="http://127.0.0.1:8563/">http://127.0.0.1:8563/</a> 访问，页面上的操作模式和控制台完全一样。</p>
<p><strong>基础指令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">quit/exit 退出当前 Arthas客户端，其他 Arthas喜户端不受影响</span><br><span class="line">stop/shutdown 关闭 Arthas服务端，所有 Arthas客户端全部退出</span><br><span class="line">help 查看命令帮助信息</span><br><span class="line">cat 打印文件内容，和linux里的cat命令类似</span><br><span class="line">echo 打印参数，和linux里的echo命令类似</span><br><span class="line">grep 匹配查找，和linux里的gep命令类似</span><br><span class="line">tee 复制标隹输入到标准输出和指定的文件，和linux里的tee命令类似</span><br><span class="line">pwd 返回当前的工作目录，和linux命令类似</span><br><span class="line">cs 清空当前屏幕区域</span><br><span class="line">session 查看当前会话的信息</span><br><span class="line">reset 重置增强类，将被 Arthas增强过的类全部还原, Arthas服务端关闭时会重置所有增强过的类</span><br><span class="line">version 输出当前目标Java进程所加载的 Arthas版本号</span><br><span class="line">history 打印命令历史</span><br><span class="line">keymap Arthas快捷键列表及自定义快捷键</span><br></pre></td></tr></table></figure>

<p><strong>jvm 相关</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dashboard 当前系统的实时数据面板</span><br><span class="line">thread 查看当前JVM的线程堆栈信息</span><br><span class="line">jvm 查看当前JVM的信息</span><br><span class="line">sysprop 查看和修改JVM的系统属性</span><br><span class="line">sysem 查看JVM的环境变量</span><br><span class="line">vmoption 查看和修改JVM里诊断相关的option</span><br><span class="line">perfcounter 查看当前JVM的 Perf Counter信息</span><br><span class="line">logger 查看和修改logger</span><br><span class="line">getstatic 查看类的静态属性</span><br><span class="line">ognl 执行ognl表达式</span><br><span class="line">mbean 查看 Mbean的信息</span><br><span class="line">heapdump dump java heap，类似jmap命令的 heap dump功能</span><br></pre></td></tr></table></figure>

<p><strong>class/classloader 相关</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc 查看JVM已加载的类信息</span><br><span class="line">	-d 输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的Classloader等详细信息。如果一个类被多个Classloader所加载，则会出现多次</span><br><span class="line">	-E 开启正则表达式匹配，默认为通配符匹配</span><br><span class="line">	-f 输出当前类的成员变量信息（需要配合参数-d一起使用）</span><br><span class="line">	-X 指定输出静态变量时属性的遍历深度，默认为0，即直接使用toString输出</span><br><span class="line">sm 查看已加载类的方法信息</span><br><span class="line">	-d 展示每个方法的详细信息</span><br><span class="line">	-E 开启正则表达式匹配,默认为通配符匹配</span><br><span class="line">jad 反编译指定已加载类的源码</span><br><span class="line">mc 内存编译器，内存编译.java文件为.class文件</span><br><span class="line">retransform 加载外部的.class文件, retransform到JVM里</span><br><span class="line">redefine 加载外部的.class文件，redefine到JVM里</span><br><span class="line">dump dump已加载类的byte code到特定目录</span><br><span class="line">classloader 查看classloader的继承树，urts，类加载信息，使用classloader去getResource</span><br><span class="line">	-t 查看classloader的继承树</span><br><span class="line">	-l 按类加载实例查看统计信息</span><br><span class="line">	-c 用classloader对应的hashcode来查看对应的 Jar urls</span><br></pre></td></tr></table></figure>

<p><strong>monitor/watch/trace 相关</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monitor 方法执行监控，调用次数、执行时间、失败率</span><br><span class="line">	-c 统计周期，默认值为120秒</span><br><span class="line">watch 方法执行观测，能观察到的范围为：返回值、抛出异常、入参，通过编写groovy表达式进行对应变量的查看</span><br><span class="line">	-b 在方法调用之前观察(默认关闭)</span><br><span class="line">	-e 在方法异常之后观察(默认关闭)</span><br><span class="line">	-s 在方法返回之后观察(默认关闭)</span><br><span class="line">	-f 在方法结束之后(正常返回和异常返回)观察(默认开启)</span><br><span class="line">	-x 指定输岀结果的属性遍历深度,默认为0</span><br><span class="line">trace 方法内部调用路径,并输出方法路径上的每个节点上耗时</span><br><span class="line">	-n 执行次数限制</span><br><span class="line">stack 输出当前方法被调用的调用路径</span><br><span class="line">tt 方法执行数据的时空隧道,记录下指定方法每次调用的入参和返回信息,并能对这些不同的时间下调用进行观测</span><br></pre></td></tr></table></figure>

<p><strong>其他</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jobs 列出所有job</span><br><span class="line">kill 强制终止任务</span><br><span class="line">fg 将暂停的任务拉到前台执行</span><br><span class="line">bg 将暂停的任务放到后台执行</span><br><span class="line">grep 搜索满足条件的结果</span><br><span class="line">plaintext 将命令的结果去除ANSI颜色</span><br><span class="line">wc 按行统计输出结果</span><br><span class="line">options 查看或设置Arthas全局开关</span><br><span class="line">profiler 使用async-profiler对应用采样，生成火焰图</span><br></pre></td></tr></table></figure>

<h2 id="3-7-Java-Misssion-Control"><a href="#3-7-Java-Misssion-Control" class="headerlink" title="3.7. Java Misssion Control"></a>3.7. Java Misssion Control</h2><p>在 Oracle 收购 Sun 之前，Oracle 的 JRockit 虚拟机提供了一款叫做 JRockit Mission Control 的虚拟机诊断工具。</p>
<p>在 Oracle 收购 sun 之后，Oracle 公司同时拥有了 Hotspot 和 JRockit 两款虚拟机。根据 Oracle 对于 Java 的战略，在今后的发展中，会将 JRokit 的优秀特性移植到 Hotspot 上。其中一个重要的改进就是在 Sun 的 JDK 中加入了 JRockit 的支持。</p>
<p>在 Oracle JDK 7u40 之后，Mission Control 这款工具己经绑定在 Oracle JDK 中发布。</p>
<p>自 Java11 开始，本节介绍的 JFR 己经开源。但在之前的 Java 版本，JFR 属于 Commercial Feature 通过 Java 虚拟机参数-XX:+UnlockCommercialFeatures 开启。</p>
<p>Java Mission Control（简称 JMC) ， Java 官方提供的性能强劲的工具，是一个用于对 Java 应用程序进行管理、监视、概要分析和故障排除的工具套件。它包含一个 GUI 客户端以及众多用来收集 Java 虚拟机性能数据的插件如 JMX Console（能够访问用来存放虚拟机齐个于系统运行数据的 MXBeans）以及虚拟机内置的高效 profiling 工具 Java Flight Recorder（JFR）。</p>
<p>JMC 的另一个优点就是：采用取样，而不是传统的代码植入技术，对应用性能的影响非常非常小，完全可以开着 JMC 来做压测（唯一影响可能是 full gc 多了）。</p>
<p>官方地址：<a href="https://github.com/JDKMissionControl/jmc">https://github.com/JDKMissionControl/jmc</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/042f2d109ebcf51894f822706963e399.png" alt="image-20210505184358041"></p>
<p><strong>Java Flight Recorder</strong></p>
<p>Java Flight Recorder 是 JMC 的其中一个组件，能够以极低的性能开销收集 Java 虚拟机的性能数据。与其他工具相比，JFR 的性能开销很小，在默认配置下平均低于 1%。JFR 能够直接访问虚拟机内的敌据并且不会影响虚拟机的优化。因此它非常适用于生产环境下满负荷运行的 Java 程序。</p>
<p>Java Flight Recorder 和 JDK Mission Control 共同创建了一个完整的工具链。JDK Mission Control 可对 Java Flight Recorder 连续收集低水平和详细的运行时信息进行高效、详细的分析。</p>
<p>当启用时 JFR 将记录运行过程中发生的一系列事件。其中包括 Java 层面的事件如线程事件、锁事件，以及 Java 虚拟机内部的事件，如新建对象，垃圾回收和即时编译事件。按照发生时机以及持续时间来划分，JFR 的事件共有四种类型，它们分别为以下四种：</p>
<ul>
<li>瞬时事件（Instant Event) ，用户关心的是它们发生与否，例如异常、线程启动事件。</li>
<li>持续事件(Duration Event) ，用户关心的是它们的持续时间，例如垃圾回收事件。</li>
<li>计时事件(Timed Event) ，是时长超出指定阈值的持续事件。</li>
<li>取样事件（Sample Event)，是周期性取样的事件。</li>
</ul>
<p>取样事件的其中一个常见例子便是方法抽样（Method Sampling），即每隔一段时问统计各个线程的栈轨迹。如果在这些抽样取得的栈轨迹中存在一个反复出现的方法，那么我们可以推测该方法是热点方法</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d96c890e6187bcfa8d4a558be64354e6.png" alt="image-20210505185941373"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/dbaae7f62c614ef03aebb267b4249650.png" alt="image-20210505185954567"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a0bc985fd0274fc17c9dc2e8e205a8a2.png" alt="image-20210505190009274"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fe38780df6ccf1c3f3206baaa089ff1a.png" alt="image-20210505190023099"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0e8ab54b4fdc5cd2f4d7e1cda87dfe52.png" alt="image-20210505190037354"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ef07d257c25f15fe7d6bfdbe6ee0f087.png" alt="image-20210505190052561"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3f65159c21e0c6996588c90c7c5ca8e6.png" alt="image-20210505190106004"></p>
<h2 id="3-8-其他工具"><a href="#3-8-其他工具" class="headerlink" title="3.8. 其他工具"></a>3.8. 其他工具</h2><p><strong>Flame Graphs（火焰图）</strong></p>
<p>在追求极致性能的场景下，了解你的程序运行过程中 cpu 在干什么很重要，火焰图就是一种非常直观的展示 CPU 在程序整个生命周期过程中时间分配的工具。火焰图对于现代的程序员不应该陌生，这个工具可以非常直观的显示出调用找中的 CPU 消耗瓶颈。</p>
<p>网上的关于 Java 火焰图的讲解大部分来自于 Brenden Gregg 的博客 <a href="http://new.brendangregg.com/flamegraphs.html">http://new.brendangregg.com/flamegraphs.html</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c2692cea072a29b00b420933892ae9f9.png" alt="image-20210505190823214"></p>
<p>火焰图，简单通过 x 轴横条宽度来度量时间指标，y 轴代表线程栈的层次。</p>
<p><strong>Tprofiler</strong></p>
<p>案例： 使用 JDK 自身提供的工具进行 JVM 调优可以将下 TPS 由 2.5 提升到 20（提升了 7 倍），并准确 定位系统瓶颈。</p>
<p>系统瓶颈有：应用里释态对象不是太多、有大量的业务线程在频繁创建一些生命周期很长的临时对象，代码里有问题。</p>
<p>那么，如何在海量业务代码里边准确定位这些性能代码？这里使用阿里开源工具 Tprofiler 来定位 这些性能代码，成功解决掉了 GC 过于频繁的性能瓶预，并最终在上次优化的基础上将 TPS 再提升了 4 倍，即提升到 100。</p>
<ul>
<li>Tprofiler 配置部署、远程操作、 日志阅谈都不太复杂，操作还是很简单的。但是其却是能够 起到一针见血、立竿见影的效果，帮我们解决了 GC 过于频繁的性能瓶预。</li>
<li>Tprofiler 最重要的特性就是能够统汁出你指定时间段内 JVM 的 top method 这些 top method 极有可能就是造成你 JVM 性能瓶颈的元凶。这是其他大多数 JVM 调优工具所不具备的，包括 JRockit Mission Control。JRokit 首席开发者 Marcus Hirt 在其私人博客《 Lom Overhead Method Profiling cith Java Mission Control》下的评论中曾明确指出 JRMC 井不支持 TOP 方法的统计。</li>
</ul>
<p>官方地址：<a href="http://github.com/alibaba/Tprofiler">http://github.com/alibaba/Tprofiler</a></p>
<p><strong>Btrace</strong></p>
<p>常见的动态追踪工具有 BTrace、HouseHD（该项目己经停止开发）、Greys-Anatomy（国人开发 个人开发者）、Byteman（JBoss 出品），注意 Java 运行时追踪工具井不限干这几种，但是这几个是相对比较常用的。</p>
<p>BTrace 是 SUN Kenai 云计算开发平台下的一个开源项目，旨在为 java 提供安全可靠的动态跟踪分析工具。先看一卜日 Trace 的官方定义：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8df058bdfb18387a90cd5dd87a2a2f04.png" alt="image-20210505192042974"></p>
<p>大概意思是一个 Java 平台的安全的动态追踪工具，可以用来动态地追踪一个运行的 Java 程序。BTrace 动态调整目标应用程序的类以注入跟踪代码（“字节码跟踪“）。</p>
<p><strong>YourKit</strong></p>
<p><strong>JProbe</strong></p>
<p><strong>Spring Insight</strong></p>
<h1 id="4-JVM-运行时参数"><a href="#4-JVM-运行时参数" class="headerlink" title="4. JVM 运行时参数"></a>4. JVM 运行时参数</h1><h2 id="4-1-JVM-参数选项"><a href="#4-1-JVM-参数选项" class="headerlink" title="4.1. JVM 参数选项"></a>4.1. JVM 参数选项</h2><p>官网地址：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a></p>
<h3 id="4-1-1-类型一：标准参数选项"><a href="#4-1-1-类型一：标准参数选项" class="headerlink" title="4.1.1. 类型一：标准参数选项"></a>4.1.1. 类型一：标准参数选项</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; java -help</span><br><span class="line">用法: java [-options] class [args...]</span><br><span class="line">           (执行类)</span><br><span class="line">   或  java [-options] -jar jarfile [args...]</span><br><span class="line">           (执行 jar 文件)</span><br><span class="line">其中选项包括:</span><br><span class="line">    -d32          使用 32 位数据模型 (如果可用)</span><br><span class="line">    -d64          使用 64 位数据模型 (如果可用)</span><br><span class="line">    -server       选择 &quot;server&quot; VM</span><br><span class="line">                  默认 VM 是 server.</span><br><span class="line"></span><br><span class="line">    -cp &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">    -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">                  用 ; 分隔的目录, JAR 档案</span><br><span class="line">                  和 ZIP 档案列表, 用于搜索类文件。</span><br><span class="line">    -D&lt;名称&gt;=&lt;值&gt;</span><br><span class="line">                  设置系统属性</span><br><span class="line">    -verbose:[class|gc|jni]</span><br><span class="line">                  启用详细输出</span><br><span class="line">    -version      输出产品版本并退出</span><br><span class="line">    -version:&lt;值&gt;</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  需要指定的版本才能运行</span><br><span class="line">    -showversion  输出产品版本并继续</span><br><span class="line">    -jre-restrict-search | -no-jre-restrict-search</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  在版本搜索中包括/排除用户专用 JRE</span><br><span class="line">    -? -help      输出此帮助消息</span><br><span class="line">    -X            输出非标准选项的帮助</span><br><span class="line">    -ea[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  按指定的粒度启用断言</span><br><span class="line">    -da[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  禁用具有指定粒度的断言</span><br><span class="line">    -esa | -enablesystemassertions</span><br><span class="line">                  启用系统断言</span><br><span class="line">    -dsa | -disablesystemassertions</span><br><span class="line">                  禁用系统断言</span><br><span class="line">    -agentlib:&lt;libname&gt;[=&lt;选项&gt;]</span><br><span class="line">                  加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof</span><br><span class="line">                  另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help</span><br><span class="line">    -agentpath:&lt;pathname&gt;[=&lt;选项&gt;]</span><br><span class="line">                  按完整路径名加载本机代理库</span><br><span class="line">    -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]</span><br><span class="line">                  加载 Java 编程语言代理, 请参阅 java.lang.instrument</span><br><span class="line">    -splash:&lt;imagepath&gt;</span><br><span class="line">                  使用指定的图像显示启动屏幕</span><br><span class="line">有关详细信息, 请参阅 http://www.oracle.com/technetwork/java/javase/documentation/index.html。</span><br></pre></td></tr></table></figure>

<p><strong>Server 模式和 Client 模式</strong></p>
<p>Hotspot JVM 有两种模式，分别是 server 和 client，分别通过-server 和-client 模式设置</p>
<ul>
<li>32 位系统上，默认使用 Client 类型的 JVM。要想使用 Server 模式，机器配置至少有 2 个以上的 CPU 和 2G 以上的物理内存。client 模式适用于对内存要求较小的桌面应用程序，默认使用 Serial 串行垃圾收集器</li>
<li>64 位系统上，只支持 server 模式的 JVM，适用于需要大内存的应用程序，默认使用并行垃圾收集器</li>
</ul>
<p>官网地址：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/server-class.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/server-class.html</a></p>
<p>如何知道系统默认使用的是那种模式呢？</p>
<p>通过 java -version 命令：可以看到 Server VM 字样，代表当前系统使用是 Server 模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; java -version</span><br><span class="line">java version &quot;1.8.0_201&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_201-b09)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)</span><br></pre></td></tr></table></figure>

<h3 id="4-1-2-类型二：-X-参数选项"><a href="#4-1-2-类型二：-X-参数选项" class="headerlink" title="4.1.2. 类型二：-X 参数选项"></a>4.1.2. 类型二：-X 参数选项</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; java -X</span><br><span class="line">    -Xmixed           混合模式执行 (默认)</span><br><span class="line">    -Xint             仅解释模式执行</span><br><span class="line">    -Xbootclasspath:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      设置搜索路径以引导类和资源</span><br><span class="line">    -Xbootclasspath/a:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      附加在引导类路径末尾</span><br><span class="line">    -Xbootclasspath/p:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      置于引导类路径之前</span><br><span class="line">    -Xdiag            显示附加诊断消息</span><br><span class="line">    -Xnoclassgc       禁用类垃圾收集</span><br><span class="line">    -Xincgc           启用增量垃圾收集</span><br><span class="line">    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中 (带时间戳)</span><br><span class="line">    -Xbatch           禁用后台编译</span><br><span class="line">    -Xms&lt;size&gt;        设置初始 Java 堆大小</span><br><span class="line">    -Xmx&lt;size&gt;        设置最大 Java 堆大小</span><br><span class="line">    -Xss&lt;size&gt;        设置 Java 线程堆栈大小</span><br><span class="line">    -Xprof            输出 cpu 配置文件数据</span><br><span class="line">    -Xfuture          启用最严格的检查, 预期将来的默认值</span><br><span class="line">    -Xrs              减少 Java/VM 对操作系统信号的使用 (请参阅文档)</span><br><span class="line">    -Xcheck:jni       对 JNI 函数执行其他检查</span><br><span class="line">    -Xshare:off       不尝试使用共享类数据</span><br><span class="line">    -Xshare:auto      在可能的情况下使用共享类数据 (默认)</span><br><span class="line">    -Xshare:on        要求使用共享类数据, 否则将失败。</span><br><span class="line">    -XshowSettings    显示所有设置并继续</span><br><span class="line">    -XshowSettings:all</span><br><span class="line">                      显示所有设置并继续</span><br><span class="line">    -XshowSettings:vm 显示所有与 vm 相关的设置并继续</span><br><span class="line">    -XshowSettings:properties</span><br><span class="line">                      显示所有属性设置并继续</span><br><span class="line">    -XshowSettings:locale</span><br><span class="line">                      显示所有与区域设置相关的设置并继续</span><br><span class="line"></span><br><span class="line">-X 选项是非标准选项, 如有更改, 恕不另行通知。</span><br></pre></td></tr></table></figure>

<p>如何知道 JVM 默认使用的是混合模式呢？</p>
<p>同样地，通过 java -version 命令：可以看到 mixed mode 字样，代表当前系统使用的是混合模式</p>
<h3 id="4-1-3-类型三：-XX-参数选项"><a href="#4-1-3-类型三：-XX-参数选项" class="headerlink" title="4.1.3. 类型三：-XX 参数选项"></a>4.1.3. 类型三：-XX 参数选项</h3><p><strong>Boolean 类型格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+&lt;option&gt;  启用option属性</span><br><span class="line">-XX:-&lt;option&gt;  禁用option属性</span><br></pre></td></tr></table></figure>

<p><strong>非 Boolean 类型格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:&lt;option&gt;=&lt;number&gt;  设置option数值，可以带单位如k/K/m/M/g/G</span><br><span class="line">-XX:&lt;option&gt;=&lt;string&gt;  设置option字符值</span><br></pre></td></tr></table></figure>

<h2 id="4-2-添加-JVM-参数选项"><a href="#4-2-添加-JVM-参数选项" class="headerlink" title="4.2. 添加 JVM 参数选项"></a>4.2. 添加 JVM 参数选项</h2><p>eclipse 和 idea 中配置不必多说，在 Run Configurations 中 VM Options 中配置即可，大同小异</p>
<p><strong>运行 jar 包</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -Xms100m -Xmx100m -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -jar demo.jar</span><br></pre></td></tr></table></figure>

<p><strong>Tomcat 运行 war 包</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># linux下catalina.sh添加</span><br><span class="line">JAVA_OPTS=&quot;-Xms512M -Xmx1024M&quot;</span><br><span class="line"># windows下catalina.bat添加</span><br><span class="line">set &quot;JAVA_OPTS=-Xms512M -Xmx1024M&quot;</span><br></pre></td></tr></table></figure>

<p><strong>程序运行中</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置Boolean类型参数</span><br><span class="line">jinfo -flag [+|-]&lt;name&gt; &lt;pid&gt;</span><br><span class="line"># 设置非Boolean类型参数</span><br><span class="line">jinfo -flag &lt;name&gt;=&lt;value&gt; &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-常用的-JVM-参数选项"><a href="#4-3-常用的-JVM-参数选项" class="headerlink" title="4.3. 常用的 JVM 参数选项"></a>4.3. 常用的 JVM 参数选项</h2><h3 id="4-3-1-打印设置的-XX-选项及值"><a href="#4-3-1-打印设置的-XX-选项及值" class="headerlink" title="4.3.1. 打印设置的 XX 选项及值"></a>4.3.1. 打印设置的 XX 选项及值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+PrintCommandLineFlags 程序运行时JVM默认设置或用户手动设置的XX选项</span><br><span class="line">-XX:+PrintFlagsInitial 打印所有XX选项的默认值</span><br><span class="line">-XX:+PrintFlagsFinal 打印所有XX选项的实际值</span><br><span class="line">-XX:+PrintVMOptions 打印JVM的参数</span><br></pre></td></tr></table></figure>

<h3 id="4-3-2-堆、栈、方法区等内存大小设置"><a href="#4-3-2-堆、栈、方法区等内存大小设置" class="headerlink" title="4.3.2. 堆、栈、方法区等内存大小设置"></a>4.3.2. 堆、栈、方法区等内存大小设置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 栈</span><br><span class="line">-Xss128k &lt;==&gt; -XX:ThreadStackSize=128k 设置线程栈的大小为128K</span><br><span class="line"></span><br><span class="line"># 堆</span><br><span class="line">-Xms2048m &lt;==&gt; -XX:InitialHeapSize=2048m 设置JVM初始堆内存为2048M</span><br><span class="line">-Xmx2048m &lt;==&gt; -XX:MaxHeapSize=2048m 设置JVM最大堆内存为2048M</span><br><span class="line">-Xmn2g &lt;==&gt; -XX:NewSize=2g -XX:MaxNewSize=2g 设置年轻代大小为2G</span><br><span class="line">-XX:SurvivorRatio=8 设置Eden区与Survivor区的比值，默认为8</span><br><span class="line">-XX:NewRatio=2 设置老年代与年轻代的比例，默认为2</span><br><span class="line">-XX:+UseAdaptiveSizePolicy 设置大小比例自适应，默认开启</span><br><span class="line">-XX:PretenureSizeThreadshold=1024 设置让大于此阈值的对象直接分配在老年代，只对Serial、ParNew收集器有效</span><br><span class="line">-XX:MaxTenuringThreshold=15 设置新生代晋升老年代的年龄限制，默认为15</span><br><span class="line">-XX:TargetSurvivorRatio 设置MinorGC结束后Survivor区占用空间的期望比例</span><br><span class="line"></span><br><span class="line"># 方法区</span><br><span class="line">-XX:MetaspaceSize / -XX:PermSize=256m 设置元空间/永久代初始值为256M</span><br><span class="line">-XX:MaxMetaspaceSize / -XX:MaxPermSize=256m 设置元空间/永久代最大值为256M</span><br><span class="line">-XX:+UseCompressedOops 使用压缩对象</span><br><span class="line">-XX:+UseCompressedClassPointers 使用压缩类指针</span><br><span class="line">-XX:CompressedClassSpaceSize 设置Klass Metaspace的大小，默认1G</span><br><span class="line"></span><br><span class="line"># 直接内存</span><br><span class="line">-XX:MaxDirectMemorySize 指定DirectMemory容量，默认等于Java堆最大值</span><br></pre></td></tr></table></figure>

<h3 id="4-3-3-OutOfMemory-相关的选项"><a href="#4-3-3-OutOfMemory-相关的选项" class="headerlink" title="4.3.3. OutOfMemory 相关的选项"></a>4.3.3. OutOfMemory 相关的选项</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutMemoryError 内存出现OOM时生成Heap转储文件，两者互斥</span><br><span class="line">-XX:+HeapDumpBeforeFullGC 出现FullGC时生成Heap转储文件，两者互斥</span><br><span class="line">-XX:HeapDumpPath=&lt;path&gt; 指定heap转储文件的存储路径，默认当前目录</span><br><span class="line">-XX:OnOutOfMemoryError=&lt;path&gt; 指定可行性程序或脚本的路径，当发生OOM时执行脚本</span><br></pre></td></tr></table></figure>

<h3 id="4-3-4-垃圾收集器相关选项"><a href="#4-3-4-垃圾收集器相关选项" class="headerlink" title="4.3.4. 垃圾收集器相关选项"></a>4.3.4. 垃圾收集器相关选项</h3><p>首先需了解垃圾收集器之间的搭配使用关系</p>
<ul>
<li>红色虚线表示在 jdk8 时被 Deprecate，jdk9 时被删除</li>
<li>绿色虚线表示在 jdk14 时被 Deprecate</li>
<li>绿色虚框表示在 jdk9 时被 Deprecate，jdk14 时被删除</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/46dec5b346fcc5b147491481787ea8ec.png" alt="image-20210506182458663"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Serial回收器</span><br><span class="line">-XX:+UseSerialGC  年轻代使用Serial GC， 老年代使用Serial Old GC</span><br><span class="line"># ParNew回收器</span><br><span class="line">-XX:+UseParNewGC  年轻代使用ParNew GC</span><br><span class="line">-XX:ParallelGCThreads  设置年轻代并行收集器的线程数。</span><br><span class="line">	一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</span><br></pre></td></tr></table></figure>



<p>ParallelGCThreads={CPUCount(CPUCount&lt;=8) 3+(5∗CPU＿Count/8)(CPUCount&gt;8)ParallelGCThreads={CPUCount(CPUCount&lt;=8) 3+(5∗CPU＿Count/8)(CPUCount&gt;8)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Parallel回收器</span><br><span class="line">-XX:+UseParallelGC  年轻代使用 Parallel Scavenge GC，互相激活</span><br><span class="line">-XX:+UseParallelOldGC  老年代使用 Parallel Old GC，互相激活</span><br><span class="line">-XX:ParallelGCThreads</span><br><span class="line">-XX:MaxGCPauseMillis  设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒。</span><br><span class="line">	为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。</span><br><span class="line">	对于用户来讲，停顿时间越短体验越好；但是服务器端注重高并发，整体的吞吐量。</span><br><span class="line">	所以服务器端适合Parallel，进行控制。该参数使用需谨慎。</span><br><span class="line">-XX:GCTimeRatio  垃圾收集时间占总时间的比例（1 / (N＋1)），用于衡量吞吐量的大小</span><br><span class="line">	取值范围（0,100），默认值99，也就是垃圾回收时间不超过1％。</span><br><span class="line">	与前一个-XX：MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</span><br><span class="line">-XX:+UseAdaptiveSizePolicy  设置Parallel Scavenge收集器具有自适应调节策略。</span><br><span class="line">	在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。</span><br><span class="line">	在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。</span><br><span class="line"># CMS回收器</span><br><span class="line">-XX:+UseConcMarkSweepGC  年轻代使用CMS GC。</span><br><span class="line">	开启该参数后会自动将-XX：＋UseParNewGC打开。即：ParNew（Young区）+ CMS（Old区）+ Serial Old的组合</span><br><span class="line">-XX:CMSInitiatingOccupanyFraction  设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。JDK5及以前版本的默认值为68，DK6及以上版本默认值为92％。</span><br><span class="line">	如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。</span><br><span class="line">	反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。</span><br><span class="line">	因此通过该选项便可以有效降低Fu1l GC的执行次数。</span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly  是否动态可调，使CMS一直按CMSInitiatingOccupancyFraction设定的值启动</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection  用于指定在执行完Full GC后对内存空间进行压缩整理</span><br><span class="line">	以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction  设置在执行多少次Full GC后对内存空间进行压缩整理。</span><br><span class="line">-XX:ParallelCMSThreads  设置CMS的线程数量。</span><br><span class="line">	CMS 默认启动的线程数是(ParallelGCThreads＋3)/4，ParallelGCThreads 是年轻代并行收集器的线程数。</span><br><span class="line">	当CPU 资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</span><br><span class="line">-XX:ConcGCThreads  设置并发垃圾收集的线程数，默认该值是基于ParallelGCThreads计算出来的</span><br><span class="line">-XX:+CMSScavengeBeforeRemark  强制hotspot在cms remark阶段之前做一次minor gc，用于提高remark阶段的速度</span><br><span class="line">-XX:+CMSClassUnloadingEnable  如果有的话，启用回收Perm 区（JDK8之前）</span><br><span class="line">-XX:+CMSParallelInitialEnabled  用于开启CMS initial-mark阶段采用多线程的方式进行标记</span><br><span class="line">	用于提高标记速度，在Java8开始已经默认开启</span><br><span class="line">-XX:+CMSParallelRemarkEnabled  用户开启CMS remark阶段采用多线程的方式进行重新标记，默认开启</span><br><span class="line">-XX:+ExplicitGCInvokesConcurrent</span><br><span class="line">-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</span><br><span class="line">	这两个参数用户指定hotspot虚拟在执行System.gc()时使用CMS周期</span><br><span class="line">-XX:+CMSPrecleaningEnabled  指定CMS是否需要进行Pre cleaning阶段</span><br><span class="line"># G1回收器</span><br><span class="line">-XX:+UseG1GC 手动指定使用G1收集器执行内存回收任务。</span><br><span class="line">-XX:G1HeapRegionSize 设置每个Region的大小。</span><br><span class="line">	值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</span><br><span class="line">-XX:MaxGCPauseMillis  设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</span><br><span class="line">-XX:ParallelGCThread  设置STW时GC线程数的值。最多设置为8</span><br><span class="line">-XX:ConcGCThreads  设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。</span><br><span class="line">-XX:InitiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</span><br><span class="line">-XX:G1NewSizePercent  新生代占用整个堆内存的最小百分比（默认5％）</span><br><span class="line">-XX:G1MaxNewSizePercent  新生代占用整个堆内存的最大百分比（默认60％）</span><br><span class="line">-XX:G1ReservePercent=10  保留内存区域，防止 to space（Survivor中的to区）溢出</span><br></pre></td></tr></table></figure>

<p>怎么选择垃圾回收器？</p>
<ul>
<li>优先让 JVM 自适应，调整堆的大小</li>
<li>串行收集器：内存小于 100M；单核、单机程序，并且没有停顿时间的要求</li>
<li>并行收集器：多 CPU、高吞吐量、允许停顿时间超过 1 秒</li>
<li>并发收集器：多 CPU、追求低停顿时间、快速响应（比如延迟不能超过 1 秒，如互联网应用）</li>
<li>官方推荐 G1，性能高。现在互联网的项目，基本都是使用 G1</li>
</ul>
<p>特别说明：</p>
<ul>
<li>没有最好的收集器，更没有万能的收集器</li>
<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>
</ul>
<h3 id="4-3-5-GC-日志相关选项"><a href="#4-3-5-GC-日志相关选项" class="headerlink" title="4.3.5. GC 日志相关选项"></a>4.3.5. GC 日志相关选项</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGC &lt;==&gt; -verbose:gc  打印简要日志信息</span><br><span class="line">-XX:+PrintGCDetails            打印详细日志信息</span><br><span class="line">-XX:+PrintGCTimeStamps  打印程序启动到GC发生的时间，搭配-XX:+PrintGCDetails使用</span><br><span class="line">-XX:+PrintGCDateStamps  打印GC发生时的时间戳，搭配-XX:+PrintGCDetails使用</span><br><span class="line">-XX:+PrintHeapAtGC  打印GC前后的堆信息，如下图</span><br><span class="line">-Xloggc:&lt;file&gt; 输出GC导指定路径下的文件中</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/9f323dd9b55235ed0a33e6a0af8adbca.png" alt="image-20210506195156935"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+TraceClassLoading  监控类的加载</span><br><span class="line">-XX:+PrintGCApplicationStoppedTime  打印GC时线程的停顿时间</span><br><span class="line">-XX:+PrintGCApplicationConcurrentTime  打印垃圾收集之前应用未中断的执行时间</span><br><span class="line">-XX:+PrintReferenceGC 打印回收了多少种不同引用类型的引用</span><br><span class="line">-XX:+PrintTenuringDistribution  打印JVM在每次MinorGC后当前使用的Survivor中对象的年龄分布</span><br><span class="line">-XX:+UseGCLogFileRotation 启用GC日志文件的自动转储</span><br><span class="line">-XX:NumberOfGCLogFiles=1  设置GC日志文件的循环数目</span><br><span class="line">-XX:GCLogFileSize=1M  设置GC日志文件的大小</span><br></pre></td></tr></table></figure>

<h3 id="4-3-6-其他参数"><a href="#4-3-6-其他参数" class="headerlink" title="4.3.6. 其他参数"></a>4.3.6. 其他参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+DisableExplicitGC  禁用hotspot执行System.gc()，默认禁用</span><br><span class="line">-XX:ReservedCodeCacheSize=&lt;n&gt;[g|m|k]、-XX:InitialCodeCacheSize=&lt;n&gt;[g|m|k]  指定代码缓存的大小</span><br><span class="line">-XX:+UseCodeCacheFlushing  放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况</span><br><span class="line">-XX:+DoEscapeAnalysis  开启逃逸分析</span><br><span class="line">-XX:+UseBiasedLocking  开启偏向锁</span><br><span class="line">-XX:+UseLargePages  开启使用大页面</span><br><span class="line">-XX:+PrintTLAB  打印TLAB的使用情况</span><br><span class="line">-XX:TLABSize  设置TLAB大小</span><br></pre></td></tr></table></figure>

<h2 id="4-4-通过-Java-代码获取-JVM-参数"><a href="#4-4-通过-Java-代码获取-JVM-参数" class="headerlink" title="4.4. 通过 Java 代码获取 JVM 参数"></a>4.4. 通过 Java 代码获取 JVM 参数</h2><p>Java 提供了 java.lang.management 包用于监视和管理 Java 虚拟机和 Java 运行时中的其他组件，它允许本地或远程监控和管理运行的 Java 虚拟机。其中 ManagementFactory 类较为常用，另外 Runtime 类可获取内存、CPU 核数等相关的数据。通过使用这些 api，可以监控应用服务器的堆内存使用情况，设置一些阈值进行报警等处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MemoryMonitor &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MemoryMXBean memorymbean = ManagementFactory.getMemoryMXBean();</span><br><span class="line">        MemoryUsage usage = memorymbean.getHeapMemoryUsage();</span><br><span class="line">        System.out.println(&quot;INIT HEAP: &quot; + usage.getInit() / 1024 / 1024 + &quot;m&quot;);</span><br><span class="line">        System.out.println(&quot;MAX HEAP: &quot; + usage.getMax() / 1024 / 1024 + &quot;m&quot;);</span><br><span class="line">        System.out.println(&quot;USE HEAP: &quot; + usage.getUsed() / 1024 / 1024 + &quot;m&quot;);</span><br><span class="line">        System.out.println(&quot;\nFull Information:&quot;);</span><br><span class="line">        System.out.println(&quot;Heap Memory Usage: &quot; + memorymbean.getHeapMemoryUsage());</span><br><span class="line">        System.out.println(&quot;Non-Heap Memory Usage: &quot; + memorymbean.getNonHeapMemoryUsage());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;=======================通过java来获取相关系统状态============================ &quot;);</span><br><span class="line">        System.out.println(&quot;当前堆内存大小totalMemory &quot; + (int) Runtime.getRuntime().totalMemory() / 1024 / 1024 + &quot;m&quot;);// 当前堆内存大小</span><br><span class="line">        System.out.println(&quot;空闲堆内存大小freeMemory &quot; + (int) Runtime.getRuntime().freeMemory() / 1024 / 1024 + &quot;m&quot;);// 空闲堆内存大小</span><br><span class="line">        System.out.println(&quot;最大可用总堆内存maxMemory &quot; + Runtime.getRuntime().maxMemory() / 1024 / 1024 + &quot;m&quot;);// 最大可用总堆内存大小</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-分析-GC-日志"><a href="#5-分析-GC-日志" class="headerlink" title="5. 分析 GC 日志"></a>5. 分析 GC 日志</h1><h2 id="5-1-GC-分类"><a href="#5-1-GC-分类" class="headerlink" title="5.1. GC 分类"></a>5.1. GC 分类</h2><p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p>
<ul>
<li>部分收集（Partial GC）：不是完整收集整个 Java 堆的垃圾收集。其中又分为：<ul>
<li>新生代收集（Minor GC / Young GC）：只是新生代（Eden / S0, S1）的垃圾收集</li>
<li>老年代收集（Major GC / Old GC）：只是老年代的垃圾收集。目前，只有 CMS GC 会有单独收集老年代的行为。注意，很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。</li>
</ul>
</li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有 G1 GC 会有这种行为</li>
<li>整堆收集（Full GC）：收集整个 java 堆和方法区的垃圾收集。</li>
</ul>
<h2 id="5-2-GC-日志分类"><a href="#5-2-GC-日志分类" class="headerlink" title="5.2. GC 日志分类"></a>5.2. GC 日志分类</h2><p><strong>MinorGC</strong></p>
<p>MinorGC（或 young GC 或 YGC）日志：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 31744K-&gt;2192K (36864K) ] 31744K-&gt;2200K (121856K), 0.0139308 secs] [Times: user=0.05 sys=0.01, real=0.01 secs]</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/df81757685ca21a927d9335273f561c5.png" alt="image-20210506202126562"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b9a7575380bcdb91b54c0556557d8ad9.png" alt="image-20210506202156090"></p>
<p><strong>FullGC</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Full GC (Metadata GC Threshold) [PSYoungGen: 5104K-&gt;0K (132096K) ] [Par01dGen: 416K-&gt;5453K (50176K) ]5520K-&gt;5453K (182272K), [Metaspace: 20637K-&gt;20637K (1067008K) ], 0.0245883 secs] [Times: user=0.06 sys=0.00, real=0.02 secs]</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/0dcb239f0928bc374ac1b376b4189295.png" alt="image-20210506202330868"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7817f28a52c836d5ed08a4b992823f64.png" alt="image-20210506202349072"></p>
<h2 id="5-3-GC-日志结构剖析"><a href="#5-3-GC-日志结构剖析" class="headerlink" title="5.3. GC 日志结构剖析"></a>5.3. GC 日志结构剖析</h2><p><strong>透过日志看垃圾收集器</strong></p>
<ul>
<li>Serial 收集器：新生代显示 “[DefNew”，即 Default New Generation</li>
<li>ParNew 收集器：新生代显示 “[ParNew”，即 Parallel New Generation</li>
<li>Parallel Scavenge 收集器：新生代显示”[PSYoungGen”，JDK1.7 使用的即 PSYoungGen</li>
<li>Parallel Old 收集器：老年代显示”[ParoldGen”</li>
<li>G1 收集器：显示”garbage-first heap“</li>
</ul>
<p><strong>透过日志看 GC 原因</strong></p>
<ul>
<li>Allocation Failure：表明本次引起 GC 的原因是因为新生代中没有足够的区域存放需要分配的数据</li>
<li>Metadata GCThreshold：Metaspace 区不够用了</li>
<li>FErgonomics：JVM 自适应调整导致的 GC</li>
<li>System：调用了 System.gc()方法</li>
</ul>
<p><strong>透过日志看 GC 前后情况</strong></p>
<p>通过图示，我们可以发现 GC 日志格式的规律一般都是：GC 前内存占用-＞ GC 后内存占用（该区域内存总大小）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[PSYoungGen: 5986K-&gt;696K (8704K) ] 5986K-&gt;704K (9216K)</span><br></pre></td></tr></table></figure>

<ul>
<li>中括号内：GC 回收前年轻代堆大小，回收后大小，（年轻代堆总大小）</li>
<li>括号外：GC 回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li>
</ul>
<p>注意：Minor GC 堆内存总容量 = 9/10 年轻代 + 老年代。原因是 Survivor 区只计算 from 部分，而 JVM 默认年轻代中 Eden 区和 Survivor 区的比例关系，Eden:S0:S1=8:1:1。</p>
<p><strong>透过日志看 GC 时间</strong></p>
<p>GC 日志中有三个时间：user，sys 和 real</p>
<ul>
<li>user：进程执行用户态代码（核心之外）所使用的时间。这是执行此进程所使用的实际 CPU 时间，其他进程和此进程阻塞的时间并不包括在内。在垃圾收集的情况下，表示 GC 线程执行所使用的 CPU 总时间。</li>
<li>sys：进程在内核态消耗的 CPU 时间，即在内核执行系统调用或等待系统事件所使用的 CPU 时间</li>
<li>real：程序从开始到结束所用的时钟时间。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I/O 完成）。对于并行 gc，这个数字应该接近（用户时间＋系统时间）除以垃圾收集器使用的线程数。</li>
</ul>
<p>由于多核的原因，一般的 GC 事件中，real time 是小于 sys time ＋ user time 的，因为一般是多个线程并发的去做 GC，所以 real time 是要小于 sys ＋ user time 的。如果 real ＞ sys ＋ user 的话，则你的应用可能存在下列问题：IO 负载非常重或 CPU 不够用。</p>
<h2 id="5-4-GC-日志分析工具"><a href="#5-4-GC-日志分析工具" class="headerlink" title="5.4. GC 日志分析工具"></a>5.4. GC 日志分析工具</h2><p><strong>GCEasy</strong></p>
<p>GCEasy 是一款在线的 GC 日志分析器，可以通过 GC 日志分析进行内存泄露检测、GC 暂停原因分析、JVM 配置建议优化等功能，大多数功能是免费的。</p>
<p>官网地址：<a href="https://gceasy.io/">https://gceasy.io/</a></p>
<p><strong>GCViewer</strong></p>
<p>GCViewer 是一款离线的 GC 日志分析器，用于可视化 Java VM 选项 -verbose:gc 和 .NET 生成的数据 -Xloggc:<file>。还可以计算与垃圾回收相关的性能指标（吞吐量、累积的暂停、最长的暂停等）。当通过更改世代大小或设置初始堆大小来调整特定应用程序的垃圾回收时，此功能非常有用。</p>
<p>源码下载：<a href="https://github.com/chewiebug/GCViewer">https://github.com/chewiebug/GCViewer</a></p>
<p>运行版本下载：<a href="https://github.com/chewiebug/GCViewer/wiki/Changelog">https://github.com/chewiebug/GCViewer/wiki/Changelog</a></p>
<p><strong>GChisto</strong></p>
<ul>
<li>官网上没有下载的地方，需要自己从 SVN 上拉下来编译</li>
<li>不过这个工具似乎没怎么维护了，存在不少 bug</li>
</ul>
<p><strong>HPjmeter</strong></p>
<ul>
<li>工具很强大，但是只能打开由以下参数生成的 GC log，-verbose:gc -Xloggc:gc.log。添加其他参数生成的 gc.log 无法打开</li>
<li>HPjmeter 集成了以前的 HPjtune 功能，可以分析在 HP 机器上产生的垃圾回收日志文件</li>
</ul>
<h1 id="补充：使用-OQL-语言查询对象信息"><a href="#补充：使用-OQL-语言查询对象信息" class="headerlink" title="补充：使用 OQL 语言查询对象信息"></a>补充：使用 OQL 语言查询对象信息</h1><p>MAT 支持一种类似于 SQL 的查询语言 OQL（Object Query Language）。OQL 使用类 SQL 语法，可以在堆中进行对象的查找和筛选。</p>
<h2 id="1-SELECT-子句"><a href="#1-SELECT-子句" class="headerlink" title="1. SELECT 子句"></a>1. SELECT 子句</h2><p>在 MAT 中，Select 子句的格式与 SQL 基本一致，用于指定要显示的列。Select 子句中可以使用“＊”，查看结果对象的引用实例（相当于 outgoing references）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM java.util.Vector v</span><br></pre></td></tr></table></figure>

<p>使用“OBJECTS”关键字，可以将返回结果集中的项以对象的形式显示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT objects v.elementData FROM java.util.Vector v</span><br><span class="line"></span><br><span class="line">SELECT OBJECTS s.value FROM java.lang.String s</span><br></pre></td></tr></table></figure>

<p>在 Select 子句中，使用“AS RETAINED SET”关键字可以得到所得对象的保留集。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT AS RETAINED SET *FROM com.atguigu.mat.Student</span><br></pre></td></tr></table></figure>

<p>“DISTINCT”关键字用于在结果集中去除重复对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT OBJECTS classof(s) FROM java.lang.String s</span><br></pre></td></tr></table></figure>

<h2 id="2-FROM-子句"><a href="#2-FROM-子句" class="headerlink" title="2. FROM 子句"></a>2. FROM 子句</h2><p>From 子句用于指定查询范围，它可以指定类名、正则表达式或者对象地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM java.lang.String s</span><br></pre></td></tr></table></figure>

<p>使用正则表达式，限定搜索范围，输出所有 com.atguigu 包下所有类的实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM &quot;com\.atguigu\..*&quot;</span><br></pre></td></tr></table></figure>

<p>使用类的地址进行搜索。使用类的地址的好处是可以区分被不同 ClassLoader 加载的同一种类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from 0x37a0b4d</span><br></pre></td></tr></table></figure>

<h2 id="3-WHERE-子句"><a href="#3-WHERE-子句" class="headerlink" title="3. WHERE 子句"></a>3. WHERE 子句</h2><p>Where 子句用于指定 OQL 的查询条件。OQL 查询将只返回满足 Where 子句指定条件的对象。Where 子句的格式与传统 SQL 极为相似。</p>
<p>返回长度大于 10 的 char 数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT *FROM Ichar[] s WHERE s.@length&gt;10</span><br></pre></td></tr></table></figure>

<p>返回包含“java”子字符串的所有字符串，使用“LIKE”操作符，“LIKE”操作符的操作参数为正则表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM java.lang.String s WHERE toString(s) LIKE &quot;.*java.*&quot;</span><br></pre></td></tr></table></figure>

<p>返回所有 value 域不为 null 的字符串，使用“＝”操作符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM java.lang.String s where s.value!=null</span><br></pre></td></tr></table></figure>

<p>返回数组长度大于 15，并且深堆大于 1000 字节的所有 Vector 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM java.util.Vector v WHERE v.elementData.@length&gt;15 AND v.@retainedHeapSize&gt;1000</span><br></pre></td></tr></table></figure>

<h2 id="4-内置对象与方法"><a href="#4-内置对象与方法" class="headerlink" title="4. 内置对象与方法"></a>4. 内置对象与方法</h2><p>OQL 中可以访问堆内对象的属性，也可以访问堆内代理对象的属性。访问堆内对象的属性时，格式如下，其中 alias 为对象名称：</p>
<p>[ <alias>. ] <field> . <field>. <field></p>
<p>访问 java.io.File 对象的 path 属性，并进一步访问 path 的 value 属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT toString(f.path.value) FROM java.io.File f</span><br></pre></td></tr></table></figure>

<p>显示 String 对象的内容、objectid 和 objectAddress。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT s.toString(),s.@objectId, s.@objectAddress FROM java.lang.String s</span><br></pre></td></tr></table></figure>

<p>显示 java.util.Vector 内部数组的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT v.elementData.@length FROM java.util.Vector v</span><br></pre></td></tr></table></figure>

<p>显示所有的 java.util.Vector 对象及其子类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from INSTANCEOF java.util.Vector</span><br></pre></td></tr></table></figure>

<h1 id="补充：浅堆深堆与内存泄露"><a href="#补充：浅堆深堆与内存泄露" class="headerlink" title="补充：浅堆深堆与内存泄露"></a>补充：浅堆深堆与内存泄露</h1><h2 id="1-浅堆（Shallow-Heap）"><a href="#1-浅堆（Shallow-Heap）" class="headerlink" title="1. 浅堆（Shallow Heap）"></a>1. 浅堆（Shallow Heap）</h2><p>浅堆是指一个对象所消耗的内存。在 32 位系统中，一个对象引用会占据 4 个字节，一个 int 类型会占据 4 个字节，long 型变量会占据 8 个字节，每个对象头需要占用 8 个字节。根据堆快照格式不同，对象的大小可能会同 8 字节进行对齐。</p>
<p>以 String 为例：2 个 int 值共占 8 字节，对象引用占用 4 字节，对象头 8 字节，合计 20 字节，向 8 字节对齐，故占 24 字节。（jdk7 中）</p>
<table>
<thead>
<tr>
<th>int</th>
<th>hash32</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td><strong>int</strong></td>
<td><strong>hash</strong></td>
<td><strong>0</strong></td>
</tr>
<tr>
<td><strong>ref</strong></td>
<td><strong>value</strong></td>
<td><strong>C:\Users\Administrat</strong></td>
</tr>
</tbody></table>
<p>这 24 字节为 String 对象的浅堆大小。它与 String 的 value 实际取值无关，无论字符串长度如何，浅堆大小始终是 24 字节。</p>
<h2 id="2-保留集（Retained-Set）"><a href="#2-保留集（Retained-Set）" class="headerlink" title="2. 保留集（Retained Set）"></a>2. 保留集（Retained Set）</h2><p>对象 A 的保留集指当对象 A 被垃圾回收后，可以被释放的所有的对象集合（包括对象 A 本身），即对象 A 的保留集可以被认为是只能通过对象 A 被直接或间接访问到的所有对象的集合。通俗地说，就是指仅被对象 A 所持有的对象的集合。</p>
<h2 id="3-深堆（Retained-Heap）"><a href="#3-深堆（Retained-Heap）" class="headerlink" title="3. 深堆（Retained Heap）"></a>3. 深堆（Retained Heap）</h2><p>深堆是指对象的保留集中所有的对象的浅堆大小之和。</p>
<p>注意：浅堆指对象本身占用的内存，不包括其内部引用对象的大小。一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间。</p>
<h2 id="4-对象的实际大小"><a href="#4-对象的实际大小" class="headerlink" title="4. 对象的实际大小"></a>4. 对象的实际大小</h2><p>这里，对象的实际大小定义为一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小。与深堆相比，似乎这个在日常开发中更为直观和被人接受，但实际上，这个概念和垃圾回收无关。</p>
<p>下图显示了一个简单的对象引用关系图，对象 A 引用了 C 和 D，对象 B 引用了 C 和 E。那么对象 A 的浅堆大小只是 A 本身，不含 C 和 D，而 A 的实际大小为 A、C、D 三者之和。而 A 的深堆大小为 A 与 D 之和，由于对象 C 还可以通过对象 B 访问到，因此不在对象 A 的深堆范围内。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ecc35ddfcfd13200bbc881333d38ac93.png" alt="image-20210505151123427"></p>
<h2 id="5-支配树（Dominator-Tree）"><a href="#5-支配树（Dominator-Tree）" class="headerlink" title="5. 支配树（Dominator Tree）"></a>5. 支配树（Dominator Tree）</h2><p>支配树的概念源自图论。MAT 提供了一个称为支配树（Dominator Tree）的对象图。支配树体现了对象实例间的支配关系。在对象引用图中，所有指向对象 B 的路径都经过对象 A，则认为对象 A 支配对象 B。如果对象 A 是离对象 B 最近的一个支配对象，则认为对象 A 为对象 B 的直接支配者。支配树是基于对象间的引用图所建立的，它有以下基本性质：</p>
<ul>
<li>对象 A 的子树（所有被对象 A 支配的对象集合）表示对象 A 的保留集（retained set），即深堆。</li>
<li>如果对象 A 支配对象 B，那么对象 A 的直接支配者也支配对象 B。</li>
<li>支配树的边与对象引用图的边不直接对应。</li>
</ul>
<p>如下图所示：左图表示对象引用图，右图表示左图所对应的支配树。对象 A 和 B 由根对象直接支配，由于在到对象 C 的路径中，可以经过 A，也可以经过 B，因此对象 C 的直接支配者也是根对象。对象 F 与对象 D 相互引用，因为到对象 F 的所有路径必然经过对象 D，因此，对象 D 是对象 F 的直接支配者。而到对象 D 的所有路径中，必然经过对象 C，即使是从对象 F 到对象 D 的引用，从根节点出发，也是经过对象 C 的，所以，对象 D 的直接支配者为对象 C。同理，对象 E 支配对象 G。到达对象 H 的可以通过对象 D，也可以通过对象 E，因此对象 D 和 E 都不能支配对象 H，而经过对象 C 既可以到达 D 也可以到达 E，因此对象 C 为对象 H 的直接支配者。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4aea560be1feff266c7cb79c6a3a27ec.png" alt="image-20210505151951136"></p>
<h2 id="6-内存泄漏（memory-leak）"><a href="#6-内存泄漏（memory-leak）" class="headerlink" title="6. 内存泄漏（memory leak）"></a>6. 内存泄漏（memory leak）</h2><p>可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多种内存泄漏问题（让 JVM 误以为此对象还在引用中，无法回收，造成内存泄漏）。</p>
<p>＞ 是否还被使用？是</p>
<p>＞ 是否还被需要？否</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d5715ef16f3d967f6a79c82909877c15.png" alt="image-20210505152542224"></p>
<p>严格来说，只有对象不会再被程序用到了，但是 GC 又不能回收他们的情况，才叫内存泄漏。但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致 00M，也可以叫做宽泛意义上的“内存泄漏”。</p>
<p>如下图，当 Y 生命周期结束的时候，X 依然引用着 Y，这时候，垃圾回收期是不会回收对象 Y 的；如果对象 X 还引用着生命周期比较短的 A、B、C，对象 A 又引用着对象 a、b、c，这样就可能造成大量无用的对象不能被回收，进而占据了内存资源，造成内存泄漏，直到内存溢出。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/98ee5c3507d1b8b73f4e12789728c56c.png" alt="image-20210505152704141"></p>
<p>申请了内存用完了不释放，比如一共有 1024M 的内存，分配了 512M 的内存一直不回收，那么可以用的内存只有 512M 了，仿佛泄露掉了一部分；通俗一点讲的话，内存泄漏就是【占着茅坑不拉 shi】</p>
<h2 id="7-内存溢出（out-of-memory）"><a href="#7-内存溢出（out-of-memory）" class="headerlink" title="7. 内存溢出（out of memory）"></a>7. 内存溢出（out of memory）</h2><p>申请内存时，没有足够的内存可以使用；通俗一点儿讲，一个厕所就三个坑，有两个站着茅坑不走的（内存泄漏），剩下最后一个坑，厕所表示接待压力很大，这时候一下子来了两个人，坑位（内存）就不够了，内存泄漏变成内存溢出了。可见，内存泄漏和内存溢出的关系：内存泄漏的增多，最终会导致内存溢出。</p>
<p>泄漏的分类</p>
<ul>
<li>经常发生：发生内存泄露的代码会被多次执行，每次执行，泄露一块内存；</li>
<li>偶然发生：在某些特定情况下才会发生</li>
<li>一次性：发生内存泄露的方法只会执行一次；</li>
<li>隐式泄漏：一直占着内存不释放，直到执行结束；严格的说这个不算内存泄漏，因为最终释放掉了，但是如果执行时间特别长，也可能会导致内存耗尽。</li>
</ul>
<h2 id="8-Java-中内存泄露的-8-种情况"><a href="#8-Java-中内存泄露的-8-种情况" class="headerlink" title="8. Java 中内存泄露的 8 种情况"></a>8. Java 中内存泄露的 8 种情况</h2><h3 id="8-1-静态集合类"><a href="#8-1-静态集合类" class="headerlink" title="8.1. 静态集合类"></a>8.1. 静态集合类</h3><p>静态集合类，如 HashMap、LinkedList 等等。如果这些容器为静态的，那么它们的生命周期与 JVM 程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MemoryLeak &#123;</span><br><span class="line">    static List list = new ArrayList();</span><br><span class="line">    public void oomTests()&#123;</span><br><span class="line">        Object obj＝new Object();//局部变量</span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-单例模式"><a href="#8-2-单例模式" class="headerlink" title="8.2. 单例模式"></a>8.2. 单例模式</h3><p>单例模式，和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和 JVM 的生命周期一样长，所以如果单例对象如果持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏。</p>
<h3 id="8-3-内部类持有外部类"><a href="#8-3-内部类持有外部类" class="headerlink" title="8.3. 内部类持有外部类"></a>8.3. 内部类持有外部类</h3><p>内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。</p>
<h3 id="8-4-各种连接，如数据库连接、网络连接和-IO-连接等"><a href="#8-4-各种连接，如数据库连接、网络连接和-IO-连接等" class="headerlink" title="8.4. 各种连接，如数据库连接、网络连接和 IO 连接等"></a>8.4. 各种连接，如数据库连接、网络连接和 IO 连接等</h3><p>在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用 close 方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对 Connection、Statement 或 ResultSet 不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        Connection conn =null;</span><br><span class="line">        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        conn =DriverManager.getConnection(&quot;url&quot;,&quot;&quot;,&quot;&quot;);</span><br><span class="line">        Statement stmt =conn.createStatement();</span><br><span class="line">        ResultSet rs =stmt.executeQuery(&quot;....&quot;);</span><br><span class="line">    &#125; catch（Exception e）&#123;//异常日志</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 1．关闭结果集 Statement</span><br><span class="line">        // 2．关闭声明的对象 ResultSet</span><br><span class="line">        // 3．关闭连接 Connection</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-5-变量不合理的作用域"><a href="#8-5-变量不合理的作用域" class="headerlink" title="8.5. 变量不合理的作用域"></a>8.5. 变量不合理的作用域</h3><p>变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为 null，很有可能导致内存泄漏的发生。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UsingRandom &#123;</span><br><span class="line">    private String msg;</span><br><span class="line">    public void receiveMsg()&#123;</span><br><span class="line">        readFromNet();//从网络中接受数据保存到msg中</span><br><span class="line">        saveDB();//把msg保存到数据库中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面这个伪代码，通过 readFromNet 方法把接受的消息保存在变量 msg 中，然后调用 saveDB 方法把 msg 的内容保存到数据库中，此时 msg 已经就没用了，由于 msg 的生命周期与对象的生命周期相同，此时 msg 还不能回收，因此造成了内存泄漏。实际上这个 msg 变量可以放在 receiveMsg 方法内部，当方法使用完，那么 msg 的生命周期也就结束，此时就可以回收了。还有一种方法，在使用完 msg 后，把 msg 设置为 null，这样垃圾回收器也会回收 msg 的内存空间。</p>
<h3 id="8-6-改变哈希值"><a href="#8-6-改变哈希值" class="headerlink" title="8.6. 改变哈希值"></a>8.6. 改变哈希值</h3><p>改变哈希值，当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。</p>
<p>否则，对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet 集合中单独删除当前对象，造成内存泄漏。</p>
<p>这也是 String 为什么被设置成了不可变类型，我们可以放心地把 String 存入 HashSet，或者把 String 当做 HashMap 的 key 值；</p>
<p>当我们想把自己定义的类保存到散列表的时候，需要保证对象的 hashCode 不可变。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 例1</span><br><span class="line"> */</span><br><span class="line">public class ChangeHashCode &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet set = new HashSet();</span><br><span class="line">        Person p1 = new Person(1001, &quot;AA&quot;);</span><br><span class="line">        Person p2 = new Person(1002, &quot;BB&quot;);</span><br><span class="line"></span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line"></span><br><span class="line">        p1.name = &quot;CC&quot;;//导致了内存的泄漏</span><br><span class="line">        set.remove(p1); //删除失败</span><br><span class="line"></span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(new Person(1001, &quot;CC&quot;));</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(new Person(1001, &quot;AA&quot;));</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    int id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    public Person(int id, String name) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (!(o instanceof Person)) return false;</span><br><span class="line"></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line"></span><br><span class="line">        if (id != person.id) return false;</span><br><span class="line">        return name != null ? name.equals(person.name) : person.name == null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        int result = id;</span><br><span class="line">        result = 31 * result + (name != null ? name.hashCode() : 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 例2</span><br><span class="line"> */</span><br><span class="line">public class ChangeHashCode1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;Point&gt; hs = new HashSet&lt;Point&gt;();</span><br><span class="line">        Point cc = new Point();</span><br><span class="line">        cc.setX(10);//hashCode = 41</span><br><span class="line">        hs.add(cc);</span><br><span class="line"></span><br><span class="line">        cc.setX(20);//hashCode = 51  此行为导致了内存的泄漏</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;hs.remove = &quot; + hs.remove(cc));//false</span><br><span class="line">        hs.add(cc);</span><br><span class="line">        System.out.println(&quot;hs.size = &quot; + hs.size());//size = 2</span><br><span class="line"></span><br><span class="line">        System.out.println(hs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Point &#123;</span><br><span class="line">    int x;</span><br><span class="line"></span><br><span class="line">    public int getX() &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setX(int x) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        final int prime = 31;</span><br><span class="line">        int result = 1;</span><br><span class="line">        result = prime * result + x;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object obj) &#123;</span><br><span class="line">        if (this == obj) return true;</span><br><span class="line">        if (obj == null) return false;</span><br><span class="line">        if (getClass() != obj.getClass()) return false;</span><br><span class="line">        Point other = (Point) obj;</span><br><span class="line">        if (x != other.x) return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Point&#123;&quot; +</span><br><span class="line">                &quot;x=&quot; + x +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-7-缓存泄露"><a href="#8-7-缓存泄露" class="headerlink" title="8.7. 缓存泄露"></a>8.7. 缓存泄露</h3><p>内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘。比如：之前项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载一个表中的数据到缓存（内存）中，测试环境只有几百条数据，但是生产环境有几百万的数据。</p>
<p>对于这个问题，可以使用 WeakHashMap 代表缓存，此种 Map 的特点是，当除了自身有对 key 的引用外，此 key 没有其他引用那么此 map 会自动丢弃此值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MapTest &#123;</span><br><span class="line">    static Map wMap = new WeakHashMap();</span><br><span class="line">    static Map map = new HashMap();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        init();</span><br><span class="line">        testWeakHashMap();</span><br><span class="line">        testHashMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void init() &#123;</span><br><span class="line">        String ref1 = new String(&quot;obejct1&quot;);</span><br><span class="line">        String ref2 = new String(&quot;obejct2&quot;);</span><br><span class="line">        String ref3 = new String(&quot;obejct3&quot;);</span><br><span class="line">        String ref4 = new String(&quot;obejct4&quot;);</span><br><span class="line">        wMap.put(ref1, &quot;cacheObject1&quot;);</span><br><span class="line">        wMap.put(ref2, &quot;cacheObject2&quot;);</span><br><span class="line">        map.put(ref3, &quot;cacheObject3&quot;);</span><br><span class="line">        map.put(ref4, &quot;cacheObject4&quot;);</span><br><span class="line">        System.out.println(&quot;String引用ref1，ref2，ref3，ref4 消失&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void testWeakHashMap() &#123;</span><br><span class="line">        System.out.println(&quot;WeakHashMap GC之前&quot;);</span><br><span class="line">        for (Object o : wMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;WeakHashMap GC之后&quot;);</span><br><span class="line">        for (Object o : wMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void testHashMap() &#123;</span><br><span class="line">        System.out.println(&quot;HashMap GC之前&quot;);</span><br><span class="line">        for (Object o : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;HashMap GC之后&quot;);</span><br><span class="line">        for (Object o : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码和图示主演演示 WeakHashMap 如何自动释放缓存对象，当 init 函数执行完成后，局部变量字符串引用 weakd1，weakd2，d1，d2 都会消失，此时只有静态 map 中保存中对字符串对象的引用，可以看到，调用 gc 之后，HashMap 的没有被回收，而 WeakHashMap 里面的缓存被回收了。</p>
<h3 id="8-8-监听器和其他回调"><a href="#8-8-监听器和其他回调" class="headerlink" title="8.8. 监听器和其他回调"></a>8.8. 监听器和其他回调</h3><p>内存泄漏第三个常见来源是监听器和其他回调，如果客户端在你实现的 API 中注册回调，却没有显示的取消，那么就会积聚。</p>
<p>需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存成为 WeakHashMap 中的键。</p>
<h2 id="9-内存泄露案例分析"><a href="#9-内存泄露案例分析" class="headerlink" title="9. 内存泄露案例分析"></a>9. 内存泄露案例分析</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Stack &#123;</span><br><span class="line">    private Object[] elements;</span><br><span class="line">    private int size = 0;</span><br><span class="line">    private static final int DEFAULT_INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">    public Stack() &#123;</span><br><span class="line">        elements = new Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(Object e) &#123; //入栈</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object pop() &#123; //出栈</span><br><span class="line">        if (size == 0)</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        return elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ensureCapacity() &#123;</span><br><span class="line">        if (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, 2 * size + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序并没有明显的错误，但是这段程序有一个内存泄漏，随着 GC 活动的增加，或者内存占用的不断增加，程序性能的降低就会表现出来，严重时可导致内存泄漏，但是这种失败情况相对较少。</p>
<p>代码的主要问题在 pop 函数，下面通过这张图示展现。假设这个栈一直增长，增长后如下图所示</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/36134d739f40208bf54a0b5c89a8f882.png" alt="image-20210505160114618"></p>
<p>当进行大量的 pop 操作时，由于引用未进行置空，gc 是不会释放的，如下图所示</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/52eed9c8a0279db4b1f07fd23c0d5eca.png" alt="image-20210505160158618"></p>
<p>从上图中看以看出，如果栈先增长，再收缩，那么从栈中弹出的对象将不会被当作垃圾回收，即使程序不再使用栈中的这些队象，他们也不会回收，因为栈中仍然保存这对象的引用，俗称过期引用，这个内存泄露很隐蔽。</p>
<p>将代码中的 pop()方法变成如下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object pop() &#123;</span><br><span class="line">    if (size == 0)</span><br><span class="line">        throw new EmptyStackException();</span><br><span class="line">    Object result = elements[--size];</span><br><span class="line">    elements[size] = null;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦引用过期，清空这些引用，将引用置空。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/513c31471d30b0458114859524c35adc.png" alt="image-20210505160423289"></p>
]]></content>
      <categories>
        <category>jvm</category>
        <category>jvm理论</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm基础2之字节码与类的加载篇</title>
    <url>/9f1e208e.html</url>
    <content><![CDATA[<h1 id="jvm基础2"><a href="#jvm基础2" class="headerlink" title="jvm基础2"></a>jvm基础2</h1><h1 id="01概述"><a href="#01概述" class="headerlink" title="01概述"></a>01概述</h1><h2 id="字节码文件的跨平台性"><a href="#字节码文件的跨平台性" class="headerlink" title="字节码文件的跨平台性"></a>字节码文件的跨平台性</h2><h3 id="Java语言：跨平台的语言（write-once，run-anywhere"><a href="#Java语言：跨平台的语言（write-once，run-anywhere" class="headerlink" title="Java语言：跨平台的语言（write once，run anywhere"></a>Java语言：跨平台的语言（write once，run anywhere</h3><ul>
<li>当Java源代码成功编译成字节码后，如果想在不同的平台上运行，则无须再次编译</li>
<li>这个优势现在不在那么吸引人<ul>
<li><code>Python</code>、<code>PHP</code>、<code>Perl</code>、<code>Ruby</code>、<code>LISP</code>等都有强大的解释器</li>
</ul>
</li>
<li>跨平台似乎快成为了一门语言必选的特性。</li>
</ul>
<h3 id="Java虚拟机：跨语言的平台"><a href="#Java虚拟机：跨语言的平台" class="headerlink" title="Java虚拟机：跨语言的平台"></a>Java虚拟机：跨语言的平台</h3><span id="more"></span>

<p>Java虚拟机不和包括Java在内的任何语言绑定，它只和“class文件”这种特点的二进制文件格式所关联。无论使用何种语言进行软件开发，只要能将源文件编译成正确的Class文件，那么这种语言就可以在Java虚拟机上运行。可以说，统一而强大的Class文件结构，就是Java虚拟机的基石、桥梁。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210913100058369.png" alt="image-20210913100058369"></p>
<p>java文档说明：<a href="https://docs.oracle.com/javase/specs/index.html">https://docs.oracle.com/javase/specs/index.html</a></p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210913101146078.png" alt="image-20210913101146078" style="zoom:67%;" />



<p>我们主要是查看java8：</p>
<p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/index.html">https://docs.oracle.com/javase/specs/jls/se8/html/index.html</a></p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p>
<ul>
<li>所有的Jvm全部遵守<code>Java</code>虚拟机规范，也就是说所有的<code>jvm</code>环境都是一样 的，这样一来字节码文件就可以在各种jvm上运行</li>
</ul>
<h3 id="java源码必须编译为符合jvm规范的字节码"><a href="#java源码必须编译为符合jvm规范的字节码" class="headerlink" title="java源码必须编译为符合jvm规范的字节码"></a>java源码必须编译为符合jvm规范的字节码</h3><ul>
<li>前端编译器的主要任务就是负责将符合Java语法规范的Java代码转换为符合Jvm规范的字节码文件。</li>
<li>javac是一种能够将Java源码编译为字节码的前端编译器</li>
<li>javac编译器在将java源码编译为一个有效的字节码文件过程中经历了4个阶段，分别是词法解析、语法解析、语义解析以及生成字节码</li>
</ul>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210913102004220.png" alt="image-20210913102004220"></p>
<p>Oracle的JDK软件包括两部分内容：</p>
<ul>
<li>一部分是将Java源代码编译成Java虚拟机的指令集的编译器</li>
<li>另一部分是用于实习Java虚拟机的运行环境</li>
</ul>
<h2 id="前端编译器和后端编译器"><a href="#前端编译器和后端编译器" class="headerlink" title="前端编译器和后端编译器"></a>前端编译器和后端编译器</h2><h3 id="前端编译器"><a href="#前端编译器" class="headerlink" title="前端编译器"></a>前端编译器</h3><p><strong>将java文件编译成class文件的编译器。</strong></p>
<p>​        Java源代码的编译结果是字节码，那么肯定需要一种编译器能够将Java源码编译为字节码，承当这个重要责任的就是配置在<code>path</code>环境变量中的j<code>avac</code>编译器。javac是一种能够将Java源码编译为字节码的前端编译器。</p>
<p>​        <code>HotSpot VM</code>并没有强制要求前端编译器只能使用javac来编译字节码，其实只要编译结果符合JVM规范可以被JVM所识别即可。在Java的前端编译器领域，除了<code>javac</code>之外，还有一种被大家经常用到的前端编译器，那就是内置在Eclipse中的<code>ECJ（Eclipse Compiler for java）</code>编译器。和javac的全量式编译不同，<code>ECJ</code>是一种增量式编译器。</p>
<ul>
<li>在<code>Eclipse</code>中，当开发人员编写完代码后，使用“Ctrl+s”快捷键时，ECJ编译器锁采用的编译方案是把未编译部分的源码逐行进行编译，而非每次都进行全量编译。因此<code>ECJ</code>的编译效率会比javac更加迅速和高效，当然编译质量和javac相比大致还是一样的。</li>
<li>ECJ不仅是Eclipse的默认内置前端编译器，在Tomcat中同样也是使用ECJ编译器来编译jsp文件。由于<code>ECJ</code>编译器是采用<code>GPLv2</code>开源协议进行源代码公开，所以，大家可以登录eclipse官网下载<code>ECJ</code>编译器的源码进行二次开发。</li>
<li>默认情况下，<code>Intelij IDEA</code>使用<code>javac</code>编译器。（还可以自己设置为<code>AspectJ </code>编译器<code> ajc</code>）</li>
</ul>
<p>前端编译器并不会直接涉及编译优化等方面的技术，而是将这些具体优化细节交给HotSpot的JIT编译器负责</p>
<p>复习：<code>AOT</code>（静态提前编译器，<code>Ahead of Time Compile</code>r） </p>
<h3 id="后端编译器"><a href="#后端编译器" class="headerlink" title="后端编译器"></a>后端编译器</h3><p>将Class文件编译为与本地机器上可以识别的二进制指令的编译器。</p>
<p>主要有解释执行的解释器和编译执行的编译器。</p>
<p>目前主流的虚拟机都是解释器和编译器并存的运行架构，解释器和编译器各有优势。</p>
<h2 id="深入字节码观察"><a href="#深入字节码观察" class="headerlink" title="深入字节码观察"></a>深入字节码观察</h2><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="面试题1"><a href="#面试题1" class="headerlink" title="面试题1"></a>面试题1</h4><p>类文件结构有几个部分</p>
<p>答案在Class文件结构章节</p>
<h4 id="面试题2"><a href="#面试题2" class="headerlink" title="面试题2"></a>面试题2</h4><p>知道字节码吗，字节码都有哪些？比较下面代码<code>x == y</code>都经过了哪些过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">interview</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer x = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line">        System.out.println(x == y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确答案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>通过idea的工具jClasslib插件查看main方法的code，发现：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210913142135732.png" alt="image-20210913142135732"></p>
<p>然后我们去Integer中查看Valueof和intValue方法</p>
<h5 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.valueOf(parseInt(s, <span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里调用了</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="comment">// 如果在缓存里面，这从这个缓存数组中取出值（这个值是integer对象）</span></span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Integer的内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义最小值为-128</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="comment">// 定义一个缓存数组</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="comment">// high 的默认值为127</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        <span class="comment">// 从vm中拿到high的数值，这个数值可以通过vm参数配置</span></span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果拿到了这个值，说明进行了vm配置</span></span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 把这个值转化为int类型</span></span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                <span class="comment">// 这个值得最小值要大于等于127</span></span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                <span class="comment">// 这个值得最大值是2147483518，也就是整个cache数组的长度为Integer的最大值</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        high = h;</span><br><span class="line">		<span class="comment">// 定义cache数组的长度</span></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="comment">// 为这个cache填充值，这些都是Integer对象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="comment">// 断言这个值得最大值大于等于127</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 私有化构造方法，jvm级别单例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="intValue"><a href="#intValue" class="headerlink" title="intValue"></a>intValue</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回了int类型的一个值value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个vlaue在创建Integer对象的时候</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="comment">// 在一步调用了new Integer()的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol>
<li>在创建一个integer的对象的时候，回调用valueOf方法<ol>
<li>valueOf方法回去调用IntegerCache中的一个值<ol>
<li>IntegerCache<ol>
<li>如果没被初始化，则优先从jvm参数中读取值进行初始化</li>
<li>如果初始化过了则直接拿到值，直接就返回了</li>
</ol>
</li>
<li>然后调用new Integer(i)方法</li>
</ol>
</li>
</ol>
</li>
<li>然后把这个对象放入栈中的局部变量表</li>
<li>然后判断的时候，调用intValue方法，然后int类型的值</li>
<li>两个int类型的值进行判断</li>
</ol>
<h3 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h3><h4 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">interview2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Integer a1 = <span class="number">10</span>;</span><br><span class="line">        Integer a2 = <span class="number">10</span>;</span><br><span class="line">        System.out.println(a1 == a2);</span><br><span class="line"></span><br><span class="line">        Integer a3 = <span class="number">128</span>;</span><br><span class="line">        Integer a4 = <span class="number">128</span>;</span><br><span class="line">        System.out.println(a3 == a4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我的答案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>正确答案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>这道题我之前见过</p>
<p>详解参考上面，默认情况下-128到127的数都是存放在缓存数组中的</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20191019215314818.png" alt="在这里插入图片描述"></p>
<h4 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">interview3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        String str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        str1 += <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;helloWorld&quot;</span>;</span><br><span class="line">        System.out.println(str == str1);</span><br><span class="line">        System.out.println(str == str2);</span><br><span class="line">        System.out.println(str1 == str2);</span><br><span class="line">        String str3 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        System.out.println(str2 == str3);</span><br><span class="line">        String str4 = <span class="string">&quot;helloWorld&quot;</span>;</span><br><span class="line">        System.out.println(str2 == str4);</span><br><span class="line">        String str5 = <span class="keyword">new</span> String(<span class="string">&quot;helloWorld&quot;</span>);</span><br><span class="line">        System.out.println(str2 == str5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我的答案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>正确答案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>因为在第一节学习的时候我记得，这个字符串全部是存在在常量池中的，创建一个字符串如果常量池中有这个字符串会直接指向字符串，而且字符串拼接的时候每次都会创建一个新的字符串对象。</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210913153657364.png" alt="image-20210913153657364" style="zoom:67%;" />

<p>通过字节码我们可以看出来，在每次传化为字符串的时候都调用了一个toString方法，而这个方法是新创建了一个string对象。两个不同的string对象用==肯定是不想等的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a copy, don&#x27;t share the array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="举例3"><a href="#举例3" class="headerlink" title="举例3"></a>举例3</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">interview4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println(father.x); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.print();</span><br><span class="line">            x = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Father.x = &quot;</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.print();</span><br><span class="line">            x = <span class="number">40</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Son.x = &quot;</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我的答案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Father.x = <span class="number">0</span></span><br><span class="line">Son.x = <span class="number">40</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>正确答案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Son.x = <span class="number">0</span></span><br><span class="line">Son.x = <span class="number">30</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>

<ol>
<li>父类、子类变量的默认初始化</li>
<li>初始化父类的成员变量，x = 10</li>
<li>执行父类的构造方法</li>
<li>执行print方法，然后发现当前子类的print方法对父类的方法进行了重写（多态性），这个时候就调用了son的print方法</li>
<li>应为son的变量只进行了默认初始化，所以这个时候打印的为0</li>
<li>继续执行父类构造器中x=20</li>
<li>回到子类，执行子类的成员变量赋值x=30</li>
<li>执行子类的构造器，调用print方法，打印的值为30</li>
<li>创建对象成功</li>
<li>打印Father对象的x对象（属性不存在多肽，没有重写）</li>
</ol>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>初始化顺序</p>
<ol>
<li><p>静态代码块、静态成员变量只有第一次加载类的时候才会执行</p>
</li>
<li><p>执行顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">默认初始化</span><br><span class="line">父类静态代码块及父类静态成员变量（并列优先级看代码顺序）</span><br><span class="line">子类静态代码块及子类静态成员变量（并列优先级看代码顺序）</span><br><span class="line">父类普通代码块及父类成员变量</span><br><span class="line">父类构造器</span><br><span class="line">子类普通代码块及子类成员变量</span><br><span class="line">子类构造器</span><br><span class="line">有了对象后，用直接对对象属性赋值    </span><br></pre></td></tr></table></figure></li>
<li><p>静态内部类，只有在第一次调用的时候才会被初始化</p>
</li>
</ol>
<h1 id="02虚拟机的基石：Class文件"><a href="#02虚拟机的基石：Class文件" class="headerlink" title="02虚拟机的基石：Class文件"></a>02虚拟机的基石：Class文件</h1><h2 id="字节码文件是什么"><a href="#字节码文件是什么" class="headerlink" title="字节码文件是什么"></a>字节码文件是什么</h2><p>源代码经过编译器编译后会生成一个字节码文件，字节码是一种二进制的类文件，它的内容是JVM的指令，而不像C、C++由编译器直接生成机器码</p>
<h2 id="什么是字节码指令（byte-code）"><a href="#什么是字节码指令（byte-code）" class="headerlink" title="什么是字节码指令（byte code）"></a>什么是字节码指令（byte code）</h2><p>Java虚拟机的指令由一个字节长、代表着某种特定操作含义的操作码（opcode）以及跟随其后的零至多个代表此操作所需参数的操作数（operand）所构成。虚拟机中许多指令并不包含操作数，只有一个操作码。</p>
<p>比如：操作码+操作数（操作数在有些指令中没有）</p>
<p>存放指令到本地变量（Store <code>reference</code> into local variable）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">astore_1</span><br><span class="line"><span class="comment">//只有一个操作码</span></span><br></pre></td></tr></table></figure>

<p>存放字节到操作数栈（Push <code>byte</code>，The immediate <em>byte</em> is sign-extended to an <code>int</code> <em>value</em>. That <em>value</em> is pushed onto the operand stack.）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bipush <span class="number">10</span></span><br><span class="line"><span class="comment">//操作码+操作数</span></span><br></pre></td></tr></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210913170148044.png" alt="image-20210913170148044"></p>
<h2 id="如何解读"><a href="#如何解读" class="headerlink" title="如何解读"></a>如何解读</h2><p>那如何解读供虚拟机解释执行的二进制字节码？</p>
<h3 id="方法一：notepad"><a href="#方法一：notepad" class="headerlink" title="方法一：notepad++"></a>方法一：notepad++</h3><p>一个一个二进制的看。这里用的是notePad++，需要安装一个hex-editor插件，或者使用Binary Viewer</p>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>插件下载地址：<a href="https://github.com/chcg/NPP_HexEdit/releases">https://github.com/chcg/NPP_HexEdit/releases</a></p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210913171222155.png" alt="image-20210913171222155" style="zoom:50%;" />

<p>我是x86_64位，选择x64的下载</p>
<p>arm64：arm架构的64位指令集，最近苹果M1芯片就是用的arm架构</p>
<p>Win32：：所有32位的平台，不仅仅是x86</p>
<p>X64：x86的64位,Inter和AMD的主流</p>
<p>source code(zip)：zip压缩的源代码文件，一般主要是windows</p>
<p>souce code（tar.gz）:tar.gz压缩的源代码文件，常用与windows</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ol>
<li><p>下载后，解压储一个dll文件</p>
</li>
<li><p>打开Notepad++，选择插件、打开插件目录，创建文件夹HexEditor</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210913171112450.png" alt="image-20210913171112450" style="zoom:67%;" /></li>
<li><p>然后把这个dll文件放在HexEditor目录中</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210913171208848.png" alt="image-20210913171208848"></p>
</li>
<li><p>重启Notepad++</p>
</li>
</ol>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210913172423198.png" alt="image-20210913172423198"></p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210913174409951.png" alt="image-20210913174409951" style="zoom:50%;" />

<p>但是这个没有看到CA FE BA BE，我猜测可能是因为读取进制的问题，但是我调整后没有成功</p>
<h3 id="方法二：使用Binary-Viewer"><a href="#方法二：使用Binary-Viewer" class="headerlink" title="方法二：使用Binary Viewer"></a>方法二：使用Binary Viewer</h3><p>这个直接搜索下载安装就行了，特别小</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210913174628188.png" alt="image-20210913174628188"></p>
<h3 id="方法三：使用javap指令"><a href="#方法三：使用javap指令" class="headerlink" title="方法三：使用javap指令"></a>方法三：使用javap指令</h3><p>jdk自带的反解析工具</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210913174910767.png" alt="image-20210913174910767"></p>
<h3 id="方法四：jclasslib-bytecode-viewer（推荐）"><a href="#方法四：jclasslib-bytecode-viewer（推荐）" class="headerlink" title="方法四：jclasslib bytecode viewer（推荐）"></a>方法四：jclasslib bytecode viewer（推荐）</h3><p>使用jclasslib bytecode viewer，这个在jvm基础1中安装过了，或者直接搜索安装教程就行</p>
<h1 id="03-Class-文件结构"><a href="#03-Class-文件结构" class="headerlink" title="03-Class 文件结构"></a>03-Class 文件结构</h1><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210911215600796.png" alt="image-20210911215600796" style="zoom:67%;" />





<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>官方文档位置：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p>
<h3 id="Class类的本质"><a href="#Class类的本质" class="headerlink" title="Class类的本质"></a>Class类的本质</h3><p>任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说Class文件实际上它并不一定以磁盘文件形式存在。Class文件是一组以字节为基础单位的二进制流，在内存中的表现形式为字节数组</p>
<h3 id="Class文件格式"><a href="#Class文件格式" class="headerlink" title="Class文件格式"></a>Class文件格式</h3><ul>
<li>Class的结构不像XML等描述语言，由于它没有任何分隔符号。所以在其中的数据项，无论是字节顺序还是数量，都是被严格限定的。哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变</li>
</ul>
<p>Class文件格式采用一种类似于C语言结构体的方式进行数据存储，这种结构中只有两种数据类型：无符号数和表  </p>
<ul>
<li><p>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节、8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值</p>
</li>
<li><p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以”_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。由于表没有固定长度，所以通常会在其前面加上个数说明</p>
</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        num = num + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="原始字节码文件"><a href="#原始字节码文件" class="headerlink" title="原始字节码文件"></a>原始字节码文件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cafe babe <span class="number">0000</span> <span class="number">0034</span> <span class="number">0016</span> 0a00 <span class="number">0400</span> <span class="number">1209</span></span><br><span class="line"><span class="number">0003</span> <span class="number">0013</span> <span class="number">0700</span> <span class="number">1407</span> <span class="number">0015</span> <span class="number">0100</span> 036e <span class="number">756d</span></span><br><span class="line"><span class="number">0100</span> 0149 <span class="number">0100</span> 063c 696e <span class="number">6974</span> <span class="number">3e01</span> <span class="number">0003</span></span><br><span class="line"><span class="number">2829</span> <span class="number">5601</span> <span class="number">0004</span> <span class="number">436f</span> <span class="number">6465</span> <span class="number">0100</span> 0f4c 696e</span><br><span class="line">654e <span class="number">756d</span> <span class="number">6265</span> <span class="number">7254</span> <span class="number">6162</span> 6c65 <span class="number">0100</span> 124c</span><br><span class="line">6f63 616c <span class="number">5661</span> <span class="number">7269</span> <span class="number">6162</span> 6c65 <span class="number">5461</span> 626c</span><br><span class="line"><span class="number">6501</span> <span class="number">0004</span> <span class="number">7468</span> <span class="number">6973</span> <span class="number">0100</span> 184c <span class="number">636f</span> 6d2f</span><br><span class="line"><span class="number">6174</span> <span class="number">6775</span> <span class="number">6967</span> <span class="number">752f</span> 6a61 <span class="number">7661</span> <span class="number">312f</span> <span class="number">4465</span></span><br><span class="line">6d6f 3b01 <span class="number">0003</span> <span class="number">6164</span> <span class="number">6401</span> <span class="number">0003</span> <span class="number">2829</span> <span class="number">4901</span></span><br><span class="line">000a <span class="number">536f</span> <span class="number">7572</span> <span class="number">6365</span> <span class="number">4669</span> 6c65 <span class="number">0100</span> 0944</span><br><span class="line"><span class="number">656d</span> 6f2e 6a61 <span class="number">7661</span> 0c00 <span class="number">0700</span> 080c <span class="number">0005</span></span><br><span class="line"><span class="number">0006</span> <span class="number">0100</span> <span class="number">1663</span> 6f6d 2f61 <span class="number">7467</span> <span class="number">7569</span> <span class="number">6775</span></span><br><span class="line">2f6a <span class="number">6176</span> <span class="number">6131</span> 2f44 <span class="number">656d</span> 6f01 <span class="number">0010</span> 6a61</span><br><span class="line"><span class="number">7661</span> 2f6c 616e <span class="number">672f</span> 4f62 6a65 <span class="number">6374</span> <span class="number">0021</span></span><br><span class="line"><span class="number">0003</span> <span class="number">0004</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0002</span> <span class="number">0005</span> <span class="number">0006</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0002</span> <span class="number">0001</span> <span class="number">0007</span> 0008 <span class="number">0001</span> 0009 <span class="number">0000</span> 0038</span><br><span class="line"><span class="number">0002</span> <span class="number">0001</span> <span class="number">0000</span> 000a 2ab7 <span class="number">0001</span> 2a04 b500</span><br><span class="line">02b1 <span class="number">0000</span> <span class="number">0002</span> 000a <span class="number">0000</span> 000a <span class="number">0002</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0007</span> <span class="number">0004</span> 0008 000b <span class="number">0000</span> 000c <span class="number">0001</span> <span class="number">0000</span></span><br><span class="line">000a 000c <span class="number">000d</span> <span class="number">0000</span> <span class="number">0001</span> 000e <span class="number">000f</span> <span class="number">0001</span></span><br><span class="line">0009 <span class="number">0000</span> <span class="number">003d</span> <span class="number">0003</span> <span class="number">0001</span> <span class="number">0000</span> <span class="number">000f</span> 2a2a</span><br><span class="line">b400 <span class="number">0205</span> 60b5 <span class="number">0002</span> 2ab4 <span class="number">0002</span> ac00 <span class="number">0000</span></span><br><span class="line"><span class="number">0200</span> 0a00 <span class="number">0000</span> 0a00 <span class="number">0200</span> <span class="number">0000</span> <span class="number">0b00</span> 0a00</span><br><span class="line">0c00 <span class="number">0b00</span> <span class="number">0000</span> 0c00 <span class="number">0100</span> <span class="number">0000</span> 0f00 0c00</span><br><span class="line">0d00 <span class="number">0000</span> <span class="number">0100</span> <span class="number">1000</span> <span class="number">0000</span> <span class="number">0200</span> <span class="number">11</span></span><br></pre></td></tr></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/601902c4637689536e154818.png" alt="601902c4637689536e154818"></p>
<h3 id="总体文件结构"><a href="#总体文件结构" class="headerlink" title="总体文件结构"></a>总体文件结构</h3><ul>
<li>魔数(magic)</li>
<li>Class文件版本(minor_version,major_version)</li>
<li>常量池(constant_pool_count)</li>
<li>访问标志(access_flags)</li>
<li>类索引，父类索引，接口索引集合(clsss/interfaces)</li>
<li>字段表集合(fields)</li>
<li>方法表集合(methods)</li>
<li>属性表集合(attribute)</li>
</ul>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210913213521629.png" alt="image-20210913213521629"></p>
<h2 id="1-1-Class-字节码文件结构"><a href="#1-1-Class-字节码文件结构" class="headerlink" title="1.1. Class 字节码文件结构"></a>1.1. Class 字节码文件结构</h2><table>
<thead>
<tr>
<th></th>
<th>类型</th>
<th>名称</th>
<th>说明</th>
<th>长度</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>魔数</td>
<td>u4</td>
<td>magic</td>
<td>魔数,识别Class文件格式</td>
<td>4个字节</td>
<td>1</td>
</tr>
<tr>
<td>版本号</td>
<td>u2</td>
<td>minor_version</td>
<td>副版本号(小版本)</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>major_version</td>
<td>主版本号(大版本)</td>
<td>2个字节</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>常量池集合</td>
<td>u2</td>
<td>constant_pool_count</td>
<td>常量池计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>常量池表</td>
<td>n个字节</td>
<td>constant_pool_count - 1</td>
<td></td>
</tr>
<tr>
<td>访问标识</td>
<td>u2</td>
<td>access_flags</td>
<td>访问标识</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>索引集合</td>
<td>u2</td>
<td>this_class</td>
<td>类索引</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>父类索引</td>
<td>2个字节</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
<td>接口计数器</td>
<td>2个字节</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>u2</td>
<td>interfaces</td>
<td>接口索引集合</td>
<td>2个字节</td>
<td>interfaces_count</td>
<td></td>
</tr>
<tr>
<td>字段表集合</td>
<td>u2</td>
<td>fields_count</td>
<td>字段计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>字段表</td>
<td>n个字节</td>
<td>fields_count</td>
<td></td>
</tr>
<tr>
<td>方法表集合</td>
<td>u2</td>
<td>methods_count</td>
<td>方法计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods</td>
<td>方法表</td>
<td>n个字节</td>
<td>methods_count</td>
<td></td>
</tr>
<tr>
<td>属性表集合</td>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性表</td>
<td>n个字节</td>
<td>attributes_count</td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-2-Class-文件数据类型"><a href="#1-2-Class-文件数据类型" class="headerlink" title="1.2. Class 文件数据类型"></a>1.2. Class 文件数据类型</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>定义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>无符号数</td>
<td>无符号数可以用来描述数字、索引引用、数量值或按照 utf-8 编码构成的字符串值。</td>
<td>其中无符号数属于基本的数据类型。 以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节</td>
</tr>
<tr>
<td>表</td>
<td>表是由多个无符号数或其他表构成的复合数据结构。</td>
<td>所有的表都以“_info”结尾。 由于表没有固定长度，所以通常会在其前面加上个数说明。</td>
</tr>
</tbody></table>
<h2 id="1-3-魔数"><a href="#1-3-魔数" class="headerlink" title="1.3. 魔数"></a>1.3. 魔数</h2><p><strong>Magic Number（魔数）</strong></p>
<ul>
<li><p>每个 Class 文件开头的 4 个字节（<code>ca fe ba be</code>）的无符号整数称为魔数（Magic Number）</p>
<ul>
<li><p>魔数不仅仅应用于class，在每个类型的文件用二进制打开都有这样的魔数标志</p>
</li>
<li><p>例如：</p>
<ul>
<li>png</li>
</ul>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210913212011402.png" alt="image-20210913212011402"></p>
</li>
</ul>
</li>
<li><p>它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的 Class 文件。即：魔数是 Class 文件的标识符。</p>
</li>
<li><p>魔数值固定为 0xCAFEBABE。不会改变。</p>
</li>
<li><p>如果一个 Class 文件不以 0xCAFEBABE 开头，虚拟机在进行文件校验的时候就会直接抛出以下错误：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error: A JNI error has occurred, please check your installation and try again</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassFormatError: Incompatible magic value 1885430635 in class file StringTest</span><br></pre></td></tr></table></figure>

<ul>
<li>使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。</li>
</ul>
<h2 id="1-4-文件版本号"><a href="#1-4-文件版本号" class="headerlink" title="1.4. 文件版本号"></a>1.4. 文件版本号</h2><p>紧接着魔数的 4 个字节存储的是 Class 文件的版本号。同样也是 4 个字节。第 5 个和第 6 个字节所代表的含义就是编译的副版本号 minor_version，而第 7 个和第 8 个字节就是编译的主版本号 major_version。</p>
<p>它们共同构成了 class 文件的格式版本号。譬如某个 Class 文件的主版本号为 M，副版本号为 m，那么这个 Class 文件的格式版本号就确定为 M.m。</p>
<p>版本号和 Java 编译器的对应关系如下表：</p>
<h3 id="1-4-1-Class-文件版本号对应关系"><a href="#1-4-1-Class-文件版本号对应关系" class="headerlink" title="1.4.1. Class 文件版本号对应关系"></a>1.4.1. Class 文件版本号对应关系</h3><table>
<thead>
<tr>
<th>主版本（十进制）</th>
<th>副版本（十进制）</th>
<th>编译器版本</th>
</tr>
</thead>
<tbody><tr>
<td>45</td>
<td>3</td>
<td>1.1</td>
</tr>
<tr>
<td>46</td>
<td>0</td>
<td>1.2</td>
</tr>
<tr>
<td>47</td>
<td>0</td>
<td>1.3</td>
</tr>
<tr>
<td>48</td>
<td>0</td>
<td>1.4</td>
</tr>
<tr>
<td>49</td>
<td>0</td>
<td>1.5</td>
</tr>
<tr>
<td>50</td>
<td>0</td>
<td>1.6</td>
</tr>
<tr>
<td>51</td>
<td>0</td>
<td>1.7</td>
</tr>
<tr>
<td><strong>52</strong></td>
<td><strong>0</strong></td>
<td><strong>1.8</strong></td>
</tr>
<tr>
<td>53</td>
<td>0</td>
<td>1.9</td>
</tr>
<tr>
<td>54</td>
<td>0</td>
<td>1.10</td>
</tr>
<tr>
<td>55</td>
<td>0</td>
<td>1.11</td>
</tr>
</tbody></table>
<p>Java 的版本号是从 45 开始的，JDK1.1 之后的每个 JDK 大版本发布主版本号向上加 1。</p>
<p>不同版本的 Java 编译器编译的 Class 文件对应的版本是不一样的。目前，高版本的 Java 虚拟机可以执行由低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行由高版本编译器生成的 Class 文件。否则 JVM 会抛出 java.lang.UnsupportedClassVersionError 异常。（向下兼容）</p>
<p>在实际应用中，由于开发环境和生产环境的不同，可能会导致该问题的发生。因此，需要我们在开发时，特别注意开发编译的 JDK 版本和生产环境中的 JDK 版本是否一致。</p>
<ul>
<li>虚拟机 JDK 版本为 1.k（k&gt;=2）时，对应的 class 文件格式版本号的范围为 45.0 - 44+k.0（含两端）。</li>
</ul>
<h2 id="1-5-常量池集合"><a href="#1-5-常量池集合" class="headerlink" title="1.5. 常量池集合"></a>1.5. 常量池集合</h2><p>常量池是 Class 文件中内容最为丰富的区域之一。常量池对于 Class 文件中的字段和方法解析也有着至关重要的作用。</p>
<p>随着 Java 虚拟机的不断发展，常量池的内容也日渐丰富。可以说，常量池是整个 Class 文件的基石。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210913213608155.png" alt="image-20210913213608155"></p>
<p>在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项。</p>
<p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的无符号数，代表常量池容量计数值（constant_pool_count）。与 Java 中语言习惯不一样的是，这个容量计数是从 1 而不是 0 开始的。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>u2（无符号数）</td>
<td>constant_pool_count</td>
<td>1</td>
<td>常量池计数器</td>
</tr>
<tr>
<td>cp_info（表）</td>
<td>constant_pool</td>
<td>constant_pool_count - 1</td>
<td>常量池表</td>
</tr>
</tbody></table>
<p>由上表可见，Class 文件使用了一个前置的容量计数器（constant_pool_count）加若干个连续的数据项（constant_pool）的形式来描述常量池内容。我们把这一系列连续常量池数据称为常量池集合。</p>
<ul>
<li>常量池表项中，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放</li>
</ul>
<h3 id="1-5-1-常量池计数器"><a href="#1-5-1-常量池计数器" class="headerlink" title="1.5.1. 常量池计数器"></a>1.5.1. 常量池计数器</h3><p><strong>constant_pool_count（常量池计数器）</strong></p>
<ul>
<li>由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示常量池容量计数值。</li>
<li>常量池容量计数值（u2 类型）：从 1 开始，表示常量池中有多少项常量。即 constant_pool_count=1 表示常量池中有 0 个常量项。</li>
<li>Demo 的值为：</li>
</ul>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/a17ef03e0783c664a51491aafde85d2a.png" alt="image-20210508234020104"></p>
<p>其值为 0x0016，掐指一算，也就是 22。需要注意的是，这实际上只有 21 项常量。索引为范围是 1-21。为什么呢？</p>
<p>通常我们写代码时都是从 0 开始的，但是这里的常量池却是从 1 开始，因为它把第 0 项常量空出来了。这是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“<strong>不引用任何一个常量池项目</strong>”的含义，这种情况可用索引值 0 来表示。</p>
<h3 id="1-5-2-常量池表"><a href="#1-5-2-常量池表" class="headerlink" title="1.5.2. 常量池表"></a>1.5.2. 常量池表</h3><p>constant_pool 是一种表结构，以 1 ~ constant_pool_count - 1 为索引。表明了后面有多少个常量项。</p>
<p>常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）</p>
<p>它包含了 class 文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第 1 个字节作为类型标记，用于确定该项的格式，这个字节称为 tag byte（标记字节、标签字节）。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志(或标识)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_Utf8_info</td>
<td>1</td>
<td>UTF-8 编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>5</td>
<td>长整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>6</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>7</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>8</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段或方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_MethodType_info</td>
<td>16</td>
<td>标志方法类型</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td>18</td>
<td>表示一个动态方法调用点</td>
</tr>
</tbody></table>
<h4 id="Ⅰ-字面量和符号引用"><a href="#Ⅰ-字面量和符号引用" class="headerlink" title="Ⅰ. 字面量和符号引用"></a>Ⅰ. 字面量和符号引用</h4><p>在对这些常量解读前，我们需要搞清楚几个概念。</p>
<p>常量池主要存放两大类常量：字面量（<code>Literal</code>）和符号引用（<code>Symbolic References</code>）。如下表：</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>具体的常量</th>
</tr>
</thead>
<tbody><tr>
<td>字面量</td>
<td>文本字符串</td>
</tr>
<tr>
<td></td>
<td>声明为 final 的常量值</td>
</tr>
<tr>
<td>符号引用</td>
<td>类和接口的全限定名</td>
</tr>
<tr>
<td></td>
<td>字段的名称和描述符</td>
</tr>
<tr>
<td></td>
<td>方法的名称和描述符</td>
</tr>
</tbody></table>
<p><strong>全限定名</strong></p>
<p>全类名：<code>top.lvxiaoyi.classstruct.Demo</code></p>
<p>全限定名：<code>top/lvxiaoyi/classstruct/Demo</code></p>
<p>仅仅是把包名的“.“替换成”/”，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“**;**”表示全限定名结束。</p>
<p><strong>简单名称</strong></p>
<p>简单名称是指没有类型和参数修饰的方法或者字段名称，上面例子中的类的 <code>add()</code>方法和 <code>num</code> 字段的简单名称分别是<code> add</code> 和<code>num</code>。</p>
<p><strong>描述符</strong></p>
<p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的 void 类型都用一个大写字符来表示，而对象类型则用字符 L 加对象的全限定名来表示，详见下表：</p>
<table>
<thead>
<tr>
<th>标志符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>基本数据类型 byte</td>
</tr>
<tr>
<td>C</td>
<td>基本数据类型 char</td>
</tr>
<tr>
<td>D</td>
<td>基本数据类型 double</td>
</tr>
<tr>
<td>F</td>
<td>基本数据类型 float</td>
</tr>
<tr>
<td>I</td>
<td>基本数据类型 int</td>
</tr>
<tr>
<td>J</td>
<td>基本数据类型 long</td>
</tr>
<tr>
<td>S</td>
<td>基本数据类型 short</td>
</tr>
<tr>
<td>Z</td>
<td>基本数据类型 boolean</td>
</tr>
<tr>
<td>V</td>
<td>代表 void 类型</td>
</tr>
<tr>
<td>L</td>
<td>对象类型，比如：<code>Ljava/lang/Object;</code></td>
</tr>
<tr>
<td>[</td>
<td>数组类型，代表一维数组。比如：`double[] is [D</td>
</tr>
</tbody></table>
<p>用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法<code> java.lang.String tostring()</code>的描述符为<code>()Ljava/lang/String;</code> ，方法 <code>int abc(int[]x, int y)</code>的描述符为<code>([II)I</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object[] arr = <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">        System.out.println(arr);</span><br><span class="line"></span><br><span class="line">        String[] arr1 = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">        System.out.println(arr1);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span>[][] arr2 = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">        System.out.println(arr2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hashcode只有在运行的时候才有，这个时候已经是直接引用了而不是符号引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组+对象+全限定名+分号+hashcode</span></span><br><span class="line">[Ljava.lang.Object;@4554617c</span><br><span class="line"><span class="comment">// 数组+对象+全限定名+分号+hashcode</span></span><br><span class="line">[Ljava.lang.String;@74a14482</span><br><span class="line"><span class="comment">// 二维数组+long+hashcode</span></span><br><span class="line">[[J@<span class="number">1540e19d</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>补充说明：</strong></p>
<p>​        虚拟机在加载 Class 文件时才会进行动态链接，也就是说，<strong>Class 文件中不会保存各个方法和字段的最终内存布局信息</strong>。因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当<strong>虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中。</strong></p>
<p>这里说明下符号引用和直接引用的区别与关联：</p>
<ul>
<li>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。</li>
<li>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</li>
</ul>
<h4 id="Ⅱ-常量类型和结构"><a href="#Ⅱ-常量类型和结构" class="headerlink" title="Ⅱ. 常量类型和结构"></a>Ⅱ. 常量类型和结构</h4><p>常量池中每一项常量都是一个表，J0K1.7 之后共有 14 种不同的表结构数据。如下表格所示：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/8266c05b4b1506d4c456b427b90b1b75.png" alt="image-20210509001319088"></p>
<p>根据上图每个类型的描述我们也可以知道每个类型是用来描述常量池中哪些内容（主要是字面量、符号引用）的。比如： CONSTANT_Integer_info 是用来描述常量池中字面量信息的，而且只是整型字面量信息。</p>
<p>标志为 15、16、18 的常量项类型是用来支持动态语言调用的（jdk1.7 时才加入的）。</p>
<p><strong>细节说明：</strong></p>
<ul>
<li>CONSTANT_Class_info 结构用于表示类或接口</li>
<li>CONSTAT_Fieldref_info、CONSTAHT_Methodref_infoF 和 lCONSTANIT_InterfaceMethodref_info 结构表示字段、方汇和按口小法</li>
<li>CONSTANT_String_info 结构用于表示示 String 类型的常量对象</li>
<li>CONSTANT_Integer_info 和 CONSTANT_Float_info 表示 4 字节（int 和 float）的数值常量<ul>
<li>这里面没有byte、short、char、boolean。因为这四个都可以转化为int来表示</li>
</ul>
</li>
<li>CONSTANT_Long_info 和 CONSTAT_Double_info 结构表示 8 字作（long 和 double）的数值常量<ul>
<li>在 class 文件的常最池表中，所行的 a 字节常借均占两个表成员（项）的空问。如果一个 CONSTAHT_Long_info 和 CNSTAHT_Double_info 结构在常量池中的索引位 n，则常量池中一个可用的索引位 n+2，此时常量池长中索引为 n+1 的项仍然有效但必须视为不可用的。</li>
</ul>
</li>
<li>CONSTANT_NameAndType_info 结构用于表示字段或方法，但是和之前的 3 个结构不同，CONSTANT_NameAndType_info 结构没有指明该字段或方法所属的类或接口。</li>
<li>CONSTANT_Utf8_info 用于表示字符常量的值</li>
<li>CONSTANT_MethodHandle_info 结构用于表示方法句柄</li>
<li>CONSTANT_MethodType_info 结构表示方法类型</li>
<li>CONSTANT_InvokeDynamic_info 结构表示 invokedynamic 指令所用到的引导方法(bootstrap method)、引导方法所用到的动态调用名称(dynamic invocation name)、参数和返回类型，并可以给引导方法传入一系列称为静态参数（static argument）的常量。</li>
</ul>
<p><strong>解析方法：</strong></p>
<ul>
<li><p>一个字节一个字节的解析</p>
</li>
<li><p>使用 javap 命令解析：javap-verbose Demo.class 或 jclasslib 工具会更方便。</p>
</li>
</ul>
<p><strong>总结 1：</strong></p>
<ul>
<li>这 14 种表（或者常量项结构）的共同点是：表开始的第一位是一个 u1 类型的标志位（tag），代表当前这个常量项使用的是哪种表结构，即哪种常量类型。</li>
<li>在常量池列表中，CONSTANT_Utf8_info 常量项是一种使用改进过的 UTF-8 编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息。</li>
<li>这 14 种常量项结构还有一个特点是，其中 13 个常量项占用的字节固定，只有 CONSTANT_Utf8_info 占用字节不固定，其大小由 length 决定。为什么呢？因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定，比如你定义一个类，类名可以取长取短，所以在没编译前，大小不固定，编译后，通过 utf-8 编码，就可以知道其长度。</li>
</ul>
<p><strong>总结 2：</strong></p>
<ul>
<li>常量池：可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用 Class 文件空间最大的数据项目之一。</li>
<li>常量池中为什么要包含这些内容？Java 代码在进行 Javac 编译的时候，并不像 C 和 C++那样有“连接”这一步骤，而是在虚拟机加载 C1ass 文件的时候进行动态链接。也就是说，在 Class 文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。关于类的创建和动态链接的内容，在虚拟机类加载过程时再进行详细讲解</li>
</ul>
<h2 id="1-6-访问标志"><a href="#1-6-访问标志" class="headerlink" title="1.6. 访问标志"></a>1.6. 访问标志</h2><p><strong>访问标识（access_flag、访问标志、访问标记）</strong></p>
<p>在常量池后，紧跟着访问标记。该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等。各种访问标记如下所示：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>标志为 public 类型</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>标志被声明为 final，只有类可以设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>标志允许使用 invokespecial 字节码指令的新语义，JDK1.0.2 之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标志这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为 abstract 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标志这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标志这是一个枚举</td>
</tr>
</tbody></table>
<p>类的访问权限通常为 ACC_开头的常量。</p>
<p>每一种类型的表示都是通过设置访问标记的 32 位中的特定位来实现的。比如，若是 public final 的类，则该标记为 ACC_PUBLIC | ACC_FINAL。</p>
<p>使用 ACC_SUPER 可以让类更准确地定位到父类的方法 super.method()，现代编译器都会设置并且使用这个标记。</p>
<p><strong>补充说明：</strong></p>
<ol>
<li>带有 ACC_INTERFACE 标志的 class 文件表示的是接口而不是类，反之则表示的是类而不是接口。<ul>
<li>如果一个 class 文件被设置了 ACC_INTERFACE 标志，那么同时也得设置 ACC_ABSTRACT 标志。同时它不能再设置 ACC_FINAL、ACC_SUPER 或 ACC_ENUM 标志。</li>
<li>如果没有设置 ACC_INTERFACE 标志，那么这个 class 文件可以具有上表中除 ACC_ANNOTATION 外的其他所有标志。当然，ACC_FINAL 和 ACC_ABSTRACT 这类互斥的标志除外。这两个标志不得同时设置。</li>
</ul>
</li>
<li>ACC_SUPER 标志用于确定类或接口里面的 invokespecial 指令使用的是哪一种执行语义。针对 Java 虚拟机指令集的编译器都应当设置这个标志。对于 Java SE 8 及后续版本来说，无论 class 文件中这个标志的实际值是什么，也不管 class 文件的版本号是多少，Java 虚拟机都认为每个 class 文件均设置了 ACC_SUPER 标志。<ul>
<li>ACC_SUPER 标志是为了向后兼容由旧 Java 编译器所编译的代码而设计的。目前的 ACC_SUPER 标志在由 JDK1.0.2 之前的编译器所生成的 access_flags 中是没有确定含义的，如果设置了该标志，那么 0racle 的 Java 虚拟机实现会将其忽略。</li>
</ul>
</li>
<li>ACC_SYNTHETIC 标志意味着该类或接口是由编译器生成的，而不是由源代码生成的。</li>
<li>注解类型必须设置 ACC_ANNOTATION 标志。如果设置了 ACC_ANNOTATION 标志，那么也必须设置 ACC_INTERFACE 标志。</li>
<li>ACC_ENUM 标志表明该类或其父类为枚举类型。</li>
</ol>
<h2 id="1-7-类索引、父类索引、接口索引"><a href="#1-7-类索引、父类索引、接口索引" class="headerlink" title="1.7. 类索引、父类索引、接口索引"></a>1.7. 类索引、父类索引、接口索引</h2><p>在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>this_class</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces[interfaces_count]</td>
</tr>
</tbody></table>
<p>这三项数据来确定这个类的继承关系：</p>
<ul>
<li>类索引用于确定这个类的全限定名</li>
<li>父类索引用于确定这个类的父类的全限定名。由于 Java 语言不允许多重继承，所以父类索引只有一个，除了 java.1ang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 e。</li>
<li>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身是一个接口，则应当是 extends 语句）后的接口顺序从左到右排列在接口索引集合中。</li>
</ul>
<h3 id="1-7-1-this-class（类索引）"><a href="#1-7-1-this-class（类索引）" class="headerlink" title="1.7.1. this_class（类索引）"></a>1.7.1. this_class（类索引）</h3><p>2 字节无符号整数，指向常量池的索引。它提供了类的全限定名，如 com/atguigu/java1/Demo。this_class 的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为 CONSTANT_Class_info 类型结构体，该结构体表示这个 class 文件所定义的类或接口。</p>
<h3 id="1-7-2-super-class（父类索引）"><a href="#1-7-2-super-class（父类索引）" class="headerlink" title="1.7.2. super_class（父类索引）"></a>1.7.2. super_class（父类索引）</h3><p>2 字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是 java/lang/object 类。同时，由于 Java 不支持多继承，所以其父类只有一个。</p>
<p>super_class 指向的父类不能是 final。</p>
<h3 id="1-7-3-interfaces"><a href="#1-7-3-interfaces" class="headerlink" title="1.7.3. interfaces"></a>1.7.3. interfaces</h3><p>指向常量池索引集合，它提供了一个符号引用到所有已实现的接口</p>
<p>由于一个类可以实现多个接口，因此需要以数组形式保存多个接口的索引，表示接口的每个索引也是一个指向常量池的 CONSTANT_Class（当然这里就必须是接口，而不是类）。</p>
<h4 id="Ⅰ-interfaces-count（接口计数器）"><a href="#Ⅰ-interfaces-count（接口计数器）" class="headerlink" title="Ⅰ. interfaces_count（接口计数器）"></a>Ⅰ. interfaces_count（接口计数器）</h4><p>interfaces_count 项的值表示当前类或接口的直接超接口数量。</p>
<h4 id="Ⅱ-interfaces-（接口索引集合）"><a href="#Ⅱ-interfaces-（接口索引集合）" class="headerlink" title="Ⅱ. interfaces[]（接口索引集合）"></a>Ⅱ. interfaces[]（接口索引集合）</h4><p><code>interfaces[]</code>中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为 <code>interfaces_count</code>。每个成员<code> interfaces[i]</code>必须为 <code>CONSTANT_Class_info</code> 结构，其中 <code>0 &lt;= i &lt; interfaces_count</code>。在 <code>interfaces[]</code>中，各成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即<code> interfaces[0]</code>对应的是源代码中最左边的接口。</p>
<h2 id="1-8-字段表集合"><a href="#1-8-字段表集合" class="headerlink" title="1.8. 字段表集合"></a>1.8. 字段表集合</h2><p><strong>fields</strong></p>
<p>用于描述接口或类中声明的变量。字段（field）包括类级变量（静态变量）以及实例级变量（局部变量），但是<strong>不包括方法内部、代码块内部声明的局部变量</strong>（local varibales）。</p>
<p>字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</p>
<p>它指向常量池索引集合，它描述了每个字段的完整信息。比如字段的标识符、访问修饰符（public、private 或 protected）、是类变量还是实例变量（static 修饰符）、是否是常量（final 修饰符）等。</p>
<p><strong>注意事项：</strong></p>
<ul>
<li>字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原本 Java 代码之中不存在的字段。譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</li>
<li>在 Java 语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。</li>
</ul>
<h3 id="1-8-1-字段计数器"><a href="#1-8-1-字段计数器" class="headerlink" title="1.8.1. 字段计数器"></a>1.8.1. 字段计数器</h3><p><strong>fields_count（字段计数器）</strong></p>
<p>fields_count 的值表示当前 class 文件 fields 表的成员个数。使用两个字节来表示。</p>
<p>fields 表中每个成员都是一个 field_info 结构，用于表示该类或接口所声明的所有类字段或者实例字段，不包括方法内部声明的变量，也不包括从父类或父接口继承的那些字段。</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>字段名索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>描述符索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性集合</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<h3 id="1-8-2-字段表"><a href="#1-8-2-字段表" class="headerlink" title="1.8.2. 字段表"></a>1.8.2. 字段表</h3><h4 id="Ⅰ-字段表访问标识"><a href="#Ⅰ-字段表访问标识" class="headerlink" title="Ⅰ. 字段表访问标识"></a>Ⅰ. 字段表访问标识</h4><p>我们知道，一个字段可以被各种关键字去修饰，比如：作用域修饰符（public、private、protected）、static 修饰符、final 修饰符、volatile 修饰符等等。因此，其可像类的访问标志那样，使用一些标志来标记字段。字段的访问标志有如下这些：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>字段是否为 public</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>字段是否为 private</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>字段是否为 protected</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>字段是否为 static</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>字段是否为 final</td>
</tr>
<tr>
<td>ACC_VOLATILE</td>
<td>0x0040</td>
<td>字段是否为 volatile</td>
</tr>
<tr>
<td>ACC_TRANSTENT</td>
<td>0x0080</td>
<td>字段是否为 transient</td>
</tr>
<tr>
<td>ACC_SYNCHETIC</td>
<td>0x1000</td>
<td>字段是否为由编译器自动产生</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>字段是否为 enum</td>
</tr>
</tbody></table>
<h4 id="Ⅱ-描述符索引"><a href="#Ⅱ-描述符索引" class="headerlink" title="Ⅱ. 描述符索引"></a>Ⅱ. 描述符索引</h4><p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte，char，double，float，int，long，short，boolean）及代表无返回值的 void 类型都用一个大写字符来表示，而对象则用字符 L 加对象的全限定名来表示，如下所示：</p>
<table>
<thead>
<tr>
<th>标志符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>基本数据类型 byte</td>
</tr>
<tr>
<td>C</td>
<td>基本数据类型 char</td>
</tr>
<tr>
<td>D</td>
<td>基本数据类型 double</td>
</tr>
<tr>
<td>F</td>
<td>基本数据类型 float</td>
</tr>
<tr>
<td>I</td>
<td>基本数据类型 int</td>
</tr>
<tr>
<td>J</td>
<td>基本数据类型 long</td>
</tr>
<tr>
<td>S</td>
<td>基本数据类型 short</td>
</tr>
<tr>
<td>Z</td>
<td>基本数据类型 boolean</td>
</tr>
<tr>
<td>V</td>
<td>代表 void 类型</td>
</tr>
<tr>
<td>L</td>
<td>对象类型，比如：<code>Ljava/lang/Object;</code></td>
</tr>
<tr>
<td>[</td>
<td>数组类型，代表一维数组。比如：`double[][][] is [[[D</td>
</tr>
</tbody></table>
<h4 id="Ⅲ-属性表集合"><a href="#Ⅲ-属性表集合" class="headerlink" title="Ⅲ. 属性表集合"></a>Ⅲ. 属性表集合</h4><p>一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性个数存放在 attribute_count 中，属性具体内容存放在 attributes 数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以常量属性为例，结构为：</span></span><br><span class="line">ConstantValue_attribute&#123;</span><br><span class="line">	u2 attribute_name_index;</span><br><span class="line">	u4 attribute_length;</span><br><span class="line">    u2 constantvalue_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：对于常量属性而言，attribute_length 值恒为 2。</p>
<h2 id="1-9-方法表集合"><a href="#1-9-方法表集合" class="headerlink" title="1.9. 方法表集合"></a>1.9. 方法表集合</h2><p>methods：指向常量池索引集合，它完整描述了每个方法的签名。</p>
<ul>
<li>在字节码文件中，每一个 method_info 项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符（public、private 或 protected），方法的返回值类型以及方法的参数信息等。</li>
<li>如果这个方法不是抽象的或者不是 native 的，那么字节码中会体现出来。</li>
<li>一方面，methods 表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods 表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息（比如：类（接口）初始化方法<clinit>()和实例初始化方法<init>()）。</li>
</ul>
<p><strong>使用注意事项：</strong></p>
<p>在 Java 语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此 Java 语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个 class 文件中。</p>
<p>也就是说，尽管 Java 语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和 Java 语法规范相反，字节码文件中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同。</p>
<h3 id="1-9-1-方法计数器"><a href="#1-9-1-方法计数器" class="headerlink" title="1.9.1. 方法计数器"></a>1.9.1. 方法计数器</h3><p><strong>methods_count（方法计数器）</strong></p>
<p>methods_count 的值表示当前 class 文件 methods 表的成员个数。使用两个字节来表示。</p>
<p>methods 表中每个成员都是一个 method_info 结构。</p>
<h3 id="1-9-2-方法表"><a href="#1-9-2-方法表" class="headerlink" title="1.9.2. 方法表"></a>1.9.2. 方法表</h3><p><strong>methods[]（方法表）</strong></p>
<p>methods 表中的每个成员都必须是一个 method_info 结构，用于表示当前类或接口中某个方法的完整描述。如果某个 method_info 结构的 access_flags 项既没有设置 ACC_NATIVE 标志也没有设置 ACC_ABSTRACT 标志，那么该结构中也应包含实现这个方法所用的 Java 虚拟机指令。</p>
<p>method_info 结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法</p>
<p>方法表的结构实际跟字段表是一样的，方法表结构如下：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>方法名索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>描述符索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性集合</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<p><strong>方法表访问标志</strong></p>
<p>跟字段表一样，方法表也有访问标志，而且他们的标志有部分相同，部分则不同，方法表的具体访问标志如下：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>public，方法可以从包外访问</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>private，方法只能本类访问</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>protected，方法在自身和子类可以访问</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>static，静态方法</td>
</tr>
</tbody></table>
<h2 id="1-10-属性表集合"><a href="#1-10-属性表集合" class="headerlink" title="1.10. 属性表集合"></a>1.10. 属性表集合</h2><p>方法表集合之后的属性表集合，指的是 class 文件所携带的辅助信息，比如该 class 文件的源文件的名称。以及任何带有 RetentionPolicy.CLASS 或者 RetentionPolicy.RUNTIME 的注解。这类信息通常被用于 Java 虚拟机的验证和运行，以及 Java 程序的调试，一般无须深入了解。</p>
<p>此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息。</p>
<p>属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但 Java 虚拟机运行时会忽略掉它不认识的属性。</p>
<h3 id="1-10-1-属性计数器"><a href="#1-10-1-属性计数器" class="headerlink" title="1.10.1. 属性计数器"></a>1.10.1. 属性计数器</h3><p><strong>attributes_count（属性计数器）</strong></p>
<p>attributes_count 的值表示当前 class 文件属性表的成员个数。属性表中每一项都是一个 attribute_info 结构。</p>
<h3 id="1-10-2-属性表"><a href="#1-10-2-属性表" class="headerlink" title="1.10.2. 属性表"></a>1.10.2. 属性表</h3><p><strong>attributes[]（属性表）</strong></p>
<p>属性表的每个项的值必须是 attribute_info 结构。属性表的结构比较灵活，各种不同的属性只要满足以下结构即可。</p>
<p><strong>属性的通用格式</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>属性名索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td>u1</td>
<td>info</td>
<td>attribute_length</td>
<td>属性表</td>
</tr>
</tbody></table>
<p><strong>属性类型</strong></p>
<p>属性表实际上可以有很多类型，上面看到的 Code 属性只是其中一种，Java8 里面定义了 23 种属性。下面这些是虚拟机中预定义的属性：</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>使用位置</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Code</td>
<td>方法表</td>
<td>Java 代码编译成的字节码指令</td>
</tr>
<tr>
<td>ConstantValue</td>
<td>字段表</td>
<td>final 关键字定义的常量池</td>
</tr>
<tr>
<td>Deprecated</td>
<td>类，方法，字段表</td>
<td>被声明为 deprecated 的方法和字段</td>
</tr>
<tr>
<td>Exceptions</td>
<td>方法表</td>
<td>方法抛出的异常</td>
</tr>
<tr>
<td>EnclosingMethod</td>
<td>类文件</td>
<td>仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td>
</tr>
<tr>
<td>InnerClass</td>
<td>类文件</td>
<td>内部类列表</td>
</tr>
<tr>
<td>LineNumberTable</td>
<td>Code 属性</td>
<td>Java 源码的行号与字节码指令的对应关系</td>
</tr>
<tr>
<td>LocalVariableTable</td>
<td>Code 属性</td>
<td>方法的局部变量描述</td>
</tr>
<tr>
<td>StackMapTable</td>
<td>Code 属性</td>
<td>JDK1.6 中新增的属性，供新的类型检查检验器和处理目标方法的局部变量和操作数有所需要的类是否匹配</td>
</tr>
<tr>
<td>Signature</td>
<td>类，方法表，字段表</td>
<td>用于支持泛型情况下的方法签名</td>
</tr>
<tr>
<td>SourceFile</td>
<td>类文件</td>
<td>记录源文件名称</td>
</tr>
<tr>
<td>SourceDebugExtension</td>
<td>类文件</td>
<td>用于存储额外的调试信息</td>
</tr>
<tr>
<td>Synthetic</td>
<td>类，方法表，字段表</td>
<td>标志方法或字段为编译器自动生成的</td>
</tr>
<tr>
<td>LocalVariableTypeTable</td>
<td>类</td>
<td>是哟很难过特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td>
</tr>
<tr>
<td>RuntimeVisibleAnnotations</td>
<td>类，方法表，字段表</td>
<td>为动态注解提供支持</td>
</tr>
<tr>
<td>RuntimeInvisibleAnnotations</td>
<td>类，方法表，字段表</td>
<td>用于指明哪些注解是运行时不可见的</td>
</tr>
<tr>
<td>RuntimeVisibleParameterAnnotation</td>
<td>方法表</td>
<td>作用与 RuntimeVisibleAnnotations 属性类似，只不过作用对象或方法</td>
</tr>
<tr>
<td>RuntimeInvisibleParameterAnnotation</td>
<td>方法表</td>
<td>作用与 RuntimeInvisibleAnnotations 属性类似，只不过作用对象或方法</td>
</tr>
<tr>
<td>AnnotationDefault</td>
<td>方法表</td>
<td>用于记录注解类元素的默认值</td>
</tr>
<tr>
<td>BootstrapMethods</td>
<td>类文件</td>
<td>用于保存 invokeddynamic 指令引用的引导方法限定符</td>
</tr>
</tbody></table>
<p>或者（查看官网）</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/412a7e52bfb1ee0aa8229db1402ae58a.png" alt="image-20210421235232911"></p>
<p><strong>部分属性详解</strong></p>
<p><strong>① ConstantValue 属性</strong></p>
<p>ConstantValue 属性表示一个常量字段的值。位于 field_info 结构的属性表中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConstantValue_attribute&#123;</span><br><span class="line">	u2 attribute_name_index;</span><br><span class="line">	u4 attribute_length;</span><br><span class="line">	u2 constantvalue_index;<span class="comment">//字段值在常量池中的索引，常量池在该索引处的项给出该属性表示的常量值。（例如，值是1ong型的，在常量池中便是CONSTANT_Long）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>② Deprecated 属性</strong></p>
<p>Deprecated 属性是在 JDK1.1 为了支持注释中的关键词@deprecated 而引入的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Deprecated_attribute&#123;</span><br><span class="line">	u2 attribute_name_index;</span><br><span class="line">	u4 attribute_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>③ Code 属性</strong></p>
<p>Code 属性就是存放方法体里面的代码。但是，并非所有方法表都有 Code 属性。像接口或者抽象方法，他们没有具体的方法体，因此也就不会有 Code 属性了。Code 属性表的结构，如下图：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>属性名索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td>u2</td>
<td>max_stack</td>
<td>1</td>
<td>操作数栈深度的最大值</td>
</tr>
<tr>
<td>u2</td>
<td>max_locals</td>
<td>1</td>
<td>局部变量表所需的存续空间</td>
</tr>
<tr>
<td>u4</td>
<td>code_length</td>
<td>1</td>
<td>字节码指令的长度</td>
</tr>
<tr>
<td>u1</td>
<td>code</td>
<td>code_lenth</td>
<td>存储字节码指令</td>
</tr>
<tr>
<td>u2</td>
<td>exception_table_length</td>
<td>1</td>
<td>异常表长度</td>
</tr>
<tr>
<td>exception_info</td>
<td>exception_table</td>
<td>exception_length</td>
<td>异常表</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
<td>属性集合计数器</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
<td>属性集合</td>
</tr>
</tbody></table>
<p>可以看到：Code 属性表的前两项跟属性表是一致的，即 Code 属性表遵循属性表的结构，后面那些则是他自定义的结构。</p>
<p><strong>④ InnerClasses 属性</strong></p>
<p>为了方便说明特别定义一个表示类或接口的 Class 格式为 C。如果 C 的常量池中包含某个 CONSTANT_Class_info 成员，且这个成员所表示的类或接口不属于任何一个包，那么 C 的 ClassFile 结构的属性表中就必须含有对应的 InnerClasses 属性。InnerClasses 属性是在 JDK1.1 中为了支持内部类和内部接口而引入的，位于 ClassFile 结构的属性表。</p>
<p><strong>⑤ LineNumberTable 属性</strong></p>
<p>LineNumberTable 属性是可选变长属性，位于 Code 结构的属性表。</p>
<p>LineNumberTable 属性是用来描述 Java 源码行号与字节码行号之间的对应关系。这个属性可以用来在调试的时候定位代码执行的行数。</p>
<ul>
<li>start_pc，即字节码行号；1ine_number，即 Java 源代码行号。</li>
</ul>
<p>在 Code 属性的属性表中，LineNumberTable 属性可以按照任意顺序出现，此外，多个 LineNumberTable 属性可以共同表示一个行号在源文件中表示的内容，即 LineNumberTable 属性不需要与源文件的行一一对应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LineNumberTable属性表结构：</span></span><br><span class="line">LineNumberTable_attribute&#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 line_number_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2 start_pc;</span><br><span class="line">        u2 line_number;</span><br><span class="line">    &#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>⑥ LocalVariableTable 属性</strong></p>
<p>LocalVariableTable 是可选变长属性，位于 Code 属性的属性表中。它被调试器用于确定方法在执行过程中局部变量的信息。在 Code 属性的属性表中，LocalVariableTable 属性可以按照任意顺序出现。Code 属性中的每个局部变量最多只能有一个 LocalVariableTable 属性。</p>
<ul>
<li>start pc + length 表示这个变量在字节码中的生命周期起始和结束的偏移位置（this 生命周期从头 e 到结尾 10）</li>
<li>index 就是这个变量在局部变量表中的槽位（槽位可复用）</li>
<li>name 就是变量名</li>
<li>Descriptor 表示局部变量类型描述</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LocalVariableTable属性表结构：</span></span><br><span class="line">LocalVariableTable_attribute&#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 local_variable_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2 start_pc;</span><br><span class="line">        u2 length;</span><br><span class="line">        u2 name_index;</span><br><span class="line">        u2 descriptor_index;</span><br><span class="line">        u2 index;</span><br><span class="line">    &#125; local_variable_table[local_variable_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>⑦ Signature 属性</strong></p>
<p>Signature 属性是可选的定长属性，位于 ClassFile，field_info 或 method_info 结构的属性表中。在 Java 语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则 Signature 属性会为它记录泛型签名信息。</p>
<p><strong>⑧ SourceFile 属性</strong></p>
<p>SourceFile 属性结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>属性名索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td>u2</td>
<td>sourcefile index</td>
<td>1</td>
<td>源码文件索引（能找到文件名）</td>
</tr>
</tbody></table>
<p>可以看到，其长度总是固定的 8 个字节。</p>
<p><strong>⑨ 其他属性</strong></p>
<p>Java 虚拟机中预定义的属性有 20 多个，这里就不一一介绍了，通过上面几个属性的介绍，只要领会其精髓，其他属性的解读也是易如反掌。</p>
<h2 id="1-11-javap指令解析Class文件"><a href="#1-11-javap指令解析Class文件" class="headerlink" title="1.11. javap指令解析Class文件"></a>1.11. javap指令解析Class文件</h2><h3 id="解析字节码作用"><a href="#解析字节码作用" class="headerlink" title="解析字节码作用"></a>解析字节码作用</h3><p>通过反编译生成的字节码文件，我们可以深入的了解java代码的工作机制。但是，自己分析类文件结构太麻烦了!除了使用第三方的jclasslib工具之外，oracle官方也提供了工具： javap。</p>
<p>javap是jdk自带的反解析工具。它的作用就是根据class字节码文件，反解析出当前类对应的code区(字节码指令)、局部变量表、异常表和代码行偏移量映射表、常量池等信息。</p>
<p>通过局部变量表，我们可以查看局部变量的作用域范围、所在槽位等信息，甚至可以看到槽位复用等信息。</p>
<h3 id="javac-g-操作"><a href="#javac-g-操作" class="headerlink" title="javac -g 操作"></a>javac -g 操作</h3><p>解析字节码文件得到的信息中，有些信息（如局部变量表、指令和代码行偏移量映射表、常量池中方法的参数名称等等）需要在使用javac编译成class文件时，指定参数才能输出。</p>
<p>比如，你直接javac xx.java，就不会在生成对应的局部变量表等信息，如果你使用javac -g xx.java就可以生成所有相关信息了。如果你使用的eclipse或IDEA，则默认情况下，eclipse、IDEA在编译时会帮你生成局部变量表、指令和代码行偏移量映射表等信息的。</p>
<h3 id="javap的用法"><a href="#javap的用法" class="headerlink" title="javap的用法"></a>javap的用法</h3><p>javap的用法格式：</p>
<p><code>javap &lt;options&gt; &lt;classes&gt;</code></p>
<p>其中，classes就是你要反编译的class文件。</p>
<p>在命令行中直接输入javap或javap -help可以看到javap的options有如下选项：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210914175009520.png" alt="image-20210914175009520"></p>
<p>重组后：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>-help –help -?</td>
<td>输出此用法消息</td>
</tr>
<tr>
<td>-version</td>
<td>版本信息，其实是当前javap所在jdk的版本信息，不是class在哪个jdk下生成的。</td>
</tr>
<tr>
<td>-public</td>
<td>仅显示公共类和成员</td>
</tr>
<tr>
<td>-protected</td>
<td>显示受保护的/公共类和成员</td>
</tr>
<tr>
<td>-p -private</td>
<td>显示所有类和成员</td>
</tr>
<tr>
<td>-package</td>
<td>显示程序包/受保扩的/公共类和成员（默认)</td>
</tr>
<tr>
<td>-sysinfo</td>
<td>显示正在处理的类的系统信息(路径，大小，日期,，MD5散列,源文件名)</td>
</tr>
<tr>
<td>-constants</td>
<td>显示静态最终常量</td>
</tr>
<tr>
<td>-s</td>
<td>输出内部类型签名</td>
</tr>
<tr>
<td>-l</td>
<td>输出行号和本地变量表</td>
</tr>
<tr>
<td>-c</td>
<td>对代码进行反江编</td>
</tr>
<tr>
<td>-v  -verbose</td>
<td>输出附加信息(包括行号、本地变吊表，反汇编等详细信息)</td>
</tr>
<tr>
<td>-classpath <code>&lt;path&gt;</code></td>
<td>指定查找用户类文件的位置</td>
</tr>
<tr>
<td>-cp <code>&lt;path&gt;</code></td>
<td>指定查找用户类文件的位置</td>
</tr>
<tr>
<td>-bootclasspath <code>&lt;path&gt;</code></td>
<td>覆盖引导类文件的位置</td>
</tr>
</tbody></table>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20210305121851799.png" alt="在这里插入图片描述"></p>
<p>一般常用的是-v -l -c三个选项。</p>
<p>javap -l会输出行号和本地变量表信息。</p>
<p>javap -c会对当前class字节码进行反编译生成汇编代码。</p>
<p>javap -v classxx除了包含-c内容外，还会输出行号、局部变量表信息、常量池等信息。</p>
<p>注意：</p>
<p>①-v相当于-c -l</p>
<p>②-v也不会输出私有的字段、方法等信息，所以如果想输出私有的信息，那需要在-v后面加上-p才行</p>
<h3 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavapTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="keyword">public</span> String info;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNTS = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        String url = <span class="string">&quot;https://lvxiaoyi.top/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        info = <span class="string">&quot;java&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavapTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JavapTest</span><span class="params">(<span class="keyword">boolean</span> falg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num + i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">char</span> <span class="title">showGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">        System.out.println(info + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cmd命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">javap -v -p JavaTest.class&gt;javaptest.txt</span><br></pre></td></tr></table></figure>



<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>查看javaptest.txt文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字节码文件所属的路径</span></span><br><span class="line">Classfile /D:/interview/jvm/target/classes/top/lvxiaoyi/classstruct/JavapTest.class</span><br><span class="line"><span class="comment">// 最后修改时间，字节码文件的大小</span></span><br><span class="line">  Last modified <span class="number">2021</span>-<span class="number">9</span>-<span class="number">14</span>; size <span class="number">1388</span> bytes</span><br><span class="line"><span class="comment">// MD5散列值</span></span><br><span class="line">  MD5 checksum ff5063fc3ef67a8d2714a639d2fc4c50</span><br><span class="line">  Compiled from <span class="string">&quot;JavapTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">top</span>.<span class="title">lvxiaoyi</span>.<span class="title">classstruct</span>.<span class="title">JavapTest</span></span></span><br><span class="line"><span class="class">// 副版本</span></span><br><span class="line"><span class="class">  <span class="title">minor</span> <span class="title">version</span>: 0</span></span><br><span class="line"><span class="class">  // 主版本 <span class="title">JDK1</span>.8用52表示，副班本只有<span class="title">JDK1</span>.1的时候有数字</span></span><br><span class="line"><span class="class">  <span class="title">major</span> <span class="title">version</span>: 52</span></span><br><span class="line"><span class="class">  // 访问标识 公共和<span class="title">super</span></span></span><br><span class="line"><span class="class">  // <span class="title">super</span>在<span class="title">javaSE8</span> 后，默认为每个<span class="title">Class</span>文件都添加这个标识，为了向后兼容</span></span><br><span class="line"><span class="class">  <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_SUPER</span></span></span><br><span class="line"><span class="class"> // *************************** 常量池********************************</span></span><br><span class="line"><span class="class"><span class="title">Constant</span> <span class="title">pool</span>:</span></span><br><span class="line"><span class="class">   #1 </span>= Methodref          #<span class="number">16.</span>#<span class="number">47</span>        <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = String             #<span class="number">48</span>            <span class="comment">// java</span></span><br><span class="line">   #<span class="number">3</span> = Fieldref           #<span class="number">15.</span>#<span class="number">49</span>        <span class="comment">// top/lvxiaoyi/classstruct/JavapTest.info:Ljava/lang/String;</span></span><br><span class="line">   #<span class="number">4</span> = Fieldref           #<span class="number">15.</span>#<span class="number">50</span>        <span class="comment">// top/lvxiaoyi/classstruct/JavapTest.flag:Z</span></span><br><span class="line">   #<span class="number">5</span> = Fieldref           #<span class="number">15.</span>#<span class="number">51</span>        <span class="comment">// top/lvxiaoyi/classstruct/JavapTest.num:I</span></span><br><span class="line">   #<span class="number">6</span> = Fieldref           #<span class="number">15.</span>#<span class="number">52</span>        <span class="comment">// top/lvxiaoyi/classstruct/JavapTest.gender:C</span></span><br><span class="line">   #<span class="number">7</span> = Fieldref           #<span class="number">53.</span>#<span class="number">54</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">8</span> = Class              #<span class="number">55</span>            <span class="comment">// java/lang/StringBuilder</span></span><br><span class="line">   #<span class="number">9</span> = Methodref          #<span class="number">8.</span>#<span class="number">47</span>         <span class="comment">// java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">10</span> = Methodref          #<span class="number">8.</span>#<span class="number">56</span>         <span class="comment">// java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">11</span> = Methodref          #<span class="number">8.</span>#<span class="number">57</span>         <span class="comment">// java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">12</span> = Methodref          #<span class="number">8.</span>#<span class="number">58</span>         <span class="comment">// java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">13</span> = Methodref          #<span class="number">59.</span>#<span class="number">60</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">14</span> = String             #<span class="number">61</span>            <span class="comment">// https://lvxiaoyi.top/</span></span><br><span class="line">  #<span class="number">15</span> = Class              #<span class="number">62</span>            <span class="comment">// top/lvxiaoyi/classstruct/JavapTest</span></span><br><span class="line">  #<span class="number">16</span> = Class              #<span class="number">63</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">17</span> = Utf8               num</span><br><span class="line">  #<span class="number">18</span> = Utf8               I</span><br><span class="line">  #<span class="number">19</span> = Utf8               flag</span><br><span class="line">  #<span class="number">20</span> = Utf8               Z</span><br><span class="line">  #<span class="number">21</span> = Utf8               gender</span><br><span class="line">  #<span class="number">22</span> = Utf8               C</span><br><span class="line">  #<span class="number">23</span> = Utf8               info</span><br><span class="line">  #<span class="number">24</span> = Utf8               Ljava/lang/String;</span><br><span class="line">  #<span class="number">25</span> = Utf8               COUNTS</span><br><span class="line">  #<span class="number">26</span> = Utf8               ConstantValue</span><br><span class="line">  #<span class="number">27</span> = Integer            <span class="number">1</span></span><br><span class="line">  #<span class="number">28</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">29</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">30</span> = Utf8               Code</span><br><span class="line">  #<span class="number">31</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">32</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">33</span> = Utf8               <span class="keyword">this</span></span><br><span class="line">  #<span class="number">34</span> = Utf8               Ltop/lvxiaoyi/classstruct/JavapTest;</span><br><span class="line">  #<span class="number">35</span> = Utf8               (Z)V</span><br><span class="line">  #<span class="number">36</span> = Utf8               falg</span><br><span class="line">  #<span class="number">37</span> = Utf8               methodPrivate</span><br><span class="line">  #<span class="number">38</span> = Utf8               getNum</span><br><span class="line">  #<span class="number">39</span> = Utf8               (I)I</span><br><span class="line">  #<span class="number">40</span> = Utf8               i</span><br><span class="line">  #<span class="number">41</span> = Utf8               showGender</span><br><span class="line">  #<span class="number">42</span> = Utf8               ()C</span><br><span class="line">  #<span class="number">43</span> = Utf8               showInfo</span><br><span class="line">  #<span class="number">44</span> = Utf8               &lt;clinit&gt;</span><br><span class="line">  #<span class="number">45</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">46</span> = Utf8               JavapTest.java</span><br><span class="line">  #<span class="number">47</span> = NameAndType        #<span class="number">28</span>:#<span class="number">29</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">48</span> = Utf8               java</span><br><span class="line">  #<span class="number">49</span> = NameAndType        #<span class="number">23</span>:#<span class="number">24</span>        <span class="comment">// info:Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">50</span> = NameAndType        #<span class="number">19</span>:#<span class="number">20</span>        <span class="comment">// flag:Z</span></span><br><span class="line">  #<span class="number">51</span> = NameAndType        #<span class="number">17</span>:#<span class="number">18</span>        <span class="comment">// num:I</span></span><br><span class="line">  #<span class="number">52</span> = NameAndType        #<span class="number">21</span>:#<span class="number">22</span>        <span class="comment">// gender:C</span></span><br><span class="line">  #<span class="number">53</span> = Class              #<span class="number">64</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">54</span> = NameAndType        #<span class="number">65</span>:#<span class="number">66</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">55</span> = Utf8               java/lang/StringBuilder</span><br><span class="line">  #<span class="number">56</span> = NameAndType        #<span class="number">67</span>:#<span class="number">68</span>        <span class="comment">// append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">57</span> = NameAndType        #<span class="number">67</span>:#<span class="number">69</span>        <span class="comment">// append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">58</span> = NameAndType        #<span class="number">70</span>:#<span class="number">71</span>        <span class="comment">// toString:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">59</span> = Class              #<span class="number">72</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">60</span> = NameAndType        #<span class="number">73</span>:#<span class="number">74</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">61</span> = Utf8               https:<span class="comment">//lvxiaoyi.top/</span></span><br><span class="line">  #<span class="number">62</span> = Utf8               top/lvxiaoyi/classstruct/JavapTest</span><br><span class="line">  #<span class="number">63</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">64</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">65</span> = Utf8               out</span><br><span class="line">  #<span class="number">66</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">67</span> = Utf8               append</span><br><span class="line">  #<span class="number">68</span> = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #<span class="number">69</span> = Utf8               (I)Ljava/lang/StringBuilder;</span><br><span class="line">  #<span class="number">70</span> = Utf8               toString</span><br><span class="line">  #<span class="number">71</span> = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #<span class="number">72</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">73</span> = Utf8               println</span><br><span class="line">  #<span class="number">74</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  <span class="comment">//******************************字段表集合的信息**************************************</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 字段名</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">   <span class="comment">// 字段表集合的信息,I 表示int</span></span><br><span class="line">    descriptor: I</span><br><span class="line">	<span class="comment">// 字段的访问标识 ACC_PRIVATE表示为私有</span></span><br><span class="line">    flags: ACC_PRIVATE</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> flag;</span><br><span class="line">    descriptor: Z</span><br><span class="line">    flags:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">char</span> gender;</span><br><span class="line">    descriptor: C</span><br><span class="line">    flags: ACC_PROTECTED</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.String info;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNTS;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line"><span class="comment">// 常量字段的属性：ConstantValue</span></span><br><span class="line">    ConstantValue: <span class="keyword">int</span> <span class="number">1</span></span><br><span class="line"><span class="comment">//******************************方法表集合的信息**************************************</span></span><br><span class="line"><span class="comment">// 无参构造器方法信息</span></span><br><span class="line">  <span class="keyword">public</span> top.lvxiaoyi.classstruct.JavapTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String java</span></span><br><span class="line">         <span class="number">7</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field info:Ljava/lang/String;</span></span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">19</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">10</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ltop/lvxiaoyi/classstruct/JavapTest;</span><br><span class="line"><span class="comment">// 单个参数构造器方法信息</span></span><br><span class="line">  <span class="keyword">private</span> top.lvxiaoyi.classstruct.JavapTest(<span class="keyword">boolean</span>);</span><br><span class="line">    descriptor: (Z)V</span><br><span class="line">    flags: ACC_PRIVATE</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String java</span></span><br><span class="line">         <span class="number">7</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field info:Ljava/lang/String;</span></span><br><span class="line">        <span class="number">10</span>: aload_0</span><br><span class="line">        <span class="number">11</span>: aload_0</span><br><span class="line">        <span class="number">12</span>: getfield      #<span class="number">4</span>                  <span class="comment">// Field flag:Z</span></span><br><span class="line">        <span class="number">15</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field flag:Z</span></span><br><span class="line">        <span class="number">18</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">23</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">24</span>: <span class="number">10</span></span><br><span class="line">        line <span class="number">25</span>: <span class="number">18</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">19</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ltop/lvxiaoyi/classstruct/JavapTest;</span><br><span class="line">            <span class="number">0</span>      <span class="number">19</span>     <span class="number">1</span>  <span class="function">falg   Z</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PRIVATE</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">29</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ltop/lvxiaoyi/classstruct/JavapTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    descriptor: (I)I</span><br><span class="line">    flags:</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: getfield      #<span class="number">5</span>                  <span class="comment">// Field num:I</span></span><br><span class="line">         <span class="number">4</span>: iload_1</span><br><span class="line">         <span class="number">5</span>: iadd</span><br><span class="line">         <span class="number">6</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">32</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ltop/lvxiaoyi/classstruct/JavapTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">1</span>     <span class="function">i   I</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">protected</span> <span class="keyword">char</span> <span class="title">showGender</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()C</span><br><span class="line">    flags: ACC_PROTECTED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: getfield      #<span class="number">6</span>                  <span class="comment">// Field gender:C</span></span><br><span class="line">         <span class="number">4</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">36</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ltop/lvxiaoyi/classstruct/JavapTest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 方法的描述符：方法的形参列表、返回值类型（空参和void返回值）</span></span><br><span class="line">    descriptor: ()V</span><br><span class="line"><span class="comment">// 方法的访问标识（public）</span></span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"><span class="comment">// 方法的Code属性</span></span><br><span class="line">    Code:</span><br><span class="line"><span class="comment">// stack：操作数栈的最大深度   locals：局部变量表的长度   args_size：方法接受参数的个数</span></span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line"> <span class="comment">// 偏移量   操作码     操作数</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">100</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="number">3</span>: getstatic     #<span class="number">7</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">6</span>: <span class="keyword">new</span>           #<span class="number">8</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        <span class="number">10</span>: invokespecial #<span class="number">9</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">13</span>: aload_0</span><br><span class="line">        <span class="number">14</span>: getfield      #<span class="number">3</span>                  <span class="comment">// Field info:Ljava/lang/String;</span></span><br><span class="line">        <span class="number">17</span>: invokevirtual #<span class="number">10</span>                 <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">20</span>: iload_1</span><br><span class="line">        <span class="number">21</span>: invokevirtual #<span class="number">11</span>                 <span class="comment">// Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">24</span>: invokevirtual #<span class="number">12</span>                 <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">        <span class="number">27</span>: invokevirtual #<span class="number">13</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">30</span>: <span class="keyword">return</span></span><br><span class="line"><span class="comment">// 行号表：指明字节码指令的偏移量与java源代码中代码的行号的一一对应关系</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">40</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">41</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">42</span>: <span class="number">30</span></span><br><span class="line"> <span class="comment">// 局部变量表：描述内部局部变量的相关信息</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">31</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ltop/lvxiaoyi/classstruct/JavapTest;</span><br><span class="line">            <span class="number">3</span>      <span class="number">28</span>     <span class="number">1</span>     i   I</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">14</span>                 <span class="comment">// String https://lvxiaoyi.top/</span></span><br><span class="line">         <span class="number">2</span>: astore_0</span><br><span class="line">         <span class="number">3</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">3</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 附加属性：指明当前字节码文件对应的源程序文件名</span></span><br><span class="line">SourceFile: <span class="string">&quot;JavapTest.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Jclasslib分析"><a href="#Jclasslib分析" class="headerlink" title="Jclasslib分析"></a>Jclasslib分析</h4><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210914182038375.png" alt="image-20210914182038375"></p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1、通过javap命令可以查看一个java类反汇编得到的Class文件版本号、常量池、访问标识、变量表指令代码行号表等信息。不显示类索引、父类索引、接口索引集合、<code>&lt;clinit&gt;()</code>、<code>&lt;init&gt;()</code>等结构</p>
<p>2、通过对前面例子代码反汇编文件的简单分析，可以发现，一个方法的执行通常会涉及下面几块内存的操作：</p>
<p>(1) java栈中：局部变量表、操作数栈。</p>
<p>(2) java堆。通过对象的地址引用去操作。</p>
<p>(3）常量池。</p>
<p>(4）其他如帧数据区、方法区的剩余部分等情况，测试中没有显示出来，这里说明一下。</p>
<p>3、平常，我们比较关注的是java类中每个方法的反汇编中的指令操作过程，这些指令都是顺序执行的可以参考官方文档查看每个指令的含义，很简单：</p>
<p>官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html</a></p>
<h1 id="04-字节码指令集"><a href="#04-字节码指令集" class="headerlink" title="04-字节码指令集"></a>04-字节码指令集</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>​        Java字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行命令</p>
<p>​        Java虚拟机的<code>指令</code>由一个字节长度的，代表着某种特定操作含义的数字（称为操作码：<code>Opcode</code>）以及跟随其后的零至多个代表此操作所需参数（称为操作数：<code>Operands</code>）构成</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>操作码</th>
<th>操作数</th>
</tr>
</thead>
<tbody><tr>
<td>aload_0</td>
<td>aload_0</td>
<td>无</td>
</tr>
<tr>
<td>invokespecial #1</td>
<td>invokespecial</td>
<td>#1 （符号引用地址）</td>
</tr>
</tbody></table>
<p>​        由于Java虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码由于限制了Java虚拟机操作码的长度为一个字节（即0 ~ 255），这意味着指令集的操作码总数不可能超过256条 。</p>
<p>官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html</a></p>
<p>​        熟悉虚拟机的指令对于动态字节码生成、反编译Class文件、Class文件修补都有着非常重要的价值。因此，阅读字节码作为了解Java虚拟机的基础技能，需要熟练掌握常见指令。</p>
<h3 id="执行模型"><a href="#执行模型" class="headerlink" title="执行模型"></a>执行模型</h3><p>如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    自动计算PC寄存器的值加<span class="number">1</span>;</span><br><span class="line">    根据PC寄存器的指示位置，从字节码流中取出操作码;</span><br><span class="line">    <span class="keyword">if</span> (字节码存在操作数)</span><br><span class="line">        从字节码流中取出操作数;</span><br><span class="line">        执行操作码所定义的操作;</span><br><span class="line">&#125; <span class="keyword">while</span> (字节码长度 &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<h3 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h3><p>在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息</p>
<p>例如，iload指令用于从局部变量表中加载int类型的数据到操作数栈中，而fload指令加载的则是float类型的数据</p>
<p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务</p>
<ul>
<li><code>i </code>代表对int类型的数据操作</li>
<li><code>l</code> 代表long</li>
<li><code>s</code> 代表short</li>
<li><code>b</code> 代表byte</li>
<li><code>c</code> 代表char</li>
<li><code>f</code> 代表float</li>
<li><code>d</code> 代表double</li>
</ul>
<p>也有一些指令的助记符中没有明确地指明操作类型的字母，如arraylength指令，它没有代表数据类型的特殊字符，住操作数永远只能是一个数组类型的对象。</p>
<p>还有一些指令，比如无条件跳转指令goto则是与数据类型无关</p>
<h3 id="指令的分类"><a href="#指令的分类" class="headerlink" title="指令的分类"></a>指令的分类</h3><p>大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展(Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展(Zero-Extend)为相应的int类型数据。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型。</p>
<p>由于完全介绍和学习这些指令需要花费大量时间。为了让大家能够更快地熟悉和了解这些基本指令，这里将JVM中的字节码指令集按用途大致分成9类。</p>
<ul>
<li><p>加载与存储指令</p>
<ul>
<li>加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递</li>
</ul>
</li>
<li><p>算术指令</p>
<ul>
<li>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈</li>
</ul>
</li>
<li><p>类型转换指令</p>
<ul>
<li>将两种不同的数值类型进行相互转换</li>
</ul>
</li>
<li><p>对象的创建与访问指令</p>
<ul>
<li>创建对象、访问字段、数组操作和类型检查</li>
</ul>
</li>
<li><p>方法调用与返回指令</p>
<ul>
<li>进行方法调用，结束方法以及放回相应的值</li>
</ul>
</li>
<li><p>操作数栈管理指令</p>
<ul>
<li>用于操作操作数栈</li>
</ul>
</li>
<li><p>比较控制指令</p>
<ul>
<li>进行流程控制例如if、if…else、if…else if…else、switch、for、while等</li>
</ul>
</li>
<li><p>异常处理指令</p>
<ul>
<li>例如对于throw等关键字的处理</li>
</ul>
</li>
<li><p>同步控制指令</p>
<ul>
<li>使用了synchronized关键字的处理</li>
</ul>
</li>
<li><p>(说在前面)在做值相关操作时：</p>
<ul>
<li>一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据（可能是值，可能是对象的引用）被压入操作数栈。</li>
<li>一个指令，也可以从操作数栈中取出一到多个值(pop多次），完成赋值、加减乘除、方法传参、系统调用等等操作。  </li>
</ul>
</li>
</ul>
<h2 id="2-加载与存储指令"><a href="#2-加载与存储指令" class="headerlink" title="2. 加载与存储指令"></a>2. 加载与存储指令</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递。</p>
<h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><ol>
<li><p>【局部变量压栈指令】将一个局部变量加载到操作数栈：</p>
<p><code>xload</code>、<code>xload_&lt;n&gt;</code>（其中x为i、l、f、d、a，n为0到3)</p>
</li>
<li><p>【常量入栈指令】将一个常量加载到操作数栈：</p>
<p> <strong>bipush</strong>、sipush、<strong>ldc</strong>、ldc_w、ldc2_w、aconst_null、iconst_m1、<code>iconst_&lt;i&gt;</code>、<code>lconst_&lt;1&gt;</code>、<code>fconst_&lt;f&gt;</code>、<code>dconst_&lt;d&gt;</code></p>
</li>
<li><p>【出栈装入局部变量表指令】将一个数值从操作数栈存储到局部变量表：</p>
<p><code> xstore</code>、<code>xstore_&lt;n&gt;</code>(其叶x为i、l、f、d、a，n为0到3) ; xastore（其中x为i、l、f、d、a、b、c、s)</p>
</li>
<li><p>扩充局部变量表的访问索引的指令：</p>
<p> wide</p>
</li>
</ol>
<p>上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如<code>iload_&lt;n&gt;</code>)。这些指令助记符实际上代表了一组指令(例如 <code>iload_&lt;n&gt;</code>代表了<code>iload_0</code>、<code>iload_1</code>、<code>iload_2</code>和<code>iload_3</code>这几个指令)。这几组指令都是某个带有一个操作数的通用指令（例如 iload）的特殊形式，<strong>对于这若干组特殊指令来说，它们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中。</strong></p>
<h5 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h5><p><code>iload_0</code>：将局部变量表中索引为0位置上的数据压入操作数栈中。是jvm提供好的操作码，但是只有<code>iload_0</code>、<code>iload_1</code>、<code>iload_2</code>和<code>iload_3</code>这几个指令，因为指令一共就256个，不能无限使用</p>
<p><code>iload 0</code>：与<code>iload_0</code>表达同样的含义，但是<code>iload_0</code>更节省空间因为这只是一个操作码；<code>iload 0</code>是操作码+操作数。</p>
<p>除此之外，它们的语义与原生的通用指令完全一致（例如 iload_0的语义与操作数为0时的 iload 指令语义完全一致)。在尖括号之间的字母指定了指令隐含操作数的数据类型，<code>&lt;n&gt;</code>代表非负的整数，<code>&lt;i&gt;</code>代表是int类型数据，<code>&lt;l&gt;</code>代表long类型，<code>&lt;f&gt;</code>代表float类型，<code>&lt;d&gt;</code>代表double类型。</p>
<p>操作byte、char、short和boolean类型数据时，经常用int类型的指令来表示。</p>
<h3 id="复习：操作数栈与局部变量表"><a href="#复习：操作数栈与局部变量表" class="headerlink" title="复习：操作数栈与局部变量表"></a>复习：操作数栈与局部变量表</h3><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>我们知道，Java字节码是Java虚拟机所使用的指令集。因此，它与Java虚拟机基于栈的计算模型是密不可分的。</p>
<p>在解释执行过程中，每当为Java方法分配栈桢时，Java虚拟机往往需要开辟一块额外的空间作为操作数栈，来存放计算的操作数以及返回结果。</p>
<p>具体来说便是：<strong>执行每一条指令之前，Java虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时Java虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中</strong>。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">c  = a + b;</span><br></pre></td></tr></table></figure>

<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210914144515697.png" alt="image-20210914144515697" style="zoom:50%;" />

<p>以加法指令<code>iadd</code>为例。假设在执行该指令前，栈顶的两个元素分别为int值1和 int值2，那么 iadd指令将弹出这两个int，并将求得的和int值3压入栈中。</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210914144528308.png" alt="image-20210914144528308" style="zoom:50%;" />

<p>由于 iadd 指令只消耗栈顶的两个元素，因此，对于离栈顶距离为2的元素，即图中的问号，iadd 指令并不关心它是否存在，更加不会对其进行修改。</p>
<h4 id="局部变量表（Local-Variables）"><a href="#局部变量表（Local-Variables）" class="headerlink" title="局部变量表（Local Variables）"></a>局部变量表（Local Variables）</h4><p>Java方法栈桢的另外一个重要组成部分则是局部变量区，<strong>字节码程序可以将计算的结果缓存在局部变量区之中</strong>。</p>
<p>实际上，Java虚拟机将局部变量区<strong>当成一个数组</strong>，依次存放 this 指针（仅非静态方法），所传入的参数，以及字节码中的局部变量。</p>
<p>和操作数栈一样，long类型以及 double类型的值将占据两个单元，其余类型仅占据一个单元。</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210915100050782.png" alt="image-20210915100050782" style="zoom:50%;" />

<p>一个solt占据四个字节，而long和double都是占据两个solt</p>
<p>对应举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">long</span> l, <span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        String s = <span class="string">&quot;hello, lvxiaoyi&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210914144613329.png" alt="image-20210914144613329" style="zoom:50%;" />

<h5 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h5><p>this肯定是需要占据一个solt，因为这个方法是非静态的</p>
<p>long 型的参数l占据两个solt</p>
<p>float型的参数f占据一个solt</p>
<p>i/s这两个变量占据一个solt</p>
<p>​    <code>i/s</code>共同占据一个槽位是因为槽位的复用，首先i占据了占个index为4的solt，然后出了大括号就是出了作用于，然后被回收了，s再次占据index为4的solt</p>
<p>在栈帧中，与<strong>性能调优关系最为密切的部分就是局部变量表</strong>。局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p>
<p>在方法执行时,虚拟机使用局部变量表完成方法的传递。</p>
<h3 id="2-1-局部变量压栈指令"><a href="#2-1-局部变量压栈指令" class="headerlink" title="2.1. 局部变量压栈指令"></a>2.1. 局部变量压栈指令</h3><h4 id="局部变量压栈指令"><a href="#局部变量压栈指令" class="headerlink" title="局部变量压栈指令"></a>局部变量压栈指令</h4><p>局部变量压栈指令将给定的局部变量表中的数据压入操作数栈。</p>
<p>这类指令大体可以分为：</p>
<p>​    <code>xload_&lt;n&gt;(x为i、1、f、d、a，n为0到3)</code></p>
<p>​    <code>&gt; xload (x为i、1、f、d、a)</code></p>
<p>说明：在这里，x的取值表示数据类型。</p>
<p>指令xload_n表示将第n个局部变量压入操作数栈，比如iload_1、fload_0、aload_0等指令。其中aload_n表示将个对象引用压栈。</p>
<p>指令xload通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了4个，比如指令iload、fload等。</p>
<p>举例分析如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(<span class="keyword">int</span> num, Object obj, <span class="keyword">long</span> count, <span class="keyword">boolean</span> flag, <span class="keyword">short</span>[] arr)</span> </span>&#123;</span><br><span class="line">	System.out.println(num);</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">    System.out.println(flag);</span><br><span class="line">    System.out.println(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/deb49e69ed62ed9d71c7059748299b59.png" alt="3"></p>
<h4 id="局部变量压栈常用指令集"><a href="#局部变量压栈常用指令集" class="headerlink" title="局部变量压栈常用指令集"></a>局部变量压栈常用指令集</h4><blockquote>
<p>iload 从局部变量中装载int类型值</p>
<p>lload 从局部变量中装载long类型值</p>
<p>fload 从局部变量中装载float类型值</p>
<p>dload 从局部变量中装载double类型值</p>
<p>aload 从局部变量中装载引用类型值（refernce）</p>
<p>iload_0 从局部变量0中装载int类型值</p>
<p>iload_1 从局部变量1中装载int类型值</p>
<p>iload_2 从局部变量2中装载int类型值</p>
<p>iload_3 从局部变量3中装载int类型值</p>
<p>lload_0 从局部变量0中装载long类型值</p>
<p>lload_1 从局部变量1中装载long类型值</p>
<p>lload_2 从局部变量2中装载long类型值</p>
<p>lload_3 从局部变量3中装载long类型值</p>
<p>fload_0 从局部变量0中装载float类型值</p>
<p>fload_1 从局部变量1中装载float类型值</p>
<p>fload_2 从局部变量2中装载float类型值</p>
<p>fload_3 从局部变量3中装载float类型值</p>
<p>dload_0 从局部变量0中装载double类型值</p>
<p>dload_1 从局部变量1中装载double类型值</p>
<p>dload_2 从局部变量2中装载double类型值</p>
<p>dload_3 从局部变量3中装载double类型值</p>
<p>aload_0 从局部变量0中装载引用类型值</p>
<p>aload_1 从局部变量1中装载引用类型值</p>
<p>aload_2 从局部变量2中装载引用类型值</p>
<p>aload_3 从局部变量3中装载引用类型值</p>
<p>iaload 从数组中装载int类型值</p>
<p>laload 从数组中装载long类型值</p>
<p>faload 从数组中装载float类型值</p>
<p>daload 从数组中装载double类型值</p>
<p>aaload 从数组中装载引用类型值</p>
<p>baload 从数组中装载byte类型或boolean类型值</p>
<p>caload 从数组中装载char类型值</p>
<p>saload 从数组中装载short类型值</p>
</blockquote>
<table>
<thead>
<tr>
<th>xload_n</th>
<th>xload_0</th>
<th>xload_1</th>
<th>xload_2</th>
<th>xload_3</th>
</tr>
</thead>
<tbody><tr>
<td><strong>iload_n</strong></td>
<td>iload_0</td>
<td>iload_1</td>
<td>iload_2</td>
<td>iload_3</td>
</tr>
<tr>
<td><strong>lload_n</strong></td>
<td>lload_0</td>
<td>lload_1</td>
<td>lload_2</td>
<td>lload_3</td>
</tr>
<tr>
<td><strong>fload_n</strong></td>
<td>fload_0</td>
<td>fload_1</td>
<td>fload_2</td>
<td>fload_3</td>
</tr>
<tr>
<td><strong>dload_n</strong></td>
<td>dload_0</td>
<td>dload_1</td>
<td>dload_2</td>
<td>dload_3</td>
</tr>
<tr>
<td><strong>aload_n</strong></td>
<td>aload_0</td>
<td>aload_1</td>
<td>aload_2</td>
<td>aload_3</td>
</tr>
</tbody></table>
<h3 id="2-2-常量入栈指令"><a href="#2-2-常量入栈指令" class="headerlink" title="2.2. 常量入栈指令"></a>2.2. 常量入栈指令</h3><h4 id="常量入栈指令剖析"><a href="#常量入栈指令剖析" class="headerlink" title="常量入栈指令剖析"></a>常量入栈指令剖析</h4><p>常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为<code>const</code>系列、<code>push</code>系列和<code>ldc</code>指令。</p>
<h5 id="指令const系列："><a href="#指令const系列：" class="headerlink" title="指令const系列："></a>指令const系列：</h5><p>用于对特定的常量入栈，入栈的常量隐含在指令本身里。指令有：<code> iconst_&lt;i&gt;(i从-1到5)</code>、<code>lconst_&lt;l&gt;(1从0到1)</code>、<code>fconst_&lt;f&gt;(f从e到2)</code>、<code>dconst_&lt;d&gt;(d从e到1)</code>、<code>aconst_null</code>。</p>
<p>比如：</p>
<ul>
<li><p>iconst_m1将<code>-1</code>压入操作数栈;</p>
</li>
<li><p>iconst_x (x为0到5）将x压入栈：  </p>
</li>
<li><p>lconst_0、lconst_1分别将长整数0和1压入栈;</p>
</li>
<li><p>fconst_0、fconst_1、fconst_2分别将浮点数0、1、2压入栈;</p>
</li>
<li><p>dconst_a和dconst_1分别将double型0和1压入栈。</p>
</li>
<li><p>aconst_null将null压入操作数栈;</p>
</li>
</ul>
<p>​          从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，i表示整数，1表示长整数,f表示浮点数，d表示双精度浮点，习惯上用a表示对象引用。如果指令隐含操作的参数，会以下划线形式给出。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// iconst_3</span></span><br><span class="line"><span class="comment">// iconst_&lt;i&gt;的范围是-1到5，如果大于这个范围则使用push指令</span></span><br></pre></td></tr></table></figure>

<h5 id="指令push系列："><a href="#指令push系列：" class="headerlink" title="指令push系列："></a>指令push系列：</h5><p>主要包括bipush和sipush。它们的区别在于接收数据类型的不同，bipush接收8位整数作为参数，sipush接收16位整数，它们都将参数压入栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// bipush 6</span></span><br><span class="line"><span class="comment">// sipush的范围是[-32768, 32767]，如果大于这个范围则使用ldc指令</span></span><br></pre></td></tr></table></figure>

<h5 id="指令ldc系列："><a href="#指令ldc系列：" class="headerlink" title="指令ldc系列："></a>指令ldc系列：</h5><p>如果以上指令都不能满足需求，那么可以使用万能的1dc指令，它可以接收一个8位的参数，该参数指向常量池中的int、float或者String的索引，将指定的内容压入堆栈。</p>
<p>类似的还有ldc_w，它接收两个8位参数，能支持的索引范围大于ldc。</p>
<p>如果要压入的元素是long或者double类型的,则使用ldc2_w指令，使用方式都是类似的。</p>
<p>总结如下： </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>常数指令</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>int(boolean,byte,char,short)</td>
<td>iconst</td>
<td>[-1, 5]</td>
</tr>
<tr>
<td></td>
<td>bipush</td>
<td>[-128, 127]</td>
</tr>
<tr>
<td></td>
<td>sipush</td>
<td>[-32768, 32767]</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>any int value</td>
</tr>
<tr>
<td>long</td>
<td>lconst</td>
<td>0, 1</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>any long value</td>
</tr>
<tr>
<td>float</td>
<td>fconst</td>
<td>0, 1, 2</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>any float value</td>
</tr>
<tr>
<td>double</td>
<td>dconst</td>
<td>0, 1</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>any double value</td>
</tr>
<tr>
<td>reference</td>
<td>aconst</td>
<td>null</td>
</tr>
<tr>
<td>l</td>
<td>dc</td>
<td>String literal, Class literal</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushConstLdc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">32767</span>;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">constLdc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> a2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">float</span> b1 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">float</span> b2 = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">double</span> c1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> c2 = <span class="number">2</span>;</span><br><span class="line">    Date d = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pushConstLdc</span></span><br><span class="line"><span class="number">0</span> iconst_m1</span><br><span class="line"> <span class="number">1</span> istore_1</span><br><span class="line"> <span class="number">2</span> iconst_5</span><br><span class="line"> <span class="number">3</span> istore_2</span><br><span class="line"> <span class="number">4</span> bipush <span class="number">6</span></span><br><span class="line"> <span class="number">6</span> istore_3</span><br><span class="line"> <span class="number">7</span> bipush <span class="number">127</span></span><br><span class="line"> <span class="number">9</span> istore <span class="number">4</span></span><br><span class="line"><span class="number">11</span> sipush <span class="number">128</span></span><br><span class="line"><span class="number">14</span> istore <span class="number">5</span></span><br><span class="line"><span class="number">16</span> sipush <span class="number">32767</span></span><br><span class="line"><span class="number">19</span> istore <span class="number">6</span></span><br><span class="line"><span class="number">21</span> ldc #<span class="number">7</span> &lt;<span class="number">32768</span>&gt;</span><br><span class="line"><span class="number">23</span> istore <span class="number">7</span></span><br><span class="line"><span class="number">25</span> <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//constLdc</span></span><br><span class="line"> <span class="number">0</span> lconst_1</span><br><span class="line"> <span class="number">1</span> lstore_1</span><br><span class="line"> <span class="number">2</span> ldc2_w #<span class="number">8</span> &lt;<span class="number">2</span>&gt;</span><br><span class="line"> <span class="number">5</span> lstore_3</span><br><span class="line"> <span class="number">6</span> fconst_2</span><br><span class="line"> <span class="number">7</span> fstore <span class="number">5</span></span><br><span class="line"> <span class="number">9</span> ldc #<span class="number">10</span> &lt;<span class="number">3.0</span>&gt;</span><br><span class="line"><span class="number">11</span> fstore <span class="number">6</span></span><br><span class="line"><span class="number">13</span> dconst_1</span><br><span class="line"><span class="number">14</span> dstore <span class="number">7</span></span><br><span class="line"><span class="number">16</span> ldc2_w #<span class="number">11</span> &lt;<span class="number">2.0</span>&gt;</span><br><span class="line"><span class="number">19</span> dstore <span class="number">9</span></span><br><span class="line"><span class="number">21</span> aconst_null</span><br><span class="line"><span class="number">22</span> astore <span class="number">11</span></span><br><span class="line"><span class="number">24</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/59982d71dc70f7d7b873f50130281c21.png" alt="566b9397-5afe-4a3f-9e17-9ebf504dfc80"> <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/cd990ebc801bf53b4f7b1966d9974345.png" alt="b59702d2-4c93-44df-87f1-01a5dfe53b61"></p>
<h4 id="常量入栈常用指令集"><a href="#常量入栈常用指令集" class="headerlink" title="常量入栈常用指令集"></a>常量入栈常用指令集</h4><table>
<thead>
<tr>
<th>xconst_n</th>
<th>范围</th>
<th>xconst_null</th>
<th>xconst_m1</th>
<th>xconst_0</th>
<th>xconst_1</th>
<th>xconst_2</th>
<th>xconst_3</th>
<th>xconst_4</th>
<th>xconst_5</th>
</tr>
</thead>
<tbody><tr>
<td><strong>iconst_n</strong></td>
<td>[-1, 5]</td>
<td></td>
<td>iconst_m1</td>
<td>iconst_0</td>
<td>iconst_1</td>
<td>iconst_2</td>
<td>iconst_3</td>
<td>iconst_4</td>
<td>iconst_5</td>
</tr>
<tr>
<td><strong>lconst_n</strong></td>
<td>0, 1</td>
<td></td>
<td></td>
<td>lconst_0</td>
<td>lconst_1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>fconst_n</strong></td>
<td>0, 1, 2</td>
<td></td>
<td></td>
<td>fconst_0</td>
<td>fconst_1</td>
<td>fconst_2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>dconst_n</strong></td>
<td>0, 1</td>
<td></td>
<td></td>
<td>dconst_0</td>
<td>dconst_1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>aconst_n</strong></td>
<td>null, String literal, Class literal</td>
<td>aconst_null</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>bipush</strong></td>
<td>一个字节，2^8^，[-2^7^, 2^7^ - 1]，即[-128, 127]</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>sipush</strong></td>
<td>两个字节，2^16^，[-2^15^, 2^15^ - 1]，即[-32768, 32767]</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>ldc</strong></td>
<td>四个字节，2^32^，[-2^31^, 2^31^ - 1]</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>ldc_w</strong></td>
<td>宽索引</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>ldc2_w</strong></td>
<td>宽索引，long或double</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>aconst_null 将null对象引用压入栈</p>
<p>iconst_m1 将int类型常量-1压入栈</p>
<p>iconst_0 将int类型常量0压入栈</p>
<p>iconst_1 将int类型常量1压入栈</p>
<p>iconst_2 将int类型常量2压入栈</p>
<p>iconst_3 将int类型常量3压入栈</p>
<p>iconst_4 将int类型常量4压入栈</p>
<p>iconst_5 将int类型常量5压入栈</p>
<p>lconst_0 将long类型常量0压入栈</p>
<p>lconst_1 将long类型常量1压入栈</p>
<p>fconst_0 将float类型常量0压入栈</p>
<p>fconst_1 将float类型常量1压入栈</p>
<p>dconst_0 将double类型常量0压入栈</p>
<p>dconst_1 将double类型常量1压入栈</p>
<p>bipush 将一个8位带符号整数压入栈</p>
<p>sipush 将16位带符号整数压入栈</p>
<p>ldc 把常量池中的项压入栈</p>
<p>ldc_w 把常量池中的项压入栈（使用宽索引）</p>
<p>ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）</p>
</blockquote>
<h3 id="2-3-出栈装入局部变量表指令"><a href="#2-3-出栈装入局部变量表指令" class="headerlink" title="2.3. 出栈装入局部变量表指令"></a>2.3. 出栈装入局部变量表指令</h3><h4 id="出栈装入局部变量表指令剖析"><a href="#出栈装入局部变量表指令剖析" class="headerlink" title="出栈装入局部变量表指令剖析"></a>出栈装入局部变量表指令剖析</h4><p>出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值。</p>
<p>这类指令主要以store的形式存在，比如xstore (x为i、1、f、d、a)、 xstore_n (x为i、1、f、d、a，n 为0至3)。</p>
<ul>
<li>其中，指令istore_n将从操作数栈中弹出一个整数，并把它赋值给局部变量索引n位置。</li>
<li>指令xstore由于没有隐含参数信息，故需要提供一个byte类型的参数类指定目标局部变量表的位置。</li>
</ul>
<p>说明：</p>
<p>一般说来，类似像store这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置。但是，为了尽可能压缩指令大小，使用专门的istore_1指令表示将弹出的元素放置在局部变量表第1个位置。类似的还有istore_0、istore_2、istore_3,它们分别表示从操作数栈顶弹出一个元素，存放在局部变量表第0、2、3个位置。</p>
<p>由于局部变量表前几个位置总是非常常用，因此这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码的体积。如果局部变量表很大，需要存储的槽位大于3,那么可以使用istore指令，外加一个参数，用来表示需要存放的槽位位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = k + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">long</span> l = <span class="number">12</span>;</span><br><span class="line">    String str = <span class="string">&quot;lvxiaoyi&quot;</span>;</span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">10.0F</span>;</span><br><span class="line">    d = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> iload_1</span><br><span class="line"> <span class="number">1</span> iconst_2</span><br><span class="line"> <span class="number">2</span> iadd</span><br><span class="line"> <span class="number">3</span> istore <span class="number">4</span></span><br><span class="line"> <span class="number">5</span> ldc2_w #<span class="number">13</span> &lt;<span class="number">12</span>&gt;</span><br><span class="line"> <span class="number">8</span> lstore <span class="number">5</span></span><br><span class="line"><span class="number">10</span> ldc #<span class="number">15</span> &lt;lvxiaoyi&gt;</span><br><span class="line"><span class="number">12</span> astore <span class="number">7</span></span><br><span class="line"><span class="number">14</span> ldc #<span class="number">16</span> &lt;<span class="number">10.0</span>&gt;</span><br><span class="line"><span class="number">16</span> fstore <span class="number">8</span></span><br><span class="line"><span class="number">18</span> ldc2_w #<span class="number">17</span> &lt;<span class="number">10.0</span>&gt;</span><br><span class="line"><span class="number">21</span> dstore_2</span><br><span class="line"><span class="number">22</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/4adce45129332dd04b89f4aa8ffc6e28.png" alt="2"> <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/e4665e8fc25e2d63bff2e8423b60b1dc.png" alt="3"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">long</span> l, <span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        String s = <span class="string">&quot;hello,lvxiaoyi&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> iconst_0</span><br><span class="line"><span class="number">1</span> istore <span class="number">4</span></span><br><span class="line"><span class="number">3</span> ldc #<span class="number">19</span> &lt;hello,lvxiaoyi&gt;</span><br><span class="line"><span class="number">5</span> astore <span class="number">4</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="出栈装入局部变量表常用指令集"><a href="#出栈装入局部变量表常用指令集" class="headerlink" title="出栈装入局部变量表常用指令集"></a>出栈装入局部变量表常用指令集</h4><table>
<thead>
<tr>
<th>xstore_n</th>
<th>xstore_0</th>
<th>xstore_1</th>
<th>xstore_2</th>
<th>xstore_3</th>
</tr>
</thead>
<tbody><tr>
<td><strong>istore_n</strong></td>
<td>istore_0</td>
<td>istore_1</td>
<td>istore_2</td>
<td>istore_3</td>
</tr>
<tr>
<td><strong>lstore_n</strong></td>
<td>lstore_0</td>
<td>lstore_1</td>
<td>lstore_2</td>
<td>lstore_3</td>
</tr>
<tr>
<td><strong>fstore_n</strong></td>
<td>fstore_0</td>
<td>fstore_1</td>
<td>fstore_2</td>
<td>fstore_3</td>
</tr>
<tr>
<td><strong>dstore_n</strong></td>
<td>dstore_0</td>
<td>dstore_1</td>
<td>dstore_2</td>
<td>dstore_3</td>
</tr>
<tr>
<td><strong>astore_n</strong></td>
<td>astore_0</td>
<td>astore_1</td>
<td>astore_2</td>
<td>astore_3</td>
</tr>
</tbody></table>
<blockquote>
<p>istore 将int类型值存入局部变量</p>
<p>lstore 将long类型值存入局部变量</p>
<p>fstore 将float类型值存入局部变量</p>
<p>dstore 将double类型值存入局部变量</p>
<p>astore 将将引用类型或returnAddress类型值存入局部变量</p>
<p>istore_0 将int类型值存入局部变量0</p>
<p>istore_1 将int类型值存入局部变量1</p>
<p>istore_2 将int类型值存入局部变量2</p>
<p>istore_3 将int类型值存入局部变量3</p>
<p>lstore_0 将long类型值存入局部变量0</p>
<p>lstore_1 将long类型值存入局部变量1</p>
<p>lstore_2 将long类型值存入局部变量2</p>
<p>lstore_3 将long类型值存入局部变量3</p>
<p>fstore_0 将float类型值存入局部变量0</p>
<p>fstore_1 将float类型值存入局部变量1</p>
<p>fstore_2 将float类型值存入局部变量2</p>
<p>fstore_3 将float类型值存入局部变量3</p>
<p>dstore_0 将double类型值存入局部变量0</p>
<p>dstore_1 将double类型值存入局部变量1</p>
<p>dstore_2 将double类型值存入局部变量2</p>
<p>dstore_3 将double类型值存入局部变量3</p>
<p>astore_0 将引用类型或returnAddress类型值存入局部变量0</p>
<p>astore_1 将引用类型或returnAddress类型值存入局部变量1</p>
<p>astore_2 将引用类型或returnAddress类型值存入局部变量2</p>
<p>astore_3 将引用类型或returnAddress类型值存入局部变量3</p>
<p>iastore 将int类型值存入数组中</p>
<p>lastore 将long类型值存入数组中</p>
<p>fastore 将float类型值存入数组中</p>
<p>dastore 将double类型值存入数组中</p>
<p>aastore 将引用类型值存入数组中</p>
<p>bastore 将byte类型或者boolean类型值存入数组中</p>
<p>castore 将char类型值存入数组中</p>
<p>sastore 将short类型值存入数组中</p>
<p>wide指令</p>
<p>wide 使用附加字节扩展局部变量索引</p>
</blockquote>
<h2 id="3-算术指令"><a href="#3-算术指令" class="headerlink" title="3. 算术指令"></a>3. 算术指令</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>算术指令用于对<strong>两个操作数栈上的值</strong>进行某种特定运算，并把结果重新压入操作数栈。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>大体上算术指令可以分为两种：对整型数据进行运算的指令与对汗点类型数据进行运算的指令。</p>
<h4 id="byte、short、char和boolean类型说明"><a href="#byte、short、char和boolean类型说明" class="headerlink" title="byte、short、char和boolean类型说明"></a>byte、short、char和boolean类型说明</h4><p>在每一大类中，都有针对Java虚拟机具体数据类型的专用算术指令。但没有直接支持byte、short、char和boolean类型的算术指令，对于这些数据的运算，都使用int类型的指令来处理。此外，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。</p>
<h5 id="java虚拟机中的实际类型与运算类型"><a href="#java虚拟机中的实际类型与运算类型" class="headerlink" title="java虚拟机中的实际类型与运算类型"></a>java虚拟机中的实际类型与运算类型</h5><table>
<thead>
<tr>
<th>实际类型</th>
<th>运算类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>int</td>
</tr>
<tr>
<td>byte</td>
<td>int</td>
</tr>
<tr>
<td>char</td>
<td>int</td>
</tr>
<tr>
<td>short</td>
<td>int</td>
</tr>
<tr>
<td>int</td>
<td>int</td>
</tr>
<tr>
<td>float</td>
<td>float</td>
</tr>
<tr>
<td>reference</td>
<td>reference</td>
</tr>
<tr>
<td>returnAddress</td>
<td>returnAddress</td>
</tr>
<tr>
<td>long</td>
<td>long</td>
</tr>
<tr>
<td>double</td>
<td>double</td>
</tr>
</tbody></table>
<h4 id="运算时的溢出"><a href="#运算时的溢出" class="headerlink" title="运算时的溢出"></a>运算时的溢出</h4><p>数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实Java虚拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有除法指令以及求余指令中当出现除数为e时会导致虚拟机抛出异常ArithmeticException。</p>
<h4 id="运算模式"><a href="#运算模式" class="headerlink" title="运算模式"></a>运算模式</h4><ul>
<li>向最接近数舍入模式：JVM要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的;</li>
<li>向零舍入模式：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果; </li>
</ul>
<h4 id="NAN的使用"><a href="#NAN的使用" class="headerlink" title="NAN的使用"></a>NAN的使用</h4><p>当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义的话.将会使用NaN值来表示。而且所有使用NaN值作为操作数的算术操作，结果都会返回 NaN;</p>
<p>数值类型的数据，才可以谈大小！</p>
<p>boolean、引用数据类型不能比较大小。</p>
<blockquote>
<p>注意：NaN(Not a Number)表示不是一个数字</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArithmeticTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Method1Test method1Test = <span class="keyword">new</span> Method1Test();</span><br><span class="line">        method1Test.method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 这里直接除以0会报错，因为0是绝对0</span></span><br><span class="line">        <span class="comment">// 0.0代表着无穷小</span></span><br><span class="line">        <span class="keyword">double</span> j = i / <span class="number">0.0</span>;</span><br><span class="line">        System.out.println(j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> d1 = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">double</span> d2 = d1 / <span class="number">0.0</span>;</span><br><span class="line">        System.out.println(d2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> iload_1</span><br><span class="line"> <span class="number">4</span> i2d</span><br><span class="line"> <span class="number">5</span> dconst_0</span><br><span class="line"> <span class="number">6</span> ddiv</span><br><span class="line"> <span class="number">7</span> dstore_2</span><br><span class="line"> <span class="number">8</span> getstatic #<span class="number">8</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">11</span> dload_2</span><br><span class="line"><span class="number">12</span> invokevirtual #<span class="number">9</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">15</span> dconst_0</span><br><span class="line"><span class="number">16</span> dstore <span class="number">4</span></span><br><span class="line"><span class="number">18</span> dload <span class="number">4</span></span><br><span class="line"><span class="number">20</span> dconst_0</span><br><span class="line"><span class="number">21</span> ddiv</span><br><span class="line"><span class="number">22</span> dstore <span class="number">6</span></span><br><span class="line"><span class="number">24</span> getstatic #<span class="number">8</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">27</span> dload <span class="number">6</span></span><br><span class="line"><span class="number">29</span> invokevirtual #<span class="number">9</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">32</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无穷大</span></span><br><span class="line">Infinity</span><br><span class="line"><span class="comment">// not a number</span></span><br><span class="line">NaN</span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<h3 id="算术指令集"><a href="#算术指令集" class="headerlink" title="算术指令集"></a>算术指令集</h3><blockquote>
<h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><p>iadd 执行int类型的加法</p>
<p>ladd 执行long类型的加法</p>
<p>isub 执行int类型的减法</p>
<p>lsub 执行long类型的减法</p>
<p>imul 执行int类型的乘法</p>
<p>lmul 执行long类型的乘法</p>
<p>idiv 执行int类型的除法</p>
<p>ldiv 执行long类型的除法</p>
<p>irem 计算int类型除法的余数</p>
<p>lrem 计算long类型除法的余数</p>
<p>ineg 对一个int类型值进行取反操作</p>
<p>lneg 对一个long类型值进行取反操作</p>
<p>iinc 把一个常量值加到一个int类型的局部变量上</p>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><p>ishl 执行int类型的向左移位操作</p>
<p>lshl 执行long类型的向左移位操作</p>
<p>ishr 执行int类型的向右移位操作</p>
<p>lshr 执行long类型的向右移位操作</p>
<p>iushr 执行int类型的向右逻辑移位操作</p>
<p>lushr 执行long类型的向右逻辑移位操作</p>
<h3 id="按位布尔运算"><a href="#按位布尔运算" class="headerlink" title="按位布尔运算"></a>按位布尔运算</h3><p>iand 对int类型值进行“逻辑与”操作</p>
<p>land 对long类型值进行“逻辑与”操作</p>
<p>ior 对int类型值进行“逻辑或”操作</p>
<p>lor 对long类型值进行“逻辑或”操作</p>
<p>ixor 对int类型值进行“逻辑异或”操作</p>
<p>lxor 对long类型值进行“逻辑异或”操作</p>
<h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>fadd 执行float类型的加法</p>
<p>dadd 执行double类型的加法</p>
<p>fsub 执行float类型的减法</p>
<p>dsub 执行double类型的减法</p>
<p>fmul 执行float类型的乘法</p>
<p>dmul 执行double类型的乘法</p>
<p>fdiv 执行float类型的除法</p>
<p>ddiv 执行double类型的除法</p>
<p>frem 计算float类型除法的余数</p>
<p>drem 计算double类型除法的余数</p>
<p>fneg 将一个float类型的数值取反</p>
<p>dneg 将一个double类型的数值取反</p>
</blockquote>
<table>
<thead>
<tr>
<th>算数指令</th>
<th>int(boolean,byte,char,short)</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>加法指令</td>
<td>iadd</td>
<td>ladd</td>
<td>fadd</td>
<td>dadd</td>
<td></td>
</tr>
<tr>
<td>减法指令</td>
<td>isub</td>
<td>lsub</td>
<td>fsub</td>
<td>dsub</td>
<td></td>
</tr>
<tr>
<td>乘法指令</td>
<td>imul</td>
<td>lmul</td>
<td>fmul</td>
<td>dmul</td>
<td></td>
</tr>
<tr>
<td>除法指令</td>
<td>idiv</td>
<td>ldiv</td>
<td>fdiv</td>
<td>ddiv</td>
<td></td>
</tr>
<tr>
<td>求余指令</td>
<td>irem</td>
<td>lrem</td>
<td>frem</td>
<td>drem</td>
<td></td>
</tr>
<tr>
<td>取反指令</td>
<td>ineg</td>
<td>lneg</td>
<td>fneg</td>
<td>dneg</td>
<td></td>
</tr>
<tr>
<td>自增指令</td>
<td>iinc</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>位运算指令</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>位移指令</td>
<td>ishl、ishr、iushr</td>
<td>lshl、lshr、lushr</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>按位或指令</td>
<td>ior</td>
<td>lor</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>按位与指令</td>
<td>iand</td>
<td>land</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>按位异或指令</td>
<td>ixor</td>
<td>lxor</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>比较指令</td>
<td></td>
<td>lcmp</td>
<td>fcmpg / fcmpl</td>
<td>dcmpg / dcmpl</td>
<td></td>
</tr>
</tbody></table>
<h4 id="算术指令举例"><a href="#算术指令举例" class="headerlink" title="算术指令举例"></a>算术指令举例</h4><h5 id="举例1-1"><a href="#举例1-1" class="headerlink" title="举例1"></a>举例1</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((i + <span class="number">1</span>) - <span class="number">2</span>) * <span class="number">3</span> / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/256d8a8ec2309b6d396795e9a7e79959.png" alt="a54c2ac8-dd36-49f4-a49d-9afd725e8365" style="zoom: 50%;" />

<h5 id="举例2-1"><a href="#举例2-1" class="headerlink" title="举例2"></a>举例2</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">byte</span> i = <span class="number">15</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">int</span> k = i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/58c6064f2d2103610c6e2f9c9472f122.png" alt="image-20210424210710750"> <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/d0257760ed00864d7e36421c2df971ca.png" alt="2"> <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/df724aebb307c6dda0780bbf5d4e1f92.png" alt="3"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/f2edaef3312398b63decea146718f2d6.gif" alt="img"></p>
<h5 id="举例3-1"><a href="#举例3-1" class="headerlink" title="举例3"></a>举例3</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">500</span>;</span><br><span class="line">	<span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">int</span> a = x / y;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">50</span>;</span><br><span class="line">	System.out.println(a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/ce924815ec9c6ddc5cd98f18538c250e.png" alt="c43c0407-020f-4ec4-bd27-e4c109640b39"> <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/918a9850ced5114086db35ce59e651af.png" alt="04282df1-4e52-4c3d-a47b-84023159b624"></p>
<h4 id="再举例"><a href="#再举例" class="headerlink" title="再举例"></a>再举例</h4><h5 id="举例二"><a href="#举例二" class="headerlink" title="举例二"></a>举例二</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 从本地变量表中加载i到栈中，使用feg取负数，然后把栈中的数据放入局部变量表的j的位置</span></span><br><span class="line">    <span class="keyword">float</span> j = -i;</span><br><span class="line">    <span class="comment">// 从本地变量表中加载j到栈中，使用feg取负数，然后把栈中的数据放入局部变量表i的位置</span></span><br><span class="line">    i = -j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> ldc #<span class="number">10</span> &lt;<span class="number">10.0</span>&gt;</span><br><span class="line"><span class="number">2</span> fstore_1</span><br><span class="line"><span class="number">3</span> fload_1</span><br><span class="line"><span class="number">4</span> fneg</span><br><span class="line"><span class="number">5</span> fstore_2</span><br><span class="line"><span class="number">6</span> fload_2</span><br><span class="line"><span class="number">7</span> fneg</span><br><span class="line"><span class="number">8</span> fstore_1</span><br><span class="line"><span class="number">9</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h5 id="举例三"><a href="#举例三" class="headerlink" title="举例三"></a>举例三</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 从本地变量表中加载i到栈中，push一个10到栈中，使用add相加，然后把栈中的数据放入局部变量表i的位置</span></span><br><span class="line">    i = i + <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 直接在本地变量表中使用`iinc 2 by 10`命令，在局部变量表上直接相加</span></span><br><span class="line">    i += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> bipush <span class="number">100</span></span><br><span class="line"><span class="number">2</span> istore_2</span><br><span class="line"><span class="number">3</span> iload_2</span><br><span class="line"><span class="number">4</span> bipush <span class="number">10</span></span><br><span class="line"><span class="number">6</span> iadd</span><br><span class="line"><span class="number">7</span> istore_2</span><br><span class="line"><span class="number">8</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h5 id="举例四"><a href="#举例四" class="headerlink" title="举例四"></a>举例四</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int method4() &#123;</span><br><span class="line">    int a = 80;</span><br><span class="line">    int b = 7;</span><br><span class="line">    int c = 10;</span><br><span class="line">    // 这里就是正常的指令</span><br><span class="line">    // 线板adc放入局部变量表中，然后把ab读入到栈中使用add命令相加，然后把c放入栈中使用imul命令相乘，适应ireturn返回int类型</span><br><span class="line">    return (a + b) * c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">80</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> bipush <span class="number">7</span></span><br><span class="line"> <span class="number">5</span> istore_2</span><br><span class="line"> <span class="number">6</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">8</span> istore_3</span><br><span class="line"> <span class="number">9</span> iload_1</span><br><span class="line"><span class="number">10</span> iload_2</span><br><span class="line"><span class="number">11</span> iadd</span><br><span class="line"><span class="number">12</span> iload_3</span><br><span class="line"><span class="number">13</span> imul</span><br><span class="line"><span class="number">14</span> ireturn</span><br></pre></td></tr></table></figure>



<h5 id="举例五"><a href="#举例五" class="headerlink" title="举例五"></a>举例五</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method5</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把ij直接放入栈中（参数传递）使用add命令相加，栈中加入常量1使用sub命令相减</span></span><br><span class="line">    <span class="comment">// 栈中加入常量-1，使用xor明亮异或</span></span><br><span class="line">    <span class="comment">// 然后取栈顶的两个元素and操作</span></span><br><span class="line">    <span class="keyword">return</span> ((i + j - <span class="number">1</span>) &amp; ~(j - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> iload_1</span><br><span class="line"> <span class="number">1</span> iload_2</span><br><span class="line"> <span class="number">2</span> iadd</span><br><span class="line"> <span class="number">3</span> iconst_1</span><br><span class="line"> <span class="number">4</span> isub</span><br><span class="line"> <span class="number">5</span> iload_2</span><br><span class="line"> <span class="number">6</span> iconst_1</span><br><span class="line"> <span class="number">7</span> isub</span><br><span class="line"> <span class="number">8</span> iconst_m1</span><br><span class="line"> <span class="number">9</span> ixor</span><br><span class="line"><span class="number">10</span> iand</span><br><span class="line"><span class="number">11</span> ireturn</span><br></pre></td></tr></table></figure>



<h5 id="举例六"><a href="#举例六" class="headerlink" title="举例六"></a>举例六</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 两者都是使用的`iinc 1 by 1`指令</span></span><br><span class="line">    i++;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> bipush <span class="number">10</span></span><br><span class="line"><span class="number">2</span> istore_1</span><br><span class="line"><span class="number">3</span> iinc <span class="number">1</span> by <span class="number">1</span></span><br><span class="line"><span class="number">6</span> iinc <span class="number">1</span> by <span class="number">1</span></span><br><span class="line"><span class="number">9</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<h5 id="举例七"><a href="#举例七" class="headerlink" title="举例七"></a>举例七</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// i++;先将i的值从本地变量表入栈，然后使用`iinc 1 by 1`指令在局部变量表上++；然后把栈中的数据放入局部变量表的next的index，这里的index就是a</span></span><br><span class="line">    <span class="keyword">int</span> a = i++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// i++; 使用`iinc 1 by 1`指令在局部变量表上++；然后先将i的值从本地变量表入栈，然后把栈中的数据放入局部变量表的next的index，这里的index就是b</span></span><br><span class="line">    <span class="keyword">int</span> b = ++j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> iload_1</span><br><span class="line"> <span class="number">4</span> iinc <span class="number">1</span> by <span class="number">1</span></span><br><span class="line"> <span class="number">7</span> istore_2</span><br><span class="line"> <span class="number">8</span> bipush <span class="number">20</span></span><br><span class="line"><span class="number">10</span> istore_3</span><br><span class="line"><span class="number">11</span> iinc <span class="number">3</span> by <span class="number">1</span></span><br><span class="line"><span class="number">14</span> iload_3</span><br><span class="line"><span class="number">15</span> istore <span class="number">4</span></span><br><span class="line"><span class="number">17</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<h5 id="举例八"><a href="#举例八" class="headerlink" title="举例八"></a>举例八</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//i++;先将i的值从本地变量表入栈，然后使用`iinc 1 by 1`指令在局部变量表上++，这里的i就变成了11</span></span><br><span class="line">    <span class="comment">// 然后把栈中的数据放入局部变量表的next的index，这里的index就是i，这里覆盖了原来的11，所以最后导致的诗句为10</span></span><br><span class="line">    i = i++;</span><br><span class="line">    <span class="comment">// 这里打印的是10</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> iload_1</span><br><span class="line"> <span class="number">4</span> iinc <span class="number">1</span> by <span class="number">1</span></span><br><span class="line"> <span class="number">7</span> istore_1</span><br><span class="line"> <span class="number">8</span> getstatic #<span class="number">8</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">11</span> iload_1</span><br><span class="line"><span class="number">12</span> invokevirtual #<span class="number">11</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">15</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="举例九"><a href="#举例九" class="headerlink" title="举例九"></a>举例九</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">metthod9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> b = <span class="keyword">false</span>;</span><br><span class="line">    a = a % <span class="number">10</span>;</span><br><span class="line">    b = !b;</span><br><span class="line">    a = a ^ a;</span><br><span class="line">    b = (b &amp; b) &amp;&amp; b;</span><br><span class="line">    b = (b | b) || b;</span><br><span class="line">    a = ((a + <span class="number">1</span>) - <span class="number">1</span>) * <span class="number">1</span> / <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_0</span><br><span class="line"> <span class="number">1</span> istore_1</span><br><span class="line"> <span class="number">2</span> iconst_0</span><br><span class="line"> <span class="number">3</span> istore_2</span><br><span class="line"> <span class="number">4</span> iload_1</span><br><span class="line"> <span class="number">5</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">7</span> irem</span><br><span class="line"> <span class="number">8</span> istore_1</span><br><span class="line"> <span class="number">9</span> iload_2</span><br><span class="line"><span class="number">10</span> ifne <span class="number">17</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">13</span> iconst_1</span><br><span class="line"><span class="number">14</span> goto <span class="number">18</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">17</span> iconst_0</span><br><span class="line"><span class="number">18</span> istore_2</span><br><span class="line"><span class="number">19</span> iload_1</span><br><span class="line"><span class="number">20</span> iload_1</span><br><span class="line"><span class="number">21</span> ixor</span><br><span class="line"><span class="number">22</span> istore_1</span><br><span class="line"><span class="number">23</span> iload_2</span><br><span class="line"><span class="number">24</span> iload_2</span><br><span class="line"><span class="number">25</span> iand</span><br><span class="line"><span class="number">26</span> ifeq <span class="number">37</span> (+<span class="number">11</span>)</span><br><span class="line"><span class="number">29</span> iload_2</span><br><span class="line"><span class="number">30</span> ifeq <span class="number">37</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">33</span> iconst_1</span><br><span class="line"><span class="number">34</span> goto <span class="number">38</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">37</span> iconst_0</span><br><span class="line"><span class="number">38</span> istore_2</span><br><span class="line"><span class="number">39</span> iload_2</span><br><span class="line"><span class="number">40</span> iload_2</span><br><span class="line"><span class="number">41</span> ior</span><br><span class="line"><span class="number">42</span> ifne <span class="number">49</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">45</span> iload_2</span><br><span class="line"><span class="number">46</span> ifeq <span class="number">53</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">49</span> iconst_1</span><br><span class="line"><span class="number">50</span> goto <span class="number">54</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">53</span> iconst_0</span><br><span class="line"><span class="number">54</span> istore_2</span><br><span class="line"><span class="number">55</span> iload_1</span><br><span class="line"><span class="number">56</span> iconst_1</span><br><span class="line"><span class="number">57</span> iadd</span><br><span class="line"><span class="number">58</span> iconst_1</span><br><span class="line"><span class="number">59</span> isub</span><br><span class="line"><span class="number">60</span> iconst_1</span><br><span class="line"><span class="number">61</span> imul</span><br><span class="line"><span class="number">62</span> iconst_1</span><br><span class="line"><span class="number">63</span> idiv</span><br><span class="line"><span class="number">64</span> istore_1</span><br><span class="line"><span class="number">65</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<p>这里主要区分哪些是往栈里面存放数据，哪些是往局部变量表里面存放数据，<strong>其中store是往局部变量表里面存放数据</strong>。还有就是清除每个指令的意思</p>
<p>简单记忆：push往栈里面存放数据、store往局部变量表里存放数据、load从局部变量表里向栈里面存放数据、add相加、sub相减、imul相乘</p>
<p>常量：<code>constant</code></p>
<p>加：<code>add</code></p>
<p>减：<code>substract</code></p>
<p>乘：<code>multiply</code></p>
<p>除：<code>divide</code></p>
<p>取反：<code>negation</code></p>
<p>异或：<code>xor</code></p>
<p>取余（取模）：<code>remainder</code></p>
<p>与：<code>and</code></p>
<p>或：<code>or</code></p>
<h3 id="比较指令的说明"><a href="#比较指令的说明" class="headerlink" title="比较指令的说明"></a>比较指令的说明</h3><p>比较指令的说明</p>
<p>比较：<code>compare</code></p>
<ul>
<li><p>比较指令的作用是比较栈顶两个元素的大小，并将比较结果入栈。</p>
</li>
<li><p>比较指令有： dcmpg, dcmpl、 fcmpg、fcmp1、lcmp.</p>
<ul>
<li>与前面讲解的指令类似，首字符d表示double类型，f表示float,l表示long。</li>
</ul>
</li>
<li><p>对于double和float类型的数字，由于NaN的存在，各有两个版本的比较指令。以float为例，有fcmpg和fcmpi两个指令，它们的区别在于在数字比较时，若遇到NaN值，处理结果不同。</p>
</li>
<li><p>指令dcmpl和dcmpg也是类似的，根据其命名可以推测其含义，在此不再赘述。</p>
</li>
<li><p>指令lcmp针对long型整数，由于long型整数没有NaN值，故无需准备两套指令。</p>
</li>
</ul>
<p>举例：</p>
<p>指令fcmpg和fcmpl都从栈中弹出两个操作数，并将它们做比较，设栈顶的元素为v2,栈顶顺位第2位的元素为v1,若v1=v2,则压入0;若v1&gt;v2则压入1;若v1&lt;v2则压入-1。</p>
<p>两个指令的不同之处在于，如果遇到NaN值，fcmpg会压入1,而fcmpl会压入-1。</p>
<p><strong>demo请看控制转移指令</strong></p>
<h2 id="4-类型转换指令"><a href="#4-类型转换指令" class="headerlink" title="4. 类型转换指令"></a>4. 类型转换指令</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>类型转换指令说明</p>
<ul>
<li><p>类型转换指令可以将两种不同的数值类型进行相互转换。</p>
</li>
<li><p>这些转换操作一般用于实现用户代码中的<strong>显式类型转换操作</strong>，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p>
</li>
</ul>
<blockquote>
<h2 id="宽化类型转换"><a href="#宽化类型转换" class="headerlink" title="宽化类型转换"></a>宽化类型转换</h2><p>i2l 把int类型的数据转化为long类型</p>
<p>i2f 把int类型的数据转化为float类型</p>
<p>i2d 把int类型的数据转化为double类型</p>
<p>l2f 把long类型的数据转化为float类型</p>
<p>l2d 把long类型的数据转化为double类型</p>
<p>f2d 把float类型的数据转化为double类型</p>
<h2 id="窄化类型转换"><a href="#窄化类型转换" class="headerlink" title="窄化类型转换"></a>窄化类型转换</h2><p>i2b 把int类型的数据转化为byte类型</p>
<p>i2c 把int类型的数据转化为char类型</p>
<p>i2s 把int类型的数据转化为short类型</p>
<p>l2i 把long类型的数据转化为int类型</p>
<p>f2i 把float类型的数据转化为int类型</p>
<p>f2l 把float类型的数据转化为long类型</p>
<p>d2i 把double类型的数据转化为int类型</p>
<p>d2l 把double类型的数据转化为long类型</p>
<p>d2f 把double类型的数据转化为float类型</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th><strong>byte</strong></th>
<th><strong>char</strong></th>
<th><strong>short</strong></th>
<th><strong>int</strong></th>
<th><strong>long</strong></th>
<th><strong>float</strong></th>
<th><strong>double</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>int</strong></td>
<td>i2b</td>
<td>i2c</td>
<td>i2s</td>
<td>○</td>
<td>i2l</td>
<td>i2f</td>
<td>i2d</td>
</tr>
<tr>
<td><strong>long</strong></td>
<td>l2i i2b</td>
<td>l2i i2c</td>
<td>l2i i2s</td>
<td>l2i</td>
<td>○</td>
<td>l2f</td>
<td>l2d</td>
</tr>
<tr>
<td><strong>float</strong></td>
<td>f2i i2b</td>
<td>f2i i2c</td>
<td>f2i i2s</td>
<td>f2i</td>
<td>f2l</td>
<td>○</td>
<td>f2d</td>
</tr>
<tr>
<td><strong>double</strong></td>
<td>d2i i2b</td>
<td>d2i i2c</td>
<td>d2i i2s</td>
<td>d2i</td>
<td>d2l</td>
<td>d2f</td>
<td>○</td>
</tr>
</tbody></table>
<h3 id="4-1-宽化类型转换剖析"><a href="#4-1-宽化类型转换剖析" class="headerlink" title="4.1. 宽化类型转换剖析"></a>4.1. 宽化类型转换剖析</h3><p>宽化类型转换( Widening Numeric Conversions)</p>
<h4 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h4><p>Java虚拟机直接支持以下数值的宽化类型转换（ widening numeric conversion，<strong>小范围类型向大范围类型的安全转换</strong>）。也就是说，并不需要指令执行，包括：</p>
<ul>
<li><p>从int类型到long、float或者 double类型。对应的指令为：i21、i2f、i2d</p>
</li>
<li><p>从long类型到float、 double类型。对应的指令为：l2f、l2d</p>
</li>
<li><p>从float类型到double类型。对应的指令为：f2d </p>
</li>
</ul>
<p>简化为：int –&gt; long –&gt; float -&gt; double</p>
<p>简化理解：也就是2 == to，这样的简化在英语用比较常见，英语中 4 == for</p>
<p>比如：log4j == log for java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upCast1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">long</span> l = i;</span><br><span class="line">    <span class="keyword">float</span> f = i;</span><br><span class="line">    <span class="keyword">double</span> d = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> f1 = l;</span><br><span class="line">    <span class="keyword">double</span> d1 = l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> d2 = f1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> iload_1</span><br><span class="line"> <span class="number">4</span> i2l</span><br><span class="line"> <span class="number">5</span> lstore_2</span><br><span class="line"> <span class="number">6</span> iload_1</span><br><span class="line"> <span class="number">7</span> i2f</span><br><span class="line"> <span class="number">8</span> fstore <span class="number">4</span></span><br><span class="line"><span class="number">10</span> iload_1</span><br><span class="line"><span class="number">11</span> i2d</span><br><span class="line"><span class="number">12</span> dstore <span class="number">5</span></span><br><span class="line"><span class="number">14</span> lload_2</span><br><span class="line"><span class="number">15</span> l2f</span><br><span class="line"><span class="number">16</span> fstore <span class="number">7</span></span><br><span class="line"><span class="number">18</span> lload_2</span><br><span class="line"><span class="number">19</span> l2d</span><br><span class="line"><span class="number">20</span> dstore <span class="number">8</span></span><br><span class="line"><span class="number">22</span> fload <span class="number">7</span></span><br><span class="line"><span class="number">24</span> f2d</span><br><span class="line"><span class="number">25</span> dstore <span class="number">10</span></span><br><span class="line"><span class="number">27</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<h4 id="精度损失问题"><a href="#精度损失问题" class="headerlink" title="精度损失问题"></a>精度损失问题</h4><ul>
<li><p>宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从int转换到long,或者从int转换到double,都不会丢失任何信息，转换前后的值是精确相等的。</p>
</li>
<li><p>从int、long类型数值转换到float,或者long类型数值转换到double时，将可能发生精度丢失一一可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据IEEE754最接近含入模式所得到的正确整数值。</p>
</li>
</ul>
<p>尽管宽化类型转换实际上是可能发生精度丢失的，但是这种转换永远<strong>不会导致Java虚拟机抛出运行时异常</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upCast2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">123123123</span>;</span><br><span class="line">    <span class="keyword">float</span> f = i;</span><br><span class="line">    System.out.println(f);<span class="comment">//1.2312312E8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> l = <span class="number">123123123123L</span>;</span><br><span class="line">    <span class="keyword">double</span> d = l;</span><br><span class="line">    System.out.println(d);<span class="comment">//1.23123123123E11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>float组成：符号位、指数位、有效位（下面举例的位数可以转变，也就是可以转变精度）</p>
<p>​       第一个字节  第二个字节  第三个字节  第四个字节</p>
<p>​    <font color=blue>0</font><font color=orange>101 0000  0</font><font color=green>000 0000 0000 0000 0000 0000</font></p>
<p>​    蓝色：符号位（ 31 ）</p>
<p>​    橘黄色：幂指数位（23－－30）</p>
<p>​    绿色：有效位 （0－－22）</p>
<p>浮点数的32位在内存的排列情况，其中的前23位是有效位，占23个比特位，第24位到31位为幂指数位，占8个比特位，第32位依旧是符号位。</p>
<p>所以float一共就四个字节，其中有效位只占据一部分，所以在同样字节转换的时候有可能会发生精度丢失</p>
<h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><p>从byte、char和 short类型到int类型的宽化类型转换实际上是不存在的。对于byte类型转为int,拟机并没有做实质性的转化处理，只是简单地通过操作数栈交換了两个数据。而将byte转为long时，使用的是i2l,可以看到在内部，byte在这里已经等同于int类型处理，类似的还有 short类型，这种处理方式有两个特点：</p>
<p>一方面可以减少实际的数据类型，如果为 short和byte都准备一套指令，那么指令的数量就会大増，而虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过256个，为了节省指令资源，将 short和byte当做int处理也在情理之中。</p>
<p>另一方面，由于局部变量表中的槽位固定为32位，无论是byte或者 short存入局部变量表，都会占用32位空间。从这个角度说，也没有必要特意区分这几种数据类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upCast3</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = b;</span><br><span class="line">    <span class="keyword">long</span> l = b;</span><br><span class="line">    <span class="keyword">double</span> d = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upCast4</span><span class="params">(<span class="keyword">short</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = s;</span><br><span class="line">    <span class="keyword">long</span> l = s;</span><br><span class="line">    <span class="keyword">float</span> f = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//upCast3</span></span><br><span class="line"><span class="number">0</span> iload_1</span><br><span class="line"><span class="number">1</span> istore_2</span><br><span class="line"><span class="number">2</span> iload_1</span><br><span class="line"><span class="number">3</span> i2l</span><br><span class="line"><span class="number">4</span> lstore_3</span><br><span class="line"><span class="number">5</span> iload_1</span><br><span class="line"><span class="number">6</span> i2d</span><br><span class="line"><span class="number">7</span> dstore <span class="number">5</span></span><br><span class="line"><span class="number">9</span> <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//upCast4</span></span><br><span class="line"><span class="number">0</span> iload_1</span><br><span class="line"><span class="number">1</span> istore_2</span><br><span class="line"><span class="number">2</span> iload_1</span><br><span class="line"><span class="number">3</span> i2l</span><br><span class="line"><span class="number">4</span> lstore_3</span><br><span class="line"><span class="number">5</span> iload_1</span><br><span class="line"><span class="number">6</span> i2f</span><br><span class="line"><span class="number">7</span> fstore <span class="number">5</span></span><br><span class="line"><span class="number">9</span> <span class="keyword">return</span>    </span><br></pre></td></tr></table></figure>

<p>然后我们发现没有从byte和short到int的转换，byte到int和到double的转换都是用的int转long和转double</p>
<h3 id="4-2-窄化类型转换剖析"><a href="#4-2-窄化类型转换剖析" class="headerlink" title="4.2. 窄化类型转换剖析"></a>4.2. 窄化类型转换剖析</h3><p>窄化类型转换( Narrowing Numeric Conversion)</p>
<h4 id="转换规则-1"><a href="#转换规则-1" class="headerlink" title="转换规则"></a>转换规则</h4><p>Java虚拟机也直接支持以下窄化类型转换：</p>
<p>从int类型至byte、 short或者char类型。对应的指令有：<code>i2b</code>、<code>i2c</code>、<code>i2c</code></p>
<p>从long类型到int类型。对应的指令有：<code>l2i</code></p>
<p>从float类型到int或者long类型。对应的指令有：<code>f2i</code>、<code>f2l</code></p>
<p>从double类型到int、long或者float类型。对应的指令有：<code>d2i</code>、<code>d2l</code>、<code>d2f</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downCast1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">    <span class="keyword">short</span> s = (<span class="keyword">short</span>) i;</span><br><span class="line">    <span class="keyword">char</span> c = (<span class="keyword">char</span>) i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> l = <span class="number">10L</span>;</span><br><span class="line">    <span class="keyword">int</span> i1 = (<span class="keyword">int</span>) l;</span><br><span class="line">    <span class="comment">// 重点在这里，这里把一个long类型转化为byte类型用到了两个指令，l2i和l2b，先把long转化为int，在吧int转化为byte</span></span><br><span class="line">    <span class="keyword">byte</span> b1 = (<span class="keyword">byte</span>) l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downCast2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">long</span> l = (<span class="keyword">long</span>)f;</span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)f;</span><br><span class="line">    <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)f;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 这里用的d2i 和 i2d</span></span><br><span class="line">    <span class="keyword">byte</span> b1 = (<span class="keyword">byte</span>)d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//downCast1()</span></span><br><span class="line"><span class="number">0</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> iload_1</span><br><span class="line"> <span class="number">4</span> i2b</span><br><span class="line"> <span class="number">5</span> istore_2</span><br><span class="line"> <span class="number">6</span> iload_1</span><br><span class="line"> <span class="number">7</span> i2s</span><br><span class="line"> <span class="number">8</span> istore_3</span><br><span class="line"> <span class="number">9</span> iload_1</span><br><span class="line"><span class="number">10</span> i2c</span><br><span class="line"><span class="number">11</span> istore <span class="number">4</span></span><br><span class="line"><span class="number">13</span> ldc2_w #<span class="number">11</span> &lt;<span class="number">10</span>&gt;</span><br><span class="line"><span class="number">16</span> lstore <span class="number">5</span></span><br><span class="line"><span class="number">18</span> lload <span class="number">5</span></span><br><span class="line"><span class="number">20</span> l2i</span><br><span class="line"><span class="number">21</span> istore <span class="number">7</span></span><br><span class="line"><span class="number">23</span> lload <span class="number">5</span></span><br><span class="line"><span class="number">25</span> l2i</span><br><span class="line"><span class="number">26</span> i2b</span><br><span class="line"><span class="number">27</span> istore <span class="number">8</span></span><br><span class="line"><span class="number">29</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<h4 id="精度损失问题-1"><a href="#精度损失问题-1" class="headerlink" title="精度损失问题"></a>精度损失问题</h4><p>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度。</p>
<p>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downCast4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;</span><br><span class="line">    System.out.println(b);<span class="comment">// -128</span></span><br><span class="line">    <span class="comment">// 因为128的int二进制为0000 ... 0000 1000 0000</span></span><br><span class="line">    <span class="comment">// 然后转化为byte后高位截取保留8位，剩余1000 0000就是`-128`</span></span><br><span class="line">    <span class="comment">// 计算机存储数据是用的补码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-128的机器码原码实际是：110000000，反码101111111，补码110000000，截取低8位即10000000</p>
<h4 id="补充说明-1"><a href="#补充说明-1" class="headerlink" title="补充说明"></a>补充说明</h4><h5 id="当将一个浮点值窄化转换为整数类型T-T限于int或long类型之一-的时候，将遵循以下转换规则："><a href="#当将一个浮点值窄化转换为整数类型T-T限于int或long类型之一-的时候，将遵循以下转换规则：" class="headerlink" title="当将一个浮点值窄化转换为整数类型T(T限于int或long类型之一)的时候，将遵循以下转换规则："></a>当将一个浮点值窄化转换为整数类型T(T限于int或long类型之一)的时候，将遵循以下转换规则：</h5><ul>
<li><p>如果浮点值是NaN,那转换结果就是int或long类型的0.</p>
</li>
<li><p>如果浮点值不是无穷大的话，浮点值使用IEEE754的向零含入模式取整，获得整数值V，如果v在目标类型T(int或long)的表示范围之内，那转换结果就是v。否则，将根据v的符号，转换为T所能表示的最大或者最小正数</p>
</li>
</ul>
<h5 id="当将一个double类型窄化转换为float类型时，将遵循以下转换规则："><a href="#当将一个double类型窄化转换为float类型时，将遵循以下转换规则：" class="headerlink" title="当将一个double类型窄化转换为float类型时，将遵循以下转换规则："></a>当将一个double类型窄化转换为float类型时，将遵循以下转换规则：</h5><p>通过向最接近数舍入模式舍入一个可以使用float类型表示的数字。最后结果根据下面这3条规则判断</p>
<ul>
<li><p>如果转换结果的绝对值太小而无法使用float来表示，将返回float类型的正负零</p>
</li>
<li><p>如果转换结果的绝对值太大而无法使用float来表示，将返回float类型的正负无穷大。</p>
</li>
<li><p>对于double类型的NaN值将按规定转換为float类型的NaN值。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downCast5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d1 = Double.NaN;</span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>) d1;</span><br><span class="line">    <span class="keyword">float</span> f = (<span class="keyword">float</span>) d1;</span><br><span class="line">    <span class="comment">// NaN</span></span><br><span class="line">    System.out.println(d1);</span><br><span class="line">    <span class="comment">// int类型没有NaN</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">    <span class="comment">// float的NaN</span></span><br><span class="line">    System.out.println(f);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d2为double的正向无穷大</span></span><br><span class="line">    <span class="keyword">double</span> d2 = Double.POSITIVE_INFINITY;</span><br><span class="line">    <span class="keyword">long</span> l = (<span class="keyword">long</span>) d2;</span><br><span class="line">    <span class="keyword">int</span> j = (<span class="keyword">int</span>) d2;</span><br><span class="line">    <span class="keyword">float</span> f2 = (<span class="keyword">float</span>) d2;</span><br><span class="line">    <span class="comment">// 转化为long的正向最大值</span></span><br><span class="line">    System.out.println(l);</span><br><span class="line">    <span class="comment">// 转化为int的正向最大值</span></span><br><span class="line">    System.out.println(j);</span><br><span class="line">    <span class="comment">// 转为float的正向最大值：Infinity</span></span><br><span class="line">    System.out.println(f2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NaN</span><br><span class="line"><span class="number">0</span></span><br><span class="line">NaN</span><br><span class="line"><span class="number">9223372036854775807</span></span><br><span class="line"><span class="number">2147483647</span></span><br><span class="line">Infinity</span><br></pre></td></tr></table></figure>



<h2 id="5-对象的创建与访问指令"><a href="#5-对象的创建与访问指令" class="headerlink" title="5. 对象的创建与访问指令"></a>5. 对象的创建与访问指令</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>Java是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为创建指令、字段访问指令、数组操作指令、类型检查指令。</p>
<blockquote>
<h2 id="对象操作指令"><a href="#对象操作指令" class="headerlink" title="对象操作指令"></a>对象操作指令</h2><p>new 创建一个新对象</p>
<p>getfield 从对象中获取字段</p>
<p>putfield 设置对象中字段的值</p>
<p>getstatic 从类中获取静态字段</p>
<p>putstatic 设置类中静态字段的值</p>
<p>checkcast 确定对象为所给定的类型。后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。如果不是便抛出异常</p>
<p>instanceof 判断对象是否为给定的类型。后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。是则压入 1，否则压入 0</p>
<h2 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h2><p>newarray 分配数据成员类型为基本上数据类型的新数组</p>
<p>anewarray 分配数据成员类型为引用类型的新数组</p>
<p>arraylength 获取数组长度</p>
<p>multianewarray 分配新的多维数组</p>
</blockquote>
<h3 id="5-1-创建指令"><a href="#5-1-创建指令" class="headerlink" title="5.1. 创建指令"></a>5.1. 创建指令</h3><table>
<thead>
<tr>
<th>创建指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>new</td>
<td>创建类实例</td>
</tr>
<tr>
<td>newarray</td>
<td>创建基本类型数组</td>
</tr>
<tr>
<td>anewarray</td>
<td>创建引用类型数组</td>
</tr>
<tr>
<td>multilanewarra</td>
<td>创建多维数组</td>
</tr>
</tbody></table>
<p>一、创建指令</p>
<p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令：</p>
<p>1．创建类实例的指令：</p>
<ul>
<li>创建类实例的指令： new <ul>
<li>它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的引用压入栈。 </li>
</ul>
</li>
</ul>
<p>2．创建数组的指令：</p>
<ul>
<li><p>创建数组的指令：newarray、anewarray、multianewarray:</p>
<ul>
<li><p>newarray：创建基本类型数组</p>
</li>
<li><p>anewarray：创建引用类型数组</p>
</li>
<li><p>multianewarray：创建多维数组</p>
</li>
</ul>
</li>
</ul>
<p>上述创建指令可以用于创建对象或者数组，由于对象和数组在Java中的广泛使用，这些指令的使用频率也非常高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建指令</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;lvxiaoyi.avi&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> <span class="keyword">new</span> #<span class="number">2</span> &lt;java/lang/Object&gt;</span><br><span class="line"> <span class="number">3</span> dup							<span class="comment">//栈顶的数据复制一份</span></span><br><span class="line"> <span class="number">4</span> invokespecial #<span class="number">1</span> &lt;java/lang/Object.&lt;init&gt;&gt;  <span class="comment">// 调用Object的构造器方法，然后出栈</span></span><br><span class="line"> <span class="number">7</span> astore_1 <span class="comment">// 把栈顶存储到局部变量表1的位置</span></span><br><span class="line"> <span class="number">8</span> <span class="keyword">new</span> #<span class="number">3</span> &lt;java/io/File&gt; <span class="comment">//创建File实例</span></span><br><span class="line"><span class="number">11</span> dup			<span class="comment">//栈顶的数据复制一份</span></span><br><span class="line"><span class="number">12</span> ldc #<span class="number">4</span> &lt;lvxiaoyi.avi&gt; <span class="comment">// 把这个字符串存储到栈中</span></span><br><span class="line"><span class="number">14</span> invokespecial #<span class="number">5</span> &lt;java/io/File.&lt;init&gt;&gt;<span class="comment">// 调用File的构造器方法，然后出栈</span></span><br><span class="line"><span class="number">17</span> astore_2</span><br><span class="line"><span class="number">18</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    Object[] objArray = <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span>[][] mintArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    String[][] strArray = <span class="keyword">new</span> String[<span class="number">10</span>][];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">2</span> newarray <span class="number">10</span> (<span class="keyword">int</span>)</span><br><span class="line"> <span class="number">4</span> astore_1</span><br><span class="line"> <span class="number">5</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">7</span> anewarray #<span class="number">2</span> &lt;java/lang/Object&gt;<span class="comment">//创建引用类型数组</span></span><br><span class="line"><span class="number">10</span> astore_2</span><br><span class="line"><span class="number">11</span> bipush <span class="number">10</span></span><br><span class="line"><span class="number">13</span> bipush <span class="number">10</span>		</span><br><span class="line"><span class="number">15</span> multianewarray #<span class="number">6</span> &lt;[[I&gt; dim <span class="number">2</span><span class="comment">//创建多维类型数组</span></span><br><span class="line"><span class="number">19</span> astore_3</span><br><span class="line"><span class="number">20</span> bipush <span class="number">10</span></span><br><span class="line"><span class="number">22</span> anewarray #<span class="number">7</span> &lt;[Ljava/lang/String;&gt;<span class="comment">//还是创建引用类型数组，相当于一维的</span></span><br><span class="line"><span class="number">25</span> astore <span class="number">4</span></span><br><span class="line"><span class="number">27</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<h3 id="5-2-字段访问指令"><a href="#5-2-字段访问指令" class="headerlink" title="5.2. 字段访问指令"></a>5.2. 字段访问指令</h3><table>
<thead>
<tr>
<th>字段访问指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>getstatic、putstatic</td>
<td>访问类字段（static字段，或者称为类变量）的指令</td>
</tr>
<tr>
<td>getfield、 putfield</td>
<td>访问类实例字段（非static字段，或者称为实例变量）的指令</td>
</tr>
</tbody></table>
<p>二、字段访问指令</p>
<p>对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素。</p>
<ul>
<li>访问类字段(static字段，或者称为类变量〉的指令:getstatic、putstatic</li>
<li>访问类实例字段（非static字段，或者称为实例变量〉的指令： getfield、putfield</li>
</ul>
<p>举例：</p>
<p>以getstatic指令为例，它含有一个操作数，为指向常量池的Fieldref索引，它的作用就是获取Fieldref指定的对象或者值，并将其压入操作数栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello,lvxiaoyi&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的字节码指令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> getstatic #<span class="number">8</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">3</span> ldc #<span class="number">9</span> &lt;hello,lvxiaoyi&gt;</span><br><span class="line"><span class="number">5</span> invokevirtual #<span class="number">10</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">8</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>图示：</p>
<p> <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/6f7033f9caaf3216c6ca6795de12f6a4.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    order.id = <span class="number">1001</span>;</span><br><span class="line">    System.out.println(order.id);</span><br><span class="line"></span><br><span class="line">    Order.name = <span class="string">&quot;LVXIAOYI&quot;</span>;</span><br><span class="line">    System.out.println(Order.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> <span class="keyword">new</span> #<span class="number">11</span> &lt;top/lvxiaoyi/code5/Order&gt;<span class="comment">//在操作数栈中创建一个指针，执行堆中的实体</span></span><br><span class="line"> <span class="number">3</span> dup<span class="comment">//栈中复制一份</span></span><br><span class="line"> <span class="number">4</span> invokespecial #<span class="number">12</span> &lt;top/lvxiaoyi/code5/Order.&lt;init&gt;&gt;<span class="comment">//调用order的构造器方法，出栈</span></span><br><span class="line"> <span class="number">7</span> astore_1<span class="comment">//把对象指针放入局部变量</span></span><br><span class="line"> <span class="number">8</span> aload_1<span class="comment">//对象指针加载进栈中</span></span><br><span class="line"> <span class="number">9</span> sipush <span class="number">1001</span><span class="comment">//栈中放入1001</span></span><br><span class="line"><span class="number">12</span> putfield #<span class="number">13</span> &lt;top/lvxiaoyi/code5/Order.id&gt;<span class="comment">//把1001放入对象的名叫id的field字段，出栈</span></span><br><span class="line"><span class="number">15</span> getstatic #<span class="number">8</span> &lt;java/lang/System.out&gt;<span class="comment">//调用out属性</span></span><br><span class="line"><span class="number">18</span> aload_1<span class="comment">//对象指针加载进栈中</span></span><br><span class="line"><span class="number">19</span> getfield #<span class="number">13</span> &lt;top/lvxiaoyi/code5/Order.id&gt;<span class="comment">//拿对局对象指针拿到对象的field（id）</span></span><br><span class="line"><span class="number">22</span> invokevirtual #<span class="number">14</span> &lt;java/io/PrintStream.println&gt;<span class="comment">//执行println方法</span></span><br><span class="line"><span class="number">25</span> ldc #<span class="number">15</span> &lt;LVXIAOYI&gt;<span class="comment">//把字符串“LVXIAOYI&quot;压入栈中</span></span><br><span class="line"><span class="number">27</span> putstatic #<span class="number">16</span> &lt;top/lvxiaoyi/code5/Order.name&gt;<span class="comment">//调用静态的name放入栈中，赋值后出栈</span></span><br><span class="line"><span class="number">30</span> getstatic #<span class="number">8</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">33</span> getstatic #<span class="number">16</span> &lt;top/lvxiaoyi/code5/Order.name&gt;<span class="comment">//拿到的Order的静态name字段</span></span><br><span class="line"><span class="number">36</span> invokevirtual #<span class="number">10</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">39</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<h3 id="5-3-数组操作指令"><a href="#5-3-数组操作指令" class="headerlink" title="5.3. 数组操作指令"></a>5.3. 数组操作指令</h3><table>
<thead>
<tr>
<th>数组指令</th>
<th>byte(boolean)</th>
<th>char</th>
<th>short</th>
<th>long</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th>reference</th>
</tr>
</thead>
<tbody><tr>
<td><strong>xaload</strong></td>
<td>baload</td>
<td>caload</td>
<td>saload</td>
<td>iaload</td>
<td>laload</td>
<td>faload</td>
<td>daload</td>
<td>aaload</td>
</tr>
<tr>
<td><strong>xastore</strong></td>
<td>bastore</td>
<td>castore</td>
<td>sastore</td>
<td>iastore</td>
<td>lastore</td>
<td>fastore</td>
<td>dastore</td>
<td>aastore</td>
</tr>
</tbody></table>
<p>三、数组操作指令</p>
<p>数组操作指令主要有： xastore和xaload指令。具体为：</p>
<ul>
<li>把一个数组元素加载到操作数栈的指令： baload、caload、saload、iaload、laload、faload、daload、aaload</li>
<li>将一个操作数栈的值存储到数组元素中的指令： bastore、castore、sastore、iastore、fastore、dastore、aastore</li>
</ul>
<p>即：</p>
<table>
<thead>
<tr>
<th>数组指令</th>
<th>byte(boolean)</th>
<th>char</th>
<th>short</th>
<th>long</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th>reference</th>
</tr>
</thead>
<tbody><tr>
<td><strong>xaload</strong></td>
<td>baload</td>
<td>caload</td>
<td>saload</td>
<td>iaload</td>
<td>laload</td>
<td>faload</td>
<td>daload</td>
<td>aaload</td>
</tr>
<tr>
<td><strong>xastore</strong></td>
<td>bastore</td>
<td>castore</td>
<td>sastore</td>
<td>iastore</td>
<td>lastore</td>
<td>fastore</td>
<td>dastore</td>
<td>aastore</td>
</tr>
</tbody></table>
<ul>
<li>取数组长度的指令:arraylength<ul>
<li>该指令弹出栈顶的数组元素，获取数组的长度，将长度压入栈。</li>
</ul>
</li>
</ul>
<p>2．说明</p>
<ul>
<li>指令xaload表示将数组的元素压栈，比如saload、caload分别表示压入short数组和char数组。指令xaload在执行时，要求操作数中栈顶元素为数组索引i,栈顶顺位第2个元素为数组引用a,该指令会弹出栈顶这两个元素，并将a[i]重新压入栈。</li>
<li>xastore则专门针对数组操作，以iastore为例，它用于给一个int数组的给定索引赋值。在i<strong>astore执行前，操作数栈顶需要以此准备3个元素：值、索引、数组引用，iastore会弹出这3个值，并将值赋给数组中指定索引的位置。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    intArray[<span class="number">3</span>] = <span class="number">20</span>;</span><br><span class="line">    System.out.println(intArray[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span>[] arr = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">10</span>];</span><br><span class="line">    System.out.println(arr.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//serArray</span></span><br><span class="line"> <span class="number">0</span> bipush <span class="number">10</span><span class="comment">//占中放一个10</span></span><br><span class="line"> <span class="number">2</span> newarray <span class="number">10</span> (<span class="keyword">int</span>)<span class="comment">//创建一个数组，数组地址存放栈中</span></span><br><span class="line"> <span class="number">4</span> astore_1<span class="comment">//地址存放局部变量表</span></span><br><span class="line"> <span class="number">5</span> aload_1<span class="comment">//栈中放入数组对象地址</span></span><br><span class="line"> <span class="number">6</span> iconst_3<span class="comment">//栈中压入常量3</span></span><br><span class="line"> <span class="number">7</span> bipush <span class="number">20</span><span class="comment">//栈中放入20</span></span><br><span class="line"> <span class="number">9</span> iastore<span class="comment">//iastore命令给数组的index为3的值设置为20，出栈</span></span><br><span class="line"><span class="number">10</span> getstatic #<span class="number">8</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">13</span> aload_1</span><br><span class="line"><span class="number">14</span> iconst_1</span><br><span class="line"><span class="number">15</span> iaload</span><br><span class="line"><span class="number">16</span> invokevirtual #<span class="number">14</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">19</span> bipush <span class="number">10</span></span><br><span class="line"><span class="number">21</span> newarray <span class="number">7</span> (<span class="keyword">double</span>)</span><br><span class="line"><span class="number">23</span> astore_2</span><br><span class="line"><span class="number">24</span> getstatic #<span class="number">8</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">27</span> aload_2</span><br><span class="line"><span class="number">28</span> arraylength</span><br><span class="line"><span class="number">29</span> invokevirtual #<span class="number">14</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">32</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="5-4-类型检查指令"><a href="#5-4-类型检查指令" class="headerlink" title="5.4. 类型检查指令"></a>5.4. 类型检查指令</h3><table>
<thead>
<tr>
<th>类型检查指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>instanceof</td>
<td>检查类型强制转换是否可以进行</td>
</tr>
<tr>
<td>checkcast</td>
<td>判断给定对象是否是某一个类的实例</td>
</tr>
</tbody></table>
<p>四、类型检查指令</p>
<p>检查类实例或数组类型的指令： instanceof、checkcast。</p>
<ul>
<li>指令checkcast用于检查类型强制转换是否可以进行。如果可以进行，那么checkcast指令不会改变操作数栈，否则它会抛出ClasscastException异常。</li>
<li>指令instanceof用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型检查指令</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">checkCast</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> (String) obj;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="number">0</span> aload_1 <span class="comment">// 直接把参数放入栈中 </span></span><br><span class="line"> <span class="number">1</span> <span class="keyword">instanceof</span> #<span class="number">17</span> &lt;java/lang/String&gt;<span class="comment">// 判断是不是String类型</span></span><br><span class="line"> <span class="number">4</span> ifeq <span class="number">12</span> (+<span class="number">8</span>)<span class="comment">//如果是往下走，如果不是到12行代码（aconst_null），出栈</span></span><br><span class="line"> <span class="number">7</span> aload_1<span class="comment">//把参数入站</span></span><br><span class="line"> <span class="number">8</span> checkcast #<span class="number">17</span> &lt;java/lang/String&gt;<span class="comment">// 把obj转为string类型</span></span><br><span class="line"><span class="number">11</span> areturn<span class="comment">//返回字符串</span></span><br><span class="line"><span class="number">12</span> aconst_null<span class="comment">//返回null</span></span><br><span class="line"><span class="number">13</span> areturn<span class="comment">//方法结束，默认加return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="6-方法调用与返回指令"><a href="#6-方法调用与返回指令" class="headerlink" title="6. 方法调用与返回指令"></a>6. 方法调用与返回指令</h2><blockquote>
<h2 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h2><p>invokcvirtual 运行时按照对象的类来调用实例方法</p>
<p>invokespecial 根据编译时类型来调用实例方法</p>
<p>invokestatic 调用类（静态）方法</p>
<p>invokcinterface 调用接口方法</p>
<h2 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h2><p>ireturn 从方法中返回int类型的数据</p>
<p>lreturn 从方法中返回long类型的数据</p>
<p>freturn 从方法中返回float类型的数据</p>
<p>dreturn 从方法中返回double类型的数据</p>
<p>areturn 从方法中返回引用类型的数据</p>
<p>return 从方法中返回，返回值为void</p>
</blockquote>
<h3 id="6-1-方法调用指令"><a href="#6-1-方法调用指令" class="headerlink" title="6.1. 方法调用指令"></a>6.1. 方法调用指令</h3><table>
<thead>
<tr>
<th>方法调用指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>invokevirtual</td>
<td>调用对象的实例方法</td>
</tr>
<tr>
<td>invokeinterface</td>
<td>调用接口方法</td>
</tr>
<tr>
<td>invokespecial</td>
<td>调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法</td>
</tr>
<tr>
<td>invokestatic</td>
<td>调用命名类中的类方法（static方法）</td>
</tr>
<tr>
<td>invokedynamic</td>
<td>调用动态绑定的方法</td>
</tr>
</tbody></table>
<p>方法调用指令：</p>
<p> invokevirtual、invokeinterface、invokespecial、invokestatic . invokedynamic</p>
<p>以下5条指令用于方法调用：</p>
<ul>
<li>invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是Java语言中最常见的方法分派方式。</li>
<li>invokeinterface指令：用于调用接口方法，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用。</li>
<li>invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器〉、私有方法和父类方法。这些方法都是静态类型绑定的，不会在调用时进行动态派发。</li>
<li>invokestatic指令：用于调用命名类中的类方法(static方法）。这是静态绑定的。</li>
<li>invokedynamic：调用动态绑定的方法，这个是JDK 1.7后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面4条调用指令的分派逻辑都固化在 java虚拟机内部，而 invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。  </li>
</ul>
<h4 id="举例一"><a href="#举例一" class="headerlink" title="举例一"></a>举例一</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法调用指令：invokespecial</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 情况1：类实例构造器方法：&lt;init&gt; invokespecial</span></span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread();</span><br><span class="line">    <span class="comment">// 情况2：父类的方法  invokespecial</span></span><br><span class="line">    <span class="keyword">super</span>.toString();</span><br><span class="line">    <span class="comment">// 情况3：私有方法  invokespecial</span></span><br><span class="line">    methodPrivate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用静态方法：invokestatic</span></span><br><span class="line"><span class="comment">// 调用private static也是用的invokestatic</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    methodStatic();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread();</span><br><span class="line">    <span class="comment">// 调用Runnable接口的run方法 invokeinterface</span></span><br><span class="line">    ((Runnable) t1).run();</span><br><span class="line"></span><br><span class="line">    Comparable&lt;Integer&gt; com = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 这里调用了两个方法</span></span><br><span class="line">    <span class="comment">// 首先会调用Integer.valueof方法    invokestatic #10 &lt;java/lang/Integer.valueOf&gt;</span></span><br><span class="line">    <span class="comment">// 然后调用 invokeinterface #11 &lt;java/lang/Comparable.compareTo&gt; count 2</span></span><br><span class="line">    com.compareTo(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello,lvxiaoyi&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// prublc方法调用 invokevirtual</span></span><br><span class="line">    t1.run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="举例二-1"><a href="#举例二-1" class="headerlink" title="举例二"></a>举例二</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.lvxiaoyi.code6;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/16 10:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceMethodTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AA aa = <span class="keyword">new</span> BB();</span><br><span class="line">        System.out.println(AA.b);</span><br><span class="line">        aa.method2();</span><br><span class="line">        aa.method3();</span><br><span class="line">        AA.method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AA</span> <span class="keyword">extends</span> <span class="title">DD</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,lvxiaoyi. I&#x27;m static method1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,lvxiaoyi. I&#x27;m default method2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span> <span class="keyword">implements</span> <span class="title">AA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method8</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CC</span> <span class="keyword">implements</span> <span class="title">AA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,lvxiaoyi. I&#x27;m default method4()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,lvxiaoyi. I&#x27;m static method6&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DD</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method7</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method8</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到这里突然发现一个问题，接口里面的方法在jdk8（这里没有函数式注解），也可以有静态和默认（不是抽象的）的方法，也都可以有实现，这里大部分文章都是老的（天下文章一大抄），抽象方法不能有实现。</p>
<p>成员量只能是public static final，默认也是</p>
<p>接口中不能有代码块</p>
<p>还有就是接口可是继承接口，实现接口的类必须实习父类（还有祖父类）<strong>所有的抽象方法</strong>。</p>
<p>接口主要是为了对类的行为规范（对API的抽象）</p>
<p>抽象类是为了对类的规范（提高代码复用）</p>
<h3 id="6-2-方法返回指令"><a href="#6-2-方法返回指令" class="headerlink" title="6.2. 方法返回指令"></a>6.2. 方法返回指令</h3><table>
<thead>
<tr>
<th>方法返回指令</th>
<th>void</th>
<th>int</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th>reference</th>
</tr>
</thead>
<tbody><tr>
<td><strong>xreturn</strong></td>
<td>return</td>
<td>ireturn</td>
<td>lreturn</td>
<td>freutrn</td>
<td>dreturn</td>
<td>areturn</td>
</tr>
</tbody></table>
<p>方法返回指令：</p>
<p>方法调用结束前，需要进行返回。方法返回指令是<strong>根据返回值的类型区分</strong>的。</p>
<ul>
<li>包括ireturn（当返回值是 boolean、byte、char、short和int类型时使用)、lreturn、freturn、dreturn和areturn</li>
<li>另外还有一条return指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用。</li>
</ul>
<p>举例：</p>
<p>通过ireturn指令,将当前函数操作数栈的顶层元素弹出，并将这个元素压入调用者函数的操作数栈中（因为调用者非常关心函数的返回值），所有在当前函数操作数栈中的其他元素都会被丢弃。</p>
<p>如果当前返回的是synchronized方法，那么还会执行一个隐含的monitorexit指令，退出临界区。</p>
<p>最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">methodReturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">50</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (i + j) / k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/3fbd1f2ca9f4300eee5e0c4a0227a441.png" alt="image-20210425222245665"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">returnInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">returnDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">returnString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello,lvxioayi&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] returnArr() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">returnFloat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 主要还是返回类型是什么   freturn</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">returnByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用的ireturn</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodReturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在另一个栈中调用 invokevirtual #17 &lt;top/lvxiaoyi/code6/MethodInvokeReturnTest.returnByte&gt;拿到方法返回值</span></span><br><span class="line">    <span class="comment">// 然后把方法返回值使用istore_1命令放入局部变量表</span></span><br><span class="line">    <span class="keyword">int</span> i = returnByte();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-操作数栈管理指令"><a href="#7-操作数栈管理指令" class="headerlink" title="7. 操作数栈管理指令"></a>7. 操作数栈管理指令</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><blockquote>
<h2 id="通用-无类型）栈操作"><a href="#通用-无类型）栈操作" class="headerlink" title="通用(无类型）栈操作"></a>通用(无类型）栈操作</h2><p>nop 不做任何操作</p>
<p>pop 弹出栈顶端一个字长的内容</p>
<p>pop2 弹出栈顶端两个字长的内容</p>
<p>dup 复制栈顶部一个字长内容</p>
<p>dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈</p>
<p>dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈</p>
<p>dup2 复制栈顶部两个字长内容</p>
<p>dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈</p>
<p>dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈</p>
<p>swap 交换栈顶部两个字长内容</p>
</blockquote>
<p>操作数栈管理指令</p>
<p>如同操作一个普通数据结构中的堆栈那样，JVM提供的操作数栈管理指令，可以用于直接操作操作数栈的指令。</p>
<p>这类指令包括如下内容：</p>
<ul>
<li><p>将一个或两个元素从栈顶弹出，并且直接废弃:pop，pop2;</p>
</li>
<li><p>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶： dup,dup2，dup_x1,dup2_x1，dup_x2，dup2_x2;</p>
</li>
<li><p>将栈最顶端的两个Slot数值位置交换：swap。Java虚拟机没有提供交换两个64位数据类型（long、double）数值的指令。</p>
</li>
<li><p>指令nop,是一个非常特殊的指令，它的字节码为0x00。和汇编语言中的nop一样，它表示什么都不做。这条指令一般可用于调试、占位等。</p>
</li>
</ul>
<p>这些指令属于通用型，对栈的压入或者弹出无需指明数据类型。</p>
<p>说明：</p>
<ul>
<li>不带_x的指令是复制栈顶数据并压入栈顶。包括两个指令，dup和dup2.dup的系数代表要复制的slot个数。_<ul>
<li>dup开头的指令用于复制1个Slot的数据。例如1个int或1个reference类型数据</li>
<li> dup2开头的指令用于复制2个Slot的数据。例如1个long，或2个int，或1个int+1个float类型数据</li>
</ul>
</li>
<li>带_x的指令是复制栈顶数据并插入栈顶以下的某个位置。共有4个指令, dup_x1，dup2_x1,dup_x2，dup2_x2。对于带_x的复制插入指令，只要将指令的dup和x的系数相加，结果即为需要插入的位置。因此<ul>
<li>dup_x1插入位置：1+1=2，即栈顶2个slot下面. </li>
<li>dup_x2插入位置：1+2=3，即栈顶3个Slot下面.</li>
<li>dup2_x1插入位置：2+1=3，即栈顶3个slot下面.</li>
<li>dup2_x2插入位置：2+2=4，即栈顶4个Slot下面</li>
</ul>
</li>
<li>pop：将栈顶的1个Slot数值出栈。例如1个short类型数值</li>
<li>pop2：将栈顶的2个Slot数值出栈。例如1个double类型数值，或者2个int类型数值</li>
</ul>
<h3 id="举例一-1"><a href="#举例一-1" class="headerlink" title="举例一"></a>举例一</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  9 invokevirtual #3 &lt;java/lang/Object.toString&gt;</span></span><br><span class="line"><span class="comment">     * 12 astore_2</span></span><br><span class="line"><span class="comment">     * 13 aload_1</span></span><br><span class="line"><span class="comment">     * 14 invokevirtual #3 &lt;java/lang/Object.toString&gt;</span></span><br><span class="line"><span class="comment">     * 17 pop</span></span><br><span class="line"><span class="comment">     * 18 return</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * pop指令是弹出栈顶的一个solt，因为obj.toString()不需要存储值也不需要返回，就直接弹出了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    String string = obj.toString();</span><br><span class="line">    obj.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里使用的pop2，因为long占据两个solt</span></span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="举例二-2"><a href="#举例二-2" class="headerlink" title="举例二"></a>举例二</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> aload_0 <span class="comment">// 把0放入栈中</span></span><br><span class="line"> <span class="number">1</span> dup<span class="comment">// 复制一份数据</span></span><br><span class="line"> <span class="number">2</span> getfield #<span class="number">2</span> &lt;top/lvxiaoyi/code7/StackOperateTest.index&gt;<span class="comment">// 给StackOperateTest.index赋值，弹出栈</span></span><br><span class="line"> <span class="number">5</span> dup2_x1<span class="comment">// 赋值一份数据，然后当前栈贞向下移动三个solt（2+1）</span></span><br><span class="line"> <span class="number">6</span> lconst_1<span class="comment">// 把1放入栈</span></span><br><span class="line"> <span class="number">7</span> ladd<span class="comment">// 执行++操作也就是add指令，选择栈顶的两个元素想加</span></span><br><span class="line"> <span class="number">8</span> putfield #<span class="number">2</span> &lt;top/lvxiaoyi/code7/StackOperateTest.index&gt;<span class="comment">// 给StackOperateTest.index赋值，弹出栈</span></span><br><span class="line"><span class="number">11</span> lreturn<span class="comment">// 返回栈顶元素也就是第五步复制前的数据，所以这里应该返回的是0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210916150200794.png" alt="image-20210916150200794"></p>
<h2 id="8-控制转移指令"><a href="#8-控制转移指令" class="headerlink" title="8. 控制转移指令"></a>8. 控制转移指令</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>程序流程离不开条件控制，为了支持条件跳转，虚拟机提供了大量字节码指令，大体上可以分为</p>
<ol>
<li>比较指令</li>
<li>条件跳转指令</li>
<li>比较条件跳转指令</li>
<li>多条件分支跳转指令</li>
<li>无条件跳转指令等</li>
</ol>
<blockquote>
<h2 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h2><p>lcmp 比较long类型值</p>
<p>fcmpl 比较float类型值（当遇到NaN时，返回-1）</p>
<p>fcmpg 比较float类型值（当遇到NaN时，返回1）</p>
<p>dcmpl 比较double类型值（当遇到NaN时，返回-1）</p>
<p>dcmpg 比较double类型值（当遇到NaN时，返回1）</p>
<h2 id="条件分支指令"><a href="#条件分支指令" class="headerlink" title="条件分支指令"></a>条件分支指令</h2><p>ifeq 如果等于0，则跳转</p>
<p>ifne 如果不等于0，则跳转</p>
<p>iflt 如果小于0，则跳转</p>
<p>ifge 如果大于等于0，则跳转</p>
<p>ifgt 如果大于0，则跳转</p>
<p>ifle 如果小于等于0，则跳转</p>
<h2 id="比较条件分支指令"><a href="#比较条件分支指令" class="headerlink" title="比较条件分支指令"></a>比较条件分支指令</h2><p>if_icmpeq 如果两个int值相等，则跳转</p>
<p>if_icmpne 如果两个int类型值不相等，则跳转</p>
<p>if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转</p>
<p>if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转</p>
<p>if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转</p>
<p>if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转</p>
<p>ifnull 如果等于null，则跳转</p>
<p>ifnonnull 如果不等于null，则跳转</p>
<p>if_acmpeq 如果两个对象引用相等，则跳转</p>
<p>if_acmpne 如果两个对象引用不相等，则跳转</p>
<h2 id="多条件分支跳转指令"><a href="#多条件分支跳转指令" class="headerlink" title="多条件分支跳转指令"></a>多条件分支跳转指令</h2><p>tableswitch 通过索引访问跳转表，并跳转</p>
<p>lookupswitch 通过键值匹配访问跳转表，并执行跳转操作</p>
<h2 id="无条件跳转指令"><a href="#无条件跳转指令" class="headerlink" title="无条件跳转指令"></a>无条件跳转指令</h2><p>goto 无条件跳转</p>
<p>goto_w 无条件跳转（宽索引）</p>
</blockquote>
<p>英语单词：</p>
<p>大于：<code>greater than</code></p>
<p>等于：<code>equal</code></p>
<p>小于：<code>less than</code></p>
<p>不等于：<code>unequal</code> 或者 not equal</p>
<h3 id="8-1-比较指令"><a href="#8-1-比较指令" class="headerlink" title="8.1. 比较指令"></a>8.1. 比较指令</h3><p>比较指令的作用是比较占栈顶两个元素的大小，并将比较结果入栽。</p>
<p>比较指令有： dcmpg、dcmpl、 fcmpg、fcmpl、lcmp</p>
<p>与前面讲解的指令类似，首字符d表示double类型，f表示float,l表示long.</p>
<p>对于double和float类型的数字，由于NaN的存在，各有两个版本的比较指令。以float为例，有fcmpg和fcmpl两个指令，它们的区别在于在数字比较时，若遇到NaN值，处理结果不同。</p>
<p>指令dcmpl和 dcmpg也是类似的，根据其命名可以推测其含义，在此不再赘述。</p>
<p>举例：</p>
<p>指令 fcmp和fcmpl都从中弹出两个操作数，并将它们做比较，设栈顶的元素为v2,顶顺位第2位的元素为v1,若v1=v2,则压入0:若v1&gt;v2则压入1:若v1&lt;v2则压入-1.</p>
<p><strong>两个指令的不同之处在于，如果遇到NaN值， fcmpg会压入1,而fcmpl会压入-1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compare2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f1 = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">float</span> f2 = <span class="number">10</span>;</span><br><span class="line">    System.out.println(f1 &lt; f2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> ldc #<span class="number">2</span> &lt;<span class="number">9.0</span>&gt;</span><br><span class="line"> <span class="number">2</span> fstore_1</span><br><span class="line"> <span class="number">3</span> ldc #<span class="number">3</span> &lt;<span class="number">10.0</span>&gt;</span><br><span class="line"> <span class="number">5</span> fstore_2</span><br><span class="line"> <span class="number">6</span> getstatic #<span class="number">4</span> &lt;java/lang/System.out&gt;</span><br><span class="line"> <span class="number">9</span> fload_1 <span class="comment">// 栈顶元素V1 9.0</span></span><br><span class="line"><span class="number">10</span> fload_2<span class="comment">// 栈顶元素V2 10.0</span></span><br><span class="line"><span class="number">11</span> fcmpg <span class="comment">// 弹出连个操作数进行比较， V1 less than V2 ,so  压入-1</span></span><br><span class="line"><span class="number">12</span> ifge <span class="number">19</span> (+<span class="number">7</span>)<span class="comment">// 如果大于0，调转到19行，否则继续执行，弹出</span></span><br><span class="line"><span class="number">15</span> iconst_1<span class="comment">// 栈中压入1</span></span><br><span class="line"><span class="number">16</span> goto <span class="number">20</span> (+<span class="number">4</span>)<span class="comment">// 跳转到20行</span></span><br><span class="line"><span class="number">19</span> iconst_0<span class="comment">// 栈中压入0</span></span><br><span class="line"><span class="number">20</span> invokevirtual #<span class="number">5</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">23</span> <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="8-2-条件跳转指令"><a href="#8-2-条件跳转指令" class="headerlink" title="8.2. 条件跳转指令"></a>8.2. 条件跳转指令</h3><table>
<thead>
<tr>
<th>&lt;</th>
<th>&lt;=</th>
<th>==</th>
<th>!=</th>
<th>&gt;=</th>
<th>&gt;</th>
<th>null</th>
<th>not null</th>
</tr>
</thead>
<tbody><tr>
<td>iflt</td>
<td>ifle</td>
<td>ifeq</td>
<td>ifng</td>
<td>ifge</td>
<td>ifgt</td>
<td>ifnull</td>
<td>ifnonnull</td>
</tr>
</tbody></table>
<p>一、条件跳转指令.</p>
<p>条件跳转指令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转。</p>
<p>条件跳转指令有： ifeq， iflt， ifle，ifne，ifgt，ifge，ifnull，ifnonnull。这些指令都接收两个字节的操作数，用于计算跳转的位置(16位符号整数作为当前位置的offset)。</p>
<p>它们的统一含义为：弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定位置。</p>
<p>具体说明：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ifeq</td>
<td>当栈顶int类型数值等于0时跳转</td>
</tr>
<tr>
<td>ifne</td>
<td>当栈顶int类型数值不等于O时跳转</td>
</tr>
<tr>
<td>ifit</td>
<td>当栈]页int类型数值小于0时跳转</td>
</tr>
<tr>
<td>ifle</td>
<td>当栈顶int类型数值小于等于0时跳转</td>
</tr>
<tr>
<td>ifgt</td>
<td>当栈顶int类型数组大于0时跳转</td>
</tr>
<tr>
<td>ifge</td>
<td>当栈顶int类型数值大于等于0时跳转</td>
</tr>
<tr>
<td>ifnull</td>
<td>为null时跳转</td>
</tr>
<tr>
<td>ifnonnull</td>
<td>不为null时跳转</td>
</tr>
</tbody></table>
<p>注意：</p>
<p>1.与前面运算规则一致：</p>
<ul>
<li>对于boolean、byte、char、short类型的条件分支比较操作，都是使用int类型的比较指令完成</li>
<li>对于long、float、double类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转 </li>
</ul>
<p>2.由于各类型的比较最终都会转为 int类型的比较操作，所以Java虚拟机提供的int类型的条件分支指令是最为丰富和强大的。</p>
<h4 id="举例一-2"><a href="#举例一-2" class="headerlink" title="举例一"></a>举例一</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compare1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>)&#123;</span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        a = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_0</span><br><span class="line"> <span class="number">1</span> istore_1</span><br><span class="line"> <span class="number">2</span> iload_1</span><br><span class="line"> <span class="number">3</span> ifne <span class="number">12</span> (+<span class="number">9</span>)   <span class="comment">//如果栈顶元素不等于0跳转到12行，等于0乡下执行</span></span><br><span class="line"> <span class="number">6</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">8</span> istore_1</span><br><span class="line"> <span class="number">9</span> goto <span class="number">15</span> (+<span class="number">6</span>)<span class="comment">// if里面的代码执行完毕，跳转到15行</span></span><br><span class="line"><span class="number">12</span> bipush <span class="number">20</span><span class="comment">//else里面的代码执行</span></span><br><span class="line"><span class="number">14</span> istore_1</span><br><span class="line"><span class="number">15</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h4 id="举例二-3"><a href="#举例二-3" class="headerlink" title="举例二"></a>举例二</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareNull</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> aload_1<span class="comment">// 把str指针放入栈中</span></span><br><span class="line"><span class="number">1</span> ifnonnull <span class="number">6</span> (+<span class="number">5</span>)<span class="comment">//如果不是null 跳转到第六行</span></span><br><span class="line"><span class="number">4</span> iconst_1 <span class="comment">//栈中放入1</span></span><br><span class="line"><span class="number">5</span> ireturn</span><br><span class="line"><span class="number">6</span> iconst_0<span class="comment">// 栈中放入0 </span></span><br><span class="line"><span class="number">7</span> ireturn</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="8-3-比较条件跳转指令"><a href="#8-3-比较条件跳转指令" class="headerlink" title="8.3. 比较条件跳转指令"></a>8.3. 比较条件跳转指令</h3><table>
<thead>
<tr>
<th>&lt;</th>
<th>&lt;=</th>
<th>==</th>
<th>!=</th>
<th>&gt;=</th>
<th>&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>if_icmplt</td>
<td>if_icmple</td>
<td>if_icmpeq、if_acmpeq</td>
<td>if_icmpne、if_acmpne</td>
<td>if_icmpge</td>
<td>if_icmpgt</td>
</tr>
</tbody></table>
<p>二、比较条件跳转指令</p>
<p>比较条件跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一。</p>
<p>这类指令有： if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne。其中指令助记符加上“if_”后，以字符“i”开头的指令针对int型整数操作(也包括short和byte类型)，以字符“a”开头的指令表示对象引用的比较。</p>
<p>具体说明：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>if_icmpeq</td>
<td>比较栈顶两int类型数值大小，当前者等于后者时跳转</td>
</tr>
<tr>
<td>if_icmpne</td>
<td>比较栈顶两int类型数值大小，当前者不等于后者时跳转</td>
</tr>
<tr>
<td>if_icmplt</td>
<td>比较栈页两int类型数值大小，当前者小于后者时跳转</td>
</tr>
<tr>
<td>if_icmple</td>
<td>比较栈顶两int类型数值大小，当前者小于等于后者时跳转</td>
</tr>
<tr>
<td>if_icmpgt</td>
<td>比较栈顶两int类型数值大小，当前者大于后者时跳转</td>
</tr>
<tr>
<td>if_icmpge</td>
<td>比较栈顶两int类型数值大小，当前者大于等于后者时跳转</td>
</tr>
<tr>
<td>if_acmpeq</td>
<td>比较栈顶两引用类型数值，当结果相等时跳转</td>
</tr>
<tr>
<td>if_acmpne</td>
<td>比较栈页两引用类型数值，当结果不相等时跳转</td>
</tr>
</tbody></table>
<p>这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置。同时在执行指令时，栈顶需要准备两个元素进行比较。指令执行完成后，栈顶的这两个元素被清空，且没有任何数据入栈。如果预设条件成立，则执行跳转，否则，继续执行下一条语句。</p>
<h3 id="8-4-多条件分支跳转"><a href="#8-4-多条件分支跳转" class="headerlink" title="8.4. 多条件分支跳转"></a>8.4. 多条件分支跳转</h3><p>三、多条件分支跳转指令</p>
<p>多条件分支跳转指令是专为switch-case语句设计的，主要有tableswitch和lookupswitch。</p>
<table>
<thead>
<tr>
<th>指令名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>tableswitch</td>
<td>用于switch条件跳转，case值连续</td>
</tr>
<tr>
<td>lookupswitch</td>
<td>用于switch条件跳转，case值不连续</td>
</tr>
</tbody></table>
<p>从助记符上看，两者都是switch语句的实现，它们的区别：</p>
<ul>
<li>tableswitch要求多个条件分支值是连续的，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数index，可以立即定位到跳转偏移量位置，因此效率比较高。</li>
<li>指令lookupswitch内部存放着各个离散的case-offset对，每次执行都要搜索全部的case-offset对，找到匹配的case值，并根据对应的offset计算跳转地址，因此效率较低。</li>
</ul>
<p>指令tableswitch的示意图如下图所示。由于tableswitch的case值是连续的，因此只需要记录最低值和最高值，以及每项对应的offset偏移量，根据给定的index值通过简单的计算即可直接定位到offset。</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210914154108950.png" alt="image-20210914154108950" style="zoom: 67%;" />

<p>指令lookupswitch处理的是离散的case值，但是出于效率考虑，将case-offset对按照case值大小排序，给定index时，需要查找与index相等的case,获得其offset,如果找不到则跳转到default。指令lookupswitch 如下图所示。</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210914154118957.png" alt="image-20210914154118957" style="zoom: 67%;" />

<h3 id="8-5-无条件跳转"><a href="#8-5-无条件跳转" class="headerlink" title="8.5. 无条件跳转"></a>8.5. 无条件跳转</h3><p>四、无条件跳转指令</p>
<p>目前主要的无条件跳转指令为goto。指令goto接收两个字节的操作数，共同组成一个带符号的整数，用于指定指令的偏移量，指令执行的目的就是跳转到偏移量给定的位置处。</p>
<p>如果指令偏移量太大，超过双字节的带符号整数的范围，则可以使用指令goto_w,它和goto有相同的作用，但是它接收4个字节的操作数，可以表示更大的地址范围。</p>
<p>指令jsr、jsr_w、ret虽然也是无条件跳转的，但主要用于try-finally语句，且已经被虚拟机逐渐废弃，故不在这里介绍这两个指令。</p>
<table>
<thead>
<tr>
<th>指令名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>goto</td>
<td>无条件跳转</td>
</tr>
<tr>
<td>goto_w</td>
<td>无条件跳转(宽索引)</td>
</tr>
<tr>
<td>jsr</td>
<td>跳转至指定16位offset位置，并将jsr下一条指令地址压入栈顶</td>
</tr>
<tr>
<td>jsr_w</td>
<td>跳转至指定32位offer位置，并将jsr_w下一条指令地址压入栈顶</td>
</tr>
<tr>
<td>ret</td>
<td>返回至由指定的局部变量所给出的指令位置(一般与jsr、jsr_w联合使用)</td>
</tr>
</tbody></table>
<h2 id="9-异常处理指令"><a href="#9-异常处理指令" class="headerlink" title="9. 异常处理指令"></a>9. 异常处理指令</h2><blockquote>
<h2 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h2><p>athrow 抛出异常或错误。将栈顶异常抛出</p>
<p>jsr 跳转到子例程</p>
<p>jsr_w 跳转到子例程（宽索引）</p>
<p>rct 从子例程返回</p>
</blockquote>
<p>(1) athrow指令</p>
<p>在3ava程序中显示抛出异常的操作（throw语句）都是由athrow指令来实现。</p>
<p>除了使用throw语句显示抛出异常情况之外，JVN规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如，在之前介绍的整数运算时，当除数为零时，虚拟机会在 idiv或ldiv指令中抛出ArithmeticException异常。</p>
<p>(2)注意</p>
<p>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是在抛异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上。</p>
<p>1、处理异常：<br>在Java虚拟机中，处理异常(catch语句）不是由字节码指令来实现的（早期使用jsr、ret指令），而是采用异常表来完成的。</p>
<p>2、异常表<br>如果一个方法定义了一个try-catch或者try-finally的异常处理，就会创建一个异常表。它包含了每个异常处理或者finally块的信息。异常表保存了每个异常处理信息。比如：</p>
<ul>
<li>起始位置</li>
<li>结束位置</li>
<li>程序计数器记录的代码处理的偏移地址</li>
<li>被捕获的异常类在常量池中的索引</li>
</ul>
<p>​         当一个异常被抛出时，JVA会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧，并且异常会重新抛给上层调用的方法(在调用方法栈帧)。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。如果这个异常在最后一个非守护线程里抛出，将会导致JVM自己终止，比如这个线程是个main线程。</p>
<p>​         不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行。在这种情况下，如果方法结束后没有抛出异常，仍然执行finally块，在return前，它直接跳到finally块来完成目标</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/daa25784fc259c12af58bb094d6ffc52.png" alt="img"> <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/cba1429ffc09988d78008f5309a6374a.png" alt="img"></p>
<hr>
<h2 id="10-同步控制指令"><a href="#10-同步控制指令" class="headerlink" title="10. 同步控制指令"></a>10. 同步控制指令</h2><blockquote>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>montiorenter 进入并获取对象监视器。即：为栈顶对象加锁</p>
<p>monitorexit 释放并退出对象监视器。即：为栈顶对象解锁</p>
</blockquote>
<p>Java虚拟机支持两种同步结构：<strong>方法级的同步</strong>和<strong>方法内部一段指令序列的同步</strong>，这两种同步都是使用monitor来支持的</p>
<h3 id="10-1-方法级的同步"><a href="#10-1-方法级的同步" class="headerlink" title="10.1. 方法级的同步"></a>10.1. 方法级的同步</h3><p>​        方法级的同步：是隐式的，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法;</p>
<p>当调用方法时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否设置。</p>
<ul>
<li>如果设置了，执行线程将先持有同步锁，然后执行方法。最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁。</li>
<li>在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁。</li>
<li>如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> aload_0</span><br><span class="line"><span class="number">1</span> invokespecial #<span class="number">1</span> &lt;java/lang/Object.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">4</span> aload_0</span><br><span class="line"><span class="number">5</span> iconst_0</span><br><span class="line"><span class="number">6</span> putfield #<span class="number">2</span> &lt;top/lvxiaoyi/bytecodeinstruction/SynchronizedTest.i&gt;</span><br><span class="line"><span class="number">9</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>​        这段代码和普通的无同步操作的代码没有什么不同，没有使用monitorenter和monitorexit进行同步区控制。这是因为，对于同步方法而言，当虚拟机通过方法的访问标示符判断是一个同步方法时，会自动在方法调用前进行加锁，当同步方法执行完毕后，不管方法是正常结束还是有异常抛出，均会由虚拟机释放这个锁。因此，对于同步方法而言，monitorenter和monitorexit指令是隐式存在的，并未直接出现在字节码中。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/84ff4ef05baf1b5774f43b203d6a6e23.png" alt="img"></p>
<h3 id="10-2-方法内指令指令序列的同步"><a href="#10-2-方法内指令指令序列的同步" class="headerlink" title="10.2. 方法内指令指令序列的同步"></a>10.2. 方法内指令指令序列的同步</h3><p>​        同步一段指令集序列：通常是由java中的synchronized语句块来表示的。jvm的指令集有 monitorenter和monitorexit两条指令来支持synchronized关键字的语义。</p>
<p>​        当一个线程进入同步代码块时，它使用monitorenter指令请求进入。如果当前对象的监视器计数器为e,则它会被准许进入，若为1,则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，直到对象的监视器计数器为0,才会被允许进入同步块。</p>
<p>​        当线程退出同步块时，需要使用monitorexit声明退出。在Java虚拟机中，任何对象都有一个监视器与之相关联用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。</p>
<p>​        指令monitorenter和monitorexit在执行时，都需要在操作数栈顶压入对象,之后monitorenter和monitorexit的锁定和释放都是针对这个对象的监视器进行的。</p>
<p>下图展示了监视器如何保护临界区代码不同时被多个线程访问，只有当线程4离开临界区后，线程1、2、3才有可能进入。</p>
<p>​        编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须执行其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。</p>
<p>​        为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行monitorexit指令</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/697b683f5fba682a6ed9772950f719a7.png" alt="img"> <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/71ab99d8f145e61b31daa03a233f2596.png" alt="img"> <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/ac36b8a792107c77956ef642afba2154.png" alt="img"> <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/89199776b49d72ff70615f9b0ca8cbe2.png" alt="img"></p>
<hr>
<h1 id="05-类的加载过程（类的生命周期）详解"><a href="#05-类的加载过程（类的生命周期）详解" class="headerlink" title="05-类的加载过程（类的生命周期）详解"></a>05-类的加载过程（类的生命周期）详解</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在 Java 中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。</p>
<p>按照 Java 虚拟机规范，从 class 文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括如下 7 个阶段：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/b73db20eea59665fa3de67e1dec6d4e5.png" alt="image-20210430215050746"></p>
<p>其中，验证、准备、解析 3 个部分统称为链接（Linking）</p>
<p>从程序中类的使用过程看</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/c6e5a63339bb2574b9b52a9ed14ee9c5.png" alt="image-20210430215236716"></p>
<h3 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h3><blockquote>
<p>蚂蚁金服：</p>
<p>描述一下 JVM 加载 Class 文件的原理机制？</p>
<p>一面：类加载过程</p>
<p>百度：</p>
<p>类加载的时机</p>
<p>java 类加载过程？</p>
<p>简述 java 类加载机制？</p>
<p>腾讯：</p>
<p>JVM 中类加载机制，类加载过程？</p>
<p>滴滴：</p>
<p>JVM 类加载机制</p>
<p>美团：</p>
<p>Java 类加载过程</p>
<p>描述一下 jvm 加载 class 文件的原理机制</p>
<p>京东：</p>
<p>什么是类的加载？</p>
<p>哪些情况会触发类的加载？</p>
<p>讲一下 JVM 加载一个类的过程 JVM 的类加载机制是什么？</p>
</blockquote>
<hr>
<h2 id="2-过程一：Loading（加载）阶段"><a href="#2-过程一：Loading（加载）阶段" class="headerlink" title="2. 过程一：Loading（加载）阶段"></a>2. 过程一：Loading（加载）阶段</h2><h3 id="2-1-加载完成的操作"><a href="#2-1-加载完成的操作" class="headerlink" title="2.1. 加载完成的操作"></a>2.1. 加载完成的操作</h3><p><strong>加载的理解</strong></p>
<p>所谓加载，简而言之就是将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型——类模板对象。所谓加载，简而言之就是将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型——类模板对象。所谓类模板对象，其实就是 Java 类在]VM 内存中的一个快照，JVM 将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样]VM 在运行期便能通过类模板而获取 Java 类中的任意信息，能够对 Java 类的成员变量进行遍历，也能进行 Java 方法的调用。</p>
<p>反射的机制即基于这一基础。如果 JVM 没有将 Java 类的声明信息存储起来，则 JVM 在运行期也无法反射。</p>
<p><strong>加载完成的操作</strong></p>
<p>加载阶段，简言之，查找并加载类的二进制数据，生成Class的实例。加载阶段，简言之，查找并加载类的二进制数据，生成Class的实例。</p>
<p>在加载类时，Java 虚拟机必须完成以下 3 件事情：</p>
<ul>
<li>通过类的全名，获取类的二进制数据流。</li>
<li>解析类的二进制数据流为方法区内的数据结构（Java 类模型）</li>
<li>创建 java.lang.Class 类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li>
</ul>
<h3 id="2-2-二进制流的获取方式"><a href="#2-2-二进制流的获取方式" class="headerlink" title="2.2. 二进制流的获取方式"></a>2.2. 二进制流的获取方式</h3><p>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。（只要所读取的字节码符合 JVM 规范即可）</p>
<ul>
<li>虚拟机可能通过文件系统读入一个 class 后缀的文件（最常见）（最常见）</li>
<li>读入 jar、zip 等归档数据包，提取类文件。</li>
<li>事先存放在数据库中的类的二进制数据</li>
<li>使用类似于 HTTP 之类的协议通过网络进行加载</li>
<li>在运行时生成一段 class 的二进制信息等</li>
<li>在获取到类的二进制信息后，Java 虚拟机就会处理这些数据，并最终转为一个 java.lang.Class 的实例。</li>
</ul>
<p>如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p>
<h3 id="2-3-类模型与-Class-实例的位置"><a href="#2-3-类模型与-Class-实例的位置" class="headerlink" title="2.3. 类模型与 Class 实例的位置"></a>2.3. 类模型与 Class 实例的位置</h3><p><strong>类模型的位置</strong></p>
<p>加载的类在 JVM 中创建相应的类结构，类结构会存储在方法区（JDKl.8 之前：永久代；J0Kl.8 及之后：元空间）。</p>
<p><strong>Class 实例的位置</strong></p>
<p>类将.class 文件加载至元空间后，会在堆中创建一个 Java.lang.Class 对象，用来封装类位于方法区内的数据结构，该 Class 对象是在加载类的过程中创建的，每个类都对应有一个 Class 类型的对象。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/10969de50477655b954b23bfe550fb1d.png" alt="image-20210430221037898"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(&quot;java.lang.String&quot;);</span><br><span class="line">//获取当前运行时类声明的所有方法</span><br><span class="line">Method[] ms = clazz.getDecla#FF0000Methods();</span><br><span class="line">for (Method m : ms) &#123;</span><br><span class="line">    //获取方法的修饰符</span><br><span class="line">    String mod = Modifier.toString(m.getModifiers());</span><br><span class="line">    System.out.print(mod + &quot;&quot;);</span><br><span class="line">    //获取方法的返回值类型</span><br><span class="line">    String returnType = (m.getReturnType()).getSimpleName();</span><br><span class="line">    System.out.print(returnType + &quot;&quot;);</span><br><span class="line">    //获取方法名</span><br><span class="line">    System.out.print(m.getName() + &quot;(&quot;);</span><br><span class="line">    //获取方法的参数列表</span><br><span class="line">    Class&lt;?&gt;[] ps = m.getParameterTypes();</span><br><span class="line">    if (ps.length == 0) &#123;</span><br><span class="line">        System.out.print(&#x27;)&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; ps.length; i++) &#123;</span><br><span class="line">        char end = (i == ps.length - 1) ? &#x27;)&#x27; : &#x27;,&#x27;;</span><br><span class="line">        //获取参教的类型</span><br><span class="line">        System.out.print(ps[i].getSimpleName() + end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-数组类的加载"><a href="#2-4-数组类的加载" class="headerlink" title="2.4. 数组类的加载"></a>2.4. 数组类的加载</h3><p>创建数组类的情况稍微有些特殊，因为数组类本身并不是由类加载器负责创建，而是由 JVM 在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。创建数组类（下述简称 A）的过程：</p>
<ul>
<li>如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组 A 的元素类型；</li>
<li>JVM 使用指定的元素类型和数组维度来创建新的数组类。</li>
</ul>
<p>如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为 public。</p>
<hr>
<h2 id="3-过程二：Linking（链接）阶段"><a href="#3-过程二：Linking（链接）阶段" class="headerlink" title="3. 过程二：Linking（链接）阶段"></a>3. 过程二：Linking（链接）阶段</h2><h3 id="3-1-环节-1：链接阶段之-Verification（验证）"><a href="#3-1-环节-1：链接阶段之-Verification（验证）" class="headerlink" title="3.1. 环节 1：链接阶段之 Verification（验证）"></a>3.1. 环节 1：链接阶段之 Verification（验证）</h3><p>当类加载到系统后，就开始链接操作，验证是链接操作的第一步。</p>
<p>它的目的是保证加载的字节码是合法、合理并符合规范的。它的目的是保证加载的字节码是合法、合理并符合规范的。</p>
<p>验证的步骤比较复杂，实际要验证的项目也很繁多，大体上 Java 虚拟机需要做以下检查，如图所示。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/2309ce7d4bdbffb86ae462e967af5dc9.png" alt="image-20210430221736546"></p>
<p><strong>整体说明：</strong></p>
<p>验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等。</p>
<ul>
<li>其中格式验证会和加载阶段一起执行其中格式验证会和加载阶段一起执行。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。</li>
<li>格式验证之外的验证操作将会在方法区中进行格式验证之外的验证操作将会在方法区中进行。</li>
</ul>
<p>链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查。（磨刀不误砍柴工）</p>
<p><strong>具体说明：</strong></p>
<ol>
<li><p>格式验证：是否以魔数 0XCAFEBABE 开头，主版本和副版本号是否在当前 Java 虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等。</p>
</li>
<li><p>语义检查：Java 虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如：</p>
<ul>
<li>是否所有的类都有父类的存在（在 Java 里，除了 object 外，其他类都应该有父类）</li>
<li>是否一些被定义为 final 的方法或者类被重写或继承了</li>
<li>非抽象类是否实现了所有抽象方法或者接口方法</li>
</ul>
</li>
<li><p>字节码验证：Java 虚拟机还会进行字节码验证，字节码验证也是验证过程中最为复杂的一个过程字节码验证也是验证过程中最为复杂的一个过程。它试图通过对字节码流的分析，判断字节码是否可以被正确地执行。比如：</p>
<ul>
<li>在字节码的执行过程中，是否会跳转到一条不存在的指令</li>
<li>函数的调用是否传递了正确类型的参数</li>
<li>变量的赋值是不是给了正确的数据类型等</li>
</ul>
<p>栈映射帧（StackMapTable）就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。但遗憾的是，100%准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检查出可以预知的明显的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的。</p>
<p>在前面3次检查中，已经排除了文件格式错误、语义错误以及字节码的不正确性。但是依然不能确保类是没有问题的。在前面3次检查中，已经排除了文件格式错误、语义错误以及字节码的不正确性。但是依然不能确保类是没有问题的。</p>
</li>
<li><p>符号引用的验证：校验器还将进符号引用的验证。Class 文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，虚拟机就会检查这些类或者方法确实是存在的虚拟机就会检查这些类或者方法确实是存在的，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出 NoClassDefFoundError，如果一个方法无法被找到，则会抛出 NoSuchMethodError。此阶段在解析环节才会执行。</p>
</li>
</ol>
<h3 id="3-2-环节-2：链接阶段之-Preparation（准备）"><a href="#3-2-环节-2：链接阶段之-Preparation（准备）" class="headerlink" title="3.2. 环节 2：链接阶段之 Preparation（准备）"></a>3.2. 环节 2：链接阶段之 Preparation（准备）</h3><p>准备阶段（Preparation），简言之，为类的静态变分配内存，并将其初始化为默认值。准备阶段（Preparation），简言之，为类的静态变分配内存，并将其初始化为默认值。</p>
<p>当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。Java 虚拟机为各类型变量默认的初始值如表所示。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>char</td>
<td>\u0000</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody></table>
<p>Java 并不支持 boolean 类型，对于 boolean 类型，内部实现是 int，由于 int 的默认值是 0，故对应的，boolean 的默认值就是 false。</p>
<p><strong>注意</strong></p>
<ul>
<li><p>这里不包含基本数据类型的字段用staticfinal修饰的情况，因为final在编译的时候就会分配了，准备阶段会显式赋值。这里不包含基本数据类型的字段用staticfinal修饰的情况，因为final在编译的时候就会分配了，准备阶段会显式赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 一般情况：static final修饰的基本数据类型、字符串类型字面量会在准备阶段赋值</span><br><span class="line">private static final String str = &quot;Hello world&quot;;</span><br><span class="line">// 特殊情况：static final修饰的引用类型不会在准备阶段赋值，而是在初始化阶段赋值</span><br><span class="line">private static final String str = new String(&quot;Hello world&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。</p>
</li>
<li><p>在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。</p>
</li>
</ul>
<h3 id="3-3-环节-3：链接阶段之-Resolution（解析）"><a href="#3-3-环节-3：链接阶段之-Resolution（解析）" class="headerlink" title="3.3. 环节 3：链接阶段之 Resolution（解析）"></a>3.3. 环节 3：链接阶段之 Resolution（解析）</h3><p>在准备阶段完成后，就进入了解析阶段。解析阶段（Resolution），简言之，将类、接口、字段和方法的符号引用转为直接引用。</p>
<p><strong>具体描述</strong>：</p>
<p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在 Class 类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下 println()方法被调用时，系统需要明确知道该方法的位置。</p>
<p><strong>举例</strong>：</p>
<p>输出操作 System.out.println()对应的字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invokevirtual #24 &lt;java/io/PrintStream.println&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/b223d288b413f0ed0732357023a1dc7e.png" alt="image-20210430225015932"></p>
<p>以方法为例，Java 虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</p>
<hr>
<h2 id="4-过程三：Initialization（初始化）阶段"><a href="#4-过程三：Initialization（初始化）阶段" class="headerlink" title="4. 过程三：Initialization（初始化）阶段"></a>4. 过程三：Initialization（初始化）阶段</h2><h3 id="4-1-static-与-final-的搭配问题"><a href="#4-1-static-与-final-的搭配问题" class="headerlink" title="4.1. static 与 final 的搭配问题"></a>4.1. static 与 final 的搭配问题</h3><p><strong>说明</strong>：使用 static+ final 修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？</p>
<ul>
<li>情况 1：在链接阶段的准备环节赋值</li>
<li>情况 2：在初始化阶段<clinit>()中赋值</li>
</ul>
<p><strong>结论</strong>： 在链接阶段的准备环节赋值的情况：</p>
<ul>
<li>对于基本数据类型的字段来说，如果使用 static final 修饰，则显式赋值(直接赋值常量，而非调用方法通常是在链接阶段的准备环节进行</li>
<li>对于 String 来说，如果使用字面量的方式赋值，使用 static final 修饰的话，则显式赋值通常是在链接阶段的准备环节进行</li>
<li>在初始化阶段<clinit>()中赋值的情况： 排除上述的在准备环节赋值的情况之外的情况。</li>
</ul>
<p><strong>最终结论</strong>：使用 static+final 修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类到或 String 类型的显式财值，是在链接阶段的准备环节进行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static final int INT_CONSTANT = 10;                                // 在链接阶段的准备环节赋值</span><br><span class="line">public static final int NUM1 = new Random().nextInt(10);                  // 在初始化阶段clinit&gt;()中赋值</span><br><span class="line">public static int a = 1;                                                  // 在初始化阶段&lt;clinit&gt;()中赋值</span><br><span class="line"></span><br><span class="line">public static final Integer INTEGER_CONSTANT1 = Integer.valueOf(100);     // 在初始化阶段&lt;clinit&gt;()中赋值</span><br><span class="line">public static Integer INTEGER_CONSTANT2 = Integer.valueOf(100);           // 在初始化阶段&lt;clinit&gt;()中概值</span><br><span class="line"></span><br><span class="line">public static final String s0 = &quot;helloworld0&quot;;                            // 在链接阶段的准备环节赋值</span><br><span class="line">public static final String s1 = new String(&quot;helloworld1&quot;);                // 在初始化阶段&lt;clinit&gt;()中赋值</span><br><span class="line">public static String s2 = &quot;hellowrold2&quot;;                                  // 在初始化阶段&lt;clinit&gt;()中赋值</span><br></pre></td></tr></table></figure>

<h3 id="4-2-的线程安全性"><a href="#4-2-的线程安全性" class="headerlink" title="4.2. ()的线程安全性"></a>4.2. <clinit>()的线程安全性</h3><p>对于<clinit>()方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性。</p>
<p>虚拟机会保证一个类的()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。</p>
<p>正是因为函数()带锁线程安全的函数()带锁线程安全的，因此，如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。</p>
<p>如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行<clinit>()方法了。那么，当需要使用这个类时，虚拟机会直接返回给它已经准备好的信息。</p>
<h3 id="4-3-类的初始化情况：主动使用-vs-被动使用"><a href="#4-3-类的初始化情况：主动使用-vs-被动使用" class="headerlink" title="4.3. 类的初始化情况：主动使用 vs 被动使用"></a>4.3. 类的初始化情况：主动使用 vs 被动使用</h3><p>Java 程序对类的使用分为两种：主动使用和被动使用。</p>
<p><strong>主动使用</strong></p>
<p>Class 只有在必须要首次使用的时候才会被装载，Java 虚拟机不会无条件地装载 Class 类型。Java 虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。</p>
<ol>
<li><p>实例化：当创建一个类的实例时，比如使用 new 关键字，或者通过反射、克隆、反序列化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 反序列化</span><br><span class="line"> */</span><br><span class="line">Class Order implements Serializable &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Order类的初始化&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void test() &#123;</span><br><span class="line">    ObjectOutputStream oos = null;</span><br><span class="line">    ObjectInputStream ois = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 序列化</span><br><span class="line">        oos = new ObjectOutputStream(new FileOutputStream(&quot;order.dat&quot;));</span><br><span class="line">        oos.writeObject(new Order());</span><br><span class="line">        // 反序列化</span><br><span class="line">        ois = new ObjectInputStream(new FileOutputStream(&quot;order.dat&quot;));</span><br><span class="line">        Order order = ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (oos != null) &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if (ois != null) &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>静态方法：当调用类的静态方法时，即当使用了字节码 invokestatic 指令。</p>
</li>
<li><p>静态字段：当使用类、接口的静态字段时（final 修饰特殊考虑），比如，使用 getstatic 或者 putstatic 指令。（对应访问变量、赋值变量操作）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ActiveUse &#123;</span><br><span class="line">	@Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        System.out.println(User.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;User类的初始化&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static final int num = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>反射：当使用 java.lang.reflect 包中的方法反射类的方法时。比如：Class.forName(“com.atguigu.java.Test”)</p>
</li>
<li><p>继承：当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
<blockquote>
<p>当 Java 虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。</p>
<ul>
<li>在初始化一个类时，并不会先初始化它所实现的接口</li>
<li>在初始化一个接口时，并不会先初始化它的父接口</li>
<li>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化。</li>
</ul>
</blockquote>
</li>
<li><p>default 方法：如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Compare &#123;</span><br><span class="line">	public static final Thread t = new Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;Compare接口的初始化&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>main 方法：当虚拟机启动时，用户需要指定一个要执行的主类（包含 main()方法的那个类），虚拟机会先初始化这个主类。</p>
<blockquote>
<p>VM 启动的时候通过引导类加载器加载一个初始类。这个类在调用 public static void main(String[])方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化。</p>
</blockquote>
</li>
<li><p>MethodHandle：当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。（涉及解析 REF getStatic、REF_putStatic、REF invokeStatic 方法句柄对应的类）</p>
</li>
</ol>
<p><strong>被动使用</strong></p>
<p>除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化。被动使用不会引起类的初始化。</p>
<p>也就是说：并不是在代码中出现的类，就一定会被加载或者初始化。并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。</p>
<ol>
<li><p>静态字段：当通过子类引用父类的静态变量，不会导致子类初始化，只有真正声明这个字段的类才会被初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PassiveUse &#123;</span><br><span class="line"> 	@Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        System.out.println(Child.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Child类的初始化&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Parent类的初始化&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int num = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>数组定义：通过数组定义类引用，不会触发此类的初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Parent[] parents= new Parent[10];</span><br><span class="line">System.out.println(parents.getClass());</span><br><span class="line">// new的话才会初始化</span><br><span class="line">parents[0] = new Parent();</span><br></pre></td></tr></table></figure></li>
<li><p>引用常量：引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PassiveUse &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Serival.num);</span><br><span class="line">        // 但引用其他类的话还是会初始化</span><br><span class="line">        System.out.println(Serival.num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Serival &#123;</span><br><span class="line">    public static final Thread t = new Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;Serival初始化&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static int num = 10;</span><br><span class="line">    public static final int num2 = new Random().nextInt(10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>loadClass 方法：调用 ClassLoader 类的 loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class clazz = ClassLoader.getSystemClassLoader().loadClass(&quot;com.test.java.Person&quot;);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>扩展</strong></p>
<blockquote>
<p>-XX:+TraceClassLoading：追踪打印类的加载信息</p>
</blockquote>
<hr>
<h2 id="5-过程四：类的-Using（使用）"><a href="#5-过程四：类的-Using（使用）" class="headerlink" title="5. 过程四：类的 Using（使用）"></a>5. 过程四：类的 Using（使用）</h2><p>任何一个类型在使用之前都必须经历过完整的加载、链接和初始化 3 个类加载步骤。一旦一个类型成功经历过这 3 个步骤之后，便“厉事俱备只欠东风”，就等着开发者使用了。</p>
<p>开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用 new 关键字为其创建对象实例。</p>
<hr>
<h2 id="6-过程五：类的-Unloading（卸载）"><a href="#6-过程五：类的-Unloading（卸载）" class="headerlink" title="6. 过程五：类的 Unloading（卸载）"></a>6. 过程五：类的 Unloading（卸载）</h2><h3 id="6-1-类、类的加载器、类的实例之间的引用关系"><a href="#6-1-类、类的加载器、类的实例之间的引用关系" class="headerlink" title="6.1. 类、类的加载器、类的实例之间的引用关系"></a>6.1. 类、类的加载器、类的实例之间的引用关系</h3><p>在类加载器的内部实现中，用一个 Java 集合来存放所加载类的引用。另一方面，一个 Class 对象总是会引用它的类加载器，调用 Class 对象的 getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的 Class 实例与其类的加载器之间为双向关联关系。</p>
<p>一个类的实例总是引用代表这个类的 Class 对象。在 Object 类中定义了 getClass()方法，这个方法返回代表对象所属类的 Class 对象的引用。此外，所有的 java 类都有一个静态属性 class，它引用代表这个类的 Class 对象。</p>
<h3 id="6-2-类的生命周期"><a href="#6-2-类的生命周期" class="headerlink" title="6.2.类的生命周期"></a>6.2.类的生命周期</h3><p>当 Sample 类被加载、链接和初始化后，它的生命周期就开始了。当代表 Sample 类的 Class 对象不再被引用，即不可触及时，Class 对象就会结束生命周期，Sample 类在方法区内的数据也会被卸载，从而结束 Sample 类的生命周期。</p>
<p>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</p>
<h3 id="6-3-具体例子"><a href="#6-3-具体例子" class="headerlink" title="6.3. 具体例子"></a>6.3. 具体例子</h3><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/5aaa031ab1ffc8071fb92a32ead888ef.png" alt="image-20210430235455086"></p>
<p>loader1 变量和 obj 变量间接应用代表 Sample 类的 Class 对象，而 objClass 变量则直接引用它。</p>
<p>如果程序运行过程中，将上图左侧三个引用变量都置为 null，此时 Sample 对象结束生命周期，MyClassLoader 对象结束生命周期，代表 Sample 类的 Class 对象也结束生命周期，Sample 类在方法区内的二进制数据被卸载。</p>
<p>当再次有需要时，会检查 Sample 类的 Class 对象是否存在，如果存在会直接使用，不再重新加载；如果不存在 Sample 类会被重新加载，在 Java 虚拟机的堆区会生成一个新的代表 Sample 类的 Class 实例（可以通过哈希码查看是否是同一个实例）</p>
<h3 id="6-4-类的卸载"><a href="#6-4-类的卸载" class="headerlink" title="6.4. 类的卸载"></a>6.4. 类的卸载</h3><p>（1）启动类加载器加载的类型在整个运行期间是不可能被卸载的（jvm 和 jls 规范）</p>
<p>（2）被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到 unreachable 的可能性极小。</p>
<p>（3）被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中（比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能），被加载的类型在运行期间也是几乎不太可能被卸载的（至少卸载的时间是不确定的）。</p>
<p>综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。</p>
<h3 id="回顾：方法区的垃圾回收"><a href="#回顾：方法区的垃圾回收" class="headerlink" title="回顾：方法区的垃圾回收"></a>回顾：方法区的垃圾回收</h3><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p>
<p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li>该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例。该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p>
<h1 id="06-再谈类的加载器"><a href="#06-再谈类的加载器" class="headerlink" title="06-再谈类的加载器"></a>06-再谈类的加载器</h1><h2 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>类加载器是JVM执行类加载机制的前提。</p>
<p><strong>ClassLoader的作用：</strong></p>
<p>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。然后交给Java虚拟机进行链接、初始化等操作。因此，ClassLoader在整个装载阶段，只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由Execution Engine决定。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/fb51cabb2218d857a809a59918c5beec.png" alt="image-20210501102535142"></p>
<h3 id="1-1-大厂面试题"><a href="#1-1-大厂面试题" class="headerlink" title="1.1. 大厂面试题"></a>1.1. 大厂面试题</h3><blockquote>
<p>蚂蚁金服：</p>
<p>深入分析ClassLoader，双亲委派机制</p>
<p>类加载器的双亲委派模型是什么？一面：双亲委派机制及使用原因</p>
<p>百度：</p>
<p>都有哪些类加载器，这些类加载器都加载哪些文件？</p>
<p>手写一个类加载器Demo</p>
<p>Class的forName（“java.lang.String”）和Class的getClassLoader（）的Loadclass（“java.lang.String”）有什么区别？</p>
<p>腾讯：</p>
<p>什么是双亲委派模型？</p>
<p>类加载器有哪些？</p>
<p>小米：</p>
<p>双亲委派模型介绍一下</p>
<p>滴滴：</p>
<p>简单说说你了解的类加载器一面：讲一下双亲委派模型，以及其优点</p>
<p>字节跳动：</p>
<p>什么是类加载器，类加载器有哪些？</p>
<p>京东：</p>
<p>类加载器的双亲委派模型是什么？</p>
<p>双亲委派机制可以打破吗？为什么</p>
</blockquote>
<h3 id="1-2-类加载器的分类"><a href="#1-2-类加载器的分类" class="headerlink" title="1.2. 类加载器的分类"></a>1.2. 类加载器的分类</h3><p>类的加载分类：显式加载 vs 隐式加载</p>
<p>class文件的显式加载与隐式加载的方式是指JVM加载class文件到内存的方式。</p>
<ul>
<li>显式加载指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象。</li>
<li>隐式加载则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</li>
</ul>
<p>在日常开发以上两种方式一般会混合使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//隐式加载</span><br><span class="line">User user=new User();</span><br><span class="line">//显式加载，并初始化</span><br><span class="line">Class clazz=Class.forName(&quot;com.test.java.User&quot;);</span><br><span class="line">//显式加载，但不初始化</span><br><span class="line">ClassLoader.getSystemClassLoader().loadClass(&quot;com.test.java.Parent&quot;); </span><br></pre></td></tr></table></figure>

<h3 id="1-3-类加载器的必要性"><a href="#1-3-类加载器的必要性" class="headerlink" title="1.3. 类加载器的必要性"></a>1.3. 类加载器的必要性</h3><p>一般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：</p>
<ul>
<li>避免在开发中遇到java.lang.ClassNotFoundException异常或java.lang.NoClassDefFoundError异常时，手足无措。只有了解类加载器的 加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题</li>
<li>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</li>
<li>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。</li>
</ul>
<h3 id="1-4-命名空间"><a href="#1-4-命名空间" class="headerlink" title="1.4. 命名空间"></a>1.4. 命名空间</h3><p><strong>何为类的唯一性？</strong></p>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。每一个类加载器，都拥有一个独立的类名称空间：比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p>
<p><strong>命名空间</strong></p>
<ul>
<li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成</li>
<li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li>
<li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</li>
</ul>
<p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p>
<h3 id="1-5-类加载机制的基本特征"><a href="#1-5-类加载机制的基本特征" class="headerlink" title="1.5. 类加载机制的基本特征"></a>1.5. 类加载机制的基本特征</h3><p>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</p>
<p>可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</p>
<p>单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</p>
<h3 id="1-6-类加载器之间的关系"><a href="#1-6-类加载器之间的关系" class="headerlink" title="1.6. 类加载器之间的关系"></a>1.6. 类加载器之间的关系</h3><p>Launcher类核心代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Launcher.ExtClassLoader var1;</span><br><span class="line">try &#123;</span><br><span class="line">    var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">&#125; catch (IOException var10) &#123;</span><br><span class="line">    throw new InternalError(&quot;Could not create extension class loader&quot;, var10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">&#125; catch (IOException var9) &#123;</span><br><span class="line">    throw new InternalError(&quot;Could not create application class loader&quot;, var9);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread.currentThread().setContextClassLoader(this.loader);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ExtClassLoader的Parent类是null</strong></li>
<li><strong>AppClassLoader的Parent类是ExtClassLoader</strong></li>
<li><strong>当前线程的ClassLoader是AppClassLoader</strong></li>
</ul>
<p>注意，这里的Parent类并不是Java语言意义上的继承关系，而是一种包含关系注意，这里的Parent类并不是Java语言意义上的继承关系，而是一种包含关系</p>
<hr>
<h2 id="2-类的加载器分类"><a href="#2-类的加载器分类" class="headerlink" title="2. 类的加载器分类"></a>2. 类的加载器分类</h2><p>JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/0c43fb4a7da20038c8f56b42a1ddf802.png" alt="image-20210501164413665"></p>
<ul>
<li>除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加戟器。</li>
<li>不同类加载器看似是继承（Inheritance）关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用。</li>
</ul>
<p>父类加载器和子类加载器的关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ClassLoader&#123;</span><br><span class="line">    ClassLoader parent;//父类加载器</span><br><span class="line">        public ClassLoader(ClassLoader parent)&#123;</span><br><span class="line">        this.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ParentClassLoader extends ClassLoader&#123;</span><br><span class="line">    public ParentClassLoader(ClassLoader parent)&#123;</span><br><span class="line">        super(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ChildClassLoader extends ClassLoader&#123;</span><br><span class="line">    public ChildClassLoader(ClassLoader parent)&#123; //parent = new ParentClassLoader();</span><br><span class="line">        super(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正是由于子类加载器中包含着父类加载器的引用，所以可以通过子类加载器的方法获取对应的父类加载器</p>
<p><strong>注意：</strong></p>
<p>启动类加载器通过C/C++语言编写，而自定义类加载器都是由Java语言编写的，虽然扩展类加载器和应用程序类加载器是被jdk开发人员使用java语言来编写的，但是也是由java语言编写的，所以也被称为自定义类加载器</p>
<h3 id="2-1-引导类加载器"><a href="#2-1-引导类加载器" class="headerlink" title="2.1. 引导类加载器"></a>2.1. 引导类加载器</h3><p>启动类加载器（引导类加载器，Bootstrap ClassLoader）</p>
<ul>
<li><p>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</p>
</li>
<li><p>它用来加载Java的核心库（JAVAHOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容）。用于提供JVM自身需要的类。</p>
</li>
<li><p>并不继承自java.lang.ClassLoader，没有父加载器。</p>
</li>
<li><p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p>
</li>
<li><p>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/43431a1abff0e5f2bd7bfd20fe91e5f7.png" alt="image-20210501170011811"> <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/5cd73234cd993408846ec7b4c2cb7238.png" alt="image-20210501170038212"> 使用-XX:+TraceClassLoading参数得到。</p>
</li>
</ul>
<p>启动类加载器使用C++编写的？Yes！</p>
<ul>
<li>C/C++：指针函数&amp;函数指针、C++支持多继承、更加高效</li>
<li>Java：由C++演变而来，（C++）–版，单继承</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;＊＊＊＊＊＊＊＊＊＊启动类加载器＊＊＊＊＊＊＊＊＊＊&quot;);</span><br><span class="line">// 获取BootstrapclassLoader能够加载的api的路径</span><br><span class="line">URL[] urLs = sun.misc.Launcher.getBootstrapcLassPath().getURLs();</span><br><span class="line">for (URL element : urLs) &#123;</span><br><span class="line">    System.out.println(element.toExternalForm());</span><br><span class="line">&#125;</span><br><span class="line">// 从上面的路径中随意选择一个类，来看看他的类加载器是什么：引导类加载器</span><br><span class="line">ClassLoader classLoader = java.security.Provider.class.getClassLoader();</span><br><span class="line">System.out.println(classLoader);</span><br></pre></td></tr></table></figure>

<p><strong>执行结果：</strong> <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/c72286acf05c7f86d1ea24f74e0c2a1e.png" alt="image-20210501170425889"></p>
<h3 id="2-2-扩展类加载器"><a href="#2-2-扩展类加载器" class="headerlink" title="2.2. 扩展类加载器"></a>2.2. 扩展类加载器</h3><p>扩展类加载器（Extension ClassLoader）</p>
<ul>
<li><p>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</p>
</li>
<li><p>继承于ClassLoader类</p>
</li>
<li><p>父类加载器为启动类加载器</p>
</li>
<li><p>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/ba54af96e744eb99a9248d13e55a7e3c.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;＊＊＊＊＊＊＊＊＊＊＊扩展类加载器＊＊＊＊＊＊＊＊＊＊＊&quot;);</span><br><span class="line">String extDirs =System.getProperty(&quot;java.ext.dirs&quot;);</span><br><span class="line">for (String path :extDirs.split( regex:&quot;;&quot;))&#123;</span><br><span class="line">    System.out.println(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从上面的路径中随意选择一个类，来看看他的类加载器是什么：扩展类加载器</span><br><span class="line">lassLoader classLoader1 = sun.security.ec.CurveDB.class.getClassLoader();</span><br><span class="line">System.out.print1n(classLoader1); //sun.misc. Launcher$ExtCLassLoader@1540e19d</span><br></pre></td></tr></table></figure>

<p><strong>执行结果：</strong></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/b21313ee65acb4f01f1d03b88529e9f5.png" alt="img"></p>
<h3 id="2-3-系统类加载器"><a href="#2-3-系统类加载器" class="headerlink" title="2.3. 系统类加载器"></a>2.3. 系统类加载器</h3><p>应用程序类加载器（系统类加载器，AppClassLoader）</p>
<ul>
<li>java语言编写，由sun.misc.Launcher$AppClassLoader实现</li>
<li>继承于ClassLoader类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统属性java.class.path 指定路径下的类库</li>
<li>应用程序中的类加载器默认是系统类加载器。应用程序中的类加载器默认是系统类加载器。</li>
<li>它是用户自定义类加载器的默认父加载器</li>
<li>通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器</li>
</ul>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/19dd9595afeb6543593ef14161fc1bb8.png" alt="image-20210501171206453"></p>
<h3 id="2-4-用户自定义类加载器"><a href="#2-4-用户自定义类加载器" class="headerlink" title="2.4. 用户自定义类加载器"></a>2.4. 用户自定义类加载器</h3><p>用户自定义类加载器</p>
<ul>
<li>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li>
<li>体现Java语言强大生命力和巨大魅力的关键因素之一便是，Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。</li>
<li>通过类加载器可以实现非常绝妙的插件机制通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</li>
<li>同时，自定义加载器能够实现应用隔离自定义加载器能够实现应用隔离，例如Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多，想不修改C/C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。</li>
<li>自定义类加载器通常需要继承于ClassLoader。</li>
</ul>
<hr>
<h2 id="3-测试不同的类的加载器"><a href="#3-测试不同的类的加载器" class="headerlink" title="3. 测试不同的类的加载器"></a>3. 测试不同的类的加载器</h2><p>每个Class对象都会包含一个定义它的ClassLoader的一个引用。 <strong>获取ClassLoader的途径</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获得当前类的ClassLoader</span><br><span class="line">clazz.getClassLoader()</span><br><span class="line">// 获得当前线程上下文的ClassLoader</span><br><span class="line">Thread.currentThread().getContextClassLoader()</span><br><span class="line">// 获得系统的ClassLoader</span><br><span class="line">ClassLoader.getSystemClassLoader()</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加 载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。由于引导类加载 器压根儿就不是一个Java类，因此在Java程序中只能打印出空值。</li>
<li>数组类的Class对象，不是由类加载器去创建的，而是在Java运行期JVM根据需要自动创建的。对于数组类的类加载器 来说，是通过Class.getClassLoader()返回的，与数组当中元素类型的类加载器是一样的；如果数组当中的元素类型 是基本数据类型，数组类是没有类加载器的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 运行结果：null</span><br><span class="line">String[] strArr = new String[6];</span><br><span class="line">System.out.println(strArr.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">// 运行结果：sun．misc．Launcher＄AppCLassLoader＠18b4aac2</span><br><span class="line">ClassLoaderTest[] test=new ClassLoaderTest[1];</span><br><span class="line">System.out.println(test.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">// 运行结果：null</span><br><span class="line">int[]ints =new int[2];</span><br><span class="line">System.out.println(ints.getClass().getClassLoader());</span><br></pre></td></tr></table></figure>

<p><strong>代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ClassLoaderTest1&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //获取系统该类加载器</span><br><span class="line">        ClassLoader systemClassLoader=ClassLoader.getSystemCLassLoader();</span><br><span class="line">        System.out.print1n(systemClassLoader);//sun.misc.Launcher$AppCLassLoader@18b4aac2</span><br><span class="line">        //获取扩展类加载器</span><br><span class="line">        ClassLoader extClassLoader =systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);//sun.misc. Launcher$ExtCLassLoader@1540e19d</span><br><span class="line">        //试图获取引导类加载器：失败</span><br><span class="line">        ClassLoader bootstrapClassLoader =extClassLoader.getParent();</span><br><span class="line">        System.out.print1n(bootstrapClassLoader);//null</span><br><span class="line"></span><br><span class="line">        //##################################</span><br><span class="line">        try&#123;</span><br><span class="line">            ClassLoader classLoader =Class.forName(&quot;java.lang.String&quot;).getClassLoader();</span><br><span class="line">            System.out.println(classLoader);</span><br><span class="line">            //自定义的类默认使用系统类加载器</span><br><span class="line">            ClassLoader classLoader1=Class.forName(&quot;com.atguigu.java.ClassLoaderTest1&quot;).getClassLoader();</span><br><span class="line">            System.out.println(classLoader1);</span><br><span class="line">            </span><br><span class="line">            //关于数组类型的加载：使用的类的加载器与数组元素的类的加载器相同</span><br><span class="line">            String[] arrstr = new String[10];</span><br><span class="line">            System.out.println(arrstr.getClass().getClassLoader());//null：表示使用的是引导类加载器</span><br><span class="line">                </span><br><span class="line">            ClassLoaderTest1[] arr1 =new ClassLoaderTest1[10];</span><br><span class="line">            System.out.println(arr1.getClass().getClassLoader());//sun.misc. Launcher$AppcLassLoader@18b4aac2</span><br><span class="line">            </span><br><span class="line">            int[] arr2 = new int[10];</span><br><span class="line">            System.out.println(arr2.getClass().getClassLoader());//null:</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-ClassLoader源码解析"><a href="#4-ClassLoader源码解析" class="headerlink" title="4. ClassLoader源码解析"></a>4. ClassLoader源码解析</h2><p><strong>ClassLoader与现有类的关系：</strong></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/00148a792adcf05932114dff408f82b5.png" alt="image-20210501173110637"></p>
<p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p>
<h3 id="4-1-ClassLoader的主要方法"><a href="#4-1-ClassLoader的主要方法" class="headerlink" title="4.1. ClassLoader的主要方法"></a>4.1. ClassLoader的主要方法</h3><p>抽象类ClassLoader的主要方法：（内部没有抽象方法）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final ClassLoader getParent()</span><br></pre></td></tr></table></figure>

<p>返回该类加载器的超类加载器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException</span><br></pre></td></tr></table></figure>

<p>加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回 ClassNotFoundException异常。该方法中的逻辑就是双亲委派模式的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException</span><br></pre></td></tr></table></figure>

<p>查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用。</p>
<ul>
<li>在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中，从前面的分析可知，findClass()方法是在loadClass()方法中被调用的，当loadClass()方法中父加载器加载失败后，则会调用自己的findClass()方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。</li>
<li>需要注意的是ClassLoader类中并没有实现findClass()方法的具体代码逻辑，取而代之的是抛出ClassNotFoundException异常，同时应该知道的是findClass方法通常是和defineClass方法一起使用的。一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象。一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final Class&lt;?&gt; defineClass(String name, byte[] b,int off,int len)</span><br></pre></td></tr></table></figure>

<p>根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用。</p>
<ul>
<li>defineClass()方法是用来将byte字节流解析成JVM能够识别的Class对象（ClassLoader中已实现该方法逻辑），通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象。</li>
<li>defineClass()方法通常与findClass()方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象defineClass()方法通常与findClass()方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象</li>
</ul>
<p><strong>简单举例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">    // 获取类的字节数组</span><br><span class="line">    byte[] classData =getClassData(name);</span><br><span class="line">    if (classData == null) &#123;</span><br><span class="line">        throw new ClassNotFoundException();</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">        //使用defineClass生成class对象</span><br><span class="line">        return defineClass(name,classData,θ,classData.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">protected final void resolveClass(Class&lt;?&gt; c)</span><br></pre></td></tr></table></figure>

<p>链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final Class&lt;?&gt; findLoadedClass(String name)</span><br></pre></td></tr></table></figure>

<p>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例。这个方法是final方法，无法被修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final ClassLoader parent;</span><br></pre></td></tr></table></figure>

<p>它也是一个ClassLoader的实例，这个字段所表示的ClassLoader也称为这个ClassLoader的双亲。在类加载的过程中，ClassLoader可能会将某些请求交予自己的双亲处理。</p>
<h3 id="4-2-SecureClassLoader与URLClassLoader"><a href="#4-2-SecureClassLoader与URLClassLoader" class="headerlink" title="4.2. SecureClassLoader与URLClassLoader"></a>4.2. SecureClassLoader与URLClassLoader</h3><p>接着SecureClassLoader扩展了ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对class源码的访问权限）的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联。</p>
<p>前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/53f634bada23b3400a303bfcc6e11a31.png" alt="image-20210501174730756"></p>
<h3 id="4-3-ExtClassLoader与AppClassLoader"><a href="#4-3-ExtClassLoader与AppClassLoader" class="headerlink" title="4.3. ExtClassLoader与AppClassLoader"></a>4.3. ExtClassLoader与AppClassLoader</h3><p>了解完URLClassLoader后接着看看剩余的两个类加载器，即拓展类加载器ExtClassLoader和系统类加载器AppClassLoader，这两个类都继承自URLClassLoader，是sun.misc.Launcher的静态内部类。</p>
<p>sun.misc.Launcher主要被系统用于启动主应用程序，ExtClassLoader和AppClassLoader都是由sun.misc.Launcher创建的，其类主要类结构如下：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/a77b6bca10308e6b9be35b1b2dfc84bc.png" alt="img"></p>
<p>我们发现ExtClassLoader并没有重写loadClass()方法，这足矣说明其遵循双亲委派模式，而AppClassLoader重载了loadClass()方法，但最终调用的还是父类loadClass()方法，因此依然遵守双亲委派模式。</p>
<h3 id="4-4-Class-forName-与ClassLoader-loadClass"><a href="#4-4-Class-forName-与ClassLoader-loadClass" class="headerlink" title="4.4. Class.forName()与ClassLoader.loadClass()"></a>4.4. Class.forName()与ClassLoader.loadClass()</h3><p><strong>Class.forName()</strong></p>
<ul>
<li><p>Class.forName()：是一个静态方法，最常用的是Class.forName(String className);</p>
</li>
<li><p>根据传入的类的全限定名返回一个Class对象。该方法在将Class文件加载到内存的同时，会执行类的初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class.forName(&quot;com.atguigu.java.Helloworld&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>ClassLoader.loadClass()</strong></p>
<ul>
<li><p>ClassLoader.loadClass()：这是一个实例方法，需要一个ClassLoader对象来调用该方法。</p>
</li>
<li><p>该方法将Class文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化。该方法因为需要得到一个ClassLoader对象，所以可以根据需要指定使用哪个类加载器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Classloader cl = ......; cl.loadClass(&quot;com.atguigu.java.Helloworld&quot;);</span><br></pre></td></tr></table></figure>

<hr>
</li>
</ul>
<h2 id="5-双亲委派模型"><a href="#5-双亲委派模型" class="headerlink" title="5. 双亲委派模型"></a>5. 双亲委派模型</h2><h3 id="5-1-定义与本质"><a href="#5-1-定义与本质" class="headerlink" title="5.1. 定义与本质"></a>5.1. 定义与本质</h3><p>类加载器用来把类加载到Java虚拟机中。从JDK1.2版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证Java平台的安全。</p>
<p><strong>定义</strong></p>
<p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</p>
<p><strong>本质</strong></p>
<p>规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/41cbfd9ba1da676a7f05dae0dac3abae.png" alt="image-20210501175529542"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/c1526b63e95852b48551b4f136ebbd6f.png" alt="img"></p>
<h3 id="5-2-优势与劣势"><a href="#5-2-优势与劣势" class="headerlink" title="5.2. 优势与劣势"></a>5.2. 优势与劣势</h3><p><strong>双亲委派机制优势</strong></p>
<ul>
<li><p>避免类的重复加载，确保一个类的全局唯一性</p>
<p>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</p>
</li>
<li><p>保护程序安全，防止核心API被随意篡改</p>
</li>
</ul>
<p><strong>代码支持</strong></p>
<p>双亲委派机制在java.lang.ClassLoader.loadClass(String，boolean)接口中体现。该接口的逻辑如下：</p>
<p>（1）先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</p>
<p>（2）判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name，false)接口进行加载。</p>
<p>（3）反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassorNull(name)接口，让引导类加载器进行加载。</p>
<p>（4）如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。</p>
<p>双亲委派的模型就隐藏在这第2和第3步中。</p>
<p><strong>举例</strong></p>
<p>假设当前加载的是java.lang.Object这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当]VM准备加载javaJang.Object时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第2步。扩展类的父加载器是null，因此系统调用findClass（String），最终通过引导类加载器进行加载。</p>
<p><strong>思考</strong></p>
<p>如果在自定义的类加载器中重写java.lang.ClassLoader.loadClass(String)或java.lang.ClassLoader.loadclass(String，boolean)方法，抹去其中的双亲委派机制，仅保留上面这4步中的第l步与第4步，那么是不是就能够加载核心类库了呢？</p>
<p>这也不行！因为JDK还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都必须调用 java.lang.ClassLoader.defineclass(String，byte[]，int，int，ProtectionDomain)方法，而该方法会执行preDefineClass()接口，该接口中提供了对JDK核心类库的保护。</p>
<p><strong>弊端</strong></p>
<p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</p>
<p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p>
<p><strong>结论</strong></p>
<p>由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Serylet规范推荐的一种做法。</p>
<h3 id="5-3-破坏双亲委派机制"><a href="#5-3-破坏双亲委派机制" class="headerlink" title="5.3. 破坏双亲委派机制"></a>5.3. 破坏双亲委派机制</h3><p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p>
<p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p>
<p><strong>第一次破坏双亲委派机制</strong></p>
<p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前一—即JDK1.2面世以前的“远古”时代。</p>
<p>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<p><strong>第二次破坏双亲委派机制：线程上下文类加载器</strong></p>
<p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载越基础的类由越上层的加载器进行加载），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？基础类型又要调用回用户的代码，那该怎么办呢？</p>
<p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？（SPI：在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI）</p>
<p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（ThreadContextClassLoader）线程上下文类加载器（ThreadContextClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
<p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。 ，例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK6时，JDK提供了java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/814235dcce5471c2a527e82bafcf21c7.png" alt="img"></p>
<p>默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p>
<p><strong>第三次破坏双亲委派机制</strong></p>
<p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如：**代码热替换(Hot Swap)、模块热部署(Hot Deployment)**等</p>
<p>IBM公司主导的JSR-291(即OSGiR4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(osGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bund1e连同类加载器一起换掉以实现代码的热替换。在oSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p>
<p>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p>
<p>1）将以java.∗开头的类，委派给父类加载器加载。将以java.∗开头的类，委派给父类加载器加载。</p>
<p>2）否则，将委派列表名单内的类，委派给父类加载器加载。否则，将委派列表名单内的类，委派给父类加载器加载。</p>
<p>3）否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</p>
<p>4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</p>
<p>5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</p>
<p>6）否则，查找Dynamic Import列表的Bundle，委派给对应Bund1e的类加载器加载。</p>
<p>7）否则，类查找失败。</p>
<p>说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p>
<p>小结：这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</p>
<p>正如：OSGi中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为<strong>OSGi中对类加载器的运用是值得学习的，完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹。</strong></p>
<h3 id="5-4-热替换的实现"><a href="#5-4-热替换的实现" class="headerlink" title="5.4. 热替换的实现"></a>5.4. 热替换的实现</h3><p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的，比如：PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。</p>
<p>但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。</p>
<p>注意：由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同一个类，在虚拟机内部，会认为这2个类是完全不同的。</p>
<p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/9ae876265c85af4e431932647993dab7.png" alt="image-20210501182003439"></p>
<hr>
<h2 id="6-沙箱安全机制"><a href="#6-沙箱安全机制" class="headerlink" title="6. 沙箱安全机制"></a>6. 沙箱安全机制</h2><p>沙箱安全机制</p>
<ul>
<li>保证程序安全</li>
<li>保护Java原生的JDK代码</li>
</ul>
<p>Java安全模型的核心就是Java沙箱（sandbox）Java安全模型的核心就是Java沙箱（sandbox）。什么是沙箱？沙箱是一个限制程序运行的环境。</p>
<p>沙箱机制就是将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。</p>
<p>沙箱主要限制系统资源访问，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p>
<p>所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p>
<h3 id="6-1-JDK1-0时期"><a href="#6-1-JDK1-0时期" class="headerlink" title="6.1. JDK1.0时期"></a>6.1. JDK1.0时期</h3><p>在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于<strong>沙箱（Sandbox）机制</strong>。如下图所示JDK1.0安全模型</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/71caf905a0ca13866e24419b7faa14ee.png" alt="image-20210501182608205"></p>
<h3 id="6-2-JDK1-1时期"><a href="#6-2-JDK1-1时期" class="headerlink" title="6.2. JDK1.1时期"></a>6.2. JDK1.1时期</h3><p>JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。</p>
<p>因此在后续的Java1.1版本中，针对安全机制做了改进，增加了<strong>安全策略</strong>。允许用户指定代码对本地资源的访问权限。</p>
<p>如下图所示JDK1.1安全模型</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/b93f0829e8340131a49738f8843307e4.png" alt="image-20210501182626963"></p>
<h3 id="6-3-JDK1-2时期"><a href="#6-3-JDK1-2时期" class="headerlink" title="6.3. JDK1.2时期"></a>6.3. JDK1.2时期</h3><p>在Java1.2版本中，再次改进了安全机制，增加了<strong>代码签名</strong>。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/81919ed70977f2b57ef5a11481c68abc.png" alt="image-20210501182652378"></p>
<h3 id="6-4-JDK1-6时期"><a href="#6-4-JDK1-6时期" class="headerlink" title="6.4. JDK1.6时期"></a>6.4. JDK1.6时期</h3><p>当前最新的安全机制实现，则引入了<strong>域（Domain）</strong>的概念。</p>
<p>虚拟机会把所有代码加载到不同的系统域和应用域。系统域部分专门负责与关键资源进行交互系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型（jdk1.6）</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/cf22059daec45f370ae3afb33b870c1f.png" alt="image-20210501182740197"></p>
<hr>
<h2 id="7-自定义类的加载器"><a href="#7-自定义类的加载器" class="headerlink" title="7. 自定义类的加载器"></a>7. 自定义类的加载器</h2><h3 id="7-1-为什么要自定义类加载器？"><a href="#7-1-为什么要自定义类加载器？" class="headerlink" title="7.1. 为什么要自定义类加载器？"></a>7.1. 为什么要自定义类加载器？</h3><ul>
<li><p>隔离加载类隔离加载类</p>
<p>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如:Tomcat这类Web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。</p>
</li>
<li><p>修改类加载的方式修改类加载的方式</p>
<p>类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载</p>
</li>
<li><p>扩展加载源扩展加载源</p>
<p>比如从数据库、网络、甚至是电视机机顶盒进行加载</p>
</li>
<li><p>防止源码泄漏防止源码泄漏</p>
<p>Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</p>
</li>
</ul>
<p><strong>常见的场景</strong></p>
<ul>
<li>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是JavaEE和OSGI、JPMS等框架。</li>
<li>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。</li>
</ul>
<p><strong>注意</strong></p>
<p>在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换，则加载器反而容易产生不美好的事情。在做Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。</p>
<h3 id="7-2-实现方式"><a href="#7-2-实现方式" class="headerlink" title="7.2. 实现方式"></a>7.2. 实现方式</h3><p>Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p>
<p>在自定义ClassLoader的子类时候，我们常见的会有两种做法：</p>
<ul>
<li>方式一：重写loadClass()方法</li>
<li>方式二：重写findclass()方法</li>
</ul>
<p><strong>对比</strong></p>
<ul>
<li>这两种方法本质上差不多，毕竟loadClass()也会调用findClass()，但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。</li>
<li>loadclass()这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写loadClass()方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</li>
<li>当编写好自定义类加载器后，便可以在程序中调用loadClass()方法来实现类加载操作。</li>
</ul>
<p><strong>说明</strong></p>
<ul>
<li>其父类加载器是系统类加载器</li>
<li>JVM中的所有类加载都会使用java.lang.ClassLoader.loadClass(String)接口(自定义类加载器并重写java.lang.ClassLoader.loadClass(String)接口的除外)，连JDK的核心类库也不能例外。</li>
</ul>
<hr>
<h2 id="8-Java9新特性"><a href="#8-Java9新特性" class="headerlink" title="8. Java9新特性"></a>8. Java9新特性</h2><p>为了保证兼容性，JDK9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p>
<ol>
<li><p>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器(platform class loader)。可以通过classLoader的新方法getPlatformClassLoader()来获取。</p>
<p>JDK9时基于模块化进行构建(原来的rt.jar和tools.jar被拆分成数十个JMOD文件)，其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留<JAVA_HOME>\lib\ext目录，此前使用这个目录或者java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了。</p>
</li>
<li><p>平台类加载器和应用程序类加载器都不再继承自java.net.URLClassLoader。</p>
<p>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader。</p>
</li>
</ol>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/323cfcda53f98034ed15372c0ea43685.png" alt="img"></p>
<p> 如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在JDK9及更高版本的JDK中崩溃。</p>
<ol>
<li>在Java9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</li>
<li>启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。</li>
<li>类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li>
</ol>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/cb23791a5fb1bf1a4c8a28d6a3179e84.png" alt="img"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/ef9b83abcdb9f54d0f0ec7d15f0adc44.png" alt="img"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/192fda50804d35e7d1b44dc61a65ede1.png" alt="img"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/f07a455ec275a6503bfad070ae3d9ffb.png" alt="img"></p>
<p><strong>代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader());</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getParent());</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getParent().getParent());</span><br><span class="line"></span><br><span class="line">        //获取系统类加载器</span><br><span class="line">        System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">        //获取平台类加载器</span><br><span class="line">        System.out.println(ClassLoader.getPlatformClassLoader());</span><br><span class="line">        //获取类的加载器的名称</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>参考文章：</p>
<p><a href="https://www.processon.com/view/link/60069cd7f346fb566ebba524">https://www.processon.com/view/link/60069cd7f346fb566ebba524</a></p>
<p><a href="https://www.yuque.com/u21195183/">https://www.yuque.com/u21195183/</a></p>
<p><a href="https://youthlql.gitee.io/post/8c954c6.html">https://youthlql.gitee.io/post/8c954c6.html</a></p>
]]></content>
      <categories>
        <category>jvm</category>
        <category>jvm理论</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm基础1之内存与垃圾回收篇</title>
    <url>/539b1196.html</url>
    <content><![CDATA[<h1 id="jvm基础1"><a href="#jvm基础1" class="headerlink" title="jvm基础1"></a>jvm基础1</h1><h1 id="为什么要学习jvm"><a href="#为什么要学习jvm" class="headerlink" title="为什么要学习jvm"></a>为什么要学习jvm</h1><ol>
<li><p>面试</p>
</li>
<li><p>系统调优</p>
<span id="more"></span></li>
</ol>
<h1 id="JVM与Java体系结构"><a href="#JVM与Java体系结构" class="headerlink" title="JVM与Java体系结构"></a>JVM与Java体系结构</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为Java工程师的你曾被伤害过吗？你是否也遇到过这些问题？</p>
<p>运行着的线上系统突然卡死，系统无法访问，甚至直接OOMM！</p>
<ul>
<li>想解决线上JVM GC问题，但却无从下手。</li>
<li>新项目上线，对各种JVM参数设置一脸茫然，直接默认吧然后就JJ了</li>
<li>每次面试之前都要重新背一遍JVM的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优VM参数，如何解决GC、OOM等问题，一脸懵逼。</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704111417472.png" alt="image-20200704111417472"></p>
<p>大部分Java开发人员，除会在项目中使用到与Java平台相关的各种高精尖技术，对于Java技术的核心Java虚拟机了解甚少。</p>
<p>一些有一定工作经验的开发人员，打心眼儿里觉得SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。如果我们把核心类库的API比做数学公式的话，那么Java虚拟机的知识就好比公式的推导过程。</p>
<p>计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704112119729.png" alt="image-20200704112119729"></p>
<h2 id="架构师每天都在思考什么？"><a href="#架构师每天都在思考什么？" class="headerlink" title="架构师每天都在思考什么？"></a>架构师每天都在思考什么？</h2><ul>
<li>应该如何让我的系统更快？</li>
<li>如何避免系统出现瓶颈？</li>
</ul>
<p>知乎上有条帖子：应该如何看招聘信息，直通年薪50万+？</p>
<ul>
<li>参与现有系统的性能优化，重构，保证平台性能和稳定性</li>
<li>根据业务场景和需求，决定技术方向，做技术选型</li>
<li>能够独立架构和设计海量数据下高并发分布式解决方案，满足功能和非功能需求</li>
<li>解决各类潜在系统风险，核心功能的架构与代码编写</li>
<li>分析系统瓶颈，解决各种疑难杂症，性能调优等</li>
</ul>
<h2 id="为什么要学习JVM"><a href="#为什么要学习JVM" class="headerlink" title="为什么要学习JVM"></a>为什么要学习JVM</h2><ul>
<li>面试的需要（BATJ、TMD，PKQ等面试都爱问）</li>
<li>中高级程序员必备技能<ul>
<li>项目管理、调优的需求</li>
</ul>
</li>
<li>追求极客的精神<ul>
<li>比如：垃圾回收算法、JIT（及时编译器）、底层原理</li>
</ul>
</li>
</ul>
<h2 id="Java-vs-C"><a href="#Java-vs-C" class="headerlink" title="Java vs C++"></a>Java vs C++</h2><p>垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704112700211.png" alt="image-20200704112700211"></p>
<p>C语言需要自己来分配内存和回收内存，Java全部交给JVM进行分配和回收。</p>
<h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h2><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704145340513.png" alt="image-20200704145340513"></p>
<h2 id="Java生态圈"><a href="#Java生态圈" class="headerlink" title="Java生态圈"></a>Java生态圈</h2><p>Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p>
<ul>
<li>作为一个平台，Java虚拟机扮演着举足轻重的作用<ul>
<li>Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分</li>
</ul>
</li>
<li>作为灯种文化，Java几乎成为了“开源”的代名词。<ul>
<li>第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。</li>
<li>就连JDK和JVM自身也有不少开源的实现，如openJDK、Harmony。</li>
</ul>
</li>
<li>作为一个社区，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌。</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704151731216.png" alt="image-20200704151731216"></p>
<p>每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过Java虚拟机进行运行和处理</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704152052489.png" alt="image-20200704152052489"></p>
<p>随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。</p>
<p>Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</p>
<h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。</p>
<p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</p>
<p>Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式—Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。</p>
<h2 id="多语言混合编程"><a href="#多语言混合编程" class="headerlink" title="多语言混合编程"></a>多语言混合编程</h2><p>Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</p>
<p>试想一下，在一个项目之中，并行处理用clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。</p>
<p>对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如Da Vinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。</p>
<h2 id="Java发展的重大事件"><a href="#Java发展的重大事件" class="headerlink" title="Java发展的重大事件"></a>Java发展的重大事件</h2><ul>
<li>1990年，在Sun计算机公司中，由Patrick Naughton、MikeSheridan及James Gosling领导的小组Green Team，开发出的新的程序语言，命名为oak，后期命名为Java</li>
<li>1995年，Sun正式发布Java和HotJava产品，Java首次公开亮相。</li>
<li>1996年1月23日sun Microsystems发布了JDK 1.0。</li>
<li>1998年，JDK1.2版本发布。同时，sun发布了JSP/Servlet、EJB规范，以及将Java分成了J2EE、J2SE和J2ME。这表明了Java开始向企业、桌面应用和移动设备应用3大领域挺进。</li>
<li>2000年，JDK1.3发布，Java HotSpot Virtual Machine正式发布，成为Java的默认虚拟机。</li>
<li>2002年，JDK1.4发布，古老的Classic虚拟机退出历史舞台。</li>
<li>2003年年底，Java平台的scala正式发布，同年Groovy也加入了Java阵营。</li>
<li>2004年，JDK1.5发布。同时JDK1.5改名为JavaSE5.0。</li>
<li>2006年，JDK6发布。同年，Java开源并建立了openJDK。顺理成章，Hotspot虚拟机也成为了openJDK中的默认虚拟机。</li>
<li>2007年，Java平台迎来了新伙伴Clojure。</li>
<li>2008年，oracle收购了BEA，得到了JRockit虚拟机。</li>
<li>2009年，Twitter宣布把后台大部分程序从Ruby迁移到scala，这是Java平台的又一次大规模应用。</li>
<li>2010年，oracle收购了sun，获得Java商标和最真价值的HotSpot虚拟机。此时，oracle拥有市场占用率最高的两款虚拟机HotSpot和JRockit，并计划在未来对它们进行整合：HotRockit</li>
<li>2011年，JDK7发布。在JDK1.7u4中，正式启用了新的垃圾回收器G1。</li>
<li>2017年，JDK9发布。将G1设置为默认Gc，替代CMS</li>
<li>同年，IBM的J9开源，形成了现在的open J9社区</li>
<li>2018年，Android的Java侵权案判决，Google赔偿oracle计88亿美元</li>
<li>同年，oracle宣告JavagE成为历史名词JDBC、JMS、Servlet赠予Eclipse基金会</li>
<li>同年，JDK11发布，LTS版本的JDK，发布革命性的zGc，调整JDK授权许可</li>
<li>2019年，JDK12发布，加入RedHat领导开发的shenandoah GC</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704182035810.png" alt="image-20200704182035810"></p>
<p>在JDK11之前，oracleJDK中还会存在一些openJDK中没有的、闭源的功能。但在JDK11中，我们可以认为openJDK和oracleJDK代码实质上已经完全一致的程度。</p>
<h2 id="虚拟机与Java虚拟机"><a href="#虚拟机与Java虚拟机" class="headerlink" title="虚拟机与Java虚拟机"></a>虚拟机与Java虚拟机</h2><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p>
<ul>
<li>大名鼎鼎的Visual Box，Mware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。</li>
<li>程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。</li>
</ul>
<p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p>
<h3 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h3><p>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</p>
<p>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</p>
<p>Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</p>
<p>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p>
<p>特点：</p>
<ul>
<li>一次编译，到处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
<h2 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h2><p>JVM是运行在操作系统之上的，它与硬件没有直接的交互</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704183048061.png" alt="image-20200704183048061"></p>
<p>Java的体系结构</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704183236169.png" alt="image-20200704183236169"></p>
<h2 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h2><ul>
<li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</li>
<li>它采用解释器与即时编译器并存的架构。</li>
<li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704183436495.png" alt="image-20200704183436495"></p>
<p>执行引擎包含三部分：解释器，及时编译器，垃圾回收器</p>
<h2 id="Java代码执行流程"><a href="#Java代码执行流程" class="headerlink" title="Java代码执行流程"></a>Java代码执行流程</h2><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704210429535.png" alt="image-20200704210429535"></p>
<p>只是能生成被Java虚拟机所能解释的字节码文件，那么理论上就可以自己设计一套代码了</p>
<h2 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h2><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：</p>
<p>基于栈式架构的特点</p>
<ul>
<li>设计和实现更简单，适用于资源受限的系统；</li>
<li>避开了寄存器的分配难题：使用零地址指令方式分配。</li>
<li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。</li>
<li>不需要硬件支持，可移植性更好，更好实现跨平台</li>
</ul>
<p>基于寄存器架构的特点</p>
<ul>
<li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li>
<li>指令集架构则完全依赖硬件，可移植性差</li>
<li>性能优秀和执行更高效</li>
<li>花费更少的指令去完成一项操作。</li>
<li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主方水洋</li>
</ul>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>同样执行2+3这种逻辑操作，其指令分别如下：</p>
<p>基于栈的计算流程（以Java虚拟机为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iconst_2 //常量2入栈</span><br><span class="line">istore_1</span><br><span class="line">iconst_3 // 常量3入栈</span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd //常量2/3出栈，执行相加</span><br><span class="line">istore_0 // 结果5入栈</span><br></pre></td></tr></table></figure>

<p>而基于寄存器的计算流程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax,2 //将eax寄存器的值设为1</span><br><span class="line">add eax,3 //使eax寄存器的值加3</span><br></pre></td></tr></table></figure>

<h3 id="字节码反编译"><a href="#字节码反编译" class="headerlink" title="字节码反编译"></a>字节码反编译</h3><p>我们编写一个简单的代码，然后查看一下字节码的反编译后的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author: 陌溪</span><br><span class="line"> * @create: 2020-07-04-21:17</span><br><span class="line"> */</span><br><span class="line">public class StackStruTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 2 + 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们找到编译后的 class文件，使用下列命令进行反编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javap -v StackStruTest.class</span><br></pre></td></tr></table></figure>

<p>得到的文件为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=2, locals=4, args_size=1</span><br><span class="line">       0: iconst_2</span><br><span class="line">       1: istore_1</span><br><span class="line">       2: iconst_3</span><br><span class="line">       3: istore_2</span><br><span class="line">       4: iload_1</span><br><span class="line">       5: iload_2</span><br><span class="line">       6: iadd</span><br><span class="line">       7: istore_3</span><br><span class="line">       8: return</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 9: 0</span><br><span class="line">      line 10: 2</span><br><span class="line">      line 11: 4</span><br><span class="line">      line 12: 8</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0       9     0  args   [Ljava/lang/String;</span><br><span class="line">          2       7     1     i   I</span><br><span class="line">          4       5     2     j   I</span><br><span class="line">          8       1     3     k   I</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<p>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpotVM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li>跨平台性</li>
<li>指令集小</li>
<li>指令多</li>
<li>执行性能比寄存器差</li>
</ul>
<h2 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h2><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p>
<h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ul>
<li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</li>
<li>程序开始执行时他才运行，程序结束时他就停止。</li>
<li>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</li>
</ul>
<h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><p>有如下的几种情况：</p>
<ul>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统用现错误而导致Java虚拟机进程终止</li>
<li>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</li>
<li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</li>
</ul>
<h2 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><ul>
<li>早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰。</li>
<li>这款虚拟机内部只提供解释器。现在还有及时编译器，因此效率比较低，而及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。</li>
<li>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。</li>
<li>现在hotspot内置了此虚拟机。</li>
</ul>
<h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><p>为了解决上一个虚拟机问题，jdk1.2时，sun提供了此虚拟机。 Exact Memory Management：准确式内存管理</p>
<ul>
<li>也可以叫Non-Conservative/Accurate Memory Management</li>
<li>虚拟机可以知道内存中某个位置的数据具体是什么类型。|</li>
</ul>
<p>具备现代高性能虚拟机的维形</p>
<ul>
<li>热点探测（寻找出热点代码进行缓存）</li>
<li>编译器与解释器混合工作模式</li>
</ul>
<p>只在solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换</p>
<h3 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot VM"></a>HotSpot VM</h3><p>HotSpot历史</p>
<ul>
<li>最初由一家名为“Longview Technologies”的小公司设计</li>
<li>1997年，此公司被sun收购；2009年，Sun公司被甲骨文收购。</li>
<li>JDK1.3时，HotSpot VM成为默认虚拟机</li>
</ul>
<p>目前Hotspot占有绝对的市场地位，称霸武林。</p>
<ul>
<li>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot</li>
<li>Sun/oracle JDK和openJDK的默认虚拟机</li>
<li>因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的Gc机制。（比如其他两个商用虚机都没有方法区的概念）</li>
</ul>
<p>从服务器、桌面到移动端、嵌入式都有应用。</p>
<p>名称中的HotSpot指的就是它的热点代码探测技术。</p>
<ul>
<li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li>
<li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li>
</ul>
<h3 id="JRockit"><a href="#JRockit" class="headerlink" title="JRockit"></a>JRockit</h3><p>专注于服务器端应用</p>
<ul>
<li>它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</li>
</ul>
<p>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM。</p>
<ul>
<li>使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。</li>
</ul>
<p>优势：全面的Java运行时解决方案组合</p>
<ul>
<li>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要</li>
<li>MissionControl服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li>
</ul>
<p>2008年，JRockit被oracle收购。</p>
<p>oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</p>
<p>高斯林：目前就职于谷歌，研究人工智能和水下机器人</p>
<h3 id="IBM的J9"><a href="#IBM的J9" class="headerlink" title="IBM的J9"></a>IBM的J9</h3><p>全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9</p>
<p>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。</p>
<p>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。</p>
<p>2017年左右，IBM发布了开源J9VM，命名为openJ9，交给EClipse基金会管理，也称为Eclipse OpenJ9</p>
<p>OpenJDK -&gt; 是JDK开源了，包括了虚拟机</p>
<h3 id="KVM和CDC-CLDC-Hotspot"><a href="#KVM和CDC-CLDC-Hotspot" class="headerlink" title="KVM和CDC / CLDC Hotspot"></a>KVM和CDC / CLDC Hotspot</h3><p>oracle在Java ME产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM KVM（Kilobyte）是CLDC-HI早期产品目前移动领域地位尴尬，智能机被Angroid和ioS二分天下。</p>
<p>KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场</p>
<ul>
<li>智能控制器、传感器</li>
<li>老人手机、经济欠发达地区的功能手机</li>
</ul>
<p>所有的虚拟机的原则：一次编译，到处运行。</p>
<h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><p>前面三大“高性能Java虚拟机”使用在通用硬件平台上这里Azu1VW和BEALiquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机I</p>
<ul>
<li>高性能Java虚拟机中的战斗机。</li>
</ul>
<p>Azul VM是Azu1Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的ava虚拟机。</p>
<p>每个Azu1VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</p>
<p>2010年，AzulSystems公司开始从硬件转向软件，发布了自己的zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。</p>
<h3 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h3><p>高性能Java虚拟机中的战斗机。</p>
<p>BEA公司开发的，直接运行在自家Hypervisor系统上Liquid VM即是现在的JRockit VE（Virtual Edition），</p>
<p>Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。</p>
<p>随着JRockit虚拟机终止开发，Liquid vM项目也停止了。</p>
<h3 id="Apache-Marmony"><a href="#Apache-Marmony" class="headerlink" title="Apache Marmony"></a>Apache Marmony</h3><p>Apache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。</p>
<p>它是IElf和Inte1联合开发的开源JVM，受到同样开源的openJDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK</p>
<p>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。</p>
<h3 id="Micorsoft-JVM"><a href="#Micorsoft-JVM" class="headerlink" title="Micorsoft JVM"></a>Micorsoft JVM</h3><p>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。</p>
<p>只能在window平台下运行。但确是当时Windows下性能最好的Java VM。</p>
<p>1997年，sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软windowsXPSP3中抹掉了其VM。现在windows上安装的jdk都是HotSpot。</p>
<h3 id="Taobao-JVM"><a href="#Taobao-JVM" class="headerlink" title="Taobao JVM"></a>Taobao JVM</h3><p>由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</p>
<p>基于openJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。</p>
<p>基于openJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。</p>
<ul>
<li>创新的GCIH（GCinvisible heap）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且Gc不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升Gc的回收效率的目的。</li>
<li>GCIH中的对象还能够在多个Java虚拟机进程中实现共享</li>
<li>使用crc32指令实现JvM intrinsic降低JNI的调用开销</li>
<li>PMU hardware的Java profiling tool和诊断协助功能</li>
<li>针对大数据场景的ZenGc</li>
</ul>
<p>taobao vm应用在阿里产品上性能高，硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能</p>
<p>目前已经在淘宝、天猫上线，把oracle官方JvM版本全部替换了。</p>
<h3 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h3><p>谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。</p>
<p>Dalvik y只能称作虚拟机，而不能称作“Java虚拟机”，它没有遵循 Java虚拟机规范</p>
<p>不能直接执行Java的Class文件</p>
<p>基于寄存器架构，不是jvm的栈架构。</p>
<p>执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。</p>
<ul>
<li>它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。</li>
</ul>
<p>Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。</p>
<h3 id="Graal-VM"><a href="#Graal-VM" class="headerlink" title="Graal VM"></a>Graal VM</h3><p>2018年4月，oracle Labs公开了GraalvM，号称 “Run Programs Faster Anywhere”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。</p>
<p>GraalVM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言” 的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等</p>
<p>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</p>
<p>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p>
<p>如果说HotSpot有一天真的被取代，Graalvm希望最大。但是Java的软件生态没有丝毫变化。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以oracle HotSpot VM为默认虚拟机。类加载子系统（ClassLoader）</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210604180804639.png" alt="image-20210604180804639"> </p>
<p>自己实现Java虚拟机则要实现类加载器（ClassLoader）和执行引擎（Execution Engine）</p>
<h2 id="面试题：请叙述一下类的加载过程"><a href="#面试题：请叙述一下类的加载过程" class="headerlink" title="面试题：请叙述一下类的加载过程"></a>面试题：请叙述一下类的加载过程</h2><h2 id="ClassLoader的作用"><a href="#ClassLoader的作用" class="headerlink" title="ClassLoader的作用"></a>ClassLoader的作用</h2><p>读取并加载class文件，不负责运行，运行是由Execution Engine负责，类加载器只是读取类文件，还没有到对象。</p>
<p>加载信息存放到方法区，方法区中包含常量池（存储字符串字面量和数字常量）。</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210604181845969.png" alt="image-20210604181845969" style="zoom: 50%;" />

<p>完整的流程图如下所示</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210604203614562.png" alt="image-20210604203614562"></p>
<h2 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h2><ul>
<li><p>通过一个类的 全限定名（包名+类名）获取定义此类的二进制字节流</p>
</li>
<li><p>通过这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>
<ul>
<li>静态数据结构：存储空间在程序执行过程中不能加以改变，例如：int float double</li>
<li>动态数据结构：为现有的每一个数据元素定义一个确定的初始大小空间，当问题的数据量发生变化的时候，数据的存储空间的大小也会发生变化</li>
</ul>
</li>
<li><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口</p>
<ul>
<li>每个类的运行时类型信息都是用Class对象类表示的</li>
<li>Class类就是对类的抽象和集合</li>
</ul>
</li>
</ul>
<h3 id="加载Class文件的方式"><a href="#加载Class文件的方式" class="headerlink" title="加载Class文件的方式"></a>加载Class文件的方式</h3><ul>
<li>从本地系统中加载</li>
<li>通过网络获取，代表：WEB</li>
<li>总zip压缩包中读取，成为日后jar、war包的格式基础</li>
<li>运行时计算生成，代表：动态代理</li>
<li>有其他文件生成，代表：XML生成class文件，jsp从数据库中读取，比较少</li>
<li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li>
</ul>
<h2 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h2><h3 id="验证Verify"><a href="#验证Verify" class="headerlink" title="验证Verify"></a>验证Verify</h3><p>目的在于确保Class文件的子节流卓弄个包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p>
<p>主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证。</p>
<h3 id="准备阶段-Prepare"><a href="#准备阶段-Prepare" class="headerlink" title="准备阶段 Prepare"></a>准备阶段 Prepare</h3><p>为类变量（static变量）分配并且设置该类变量的默认初始值</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>Int</td>
<td>0</td>
</tr>
<tr>
<td>Long</td>
<td>0</td>
</tr>
<tr>
<td>Boolean</td>
<td>false</td>
</tr>
<tr>
<td>float</td>
<td>0.0</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>char</td>
<td>/u0000(NULL)</td>
</tr>
<tr>
<td>String</td>
<td>NULl</td>
</tr>
<tr>
<td>Object(代表所有的类)</td>
<td>NULL</td>
</tr>
<tr>
<td>数组(未初始化)</td>
<td>NULL</td>
</tr>
<tr>
<td>数组(已初始化)</td>
<td>数组各个元素的值为，其类型的默认值</td>
</tr>
</tbody></table>
<h4 id="面试题：为什么要有默认值"><a href="#面试题：为什么要有默认值" class="headerlink" title="面试题：为什么要有默认值"></a>面试题：为什么要有默认值</h4><p>答：有些成员变量在初始化的时候不知道赋什么初始的值，这个在不同的对象中可能有不同的值，所以java就直接给显示初始化的成员变量一个默认值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a= <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>变量a在准备阶段会被赋初始值，但不是1，而是0；</p>
<p>final修饰的static，在编译的时候已经被分配了，准备阶段会显示初始化；（对吗）</p>
<p>这里不会为实例变量（没有用static修饰的变量）初始化，类变量（static修饰的变量）会被分配到方法区中，而实例变量会随着对象一起分配到堆中。局部变量在调用方法的时候才会创建，（局部变量在创建的时候必须赋予初始值，编译器检测）</p>
<h3 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析 Resolve"></a>解析 Resolve</h3><p>将常量池内的符号引用转换为直接引用的过程。</p>
<p>待完成</p>
<h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><p>初始化阶段就是执行类构造器方法（&lt;clinit）方法的过程，该方法不需要定义，是javac编译器自动收集类中的所有变量的赋值动作和静态代码块中的语句合并而来。</p>
<ul>
<li>也就是说，当我们代码中包含static变量的时候，就会有clinit方法</li>
</ul>
<p>构造器方法中指令按语句在源文件中出现的顺序执行。&lt;clinit不同于类 的构造器，是对实例变量初始化的。若该类具有父类，JVM会保证子类的clinit执行前，父类的clinit已经执行完毕。</p>
<p>而且虚拟机必须保证一个类的clinit方法在多线程下被同步枷锁。</p>
<h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><p>JVM支持两种类型的类加载器。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined Classloader）。</p>
<p>Java虚拟机中的自定义类加载器，是将所有派生与抽象类ClassLoader的类加载器都划分为自定义类加载器。</p>
<p>常见的类加载器：</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210605153312549.png" alt="image-20210605153312549" style="zoom: 67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader classLoader = Test.class.getClassLoader();</span><br><span class="line">System.out.println(classLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@4554617c</span></span><br><span class="line">ClassLoader bootClassLoader = extClassLoader.getParent();</span><br><span class="line">System.out.println(bootClassLoader);<span class="comment">//null 根类加载器使用C/C++写的，java获取不到</span></span><br><span class="line">ClassLoader parent = bootClassLoader.getParent();</span><br><span class="line">System.out.println(parent);<span class="comment">//Exception in thread &quot;main&quot; java.lang.NullPointerException</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><h4 id="启动类加载器（也叫引导类加载器、根类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（也叫引导类加载器、根类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（也叫引导类加载器、根类加载器，Bootstrap ClassLoader）"></a>启动类加载器（也叫引导类加载器、根类加载器，Bootstrap ClassLoader）</h4><ul>
<li>这个类使用C/C++实现的，嵌套在JVM内部，parent获取不到</li>
<li>它用来加载java的核心库（jre/lib目录下的rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供jvm自身需要的类</li>
<li>它不继承与java.lang.ClassLoader，没有父类加载器</li>
<li>加载扩展类加载器和应用程序类加载器，并指定为他们的父类加载器。</li>
<li>处于安全考虑，Bootstrap启动类加载器只加载报名为java、Javax、sun等开头的包</li>
</ul>
<h4 id="拓展类加载器（Extension-ClassLoader）"><a href="#拓展类加载器（Extension-ClassLoader）" class="headerlink" title="拓展类加载器（Extension ClassLoader）"></a>拓展类加载器（Extension ClassLoader）</h4><ul>
<li>java语言编写，由sun.misc.Launcher$ExtClassLoader实现</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为启动类加载器</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre、lib/ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动有拓展类加载器加载</li>
<li>是在Launcher下的一个静态内部类，随着类的加载而产生</li>
</ul>
<h4 id="应用程序类加载器（系统类加载器，AppClassLoader）"><a href="#应用程序类加载器（系统类加载器，AppClassLoader）" class="headerlink" title="应用程序类加载器（系统类加载器，AppClassLoader）"></a>应用程序类加载器（系统类加载器，AppClassLoader）</h4><ul>
<li>java语言编写，由sun.misc.Launcher$AppClassLoader</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
<li>该类加载是程序中默认的类加载器，一般来说，java应用的类都是由它来完成加载的</li>
<li>通过classLoader#getSystemclassLoader()方法可以获取到该类加载器</li>
</ul>
<h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>在java日常开发中，类的加载是由上述三种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。为什么要自定义类加载器呢？</p>
<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>防止源码泄露</li>
<li><a href="https://blog.csdn.net/u011250186/article/details/102553487?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/u011250186/article/details/102553487?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&amp;spm=1001.2101.3001.4242</a></li>
</ul>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>Java虚拟机对class文件采用按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。并且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul>
<li>如果一个类加载器收到了类请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li>
<li>如果父类加载器还存在器父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式</li>
</ul>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210605203949134.png" alt="image-20210605203949134" style="zoom:50%;" />

<h3 id="有什么用"><a href="#有什么用" class="headerlink" title="有什么用"></a>有什么用</h3><p>双亲委派机制保证了java程序的安全性，如果有用户恶意篡改了核心包下的内容，然后加载到你的程序中，你在加载核心类的时候会可能就会加载被篡改的类，然后发生安全问题。有了双亲委派机制后，当你的程序想加载一个核心类的时候，会一层层向上传递，如果父类加载器能加载，那么父类加载器优先加载，父类加载器会去指定的本地目录下面加载核心包，而不是选择从应用程序中加载你定义的核心类，这样就保证了你调用的java核心类和拓展类是安全的（如果本地的也被修改了，这个时候会加载你本地修改的）</p>
<h3 id="双亲委派机制举例"><a href="#双亲委派机制举例" class="headerlink" title="双亲委派机制举例"></a>双亲委派机制举例</h3><p>当加载jdbc.jar包的时候，java本身是没有这样对mysql的实现连接类的，这个包是由厂商实现的，但是java给厂商提供了SPI接口，厂商可以实现SPI接口来自定义连接方式。所以在加载的时候，会进行双亲委派，当尝试加载其中类的时候，触发了类加载系统，优先加载父类和接口类的，然后触发双亲委派机制，接口类是java核心类，那么就调用根类加载器，父类加载完成后加载子类，触发双亲委派机制，先传递给根类，根类加载不了，传给拓展类，拓展类加载不了，那么最后才由系统类加载器加载，最后将整个被使用的jdbc加载完成。</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210605210639583.png" alt="image-20210605210639583" style="zoom:67%;" />

<h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>java中可以定义与核心类重名的包名和类名，如果你自定义了一个java.long.String类，那么加载String类的时候，会调用双亲委派机制，先试用根类加载器去加载，根类加载器发现整个类我好像能加载，那么根类加载器就去自身jdk带的文件中rt.jar包（java.lang.string.class）中加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String string = <span class="keyword">new</span> String();</span><br><span class="line">        System.out.println(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行这段代码，发现在idea中直接就不能运行了，没有了运行按钮，因为idea编译器自己就把这种代码识别为错误代码。可以使用命令运行，然后报错，找不到main方法，因为系统加载的是自带的String类，这个类是没有main方法的</p>
<h3 id="双亲委派机制的优势"><a href="#双亲委派机制的优势" class="headerlink" title="双亲委派机制的优势"></a>双亲委派机制的优势</h3><ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心API被随意篡改<ul>
<li>例如：自定义类：java.lang.String</li>
</ul>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="如何判断两个class对象是否相同"><a href="#如何判断两个class对象是否相同" class="headerlink" title="如何判断两个class对象是否相同"></a>如何判断两个class对象是否相同</h3><p>在JVM中判断两个clas对象是否为同一个类存在两个必要条件：</p>
<ul>
<li>类的完整类名必须一致，包括包名。</li>
<li>加载这个类的ClassLoader必须相同<ul>
<li>那么什么时候同样一个class文件，使用不用的类加载器<ul>
<li>其实也特别简单，<ul>
<li>你创建不同的ClassLoader对象来加载这个类的时候，因为是不同的对象，那么类加载器当然不一样</li>
<li>你定义不用的自定义类加载器去加载文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ++count;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">&quot;count: &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//使用了不同的URLClassLoader对象来加载同一个class文件，来生成对象</span></span><br><span class="line">        URLClassLoader loader_1 =</span><br><span class="line">                <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;<span class="keyword">new</span> File(<span class="string">&quot;D:\\00-test&quot;</span>).toURI().toURL()&#125;);</span><br><span class="line">        <span class="comment">//java.net.URLClassLoader@1b6d3586</span></span><br><span class="line">        URLClassLoader loader_2 =</span><br><span class="line">                <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;<span class="keyword">new</span> File(<span class="string">&quot;D:\\00-test&quot;</span>).toURI().toURL()&#125;);</span><br><span class="line"> 		<span class="comment">//java.net.URLClassLoader@74a14482</span></span><br><span class="line">        Class&lt;?&gt; clazz_1 = loader_1.loadClass(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">        clazz_1.newInstance();</span><br><span class="line">        Class&lt;?&gt; clazz_2 = loader_2.loadClass(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">        clazz_2.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">打印结果：</span><br><span class="line">java.net.URLClassLoader@1b6d3586</span><br><span class="line">count: 1 </span><br><span class="line">java.net.URLClassLoader@74a14482</span><br><span class="line">count: 1</span><br></pre></td></tr></table></figure>

<p>理论上这两个对象共用一个类的资源，count应该先为1在为2，结果因为使用不用的类加载器，系统判断这两个不是一个class对象，那么其生成的对象也不是共用资源的。</p>
<p>JVM必须知道一个类型是由启动类加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是想通过的。（现在不需要理解，等学完字节码加载后在回来看）</p>
<h3 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h3><p>Java程序对类的使用方式分为:王动使用和被动使用。主动使用，又分为七种情况:</p>
<ul>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值。</li>
<li>调用类的静态方法Ⅰ</li>
<li>反射（比如:Class.forName ( “com.atguigu.Test”) )。</li>
<li>初始化一个类的子类</li>
<li>Java 虚拟机启动时被标明为启动类的类</li>
<li>JDK7开始提供的动态语言支持:</li>
<li>java.lang.invoke.MethodHandle实例的解析结果REF getStatic、REF putStatic、REF invokeStatic句柄对应的类没有初始化，则初始化</li>
</ul>
<p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</p>
<p>(学完后面后在回过来看)</p>
<h1 id="运行时数据区概述及线程"><a href="#运行时数据区概述及线程" class="headerlink" title="运行时数据区概述及线程"></a>运行时数据区概述及线程</h1><h2 id="前言（大纲）"><a href="#前言（大纲）" class="headerlink" title="前言（大纲）"></a>前言（大纲）</h2><p>运行时数据区为类加载完成后的阶段（<strong>现在可以，把前面类加载器子系统回顾一下，看看能不能用自己的语言叙述下来加载一个类的时候在类加载子系统的界面中国发生了什么</strong>）</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210605215155470.png" alt="image-20210605215155470"></p>
<p>当我们通过前面的：类的加载 —&gt; 验证—&gt;准备—&gt;解析—&gt;初始化这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用我们运行时数据区。</p>
<p>内存规定了java在运行过程中内存申请、分配和管理的策略，保证了jvm的高效稳定运行。不同的jvm对于内存的划分方式和管理机制存在着部分差异。结合jvm虚拟机规范，这里说明经典jvm内存布局（hotspot）。</p>
<p>我们通过磁盘或者网络io得到的数据，都需要先加载到内存中，然后cpu从内存中获取数据进行读取，也就是说内存充当了cpu和磁盘之间的桥梁。</p>
<p>下面为阿里认为的的运行数据区的完整图（元数据去和JIT编译产物位置存在部分争议，不用管）</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210606095404417.png" alt="image-20210606095404417"></p>
<p>java虚拟机定义了若干中程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应，这些与线程对应的数据区会随着线程的开始和结束而创建和销毁。</p>
<p>其中：</p>
<ul>
<li>每个线程独立：包括程序计数器、栈、本地栈。</li>
<li>线程间共享：堆、堆外内存（永久代或元空间（Metaspace）、代码缓存（CodeCache））</li>
</ul>
<p>下面开始逐个解析</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是一个程序里的运行单元，也是操作系统调度的基本单位，而进程是操作系统资源分配的基本单位。</p>
<p>jvm允许一个应用有多个线程并行的执行j.在Hotspot JVM中，每个线程都与操作系统的本地线程直接映射。</p>
<ul>
<li>当一个java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。java线程执行终止后，本地线程也会回收。</li>
</ul>
<p>操作系统负责所有线程的安排调度到任何一个可用的cpu上。一旦本地线程初始化成功，它就会调用java线程中的run（）方法。</p>
<h2 id="面试题：start方法和run方法的区别"><a href="#面试题：start方法和run方法的区别" class="headerlink" title="面试题：start方法和run方法的区别"></a>面试题：start方法和run方法的区别</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        myRunnable.run();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myRunnable, <span class="string">&quot;线程用例&quot;</span>);</span><br><span class="line">        thread.run();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> food = <span class="number">5</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程名：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; food:&quot;</span>+food--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">结果：</span><br><span class="line">线程名：main food:<span class="number">5</span></span><br><span class="line">线程名：main food:<span class="number">4</span></span><br><span class="line">线程名：main food:<span class="number">3</span></span><br><span class="line">线程名：main food:<span class="number">2</span></span><br><span class="line">线程名：main food:<span class="number">1</span></span><br><span class="line">线程名：main food:<span class="number">0</span></span><br><span class="line">线程名：main food:-<span class="number">1</span></span><br><span class="line">线程名：main food:-<span class="number">2</span></span><br><span class="line">线程名：main food:-<span class="number">3</span></span><br><span class="line">线程名：main food:-<span class="number">4</span></span><br><span class="line"><span class="comment">//到上面为止，我们发现当我们调用run方法的时候，都是main线程在调用run方法，而不是我们的创建的那个类</span></span><br><span class="line"></span><br><span class="line">线程名：线程用例 food:-<span class="number">5</span></span><br><span class="line">线程名：线程用例 food:-<span class="number">6</span></span><br><span class="line">线程名：线程用例 food:-<span class="number">7</span></span><br><span class="line">线程名：线程用例 food:-<span class="number">8</span></span><br><span class="line">线程名：线程用例 food:-<span class="number">9</span></span><br><span class="line"><span class="comment">//当我们用start后，发现我们没有调用run方法，但是run方法也已经打印了，因为在我们调用start方法的时候，只是让当前线程进入准备阶段，当该线程初始化完毕的时候，jvm虚拟机会调用run方法</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>start方法是线程内的方法，run方法是接口Runnable的的方法，这个接口内只有这一个方法</p>
<p>start方法才是调用该线程的争取方法，start方法会该线程进入准备阶段，当初始化完毕后jvm虚拟机会自动调用run方法执行（start方法只能被调用一次，因为一个线程只能被初始化一次）</p>
<p>直接调用run方法，没有准备的哪一个阶段，相当于调用一个类的普通run方法（run方法可以调用多次）</p>
<p><strong>源码分析：</strong></p>
<p>run方法：</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210612160517958.png" alt="image-20210612160517958" style="zoom: 80%;" />

<p>调用的是target的run方法</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210612160636177.png" alt="image-20210612160636177"></p>
<p>target是是Runnable方法</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210612160720245.png" alt="image-20210612160720245"></p>
<p>在我们使用这样的构造器创建一个线程的时候，就会给target赋值。</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210612160847435.png" alt="image-20210612160847435" style="zoom:50%;" />

<p>所以会调用runnable中的run方法，但是Runnable是一个接口，调用一个接口中的方法后，会调用该实现类的重写的run方法。</p>
<p>MyRunnable myRunnable = new MyRunnable();我们实际是找的myRunnable的run方法，而myRunnable是指向 new MyRunnable()这个对象的，所以java就知道到底要执行哪一个方法，毕竟Runnable的实现那么多</p>
<p>start方法</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210612163456165.png" alt="image-20210612163456165" style="zoom:67%;" />

<p>主要是调用了一个start0（）的方法，接着往下走</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210612163545826.png" alt="image-20210612163545826" style="zoom:50%;" />

<p> 我们可以看到这里是一个native的本地方法，所以这个start0就是初始化线程的一个方法，而run方法只是线程初始化完毕后的一个java方法调用。</p>
<h2 id="JVM-操作系统"><a href="#JVM-操作系统" class="headerlink" title="JVM 操作系统"></a>JVM 操作系统</h2><p>如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行这些后台线程不包括调用public static void main (String[〉的main线程以及所有这个main线程自己创建的线程。</p>
<p>这些主要的后台系统线程在Hotspot JVM里主要是以下几个（现在看一遍就行，后期要理解）:</p>
<ul>
<li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li>
<li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li>
<li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li>
<li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li>
<li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li>
</ul>
<h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>jvm中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器中才能够运行。这里，并非广义上所指的物理寄存器，获取将其翻译为pc计数器（或指令计数器）会回更加贴切（也称为钩子函数）。jvm中的pc寄存器是对物理pc寄存器的一种抽象模拟。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210606101919933.png" alt="image-20210606101919933"></p>
<p>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域。在jvm规范中，每个线程都有自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p>
<p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p>
<p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</p>
<p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<p>它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域。</p>
<p>对数据区有两个重要的衡量标志：是有有GC（垃圾回收机制）、OOM（内存溢出）。而程序计数器既没有GC也没有OOM。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/images/image-20200705155728557.png" alt="image-20200705155728557"></p>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCRegisterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将代码进行编译成字节码文件，我们再次查看( javap -v  PCRegisterTest)，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: bipush        10</span><br><span class="line">2: istore_1</span><br><span class="line">3: bipush        20</span><br><span class="line">5: istore_2</span><br><span class="line">6: iload_1</span><br><span class="line">7: iload_2</span><br><span class="line">8: iadd</span><br><span class="line">9: istore_3</span><br><span class="line">10: return</span><br></pre></td></tr></table></figure>

<p>通过PC寄存器，我们就可以知道当前程序执行到哪一步了 </p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/images/image-20200705161007423.png" alt="image-20200705161007423"></p>
<h2 id="使用pc寄存器存储字节码指令地址有什么用"><a href="#使用pc寄存器存储字节码指令地址有什么用" class="headerlink" title="使用pc寄存器存储字节码指令地址有什么用"></a>使用pc寄存器存储字节码指令地址有什么用</h2><p>cpu需要不停的切换各个线程，这时候切换回来后，就要知道接着从哪里开始执行。</p>
<p>jvm的字节码解释器就是通过改变pc寄存器的值来明确下一条应该执行什么样的字节码指令。<img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/images/image-20200705161409533.png" alt="image-20200705161409533"></p>
<h2 id="pc寄存器为什么被设定为私有的"><a href="#pc寄存器为什么被设定为私有的" class="headerlink" title="pc寄存器为什么被设定为私有的"></a>pc寄存器为什么被设定为私有的</h2><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>
<p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p>
<p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/images/image-20200705161812542.png" alt="image-20200705161812542"></p>
<h2 id="cpu时间片"><a href="#cpu时间片" class="headerlink" title="cpu时间片"></a>cpu时间片</h2><p>cpu时间片就是cpu分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p>
<p>在宏观上：我们可以同时打开多个应用程序，每个程序并不勃，同时运行。</p>
<p>在微观上：由于只有一个淳朴，一次只能处理程序要求的一部分，如何处理公平，其中一种方法就是引入时间片，每个程序轮流执行。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/images/image-20200705161849557.png" alt="image-20200705161849557"></p>
<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="虚拟机栈概述"><a href="#虚拟机栈概述" class="headerlink" title="虚拟机栈概述"></a>虚拟机栈概述</h2><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的（计算机组成原理：寄存室是cpu的内部结构，不同cpu对寄存器的实现是不一样的，如果要把设置为寄存器虽然运行速度更快，但是失去了java的一次编译处处运行的跨平台性）。 优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<p>有不少Java开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存区理解为仅有Java堆（heap）和Java战（stack）？为什么？</p>
<p>首先栈是运行时的单位，而堆是存储的单位</p>
<ul>
<li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li>
<li>堆解决的是数据存储的问题，即数据怎么放，放哪里</li>
</ul>
<h3 id="Java虚拟机栈是什么"><a href="#Java虚拟机栈是什么" class="headerlink" title="Java虚拟机栈是什么"></a>Java虚拟机栈是什么</h3><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</p>
<img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705164722033.png" alt="image-20200705164722033" style="zoom:50%;" />

<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</p>
<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p>
<blockquote>
<p>局部变量，它是相比于成员变量来说的（或属性）</p>
<p>基本数据类型变量 VS 引用类型变量（类、数组、接口</p>
</blockquote>
<h3 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h3><p>栈是一种快速有效的分配存储方式，访问速度仅次于罹序计数器。JVM直接对Java栈的操作只有两个：</p>
<ul>
<li>每个方法执行，伴随着进栈（入栈、压栈）</li>
<li>执行结束后的出栈工作</li>
</ul>
<p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p>
<img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705165025382.png" alt="image-20200705165025382" style="zoom:50%;" />

<h3 id="开发中遇到哪些异常？"><a href="#开发中遇到哪些异常？" class="headerlink" title="开发中遇到哪些异常？"></a>开发中遇到哪些异常？</h3><p>栈中可能存在的异常</p>
<p>Java虚拟机规范允许Java栈的大小是动态的或者固定不变的。</p>
<p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError 异常。</p>
<p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 outofMemoryError 异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackErrorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(count++);</span><br><span class="line">        main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当栈深度达到9775的时候，就出现栈内存空间不足</p>
<h3 id="设置栈内存大小"><a href="#设置栈内存大小" class="headerlink" title="设置栈内存大小"></a>设置栈内存大小</h3><p>我们可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss256k</span><br></pre></td></tr></table></figure>

<p>在设置-Xss256k后栈的深度为2222</p>
<h2 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h2><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。</p>
<p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p>
<p>栈帧是一个内存区块，是一个数据及，维系着方法执行过程中的各种数据信息。</p>
<h3 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h3><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。在这个线程上正在执行的每个方法都各自对应一个栈颜（Stack Frame）。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p>
<p>OOP的基本概念：类和对象</p>
<p>类中基本结构：field（属性、字段、域）、method</p>
<p>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。</p>
<p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（<strong>栈顶栈帧</strong>）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。</p>
<p>执行引擎运行的所有字节码指令只针对<strong>当前栈帧</strong>进行操作。</p>
<p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p>
<img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705203142545.png" alt="image-20200705203142545" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackFrameTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method01();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1的开始&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = method02();</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1的结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2的开始&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = method03();;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2的结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法3的开始&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">30</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法3的结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1的开始</span></span><br><span class="line"><span class="comment">//方法2的开始</span></span><br><span class="line"><span class="comment">//方法3的开始</span></span><br><span class="line"><span class="comment">//方法3的结束</span></span><br><span class="line"><span class="comment">//方法2的结束</span></span><br><span class="line"><span class="comment">//方法1的结束</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在idea的debug中可以看到栈信息</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705203916023.png" alt="image-20200705203916023"></p>
<h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><p>不同线程中所包含的栈帧是不允许相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧。</p>
<p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使前一个栈帧重新成为当前栈帧。</p>
<p>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</p>
<h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p>每个栈帧中存储者：</p>
<ul>
<li>局部变量表（Local Variables）</li>
<li>操作数栈（operand Stack）（或表达式栈）</li>
<li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705204836977.png" alt="image-20200705204836977"></p>
<p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p>
<img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705205443993.png" alt="image-20200705205443993" style="zoom:67%;" />

<h2 id="局部变量表（LocalVariableTable）"><a href="#局部变量表（LocalVariableTable）" class="headerlink" title="局部变量表（LocalVariableTable）"></a>局部变量表（LocalVariableTable）</h2><p>局部变量表：Local ，被称值为局部变量数组或本地变量表</p>
<p>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各种基本数据类型、对象引用（reference），以及returnAddress类型</p>
<p>由于局部变量是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。</p>
<p>局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p>
<p>使用idea的jclasslib工具，对已经编译过的类进行 查看，发现在main方法和clinit方法中都有一个Code，并且下面都有一个local variables，这里面就记录着你的局部变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210606165637392.png" alt="image-20210606165637392"></p>
<p>方法嵌套调用的次数是由站的大小决定，我们之前在修改虚拟机的栈的大小参数的时候看过。对于一个函数而言，它的参数和局部变量越多，使的局部变量表膨胀，它的栈帧就越大，以满足方法调用所需要传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数减少。</p>
<p>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</p>
<h3 id="关于Slot的理解"><a href="#关于Slot的理解" class="headerlink" title="关于Slot的理解"></a>关于Slot的理解</h3><p>参数值的存放总是在局部变量数组的index0开始，到数组长度减1的索引结束。</p>
<p>局部变量表，最基本的存储单元是slot（变量槽）局部变量表中存放<strong>编译器可知</strong>的各种基本数据类型（8种），引用类型（reference），returenAddress类型的变量。</p>
<p>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</p>
<p>byte、short、char在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。long和double则占据两个slot。</p>
<p><strong>这里可以解读一下为什么boolean类型没有大小</strong></p>
<p>boolean类型中0表示false，非0表示true，boolean类型的具体大小要看虚拟机配置，大部门虚拟机的slot为32位，所以部门书籍就基本上认为32位。</p>
<p><strong>但是boolea类型为什么不和byte、short这种类型一下，在最开始就确定空间大小呢？</strong></p>
<p>JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。</p>
<p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上。</p>
<p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如long或double 类型变量）</p>
<p><strong>如果当前帧是由构造方法或者实例方法创建的</strong>，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排序。</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210612213858924.png" alt="image-20210612213858924" style="zoom:50%;" />

<p>在使用jclasslib中查看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isSuccess = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">22</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210612214411763.png" alt="image-20210612214411763"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210612214452063.png" alt="image-20210612214452063"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210612214459423.png" alt="image-20210612214459423"></p>
<h3 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a>Slot的重复利用</h3><p>栈帧中的局部变量表中的槽位是可以重复使用的，如果一个局部变量过了期作用域，那么在其作用域之后声明的新的局部变量就很有可能会复用过期的局部变量的槽位，从而达到节省资源的目的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;线程名：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; food:&quot;</span>+food++);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       Long d = <span class="number">2L</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>最初我们看到这样的代码，会认为局部变量最大槽位为1+2=3，但是其实并不是。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210612215657103.png" alt="image-20210612215657103"></p>
<p>我们看到整个程序字节码长度为71，i的变量在长度为61的时候已经结束了，然后变量d是从70的位置开始，那么这个使用d就会利用i的变量槽，造成其局部变量最大槽数为2</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210612215912296.png" alt="image-20210612215912296"></p>
<h3 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h3><ul>
<li>变量的分类：<ul>
<li>按数据类型分：基本数据类型、引用数据类型</li>
<li>按类中声明的位置分：成员变量（类变量，实例变量）、局部变量<ul>
<li>类变量：linking的paper阶段，给类变量默认赋值，init阶段给类变量显示赋值即静态代码块</li>
<li>实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值</li>
<li>局部变量：在使用前必须进行显式赋值，不然编译不通过。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p>
<p>我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</p>
<p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p>
<p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p>
<p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p>
<h2 id="操作数栈（Operand-Stack）"><a href="#操作数栈（Operand-Stack）" class="headerlink" title="操作数栈（Operand Stack）"></a>操作数栈（Operand Stack）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - in - First - out）的操作数栈，也可以称为表达式栈（Expression Stack）。</p>
<p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈和 出栈</p>
<ul>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li>
<li>比如：执行复制、交换、求和等操作</li>
</ul>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706090833697.png" alt="image-20200706090833697"></p>
<p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</p>
<p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。</p>
<p>这个时候数组是有长度的，因为数组一旦创建，那么就是不可变的</p>
<p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为maxstack的值。</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210613090759898.png" alt="image-20210613090759898" style="zoom:67%;" />



<p>栈中的任何一个元素都是可以任意的Java数据类型</p>
<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈单位深度</li>
</ul>
<p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</p>
<p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。|</p>
<p>另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p>
<h3 id="代码追踪"><a href="#代码追踪" class="headerlink" title="代码追踪"></a>代码追踪</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">33000000</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b + d + e;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">getRun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210613092641205.png" alt="image-20210613092641205" style="zoom: 67%;" />





<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210613092909503.png" alt="image-20210613092909503" style="zoom:67%;" />

<p>run方法执行结束后，return这个返回值，当前栈帧结束。</p>
<p>i++和++i的区别，（字节码指令的时候）</p>
<h3 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h3><p>栈顶缓存技术：TOp of Stack Cashing</p>
<p>前面提过，基于栈式架构的虚拟机所使用的零地址指定更加紧凑，但是完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也意味着将需要更多的指令分派（instruction dispatch）次数和内存读写次数。</p>
<p> 由于操作数是存储在内存中的，因此频繁的执行内存读写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（TOS， Top-of-stack Cashing）技术，将栈顶元素全部缓存在物理cpu的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率。</p>
<p>期存器：指令更少，执行速度快</p>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>动态链接： Dynamic Linking</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706100311886.png" alt="image-20200706100311886"></p>
<p>动态链接、方法返回地址、附加信息：有些地方被称为栈帧数据区</p>
<p>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking） 。比如：inbokedynamic指令</p>
<p>在java源文件被翻译到字节码文件中时，所有的变量和方法引用都作为符号引用保存到class文件的常量池中</p>
<p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> e = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">33000000</span>;</span><br><span class="line">        <span class="keyword">int</span> c = a + b + d + e;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">getRun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = run();</span><br><span class="line">        a = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>符号引用：编译的时候就确定的，对应字节码文件中的字节码指令</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210613113135209.png" alt="image-20210613113135209"></p>
<p>像上面的那个：在符号应用阶段只是说这里调用了#3（#3的信息存储在常量池中），然后在运行时如果这个方法进入了栈中，那么这个时候jvm就会到到运行时常量池（运行时常量池会在字节码文件加载到内存中产生，也就是运行时就产生了运行时常量池）中寻找#3，把这样最开始的一个符号引用转为直接引用（内存地址），</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210613113458333.png" alt="image-20210613113458333"></p>
<p>然后这样就建立了一个真正的调用链接</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706101251847.png" alt="image-20200706101251847"></p>
<p><strong>为什么需要运行时常量池？</strong></p>
<p>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间</p>
<p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p>
<h2 id="方法调用：解析与分配"><a href="#方法调用：解析与分配" class="headerlink" title="方法调用：解析与分配"></a>方法调用：解析与分配</h2><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期克制，且运行期保持不变时，这种情况下降调用方法的符号引用转换为直接引用的过程称之为静态链接</p>
<h4 id="动态链接-1"><a href="#动态链接-1" class="headerlink" title="动态链接"></a>动态链接</h4><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接</p>
<h3 id="绑定机制"><a href="#绑定机制" class="headerlink" title="绑定机制"></a>绑定机制</h3><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p>
<h4 id="早期绑定"><a href="#早期绑定" class="headerlink" title="早期绑定"></a>早期绑定</h4><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用</p>
<h4 id="晚期绑定"><a href="#晚期绑定" class="headerlink" title="晚期绑定"></a>晚期绑定</h4><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定</p>
<h3 id="早晚期绑定的发展历史"><a href="#早晚期绑定的发展历史" class="headerlink" title="早晚期绑定的发展历史"></a>早晚期绑定的发展历史</h3><p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特悄，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p>
<p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p>
<h3 id="虚方法和非虚方法"><a href="#虚方法和非虚方法" class="headerlink" title="虚方法和非虚方法"></a>虚方法和非虚方法</h3><ul>
<li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li>
<li>静态方法、私有方法、fina1方法、实例构造器、父类方法都是非虚方法。</li>
<li>其他方法称为虚方法。</li>
</ul>
<p>子类对象的多态的使用前提</p>
<ul>
<li>类的继承或实现关系</li>
<li>方法的重写</li>
</ul>
<p>虚拟机中提供了以下几条方法调用指令</p>
<p> <strong>普通调用指令：</strong></p>
<ul>
<li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li>
<li>invokespecial：调用方法、私有及父类方法，解析阶段确定唯一方法版本</li>
<li>invokevirtual：调用所有虚方法</li>
<li>invokeinterface：调用接口方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> <span class="keyword">extends</span> <span class="title">Test3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210613154949638.png" alt="image-20210613154949638"></p>
<h4 id="动态调用指令："><a href="#动态调用指令：" class="headerlink" title="动态调用指令："></a>动态调用指令：</h4><ul>
<li>invokedynamic：动态解析出需要调用的方法，然后执行</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（fina1修饰的除外，这个是历史遗留问题）称为虚方法。</p>
<h3 id="invokednamic指令"><a href="#invokednamic指令" class="headerlink" title="invokednamic指令"></a>invokednamic指令</h3><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现动态类型语言支持而做的一种改进（拉姆达表达式）。</p>
<p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</p>
<p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p>
<h3 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h3><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p>
<p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p>
<blockquote>
<p>Java：String info = “mogu blog”; (Java是静态类型语言的，会先编译就进行类型检查)</p>
<p>JS：var name = “shkstart”; var name = 10; （运行时才进行检查）</p>
</blockquote>
<h3 id="方法重写的本质"><a href="#方法重写的本质" class="headerlink" title="方法重写的本质"></a>方法重写的本质</h3><h4 id="Java-语言中方法重写的本质："><a href="#Java-语言中方法重写的本质：" class="headerlink" title="Java 语言中方法重写的本质："></a>Java 语言中方法重写的本质：</h4><ul>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.1ang.I1legalAccessError 异常。</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.1ang.AbstractMethodsrror异常。</li>
</ul>
<h4 id="IllegalAccessError介绍"><a href="#IllegalAccessError介绍" class="headerlink" title="IllegalAccessError介绍"></a>IllegalAccessError介绍</h4><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变</p>
<h3 id="方法的调用：虚方法表"><a href="#方法的调用：虚方法表" class="headerlink" title="方法的调用：虚方法表"></a>方法的调用：虚方法表</h3><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表 （virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</p>
<p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p>
<p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。 </p>
<p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p>
<img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706144954070.png" alt="image-20200706144954070" style="zoom: 80%;" />



<p>如上图所示：如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到Object的方法中。</p>
<h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p>
<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
<p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<p>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口</p>
<ul>
<li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li>
<li>在字节码指令中，返回指令包含ireturn（当返回值是boolean，byte，char，short和int类型时使用），lreturn（Long类型），freturn（Float类型），dreturn（Double类型），areturn。另外还有一个return指令声明为void的方法，实例初始化方法，类和接口的初始化方法使用。</li>
</ul>
<p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。</p>
<p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706154554604.png" alt="image-20200706154554604"></p>
<p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p>
<p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p>
<h2 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h2><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p>
<h2 id="栈的相关面试题"><a href="#栈的相关面试题" class="headerlink" title="栈的相关面试题"></a>栈的相关面试题</h2><ul>
<li>举例栈溢出的情况？（StackOverflowError）<ul>
<li>通过 -Xss设置栈的大小 ；OOM</li>
</ul>
</li>
<li>调整栈大小，就能保证不出现溢出么？<ul>
<li>不能保证不溢出</li>
</ul>
</li>
<li>分配的栈内存越大越好么？<ul>
<li>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li>
</ul>
</li>
<li>垃圾回收是否涉及到虚拟机栈？<ul>
<li>不会</li>
</ul>
</li>
<li>方法中定义的局部变量是否线程安全？<ul>
<li>具体问题具体分析</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题</span></span><br><span class="line"><span class="comment"> * 方法中定义局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> * 何为线程安全？</span></span><br><span class="line"><span class="comment"> *    如果只有一个线程才可以操作此数据，则必是线程安全的</span></span><br><span class="line"><span class="comment"> *    如果有多个线程操作，则此数据是共享数据，如果不考虑共享机制，则为线程不安全</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 陌溪</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-07-06-16:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s1的声明方式是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程内部创建的，属于局部变量</span></span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个也是线程不安全的，因为有返回值，有可能被其它的程序所调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">method04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stringBuilder 是线程不安全的，操作的是共享数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method02</span><span class="params">(StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同时并发的执行，会出现线程不安全的问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        method02(stringBuilder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// StringBuilder是线程安全的，但是String也可能线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一句话就是：如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</p>
<p>运行时数据区，是否存在Error和GC？</p>
<table>
<thead>
<tr>
<th align="center">运行时数据区</th>
<th align="center">是否存在Error</th>
<th align="center">是否存在GC</th>
</tr>
</thead>
<tbody><tr>
<td align="center">程序计数器</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">虚拟机栈</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">本地方法栈</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">方法区</td>
<td align="center">是（OOM）</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">堆</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
</tbody></table>
<h1 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h1><h2 id="什么是本地方法"><a href="#什么是本地方法" class="headerlink" title="什么是本地方法"></a>什么是本地方法</h2><p>简单地讲，一个Native Methodt是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “c” 告知c++编译器去调用一个c的函数。</p>
<p>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</p>
<p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p>
<p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/6_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/images/image-20200706164139252.png" alt="image-20200706164139252"></p>
<p>代码举例说明Native方法是如何编写的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IhaveNatives</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native1</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">Native2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="keyword">private</span> <span class="keyword">float</span> <span class="title">Native3</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Natives</span><span class="params">(<span class="keyword">int</span>[] ary)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外</p>
<h2 id="为什么使用Native-Method"><a href="#为什么使用Native-Method" class="headerlink" title="为什么使用Native Method"></a>为什么使用Native Method</h2><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p>
<h3 id="与Java环境的交互"><a href="#与Java环境的交互" class="headerlink" title="与Java环境的交互"></a>与Java环境的交互</h3><p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p>
<h3 id="与操作系统的交互"><a href="#与操作系统的交互" class="headerlink" title="与操作系统的交互"></a>与操作系统的交互</h3><p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p>
<h3 id="Sun’s-Java"><a href="#Sun’s-Java" class="headerlink" title="Sun’s Java"></a>Sun’s Java</h3><p>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setpriority（）方法是用Java实现的，但是它实现调用的是该类里的本地方法setpriorityo（）。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority（）ApI。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVw调用。</p>
<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p>
<h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>Java虚拟机栈用于管理Java方法的调用，而<strong>本地方法栈用于管理本地方法的调用</strong>。</p>
<p>本地方法栈，也是线程私有的。</p>
<p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p>
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li>
</ul>
<p>本地方法是使用C语言实现的。</p>
<p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p>
<img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/7_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/images/image-20200706174708418.png" alt="image-20200706174708418" style="zoom:67%;" />

<p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p>
<ul>
<li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</li>
<li>它甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存。</li>
</ul>
<p>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</p>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的核心概念"><a href="#堆的核心概念" class="headerlink" title="堆的核心概念"></a>堆的核心概念</h2><p>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706195127740.png" alt="image-20200706195127740"></p>
<p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p>
<p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</p>
<ul>
<li>堆内存的大小是可以调节的。</li>
</ul>
<p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p>
<p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</p>
<blockquote>
<p>-Xms10m：最小堆内存</p>
<p>-Xmx10m：最大堆内存</p>
</blockquote>
<p>下图就是使用：Java VisualVM查看堆空间的内容，通过 jdk bin提供的插件</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706200739392.png" alt="image-20200706200739392"></p>
<p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p>
<p>我要说的是：“几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。</p>
<ul>
<li>因为还有一些对象是在栈上分配的</li>
</ul>
<p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>
<p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p>
<ul>
<li>也就是触发了GC的时候，才会进行回收</li>
<li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li>
</ul>
<p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706201904057.png" alt="image-20200706201904057"></p>
<h3 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h3><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p>
<ul>
<li>Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区</li>
<li>Tenure generation space 养老区 Old/Tenure</li>
<li>Permanent Space永久区 Perm</li>
</ul>
<p>Java 8及之后堆内存逻辑上分为三部分：新生区养老区+元空间</p>
<ul>
<li>Young Generation Space新生区 Young/New 又被划分为Eden区和Survivor区</li>
<li>Tenure generation space 养老区 Old/Tenure</li>
<li>Meta Space 元空间 Meta</li>
</ul>
<p>约定：新生区 -&gt; 新生代 -&gt; 年轻代 、 养老区 -&gt; 老年区 -&gt; 老年代、 永久区 -&gt; 永久代</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706203419496.png" alt="image-20200706203419496"></p>
<p>堆空间内部结构，JDK1.8之前从永久代 替换成 元空间</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706203835403.png" alt="image-20200706203835403"></p>
<h2 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h2><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p>
<ul>
<li>“-Xms”用于表示堆区的起始内存，等价于-xx:InitialHeapSize</li>
<li>“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li>
</ul>
<p>一旦堆区中的内存大小超过“-xmx”所指定的最大内存时，将会抛出outofMemoryError异常。</p>
<p>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是<strong>为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong>。</p>
<p>默认情况下</p>
<ul>
<li>初始内存大小：物理电脑内存大小/64</li>
<li>最大内存大小：物理电脑内存大小/4</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory() / <span class="number">1204</span> / <span class="number">1204</span>;</span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms:&quot;</span> + totalMemory + <span class="string">&quot;M&quot;</span>);<span class="comment">//-Xms:177M</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx:&quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);<span class="comment">//-Xmx:3620M</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如何查看堆内存的内存分配情况</p>
<blockquote>
<p>jps  -&gt;  jstat -gc 进程id</p>
</blockquote>
<p>java在控制台查看对空间情况，在VM option中配置</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下图是配置-Xms10M -Xmx10M -XX:+PrintGCDetails  （最小堆空间10M最大堆空间10M 打印GC详细信息）的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory() / <span class="number">1204</span> / <span class="number">1204</span>;</span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms:&quot;</span> + totalMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx:&quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/jvm-img/image-20210614102952403.png" alt="image-20210614102952403"></p>
<h3 id="OutOfMemory举例"><a href="#OutOfMemory举例" class="headerlink" title="OutOfMemory举例"></a>OutOfMemory举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">           list.add(<span class="number">999</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment">   /</span></span><br></pre></td></tr></table></figure>

<p>然后设置启动参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms10m -Xmx:10m</span><br></pre></td></tr></table></figure>

<p>运行后，就出现OOM了，那么我们可以通过 VisualVM这个工具查看具体是什么参数造成的OOM</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706211652779.png" alt="image-20200706211652779"></p>
<h2 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h2><p>存储在JVM中的Java对象可以被划分为两类：</p>
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速<ul>
<li>生命周期短的，及时回收即可</li>
</ul>
</li>
<li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li>
</ul>
<p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p>
<p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707075847954.png" alt="image-20200707075847954"></p>
<p>下面这参数开发中一般不会调：</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707080154039.png" alt="image-20200707080154039"></p>
<ul>
<li>Eden：From：to -&gt; 8:1:1</li>
<li>新生代：老年代 - &gt; 1 : 2</li>
</ul>
<p>配置新生代与老年代在堆结构的占比。</p>
<ul>
<li>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</li>
<li>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</li>
</ul>
<blockquote>
<p>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优</p>
</blockquote>
<p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:SurvivorRatio”调整这个空间比例。比如-xx:SurvivorRatio=8</p>
<p>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p>
<p>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p>
<p>可以使用选项”-Xmn”设置新生代最大内存大小</p>
<p>这个参数一般使用默认值就可以了。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707084208115.png" alt="image-20200707084208115"></p>
<h2 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<ul>
<li>new的对象先放伊甸园区。此区有大小限制。</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li>
<li>然后将伊甸园中的剩余对象移动到幸存者0区。</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li>
<li>啥时候能去养老区呢？可以设置次数。默认是15次。</li>
<li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li>
<li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li>
</ul>
<p>可以设置参数：-Xx:MaxTenuringThreshold= N进行设置</p>
<h3 id="图解过程"><a href="#图解过程" class="headerlink" title="图解过程"></a>图解过程</h3><p>我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 YGC / Minor GC操作</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707084714886.png" alt="image-20200707084714886"></p>
<p>当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。</p>
<p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707085232646.png" alt="image-20200707085232646"></p>
<p>我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的<strong>对象的年龄达到15的时候</strong>，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象 晋升到 老年代中</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707085737207.png" alt="image-20200707085737207"></p>
<h3 id="思考：幸存区区满了后？"><a href="#思考：幸存区区满了后？" class="headerlink" title="思考：幸存区区满了后？"></a>思考：幸存区区满了后？</h3><p>特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作</p>
<p>如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">举例：以当兵为例，正常人的晋升可能是 ： 新兵 -&gt; 班长 -&gt; 排长 -&gt; 连长</span><br><span class="line"></span><br><span class="line">但是也有可能有些人因为做了非常大的贡献，直接从 新兵 -&gt; 排</span><br></pre></td></tr></table></figure>

<h3 id="对象分配的特殊情况"><a href="#对象分配的特殊情况" class="headerlink" title="对象分配的特殊情况"></a>对象分配的特殊情况</h3><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707091058346.png" alt="image-20200707091058346" style="zoom:67%;" />

<h3 id="代码演示对象分配过程"><a href="#代码演示对象分配过程" class="headerlink" title="代码演示对象分配过程"></a>代码演示对象分配过程</h3><p>我们不断的创建大对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapInstanceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> [] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="keyword">new</span> Random().nextInt(<span class="number">1024</span> * <span class="number">200</span>)];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayList&lt;HeapInstanceTest&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> HeapInstanceTest());</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后设置JVM参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms600m -Xmx600m</span><br></pre></td></tr></table></figure>

<p>然后cmd输入下面命令，打开VisualVM图形化界面</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">jvisualvm </span><br></pre></td></tr></table></figure>

<p>然后通过执行上面代码，通过VisualGC进行动态化查看</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.gif" alt="垃圾回收"></p>
<p>最终，在老年代和新生代都满了，就出现OOM</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.atguigu.java.chapter08.HeapInstanceTest.&lt;init&gt;(HeapInstanceTest.java:<span class="number">13</span>)</span><br><span class="line">	at com.atguigu.java.chapter08.HeapInstanceTest.main(HeapInstanceTest.java:<span class="number">17</span>)</span><br></pre></td></tr></table></figure>

<h3 id="常用的调优工具"><a href="#常用的调优工具" class="headerlink" title="常用的调优工具"></a>常用的调优工具</h3><ul>
<li>JDK命令行</li>
<li>Eclipse：Memory Analyzer Tool</li>
<li>Jconsole</li>
<li>Visual VM（实时监控 推荐~）</li>
<li>Jprofiler（推荐~）</li>
<li>Java Flight Recorder（实时监控）</li>
<li>GCViewer</li>
<li>GCEasy</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to</li>
<li>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</li>
<li>新生代采用复制算法的目的：是为了减少内碎片</li>
</ul>
<h2 id="Minor-GC，MajorGC、Full-GC"><a href="#Minor-GC，MajorGC、Full-GC" class="headerlink" title="Minor GC，MajorGC、Full GC"></a>Minor GC，MajorGC、Full GC</h2><ul>
<li>Minor GC：新生代的GC</li>
<li>Major GC：老年代的GC</li>
<li>Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集</li>
</ul>
<p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题</p>
<p>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</p>
<p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p>
<p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p>
<ul>
<li>新生代收集（MinorGC/YoungGC）：只是新生代的垃圾收集</li>
<li>老年代收集（MajorGC/o1dGC）：只是老年代的圾收集。<ul>
<li>目前，只有CMSGC会有单独收集老年代的行为。</li>
<li>注意，很多时候Major GC会和Fu11GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li>
</ul>
</li>
<li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul>
<li>目前，只有G1 GC会有这种行为</li>
</ul>
</li>
</ul>
<p>整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。</p>
<h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）</p>
<p>因为Java对象大多都具备 <strong>朝生夕灭</strong> 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p>
<p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p>
<blockquote>
<p>STW：stop the word</p>
</blockquote>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707095606813.png" alt="image-20200707095606813"></p>
<h3 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h3><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p>
<p>出现了MajorGc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p>
<ul>
<li>也就是在老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC</li>
</ul>
<p>Major GC的速度一般会比MinorGc慢1e倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了</p>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>触发Fu11GC执行的情况有如下五种：</p>
<ul>
<li>调用System.gc（）时，系统建议执行Fu11GC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>
<li>由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ul>
<p>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</p>
<h3 id="GC-举例"><a href="#GC-举例" class="headerlink" title="GC 举例"></a>GC 举例</h3><p>我们编写一个OOM的异常，因为我们在不断的创建字符串，是存放在元空间的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            String a = <span class="string">&quot;mogu blog&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.getStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置JVM启动参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<p>打印出的日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2038K-&gt;500K(2560K)] 2038K-&gt;797K(9728K), 0.3532002 secs] [Times: user=0.01 sys=0.00, real=0.36 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2108K-&gt;480K(2560K)] 2405K-&gt;1565K(9728K), 0.0014069 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 2288K-&gt;0K(2560K)] [ParOldGen: 6845K-&gt;5281K(7168K)] 9133K-&gt;5281K(9728K), [Metaspace: 3482K-&gt;3482K(1056768K)], 0.0058675 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 5281K-&gt;5281K(9728K), 0.0002857 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 5281K-&gt;5263K(7168K)] 5281K-&gt;5263K(9728K), [Metaspace: 3482K-&gt;3482K(1056768K)], 0.0058564 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 60K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0f138,0x00000000fff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 7168K, used 5263K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)</span><br><span class="line">  object space 7168K, 73% used [0x00000000ff600000,0x00000000ffb23cf0,0x00000000ffd00000)</span><br><span class="line"> Metaspace       used 3514K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 388K, capacity 390K, committed 512K, reserved 1048576K</span><br><span class="line">  </span><br><span class="line">  Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOfRange(Arrays.java:3664)</span><br><span class="line">	at java.lang.String.&lt;init&gt;(String.java:207)</span><br><span class="line">	at java.lang.StringBuilder.toString(StringBuilder.java:407)</span><br><span class="line">	at com.atguigu.java.chapter08.GCTest.main(GCTest.java:20)</span><br></pre></td></tr></table></figure>

<p>触发OOM的时候，一定是进行了一次Full GC，因为只有在老年代空间不足时候，才会爆出OOM异常</p>
<h2 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h2><p>为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新生代：有Eden、两块大小相同的survivor（又称为from/to，s0/s1）构成，to总为空。 老年代：存放新生代中经历多次GC仍然存活的对象。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707101511025.png" alt="image-20200707101511025"></p>
<p>其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707101543871.png" alt="image-20200707101543871"></p>
<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</p>
<p>对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置</p>
<p>针对不同年龄段的对象分配原则如下所示：</p>
<ul>
<li>优先分配到Eden<ul>
<li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li>
<li> 例如创建一个大于年轻代的数组，然后在加载进入内存的时候发现，年轻代的空间不够，那么这样的一个对象将直接进入老年代</li>
</ul>
</li>
<li>大对象直接分配到老年代<ul>
<li>尽量避免程序中出现过多的大对象</li>
</ul>
</li>
<li>长期存活的对象分配到老年代</li>
<li>动态对象年龄判断<ul>
<li>如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。</li>
</ul>
</li>
</ul>
<p>空间分配担保： -Xx:HandlePromotionFailure</p>
<ul>
<li>也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。</li>
</ul>
<h2 id="为对象分配内存：TLAB"><a href="#为对象分配内存：TLAB" class="headerlink" title="为对象分配内存：TLAB"></a>为对象分配内存：TLAB</h2><h3 id="问题：堆空间都是共享的么？"><a href="#问题：堆空间都是共享的么？" class="headerlink" title="问题：堆空间都是共享的么？"></a>问题：堆空间都是共享的么？</h3><p>不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占</p>
<h3 id="为什么有TLAB？"><a href="#为什么有TLAB？" class="headerlink" title="为什么有TLAB？"></a>为什么有TLAB？</h3><p>TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区</p>
<p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p>
<p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p>
<p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p>
<h3 id="什么是TLAB"><a href="#什么是TLAB" class="headerlink" title="什么是TLAB"></a>什么是TLAB</h3><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p>
<p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p>
<p>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707103547712.png" alt="image-20200707103547712"></p>
<p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</p>
<p>在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。</p>
<p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1，当然我们可以通过选项“-Xx:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</p>
<p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p>
<h3 id="TLAB分配过程"><a href="#TLAB分配过程" class="headerlink" title="TLAB分配过程"></a>TLAB分配过程</h3><p>对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707104253530.png" alt="image-20200707104253530"></p>
<h2 id="小结：堆空间的参数设置"><a href="#小结：堆空间的参数设置" class="headerlink" title="小结：堆空间的参数设置"></a>小结：堆空间的参数设置</h2><ul>
<li>-XX：+PrintFlagsInitial：查看所有的参数的默认初始值</li>
<li>-XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</li>
<li>-Xms：初始堆空间内存（默认为物理内存的1/64）</li>
<li>-Xmx：最大堆空间内存（默认为物理内存的1/4）</li>
<li>-Xmn：设置新生代的大小。（初始值及最大值）</li>
<li>-XX:NewRatio：配置新生代与老年代在堆结构的占比</li>
<li>-XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</li>
<li>-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</li>
<li>-XX：+PrintGCDetails：输出详细的GC处理日志<ul>
<li>打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc</li>
</ul>
</li>
<li>-XX:HandlePromotionFalilure：是否设置空间分配担保</li>
</ul>
<p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。I</p>
<ul>
<li>如果大于，则此次Minor GC是安全的</li>
<li>如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。<ul>
<li>如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</li>
<li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li>
<li>如果小于，则改为进行一次FullGC。</li>
<li>如果HandlePromotionFailure=false，则改为进行一次Ful1 Gc。</li>
</ul>
</li>
</ul>
<p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。</p>
<h2 id="堆是分配对象的唯一选择么？"><a href="#堆是分配对象的唯一选择么？" class="headerlink" title="堆是分配对象的唯一选择么？"></a>堆是分配对象的唯一选择么？</h2><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p>
<p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>
<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
<p>此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>
<p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p>
<p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>
</ul>
<h4 id="逃逸分析举例"><a href="#逃逸分析举例" class="headerlink" title="逃逸分析举例"></a>逃逸分析举例</h4><p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">my_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    V v = <span class="keyword">new</span> V();</span><br><span class="line">    <span class="comment">// use v</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    v = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要StringBuffer sb不发生逃逸，可以这样写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的逃逸分析代码举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EscapeAnalysis <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span> ? <span class="keyword">new</span> EscapeAnalysis():obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象的作用于仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EscapeAnalysis e = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EscapeAnalysis e = getInstance();</span><br><span class="line">        <span class="comment">// getInstance().XXX  发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p>
<p>如果使用的是较早的版本，开发人员则可以通过：</p>
<ul>
<li>选项“-xx：+DoEscapeAnalysis”显式开启逃逸分析</li>
<li>通过选项“-xx：+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li>
</ul>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>开发中能使用局部变量的，就不要使用在方法外定义。</p>
<p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<ul>
<li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li>
<li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li>
<li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li>
</ul>
<h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p>
<p>常见的栈上分配的场景</p>
<blockquote>
<p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p>
</blockquote>
<h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>我们通过举例来说明 开启逃逸分析 和 未开启逃逸分析时候的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackAllocation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        Thread.sleep(<span class="number">10000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 未发生逃逸</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置JVM参数，表示未开启逃逸分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<p>运行结果，同时还触发了GC操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 262144K-&gt;840K(305664K)] 262144K-&gt;848K(1005056K), 0.0015604 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 262984K-&gt;728K(305664K)] 262992K-&gt;744K(1005056K), 0.0021147 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 262872K-&gt;696K(305664K)] 262888K-&gt;712K(1005056K), 0.0024543 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 262840K-&gt;744K(305664K)] 262856K-&gt;760K(1005056K), 0.0022360 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 262888K-&gt;696K(305664K)] 262904K-&gt;712K(1005056K), 0.0021751 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 262840K-&gt;712K(348160K)] 262856K-&gt;728K(1047552K), 0.0016790 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 347848K-&gt;160K(348160K)] 347864K-&gt;848K(1047552K), 0.0015821 secs] [Times: user=0.01 sys=0.02, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 347296K-&gt;416K(348160K)] 347984K-&gt;1112K(1047552K), 0.0009592 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 347552K-&gt;416K(348160K)] 348248K-&gt;1120K(1047552K), 0.0011149 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 347552K-&gt;0K(347136K)] 348256K-&gt;1068K(1046528K), 0.0008883 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">花费的时间为：1044 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后查看内存的情况，发现有大量的User存储在堆中</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707203038615.png" alt="image-20200707203038615"></p>
<p>我们在开启逃逸分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<p>然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生GC操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">花费的时间为：7 ms</span><br></pre></td></tr></table></figure>

<p>在看内存情况，我们发现只有很少的User对象，说明User未发生逃逸，因为它存储在栈中，随着栈的销毁而消失</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707203441718.png" alt="image-20200707203441718"></p>
<h3 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h3><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p>
<p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p>
<p>例如下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hellis = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(hellis) &#123;</span><br><span class="line">        System.out.println(hellis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hellis = <span class="keyword">new</span> Object();</span><br><span class="line">	System.out.println(hellis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将其转换成字节码</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707205634266.png" alt="image-20200707205634266"></p>
<p>同步省略在加载进内存的时候进行，在我们进行编译的时候这样的synchronize同样会被转为字节码指令</p>
<h3 id="分离对象和标量替换"><a href="#分离对象和标量替换" class="headerlink" title="分离对象和标量替换"></a>分离对象和标量替换</h3><p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p>
<p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>
<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point point = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x&quot;</span> + point.x + <span class="string">&quot;;point.y&quot;</span> + point.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码，经过标量替换后，就会变成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x = &quot;</span> + x + <span class="string">&quot;; point.y=&quot;</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。 标量替换为栈上分配提供了很好的基础。</p>
<h3 id="代码优化之标量替换"><a href="#代码优化之标量替换" class="headerlink" title="代码优化之标量替换"></a>代码优化之标量替换</h3><p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span><br></pre></td></tr></table></figure>

<p>这里设置参数如下：</p>
<ul>
<li>参数-server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li>
<li>参数-XX:+DoEscapeAnalysis：启用逃逸分析</li>
<li>参数-Xmx10m：指定了堆空间最大为10MB</li>
<li>参数-XX:+PrintGC：将打印Gc日志</li>
<li>参数一xx：+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li>
</ul>
<h3 id="逃逸分析的不足"><a href="#逃逸分析的不足" class="headerlink" title="逃逸分析的不足"></a>逃逸分析的不足</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。</p>
<p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>
<p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JvM设计者的选择。据我所知，oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p>
<p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p>
<p>老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGc。</p>
<p>当GC发生在老年代时则被称为MajorGc或者FullGC。一般的，MinorGc的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>这次所讲述的是运行时数据区的最后一个部分</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708093918121.png" alt="image-20200708093918121"></p>
<p>从线程共享与否的角度来看</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708094507624.png" alt="image-20200708094507624"></p>
<p>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型应用就是数据库连接管理，以及会话管理</p>
<h2 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h2><p>下面就涉及了对象的访问定位</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708094747667.png" alt="image-20200708094747667"></p>
<ul>
<li>Person：存放在元空间，也可以说方法区</li>
<li>person：存放在Java栈的局部变量表中</li>
<li>new Person()：存放在Java堆中</li>
</ul>
<h2 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h2><p>《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</p>
<p>所以，方法区看作是一块独立于Java堆的内存空间。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708095853544.png" alt="image-20200708095853544"></p>
<p>方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象</p>
<ul>
<li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li>
<li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：ava.lang.OutofMemoryError：<strong>PermGen space</strong> 或者java.lang.OutOfMemoryError:<strong>Metaspace</strong><ul>
<li>加载大量的第三方的jar包</li>
<li>Tomcat部署的工程过多（30~50个）</li>
<li>大量动态的生成反射类</li>
</ul>
</li>
<li>关闭JVM就会释放这个区域的内存。</li>
</ul>
<h3 id="HotSpot中方法区的演进"><a href="#HotSpot中方法区的演进" class="headerlink" title="HotSpot中方法区的演进"></a>HotSpot中方法区的演进</h3><p>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。</p>
<ul>
<li>JDK 1.8后，元空间存放在堆外内存中</li>
</ul>
<p>本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit / IBM J9 中不存在永久代的概念。</p>
<p>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易oom（超过-XX:MaxPermsize上限）</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708102919149.png" alt="image-20200708102919149"></p>
<p>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708103055914.png" alt="image-20200708103055914"></p>
<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存</p>
<p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p>
<p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</p>
<h2 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h2><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p>
<h3 id="jdk7及以前"><a href="#jdk7及以前" class="headerlink" title="jdk7及以前"></a>jdk7及以前</h3><ul>
<li>通过-xx:Permsize来设置永久代初始分配空间。默认值是20.75M</li>
<li>-XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li>
<li>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。</li>
</ul>
<h3 id="JDK8以后"><a href="#JDK8以后" class="headerlink" title="JDK8以后"></a>JDK8以后</h3><p>元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定</p>
<p>默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。</p>
<p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p>
<p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Ful1GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p>
<p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Ful1GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetheadOOMTest</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MetheadOOMTest metheadOOMTest = <span class="keyword">new</span> MetheadOOMTest();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">                classWriter.visit(Opcodes.V1_8,Opcodes.ACC_PUBLIC,<span class="string">&quot;class&quot;</span>+i,<span class="string">&quot;com.lvxiaoyi&quot;</span>,<span class="string">&quot;java/lang/Object&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = classWriter.toByteArray();</span><br><span class="line">                metheadOOMTest.defineClass(<span class="string">&quot;class&quot;</span>+i,bytes,<span class="number">0</span>,bytes.length);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError classFormatError) &#123;</span><br><span class="line">            classFormatError.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:MaxMetaspaceSize=10M</span><br></pre></td></tr></table></figure>



<h3 id="如何解决这些OOM"><a href="#如何解决这些OOM" class="headerlink" title="如何解决这些OOM"></a>如何解决这些OOM</h3><ul>
<li>要解决ooM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）<ul>
<li>内存泄漏就是 有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li>
</ul>
</li>
<li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li>
<li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li>
</ul>
<h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708161728320.png" alt="image-20200708161728320"></p>
<p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708161856504.png" alt="image-20200708161856504"></p>
<h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVm必须在方法区中存储以下类型信息：</p>
<ul>
<li>这个类型的完整有效名称（全名=包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li>
<li>这个类型的修饰符（public，abstract，final的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
<h3 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h3><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p>
<p>域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p>
<h3 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h3><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型（或void）</li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li>
<li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li>
<li>异常表（abstract和native方法除外）</li>
</ul>
<blockquote>
<p>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</p>
</blockquote>
<h3 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h3><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p>
<p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码所示，即使我们把order设置为null，也不会出现空指针异常</p>
<h3 id="全局常量"><a href="#全局常量" class="headerlink" title="全局常量"></a>全局常量</h3><p>全局常量就是使用 static final 进行修饰</p>
<p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</p>
<p>在查看order的编译后的指令吗后发现，number在编译的时候已经赋予初值了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Classfile /D:/arithmetic/test/out/production/test/com/lvxiaoyi/methead/Order.class</span><br><span class="line">  Last modified 2021-6-15; size 623 bytes</span><br><span class="line">  MD5 checksum eaafef4c8bbba86d1d9d665541359b78</span><br><span class="line">  Compiled from &quot;MethodAreaTest.java&quot;</span><br><span class="line">class com.lvxiaoyi.methead.Order</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #7.#24         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #27            // hello!</span><br><span class="line">   #4 = Methodref          #28.#29        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Fieldref           #6.#30         // com/lvxiaoyi/methead/Order.count:I</span><br><span class="line">   #6 = Class              #31            // com/lvxiaoyi/methead/Order</span><br><span class="line">   #7 = Class              #32            // java/lang/Object</span><br><span class="line">   #8 = Utf8               count</span><br><span class="line">   #9 = Utf8               I</span><br><span class="line">  #10 = Utf8               number</span><br><span class="line">  #11 = Utf8               ConstantValue</span><br><span class="line">  #12 = Integer            2</span><br><span class="line">  #13 = Utf8               &lt;init&gt;</span><br><span class="line">  #14 = Utf8               ()V</span><br><span class="line">  #15 = Utf8               Code</span><br><span class="line">  #16 = Utf8               LineNumberTable</span><br><span class="line">  #17 = Utf8               LocalVariableTable</span><br><span class="line">  #18 = Utf8               this</span><br><span class="line">  #19 = Utf8               Lcom/lvxiaoyi/methead/Order;</span><br><span class="line">  #20 = Utf8               hello</span><br><span class="line">  #21 = Utf8               &lt;clinit&gt;</span><br><span class="line">  #22 = Utf8               SourceFile</span><br><span class="line">  #23 = Utf8               MethodAreaTest.java</span><br><span class="line">  #24 = NameAndType        #13:#14        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #25 = Class              #33            // java/lang/System</span><br><span class="line">  #26 = NameAndType        #34:#35        // out:Ljava/io/PrintStream;</span><br><span class="line">  #27 = Utf8               hello!</span><br><span class="line">  #28 = Class              #36            // java/io/PrintStream</span><br><span class="line">  #29 = NameAndType        #37:#38        // println:(Ljava/lang/String;)V</span><br><span class="line">  #30 = NameAndType        #8:#9          // count:I</span><br><span class="line">  #31 = Utf8               com/lvxiaoyi/methead/Order</span><br><span class="line">  #32 = Utf8               java/lang/Object</span><br><span class="line">  #33 = Utf8               java/lang/System</span><br><span class="line">  #34 = Utf8               out</span><br><span class="line">  #35 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #36 = Utf8               java/io/PrintStream</span><br><span class="line">  #37 = Utf8               println</span><br><span class="line">  #38 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public static int count;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line">  public static final int number;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: int 2</span><br><span class="line"></span><br><span class="line">  com.lvxiaoyi.methead.Order();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags:</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 14: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/lvxiaoyi/methead/Order;</span><br><span class="line"></span><br><span class="line">  public static void hello();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=0, args_size=0</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 18: 0</span><br><span class="line">        line 19: 8</span><br><span class="line"></span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=0, args_size=0</span><br><span class="line">         0: iconst_1</span><br><span class="line">         1: putstatic     #5                  // Field count:I</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 15: 0</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;MethodAreaTest.java&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="运行时常量池-VS-常量池"><a href="#运行时常量池-VS-常量池" class="headerlink" title="运行时常量池 VS 常量池"></a>运行时常量池 VS 常量池</h3><p>运行时常量池，就是运行时常量池</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708171151384.png" alt="image-20200708171151384"></p>
<ul>
<li>方法区，内部包含了运行时常量池</li>
<li>字节码文件，内部包含了常量池</li>
<li>要弄清楚方法区，需要理解清楚C1assFile，因为加载类的信息都在方法区。</li>
<li>要弄清楚方法区的运行时常量池，需要理解清楚classFile中的常量池。</li>
</ul>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708172357052.png" alt="image-20200708172357052"></p>
<p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用</p>
<h4 id="为什么需要常量池"><a href="#为什么需要常量池" class="headerlink" title="为什么需要常量池"></a>为什么需要常量池</h4><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。r在动态链接的时候会用到运行时常量池，之前有介绍。</p>
<p>比如：如下的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</p>
<h4 id="常量池中有什么"><a href="#常量池中有什么" class="headerlink" title="常量池中有什么"></a>常量池中有什么</h4><ul>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ul>
<p>例如下面这段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将会被翻译成如下字节码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new #2  </span><br><span class="line">dup</span><br><span class="line">invokespecial</span><br></pre></td></tr></table></figure>

<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p>
<p>常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p>
<p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p>
<p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p>
<p>运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。</p>
<p>运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。</p>
<p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛outofMemoryError异常。</p>
<h2 id="方法区使用举例"><a href="#方法区使用举例" class="headerlink" title="方法区使用举例"></a>方法区使用举例</h2><p>如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MethodAreaDemo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        int x = 500;</span><br><span class="line">        int y = 100;</span><br><span class="line">        int a = x / y;</span><br><span class="line">        int b = 50;</span><br><span class="line">        System.out.println(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码执行过程展示</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708204750374.png" alt="image-20200708204750374"></p>
<p>首先现将操作数500放入到操作数栈中</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708204953552.png" alt="image-20200708204953552"></p>
<p>然后存储到局部变量表中</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708205029376.png" alt="image-20200708205029376"></p>
<p>然后重复一次，把100放入局部变量表中，最后再将变量表中的500 和 100 取出，进行操作</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708205221737.png" alt="image-20200708205221737"></p>
<p>将500 和 100 进行一个除法运算，在把结果入栈</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708205413721.png" alt="image-20200708205413721"></p>
<p>在最后就是输出流，需要调用运行时常量池的常量</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708205708057.png" alt="image-20200708205708057"></p>
<p>最后调用invokevirtual（虚方法调用），然后返回</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708205909176.png" alt="image-20200708205909176"></p>
<p>返回时</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708210540696.png" alt="image-20200708210540696"></p>
<p>程序计数器始终计算的都是当前代码运行的位置，目的是为了方便记录 方法调用后能够正常返回，或者是进行了CPU切换后，也能回来到原来的代码进行执行。</p>
<h2 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h2><p>首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</p>
<p>Hotspot中方法区的变化：</p>
<table>
<thead>
<tr>
<th>JDK1.6及以前</th>
<th>有永久代，静态变量存储在永久代上</th>
</tr>
</thead>
<tbody><tr>
<td>JDK1.7</td>
<td>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</td>
</tr>
<tr>
<td>JDK1.8</td>
<td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td>
</tr>
</tbody></table>
<p>JDK6的时候</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708211541300.png" alt="image-20200708211541300"></p>
<p>JDK7的时候</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708211609911.png" alt="image-20200708211609911"></p>
<p>JDK8的时候，元空间大小只受物理内存影响</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708211637952.png" alt="image-20200708211637952"></p>
<h3 id="为什么永久代要被元空间替代？"><a href="#为什么永久代要被元空间替代？" class="headerlink" title="为什么永久代要被元空间替代？"></a>为什么永久代要被元空间替代？</h3><p>JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代</p>
<p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</p>
<p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，这项改动是很有必要的，原因有：</p>
<ul>
<li>为永久代设置空间大小是很难确定的。</li>
</ul>
<p>在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p>
<p>“Exception in thread‘dubbo client x.x connector’java.lang.OutOfMemoryError:PermGen space”</p>
<p>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</p>
<ul>
<li>对永久代进行调优是很困难的。<ul>
<li>主要是为了降低Full GC</li>
</ul>
</li>
</ul>
<p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏</p>
<p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不在使用的类型</p>
<h3 id="StringTable为什么要调整位置"><a href="#StringTable为什么要调整位置" class="headerlink" title="StringTable为什么要调整位置"></a>StringTable为什么要调整位置</h3><p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而ful1gc是老年代的空间不足、永久代不足时才会触发。</p>
<p>这就导致stringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p>
<h3 id="静态变量存放在那里？"><a href="#静态变量存放在那里？" class="headerlink" title="静态变量存放在那里？"></a>静态变量存放在那里？</h3><p>静态引用对应的对象实体始终都存在堆空间</p>
<p>可以使用 jhsdb.ext，需要在jdk9的时候才引入的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticObjTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">      <span class="keyword">static</span> ObjectHolder objectHolder =  <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">        ObjectHolder instanceObj =  <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             ObjectHolder localObj =  <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">            System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>staticobj随着Test的类型信息存放在方法区，instanceobj随着Test的对象实例存放在Java堆，localobject则是存放在foo（）方法栈帧的局部变量表中。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708215025527.png" alt="image-20200708215025527"></p>
<p>测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：只要是对象实例必然会在Java堆中分配。</p>
<p>接着，找到了一个引用该staticobj对象的地方，是在一个java.1ang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708215218078.png" alt="image-20200708215218078"></p>
<p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射class对象存放在一起，存储于Java堆之中，从我们的实验中也明确验证了这一点</p>
<h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。</p>
<p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>
<p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p>
<p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
<p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。</li>
<li>该类对应的java.lang.C1ass对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。I Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息</li>
<li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li>
</ul>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708220303243.png" alt="image-20200708220303243"></p>
<h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><p>百度 三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</p>
<p>蚂蚁金服： Java8的内存分代改进 JVM内存分哪几个区，每个区的作用是什么？ 一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？ 二面：Eden和survior的比例分配</p>
<p>小米： jvm内存分区，为什么要有新生代和老年代</p>
<p>字节跳动： 二面：Java的内存分区 二面：讲讲vm运行时数据库区 什么时候对象会进入老年代？</p>
<p>京东： JVM的内存结构，Eden和Survivor比例。 JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</p>
<p>天猫： 一面：Jvm内存模型以及分区，需要详细到每个区放什么。 一面：JVM的内存模型，Java8做了什么改</p>
<p>拼多多： JVM内存分哪几个区，每个区的作用是什么？</p>
<p>美团： java内存分配 jvm的永久代中会发生垃圾回收吗？ 一面：jvm内存分区，为什么要有新生代和老年代？</p>
<h1 id="对象实例化内存布局与访问定位"><a href="#对象实例化内存布局与访问定位" class="headerlink" title="对象实例化内存布局与访问定位"></a>对象实例化内存布局与访问定位</h1><h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ul>
<li>对象在JVM中是怎么存储的？</li>
<li>对象头信息里面有哪些东西？</li>
<li>Java对象头有什么？</li>
</ul>
<p>从对象创建的方式 和 步骤开始说</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/images/image-20200709095356247.png" alt="image-20200709095356247"></p>
<h3 id="对象创建方式"><a href="#对象创建方式" class="headerlink" title="对象创建方式"></a>对象创建方式</h3><ul>
<li>new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法</li>
<li>Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器</li>
<li>Constructor的newInstance(XXX)：反射的方式，可以调用空参的，或者带参的构造器</li>
<li>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone接口</li>
<li>使用序列化：序列化一般用于Socket的网络传输</li>
<li>第三方库 Objenesis</li>
</ul>
<h3 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h3><h4 id="判断对象对应的类是否加载、链接、初始化"><a href="#判断对象对应的类是否加载、链接、初始化" class="headerlink" title="判断对象对应的类是否加载、链接、初始化"></a>判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</p>
<h4 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h4><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p>
<ul>
<li>如果内存规整：指针碰撞</li>
<li>如果内存不规整<ul>
<li>虚拟表需要维护一个列表</li>
<li>空闲列表分配</li>
</ul>
</li>
</ul>
<p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</p>
<p>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</p>
<p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</p>
<p>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<h4 id="处理并发问题"><a href="#处理并发问题" class="headerlink" title="处理并发问题"></a>处理并发问题</h4><ul>
<li>采用CAS配上失败重试保证更新的原子性</li>
<li>每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）<ul>
<li>在Eden区给每个线程分配一块区域</li>
</ul>
</li>
</ul>
<h3 id="初始化分配到的内存"><a href="#初始化分配到的内存" class="headerlink" title="初始化分配到的内存"></a>初始化分配到的内存</h3><p>给对象属性赋值的操作</p>
<ul>
<li>属性的默认初始化</li>
<li>显示初始化</li>
<li>代码块中的初始化</li>
<li>构造器初始化</li>
<li>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</li>
</ul>
<h3 id="设置对象的对象头"><a href="#设置对象的对象头" class="headerlink" title="设置对象的对象头"></a>设置对象的对象头</h3><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p>
<h3 id="执行init方法进行初始化"><a href="#执行init方法进行初始化" class="headerlink" title="执行init方法进行初始化"></a>执行init方法进行初始化</h3><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</p>
<p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p>
<h3 id="对象实例化的过程"><a href="#对象实例化的过程" class="headerlink" title="对象实例化的过程"></a>对象实例化的过程</h3><ul>
<li>加载类元信息</li>
<li>为对象分配内存</li>
<li>处理并发问题</li>
<li>属性的默认初始化（零值初始化）</li>
<li>设置对象头信息</li>
<li>属性的显示初始化、代码块中初始化、构造器中初始化</li>
</ul>
<h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/images/image-20200709151033237.png" alt="image-20200709151033237"></p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头包含了两部分，分别是 运行时元数据（Mark Word）和 类型指针</p>
<blockquote>
<p>如果是数组，还需要记录数组的长度</p>
</blockquote>
<h4 id="运行时元数据"><a href="#运行时元数据" class="headerlink" title="运行时元数据"></a>运行时元数据</h4><ul>
<li>哈希值（HashCode）</li>
<li>GC分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程ID</li>
<li>翩向时间戳</li>
</ul>
<h4 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h4><p>指向类元数据InstanceKlass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息</p>
<h3 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/images/image-20200709152801713.png" alt="image-20200709152801713"></p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/images/image-20200709164149920.png" alt="image-20200709164149920"></p>
<h3 id="对象访问的两种方式"><a href="#对象访问的两种方式" class="headerlink" title="对象访问的两种方式"></a>对象访问的两种方式</h3><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/images/image-20200709164342002.png" alt="image-20200709164342002"></p>
<p>句柄访问就是说栈的局部变量表中，记录的对象的引用，然后在堆空间中开辟了一块空间，也就是句柄池</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</p>
<h4 id="直接指针（HotSpot采用）"><a href="#直接指针（HotSpot采用）" class="headerlink" title="直接指针（HotSpot采用）"></a>直接指针（HotSpot采用）</h4><p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/images/image-20200709164350466.png" alt="image-20200709164350466"></p>
<p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的</p>
<h1 id="直接内存-Direct-Memory"><a href="#直接内存-Direct-Memory" class="headerlink" title="直接内存 Direct Memory"></a>直接内存 Direct Memory</h1><p>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</p>
<p>直接内存是在Java堆外的、直接向系统申请的内存区间。</p>
<p>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</p>
<p>通常，访问直接内存的速度会优于Java堆。即读写性能高。</p>
<ul>
<li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li>
<li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li>
</ul>
<p>使用下列代码，直接分配本地内存空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int BUFFER = 1024*1024*1024; // 1GB</span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);</span><br></pre></td></tr></table></figure>

<h2 id="非直接缓存区和缓存区"><a href="#非直接缓存区和缓存区" class="headerlink" title="非直接缓存区和缓存区"></a>非直接缓存区和缓存区</h2><p>原来采用BIO的架构，我们需要从用户态切换成内核态</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/11_%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/images/image-20200709170907611.png" alt="image-20200709170907611"></p>
<p>NIO的方式使用了缓存区的概念</p>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>也可能导致outofMemoryError异常</p>
<p>由于直接内存在Java堆外，因此它的大小不会直接受限于-xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。 缺点</p>
<ul>
<li>分配回收成本较高</li>
<li>不受JVM内存回收管理</li>
</ul>
<p>直接内存大小可以通过MaxDirectMemorySize设置</p>
<p>如果不指定，默认与堆的最大值-xmx参数值一致</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/11_%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/images/image-20200709230647277.png" alt="image-20200709230647277"></p>
<h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1><h2 id="执行引擎概述"><a href="#执行引擎概述" class="headerlink" title="执行引擎概述"></a>执行引擎概述</h2><p>执行引擎属于JVM的下层，里面包括 解释器、及时编译器、垃圾回收器</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710080707873.png" alt="image-20200710080707873"></p>
<p>执行引擎是Java虚拟机核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p>
<p>JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710081118053.png" alt="image-20200710081118053"></p>
<p>那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710081259276.png" alt="image-20200710081259276"></p>
<h3 id="执行引擎的工作流程"><a href="#执行引擎的工作流程" class="headerlink" title="执行引擎的工作流程"></a>执行引擎的工作流程</h3><ul>
<li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li>
<li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li>
<li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li>
</ul>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710081627217.png" alt="image-20200710081627217"></p>
<p>从外观上来看，所有的Java虚拟机的执行引擎输入，输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程。</p>
<h2 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h2><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤</p>
<ul>
<li>前面橙色部分是生成字节码文件的过程，和JVM无关</li>
<li>后面蓝色和绿色才是JVM需要考虑的过程</li>
</ul>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710082141643.png" alt="image-20200710082141643"></p>
<p>Java代码编译是由Java源码编译器来完成，流程图如下所示：</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710082433146.png" alt="image-20200710082433146"></p>
<p>Java字节码的执行是由JVM执行引擎来完成，流程图 如下所示</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710083036258.png" alt="image-20200710083036258"></p>
<p>我们用一个总的图，来说说 解释器和编译器</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710083656277.png" alt="image-20200710083656277"></p>
<h3 id="什么是解释器（Interpreter）"><a href="#什么是解释器（Interpreter）" class="headerlink" title="什么是解释器（Interpreter）"></a>什么是解释器（Interpreter）</h3><p>当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p>
<h3 id="什么是JIT编译器"><a href="#什么是JIT编译器" class="headerlink" title="什么是JIT编译器"></a>什么是JIT编译器</h3><p>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p>
<h3 id="为什么Java是半编译半解释型语言"><a href="#为什么Java是半编译半解释型语言" class="headerlink" title="为什么Java是半编译半解释型语言"></a>为什么Java是半编译半解释型语言</h3><p>JDK1.e时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p>
<p>翻译成本地代码后，就可以做一个缓存操作，存储在方法区中</p>
<h2 id="机器码、指令、汇编语言"><a href="#机器码、指令、汇编语言" class="headerlink" title="机器码、指令、汇编语言"></a>机器码、指令、汇编语言</h2><h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><p>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</p>
<p>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</p>
<p>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</p>
<p>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</p>
<p>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</p>
<p>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</p>
<h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。 如常见的</p>
<ul>
<li>x86指令集，对应的是x86架构的平台</li>
<li>ARM指令集，对应的是ARM架构的平台</li>
</ul>
<h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><p>由于指令的可读性还是太差，于是人们又发明了汇编语言。</p>
<p>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbo1）或标号（Labe1）代替指令或操作数的地址。在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</p>
<blockquote>
<p>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。</p>
</blockquote>
<h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。</p>
<p>高级语言比机器语言、汇编语言更接近人的语言当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710085323733.png" alt="image-20200710085323733"></p>
<p>高级语言也不是直接翻译成 机器指令，而是翻译成汇编语言吗，如下面说的C和C++</p>
<h3 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h3><p>编译过程又可以分成两个阶段：编译和汇编。</p>
<p>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p>
<p>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710085553258.png" alt="image-20200710085553258"></p>
<h3 id="字节码-1"><a href="#字节码-1" class="headerlink" title="字节码"></a>字节码</h3><p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p>
<p>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</p>
<p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</p>
<ul>
<li>字节码典型的应用为：Java bytecode</li>
</ul>
<h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710090203674.png" alt="image-20200710090203674"></p>
<p>为什么Java源文件不直接翻译成JMV，而是翻译成字节码文件？可能是因为直接翻译的代码是比较大的</p>
<p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p>
<p>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p>
<h3 id="解释器分类"><a href="#解释器分类" class="headerlink" title="解释器分类"></a>解释器分类</h3><p>在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p>
<p>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</p>
<p>而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</p>
<p>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。</p>
<ul>
<li>Interpreter模块：实现了解释器的核心功能</li>
<li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li>
</ul>
<h3 id="现状-1"><a href="#现状-1" class="headerlink" title="现状"></a>现状</h3><p>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Per1、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。</p>
<p>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</p>
<p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p>
<h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><h3 id="Java代码的执行分类"><a href="#Java代码的执行分类" class="headerlink" title="Java代码的执行分类"></a>Java代码的执行分类</h3><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p>
<p>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</p>
<p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p>
<p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++ 程序一较高下的地步。</p>
<h3 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了"></a>问题来了</h3><p>有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p>
<ul>
<li>JRockit虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为呢JRockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能</li>
</ul>
<p>首先明确： 当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p>
<p>所以： 尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。</p>
<p>在此模式下，当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</p>
<p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p>
<h3 id="HotSpot-JVM执行方式"><a href="#HotSpot-JVM执行方式" class="headerlink" title="HotSpot JVM执行方式"></a>HotSpot JVM执行方式</h3><p>当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p>
<p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—阿里团队</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710095417462.png" alt="image-20200710095417462"></p>
<h3 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h3><ul>
<li>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程；也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）</li>
<li>把字节码转变成机器码的过程。</li>
<li>还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。</li>
</ul>
<p>前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。</p>
<p>JIT编译器：HotSpot VM的C1、C2编译器。</p>
<p>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</p>
<h3 id="热点探测技术"><a href="#热点探测技术" class="headerlink" title="热点探测技术"></a>热点探测技术</h3><p>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为OSR（On Stack Replacement）编译。</p>
<p>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</p>
<p>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。</p>
<p>采用基于计数器的热点探测，HotSpot V将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。</p>
<ul>
<li>方法调用计数器用于统计方法的调用次数</li>
<li>回边计数器则用于统计循环体执行的循环次数</li>
</ul>
<h3 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h3><p>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</p>
<p>这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。</p>
<p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710101829934.png" alt="image-20200710101829934"></p>
<h3 id="热点衰减"><a href="#热点衰减" class="headerlink" title="热点衰减"></a>热点衰减</h3><p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）</p>
<ul>
<li>半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄</li>
</ul>
<p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</p>
<p>另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p>
<h3 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h3><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710103103869.png" alt="image-20200710103103869"></p>
<h3 id="HotSpotVM-可以设置程序执行方法"><a href="#HotSpotVM-可以设置程序执行方法" class="headerlink" title="HotSpotVM 可以设置程序执行方法"></a>HotSpotVM 可以设置程序执行方法</h3><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p>
<ul>
<li>-Xint：完全采用解释器模式执行程序；</li>
<li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li>
<li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li>
</ul>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710103340273.png" alt="image-20200710103340273"></p>
<h3 id="HotSpotVM中-JIT-分类"><a href="#HotSpotVM中-JIT-分类" class="headerlink" title="HotSpotVM中 JIT 分类"></a>HotSpotVM中 JIT 分类</h3><p>JIT的编译器还分为了两种，分别是C1和C2，在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p>
<ul>
<li>-client：指定Java虚拟机运行在Client模式下，并使用C1编译器；<ul>
<li>C1编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。</li>
</ul>
</li>
<li>-server：指定Java虚拟机运行在server模式下，并使用C2编译器。<ul>
<li>C2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。（使用C++）</li>
</ul>
</li>
</ul>
<h3 id="C1-和-C2编译器不同的优化策略"><a href="#C1-和-C2编译器不同的优化策略" class="headerlink" title="C1 和 C2编译器不同的优化策略"></a>C1 和 C2编译器不同的优化策略</h3><p>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。</p>
<ul>
<li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li>
<li>去虚拟化：对唯一的实现樊进行内联</li>
<li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li>
</ul>
<p>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：</p>
<ul>
<li>标量替换：用标量值代替聚合对象的属性值</li>
<li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li>
<li>同步消除：清除同步操作，通常指synchronized</li>
</ul>
<h3 id="分层编译策略"><a href="#分层编译策略" class="headerlink" title="分层编译策略"></a>分层编译策略</h3><p>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</p>
<p>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul>
<li>一般来讲，JIT编译出来的机器码性能比解释器搞</li>
<li>C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器</li>
</ul>
<h3 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h3><p>jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）</p>
<p>Java 9引入了实验性AOT编译工具aotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</p>
<p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.java -&gt; .class -&gt; (使用jaotc) -&gt; .so</span><br></pre></td></tr></table></figure>

<p>最大的好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验</p>
<p>缺点：</p>
<ul>
<li>破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包</li>
<li>降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。</li>
<li>还需要继续优化中，最初只支持Linux X64 java base</li>
</ul>
<h3 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h3><ul>
<li>自JDK10起，HotSpot又加入了一个全新的及时编译器：Graal编译器</li>
<li>编译效果短短几年时间就追评了G2编译器，未来可期</li>
<li>目前，带着实验状态标签，需要使用开关参数去激活才能使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</span><br></pre></td></tr></table></figure>



<h1 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h1><h2 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h2><ul>
<li>String：字符串，使用一对 ”” 引起来表示<ul>
<li>String s1 = “mogublog” ; // 字面量的定义方式</li>
<li>String s2 = new String(“moxi”);</li>
</ul>
</li>
<li>string声明为final的，不可被继承</li>
<li>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示string可以比较大小</li>
<li>string在jdk8及以前内部定义了final char[] value用于存储字符串数据。JDK9时改为byte[]</li>
</ul>
<h3 id="为什么JDK9改变了结构"><a href="#为什么JDK9改变了结构" class="headerlink" title="为什么JDK9改变了结构"></a>为什么JDK9改变了结构</h3><p>String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且，大多数字符串对象只包含拉丁字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用。</p>
<p>我们建议改变字符串的内部表示clasš从utf - 16字符数组到字节数组+一个encoding-flag字段。新的String类将根据字符串的内容存储编码为ISO-8859-1/Latin-1(每个字符一个字节)或UTF-16(每个字符两个字节)的字符。编码标志将指示使用哪种编码。</p>
<p>结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 之前</span><br><span class="line">private final char value[];</span><br><span class="line">// 之后</span><br><span class="line">private final byte[] value</span><br></pre></td></tr></table></figure>

<p>同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改</p>
<h3 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h3><p>String：代表不可变的字符序列。简称：不可变性。</p>
<blockquote>
<p>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 当调用string的replace（）方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p>
</blockquote>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * String的不可变性</span><br><span class="line"> *</span><br><span class="line"> * @author: 陌溪</span><br><span class="line"> * @create: 2020-07-11-8:57</span><br><span class="line"> */</span><br><span class="line">public class StringTest1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void test1() &#123;</span><br><span class="line">        // 字面量定义的方式，“abc”存储在字符串常量池中</span><br><span class="line">        String s1 = &quot;abc&quot;;</span><br><span class="line">        String s2 = &quot;abc&quot;;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        s1 = &quot;hello&quot;;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(&quot;----------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test2() &#123;</span><br><span class="line">        String s1 = &quot;abc&quot;;</span><br><span class="line">        String s2 = &quot;abc&quot;;</span><br><span class="line">        // 只要进行了修改，就会重新创建一个对象，这就是不可变性</span><br><span class="line">        s2 += &quot;def&quot;;</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(&quot;----------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test3() &#123;</span><br><span class="line">        String s1 = &quot;abc&quot;;</span><br><span class="line">        String s2 = s1.replace(&#x27;a&#x27;, &#x27;m&#x27;);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test1();</span><br><span class="line">        test2();</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">hello</span><br><span class="line">abc</span><br><span class="line">----------------</span><br><span class="line">abc</span><br><span class="line">abcdef</span><br><span class="line">----------------</span><br><span class="line">abc</span><br><span class="line">mbc</span><br></pre></td></tr></table></figure>

<h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 陌溪</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-07-11-9:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer</span> </span>&#123;</span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> [] ch = &#123;<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">char</span> ch [])</span> </span>&#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringExer ex = <span class="keyword">new</span> StringExer();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str);</span><br><span class="line">        System.out.println(ex.ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">good</span><br><span class="line">best</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>字符串常量池是不会存储相同内容的字符串的</strong></p>
<p>String的string Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进string Pool的string非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用string.intern时性能会大幅下降。</p>
<p>使用-XX:StringTablesize可设置stringTab1e的长度</p>
<p>在jdk6中stringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。stringTablesize设置没有要求</p>
<p>在jdk7中，stringTable的长度默认值是60013，</p>
<p>在JDK8中，StringTable可以设置的最小值为1009</p>
<h2 id="String的内存分配"><a href="#String的内存分配" class="headerlink" title="String的内存分配"></a>String的内存分配</h2><p>在Java语言中有8种基本数据类型和一种比较特殊的类型string。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p>
<p>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，string类型的常量池比较特殊。它的主要使用方法有两种。</p>
<p>直接使用双引号声明出来的String对象会直接存储在常量池中。</p>
<ul>
<li>比如：string info=”atguigu.com”；</li>
</ul>
<p>如果不是用双引号声明的string对象，可以使用string提供的intern（）方法。</p>
<p>Java 6及以前，字符串常量池存放在永久代</p>
<p>Java 7中 oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内</p>
<blockquote>
<p>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</p>
<p>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用string.intern（）。</p>
</blockquote>
<p>Java8元空间，字符串常量在堆</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13_StringTable/images/image-20200711093546398.png" alt="image-20200711093546398"></p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13_StringTable/images/image-20200711093558709.png" alt="image-20200711093558709"></p>
<h3 id="为什么StringTable从永久代调整到堆中"><a href="#为什么StringTable从永久代调整到堆中" class="headerlink" title="为什么StringTable从永久代调整到堆中"></a>为什么StringTable从永久代调整到堆中</h3><p>在JDK 7中，interned字符串不再在Java堆的永久生成中分配，而是在Java堆的主要部分(称为年轻代和年老代)中分配，与应用程序创建的其他对象一起分配。此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。由于这一变化，大多数应用程序在堆使用方面只会看到相对较小的差异，但加载许多类或大量使用字符串的较大应用程序会出现这种差异。intern()方法会看到更显著的差异。</p>
<ul>
<li>永久代的默认比较小</li>
<li>永久代垃圾回收频率低</li>
</ul>
<h2 id="String的基本操作"><a href="#String的基本操作" class="headerlink" title="String的基本操作"></a>String的基本操作</h2><p>Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。</p>
<h2 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h2><ul>
<li>常量与常量的拼接结果在常量池，原理是编译期优化</li>
<li>常量池中不会存在相同内容的变量</li>
<li>只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</li>
<li>如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   public static void test1() &#123;</span><br><span class="line">       String s1 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;  // 得到 abc的常量池</span><br><span class="line">       String s2 = &quot;abc&quot;; // abc存放在常量池，直接将常量池的地址返回</span><br><span class="line">       /**</span><br><span class="line">        * 最终java编译成.class，再执行.class</span><br><span class="line">        */</span><br><span class="line">       System.out.println(s1 == s2); // true，因为存放在字符串常量池</span><br><span class="line">       System.out.println(s1.equals(s2)); // true</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">public static void test2() &#123;</span><br><span class="line">       String s1 = &quot;javaEE&quot;;</span><br><span class="line">       String s2 = &quot;hadoop&quot;;</span><br><span class="line">       String s3 = &quot;javaEEhadoop&quot;;</span><br><span class="line">       String s4 = &quot;javaEE&quot; + &quot;hadoop&quot;;    </span><br><span class="line">       String s5 = s1 + &quot;hadoop&quot;;</span><br><span class="line">       String s6 = &quot;javaEE&quot; + s2;</span><br><span class="line">       String s7 = s1 + s2;</span><br><span class="line"></span><br><span class="line">       System.out.println(s3 == s4); // true</span><br><span class="line">       System.out.println(s3 == s5); // false</span><br><span class="line">       System.out.println(s3 == s6); // false</span><br><span class="line">       System.out.println(s3 == s7); // false</span><br><span class="line">       System.out.println(s5 == s6); // false</span><br><span class="line">       System.out.println(s5 == s7); // false</span><br><span class="line">       System.out.println(s6 == s7); // false</span><br><span class="line"></span><br><span class="line">       String s8 = s6.intern();</span><br><span class="line">       System.out.println(s3 == s8); // true</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>从上述的结果我们可以知道：</p>
<p>如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果</p>
<p>而调用intern方法，则会判断字符串常量池中是否存在JavaEEhadoop值，如果存在则返回常量池中的值，否者就在常量池中创建</p>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>拼接操作的底层其实使用了StringBuilder</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13_StringTable/images/image-20200711102231129.png" alt="image-20200711102231129"></p>
<p>s1 + s2的执行细节</p>
<ul>
<li>StringBuilder s = new StringBuilder();</li>
<li>s.append(s1);</li>
<li>s.append(s2);</li>
<li>s.toString(); -&gt; 类似于new String(“ab”);</li>
</ul>
<p>在JDK5之后，使用的是StringBuilder，在JDK5之前使用的是StringBuffer</p>
<table>
<thead>
<tr>
<th>String</th>
<th>StringBuffer</th>
<th>StringBuilder</th>
</tr>
</thead>
<tbody><tr>
<td>String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间</td>
<td>StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量</td>
<td>可变类，速度更快</td>
</tr>
<tr>
<td>不可变</td>
<td>可变</td>
<td>可变</td>
</tr>
<tr>
<td></td>
<td>线程安全</td>
<td>线程不安全</td>
</tr>
<tr>
<td></td>
<td>多线程操作字符串</td>
<td>单线程操作字符串</td>
</tr>
</tbody></table>
<p>注意，我们左右两边如果是变量的话，就是需要new StringBuilder进行拼接，但是如果使用的是final修饰，则是从常量池中获取。所以说拼接符号左右两边都是字符串常量或常量引用 则仍然使用编译器优化。也就是说被final修饰的变量，将会变成常量，类和方法将不能被继承、</p>
<ul>
<li>在开发中，能够使用final的时候，建议使用上</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    String s4 = s1 + s2;</span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>

<h3 id="拼接操作和append性能对比"><a href="#拼接操作和append性能对比" class="headerlink" title="拼接操作和append性能对比"></a>拼接操作和append性能对比</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void method1(int highLevel) &#123;</span><br><span class="line">    String src = &quot;&quot;;</span><br><span class="line">    for (int i = 0; i &lt; highLevel; i++) &#123;</span><br><span class="line">        src += &quot;a&quot;; // 每次循环都会创建一个StringBuilder对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void method2(int highLevel) &#123;</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    for (int i = 0; i &lt; highLevel; i++) &#123;</span><br><span class="line">        sb.append(&quot;a&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法1耗费的时间：4005ms，方法2消耗时间：7ms</p>
<p>结论：</p>
<ul>
<li>通过StringBuilder的append()方式添加字符串的效率，要远远高于String的字符串拼接方法</li>
</ul>
<p>好处</p>
<ul>
<li>StringBuilder的append的方式，自始至终只创建一个StringBuilder的对象</li>
<li>对于字符串拼接的方式，还需要创建很多StringBuilder对象和 调用toString时候创建的String对象</li>
<li>内存中由于创建了较多的StringBuilder和String对象，内存占用过大，如果进行GC那么将会耗费更多的时间</li>
</ul>
<p>改进的空间</p>
<ul>
<li>我们使用的是StringBuilder的空参构造器，默认的字符串容量是16，然后将原来的字符串拷贝到新的字符串中， 我们也可以默认初始化更大的长度，减少扩容的次数</li>
<li>因此在实际开发中，我们能够确定，前前后后需要添加的字符串不高于某个限定值，那么建议使用构造器创建一个阈值的长度</li>
</ul>
<h2 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern()的使用"></a>intern()的使用</h2><p>intern是一个native方法，调用的是底层C的方法</p>
<p>字符串池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串对象相等的字符串，则返回池中的字符串。否则，该字符串对象将被添加到池中，并返回对该字符串对象的引用。</p>
<p>如果不是用双引号声明的string对象，可以使用string提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String myInfo = new string(&quot;I love atguigu&quot;).intern();</span><br></pre></td></tr></table></figure>

<p>也就是说，如果在任意字符串上调用string.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（&quot;a&quot;+&quot;b&quot;+&quot;c&quot;）.intern（）==&quot;abc&quot;</span><br></pre></td></tr></table></figure>

<p>通俗点讲，Interned string就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p>
<h3 id="intern的空间效率测试"><a href="#intern的空间效率测试" class="headerlink" title="intern的空间效率测试"></a>intern的空间效率测试</h3><p>我们通过测试一下，使用了intern和不使用的时候，其实相差还挺多的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用Intern() 测试执行效率</span><br><span class="line"> * @author: 陌溪</span><br><span class="line"> * @create: 2020-07-11-15:19</span><br><span class="line"> */</span><br><span class="line">public class StringIntern2 &#123;</span><br><span class="line">    static final int MAX_COUNT = 1000 * 10000;</span><br><span class="line">    static final String[] arr = new String[MAX_COUNT];</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer [] data = new Integer[]&#123;1,2,3,4,5,6,7,8,9,10&#125;;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        for (int i = 0; i &lt; MAX_COUNT; i++) &#123;</span><br><span class="line">            arr[i] = new String(String.valueOf(data[i%data.length])).intern();</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;花费的时间为：&quot; + (end - start));</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000000);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.getStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong>：<strong>对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用intern()方法能够节省内存空间。</strong></p>
<p>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用intern() 方法，就会很明显降低内存的大小。</p>
<h2 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h2><h3 id="new-String-“ab”-会创建几个对象"><a href="#new-String-“ab”-会创建几个对象" class="headerlink" title="new String(“ab”)会创建几个对象"></a>new String(“ab”)会创建几个对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * new String(&quot;ab&quot;) 会创建几个对象？ 看字节码就知道是2个对象</span><br><span class="line"> *</span><br><span class="line"> * @author: 陌溪</span><br><span class="line"> * @create: 2020-07-11-11:17</span><br><span class="line"> */</span><br><span class="line">public class StringNewTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str = new String(&quot;ab&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们转换成字节码来查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0 new #2 &lt;java/lang/String&gt;</span><br><span class="line"> 3 dup</span><br><span class="line"> 4 ldc #3 &lt;ab&gt;</span><br><span class="line"> 6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line"> 9 astore_1</span><br><span class="line">10 return</span><br></pre></td></tr></table></figure>

<p>这里面就是两个对象</p>
<ul>
<li>一个对象是：new关键字在堆空间中创建</li>
<li>另一个对象：字符串常量池中的对象</li>
</ul>
<h3 id="new-String-“a”-new-String-“b”-会创建几个对象"><a href="#new-String-“a”-new-String-“b”-会创建几个对象" class="headerlink" title="new String(“a”) + new String(“b”) 会创建几个对象"></a>new String(“a”) + new String(“b”) 会创建几个对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * new String(&quot;ab&quot;) 会创建几个对象？ 看字节码就知道是2个对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 陌溪</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-07-11-11:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringNewTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码文件为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> <span class="keyword">new</span> #<span class="number">2</span> &lt;java/lang/StringBuilder&gt;</span><br><span class="line"> <span class="number">3</span> dup</span><br><span class="line"> <span class="number">4</span> invokespecial #<span class="number">3</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"> <span class="number">7</span> <span class="keyword">new</span> #<span class="number">4</span> &lt;java/lang/String&gt;</span><br><span class="line"><span class="number">10</span> dup</span><br><span class="line"><span class="number">11</span> ldc #<span class="number">5</span> &lt;a&gt;</span><br><span class="line"><span class="number">13</span> invokespecial #<span class="number">6</span> &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">16</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">19</span> <span class="keyword">new</span> #<span class="number">4</span> &lt;java/lang/String&gt;</span><br><span class="line"><span class="number">22</span> dup</span><br><span class="line"><span class="number">23</span> ldc #<span class="number">8</span> &lt;b&gt;</span><br><span class="line"><span class="number">25</span> invokespecial #<span class="number">6</span> &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">28</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">31</span> invokevirtual #<span class="number">9</span> &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">34</span> astore_1</span><br><span class="line"><span class="number">35</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>我们创建了6个对象</p>
<ul>
<li>对象1：new StringBuilder()</li>
<li>对象2：new String(“a”)</li>
<li>对象3：常量池的 a</li>
<li>对象4：new String(“b”)</li>
<li>对象5：常量池的 b</li>
<li>对象6：toString中会创建一个 new String(“ab”)<ul>
<li>调用toString方法，不会在常量池中生成ab</li>
</ul>
</li>
</ul>
<h3 id="intern的使用：JDK6和JDK7"><a href="#intern的使用：JDK6和JDK7" class="headerlink" title="intern的使用：JDK6和JDK7"></a>intern的使用：JDK6和JDK7</h3><h4 id="JDK6中"><a href="#JDK6中" class="headerlink" title="JDK6中"></a>JDK6中</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = new String(&quot;1&quot;);  // 在常量池中已经有了</span><br><span class="line">s.intern(); // 将该对象放入到常量池。但是调用此方法没有太多的区别，因为已经存在了1</span><br><span class="line">String s2 = &quot;1&quot;;</span><br><span class="line">System.out.println(s == s2); // false</span><br><span class="line"></span><br><span class="line">String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);</span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = &quot;11&quot;;</span><br><span class="line">System.out.println(s3 == s4); // true</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>为什么对象会不一样呢？</p>
<ul>
<li>一个是new创建的对象，一个是常量池中的对象，显然不是同一个</li>
</ul>
<p>如果是下面这样的，那么就是true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = new String(&quot;1&quot;);</span><br><span class="line">s = s.intern();</span><br><span class="line">String s2 = &quot;1&quot;;</span><br><span class="line">System.out.println(s == s2); // true</span><br></pre></td></tr></table></figure>

<p>而对于下面的来说，因为 s3变量记录的地址是 new String(“11”)，然后这段代码执行完以后，常量池中不存在 “11”，这是JDK6的关系，然后执行 s3.intern()后，就会在常量池中生成 “11”，最后 s4用的就是s3的地址</p>
<blockquote>
<p>为什么最后输出的 s3 == s4 会为false呢？</p>
<p>这是因为在JDK6中创建了一个新的对象 “11”，也就是有了新的地址， s2 = 新地址</p>
<p>而在JDK7中，在JDK7中，并没有创新一个新对象，而是指向常量池中的新对象</p>
</blockquote>
<h4 id="JDK7中"><a href="#JDK7中" class="headerlink" title="JDK7中"></a>JDK7中</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = new String(&quot;1&quot;);</span><br><span class="line">s.intern();</span><br><span class="line">String s2 = &quot;1&quot;;</span><br><span class="line">System.out.println(s == s2); // true</span><br><span class="line"></span><br><span class="line">String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);</span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = &quot;11&quot;;</span><br><span class="line">System.out.println(s3 == s4); // true</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13_StringTable/images/image-20200711145925091.png" alt="image-20200711145925091"></p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);</span><br><span class="line">String s4 = &quot;11&quot;;  // 在常量池中生成的字符串</span><br><span class="line">s3.intern();  // 然后s3就会从常量池中找，发现有了，就什么事情都不做</span><br><span class="line">System.out.println(s3 == s4);</span><br></pre></td></tr></table></figure>

<p>我们将 s4的位置向上移动一行，发现变化就会很大，最后得到的是 false</p>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>总结string的intern（）的使用：</p>
<p>JDK1.6中，将这个字符串对象尝试放入串池。</p>
<ul>
<li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li>
<li>如果没有，会把此<strong>对象复制一份</strong>，放入串池，并返回串池中的对象地址</li>
</ul>
<p>JDK1.7起，将这个字符串对象尝试放入串池。</p>
<ul>
<li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li>
<li>如果没有，则会把<strong>对象的引用地址</strong>复制一份，放入串池，并返回串池中的引用地址</li>
</ul>
<p>练习：</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13_StringTable/images/image-20200711150859709.png" alt="image-20200711150859709"></p>
<ul>
<li>在JDK6中，在字符串常量池中创建一个字符串 “ab”</li>
<li>在JDK8中，在字符串常量池中没有创建 “ab”，而是将堆中的地址复制到 串池中。</li>
</ul>
<p>所以上述结果，在JDK6中是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>在JDK8中是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13_StringTable/images/image-20200711151326909.png" alt="image-20200711151326909"></p>
<p>针对下面这题，在JDK6和8中表现的是一样的</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13_StringTable/images/image-20200711151433277.png" alt="image-20200711151433277"></p>
<h2 id="StringTable的垃圾回收"><a href="#StringTable的垃圾回收" class="headerlink" title="StringTable的垃圾回收"></a>StringTable的垃圾回收</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * String的垃圾回收</span><br><span class="line"> * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span><br><span class="line"> * @author: 陌溪</span><br><span class="line"> * @create: 2020-07-11-16:55</span><br><span class="line"> */</span><br><span class="line">public class StringGCTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            String.valueOf(i).intern();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="G1（G-first）中的String去重操作"><a href="#G1（G-first）中的String去重操作" class="headerlink" title="G1（G first）中的String去重操作"></a>G1（G first）中的String去重操作</h2><p>注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：</p>
<ul>
<li>堆存活数据集合里面string对象占了25%</li>
<li>堆存活数据集合里面重复的string对象有13.5%</li>
<li>string对象的平均长度是45</li>
</ul>
<p>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是string对象。更进一步，这里面差不多一半string对象是重复的，重复的意思是说： stringl.equals（string2）= true。堆上存在重复的string对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的string对象进行去重，这样就能避免浪费内存。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的string对象。</li>
<li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的string对象。</li>
<li>使用一个hashtab1e来记录所有的被string对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</li>
<li>如果存在，string对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li>
<li>如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</li>
</ul>
<h3 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h3><p>命令行选项</p>
<blockquote>
<p>UsestringDeduplication（bool）：开启string去重，默认是不开启的，需要手动开启。 Printstringbeduplicationstatistics（bool）：打印详细的去重统计信息 stringpeduplicationAgeThreshold（uintx）：达到这个年龄的string对象被认为是去重的候选对象</p>
</blockquote>
<h1 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>这次我们主要关注的是黄色部分，内存的分配与回收</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/images/image-20200712084539884.png" alt="image-20200712084539884"></p>
<h2 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h2><p>在提到什么是垃圾之前，我们先看下面一张图</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/images/image-20200712085456113.png" alt="image-20200712085456113"></p>
<p>从上图我们可以很明确的知道，Java 和 C++语言的区别，就在于垃圾收集技术和内存动态分配上，C语言没有垃圾收集技术，需要我们手动的收集。</p>
<p>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。 关于垃圾收集有三个经典问题：</p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
<p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p>
<h3 id="什么是垃圾？"><a href="#什么是垃圾？" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h3><p>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。</p>
<p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致内存溢出。</p>
<h3 id="磁盘碎片整理"><a href="#磁盘碎片整理" class="headerlink" title="磁盘碎片整理"></a>磁盘碎片整理</h3><p>机械硬盘需要进行磁盘整理，同时还有坏道</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/images/image-20200712090848669.png" alt="image-20200712090848669"></p>
<h3 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h3><h4 id="蚂蚁金服"><a href="#蚂蚁金服" class="headerlink" title="蚂蚁金服"></a>蚂蚁金服</h4><ul>
<li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下cms和G1？</li>
<li>JVM GC算法有哪些，目前的JDK版本采用什么回收算法？</li>
<li>G1回收器讲下回收过程GC是什么？为什么要有GC？</li>
<li>GC的两种判定方法？CMS收集器与G1收集器的特点</li>
</ul>
<h4 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h4><ul>
<li>说一下GC算法，分代回收说下</li>
<li>垃圾收集策略和算法</li>
</ul>
<h4 id="天猫"><a href="#天猫" class="headerlink" title="天猫"></a>天猫</h4><ul>
<li>JVM GC原理，JVM怎么回收内存</li>
<li>CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</li>
</ul>
<h4 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h4><p>Java的垃圾回收器都有哪些，说下g1的应用场景，平时你是如何搭配使用垃圾回收器的</p>
<h4 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h4><ul>
<li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，</li>
<li>包括原理，流程，优缺点。垃圾回收算法的实现原理</li>
</ul>
<h4 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h4><ul>
<li>讲一讲垃圾回收算法。</li>
<li>什么情况下触发垃圾回收？</li>
<li>如何选择合适的垃圾收集算法？</li>
<li>JVM有哪三种垃圾回收器？</li>
</ul>
<h4 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h4><ul>
<li>常见的垃圾回收器算法有哪些，各有什么优劣？</li>
<li>System.gc（）和Runtime.gc（）会做什么事情？</li>
<li>Java GC机制？GC Roots有哪些？</li>
<li>Java对象的回收方式，回收算法。</li>
<li>CMS和G1了解么，CMS解决什么问题，说一下回收的过程。</li>
<li>CMS回收停顿了几次，为什么要停顿两次?</li>
</ul>
<h2 id="为什么需要GC"><a href="#为什么需要GC" class="headerlink" title="为什么需要GC"></a>为什么需要GC</h2><p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p>
<p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。</p>
<p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p>
<h2 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h2><p>在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MibBridge *pBridge= new cmBaseGroupBridge（）；</span><br><span class="line">//如果注册失败，使用Delete释放该对象所占内存区域</span><br><span class="line">if（pBridge-&gt;Register（kDestroy）！=NO ERROR）</span><br><span class="line">	delete pBridge；</span><br></pre></td></tr></table></figure>

<p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。</p>
<p>有了垃圾回收机制后，上述代码极有可能变成这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MibBridge *pBridge=new cmBaseGroupBridge(); </span><br><span class="line">pBridge-&gt;Register(kDestroy);</span><br></pre></td></tr></table></figure>

<p>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了线代开发语言必备的标准。</p>
<h2 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</p>
<p>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</p>
<p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</p>
<p>oracle官网关于垃圾回收的介绍 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p>
<h3 id="担忧"><a href="#担忧" class="headerlink" title="担忧"></a>担忧</h3><p>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</p>
<p>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见outofMemoryError时，快速地根据错误异常日志定位问题和解决问题。</p>
<p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。</p>
<h3 id="GC主要关注的区域"><a href="#GC主要关注的区域" class="headerlink" title="GC主要关注的区域"></a>GC主要关注的区域</h3><p>GC主要关注于 方法区 和堆中的垃圾收集</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/images/image-20200712092427246.png" alt="image-20200712092427246"></p>
<p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收</p>
<ul>
<li>其中，Java堆是垃圾收集器的工作重点</li>
</ul>
<p>从次数上讲：</p>
<ul>
<li>频繁收集Young区</li>
<li>较少收集Old区</li>
<li>基本不收集Perm区（元空间）</li>
</ul>
<h1 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h1><h2 id="标记阶段：引用计数算法"><a href="#标记阶段：引用计数算法" class="headerlink" title="标记阶段：引用计数算法"></a>标记阶段：引用计数算法</h2><p>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</p>
<p>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p>
<p>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法。</strong></p>
<p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</p>
<p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p>
<p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p>
<p>缺点：它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。</p>
<blockquote>
<p>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</p>
</blockquote>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>当p的指针断开的时候，内部的引用形成一个循环，这就是循环引用，从而造成内存泄漏</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712102205795.png" alt="image-20200712102205795"></p>
<h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><p>我们使用一个案例来测试Java中是否采用的是引用计数算法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 引用计数算法测试</span><br><span class="line"> *</span><br><span class="line"> * @author: 陌溪</span><br><span class="line"> * @create: 2020-07-12-10:26</span><br><span class="line"> */</span><br><span class="line">public class RefCountGC &#123;</span><br><span class="line">    // 这个成员属性的唯一作用就是占用一点内存</span><br><span class="line">    private byte[] bigSize = new byte[5*1024*1024];</span><br><span class="line">    // 引用</span><br><span class="line">    Object reference = null;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        RefCountGC obj1 = new RefCountGC();</span><br><span class="line">        RefCountGC obj2 = new RefCountGC();</span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line">        obj1 = null;</span><br><span class="line">        obj2 = null;</span><br><span class="line">        // 显示的执行垃圾收集行为，判断obj1 和 obj2是否被回收？</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 15490K-&gt;808K(76288K)] 15490K-&gt;816K(251392K), 0.0061980 secs] [Times: user=0.00 sys=0.00, real=0.36 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 808K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;672K(175104K)] 816K-&gt;672K(251392K), [Metaspace: 3479K-&gt;3479K(1056768K)], 0.0045983 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 655K [0x000000076b500000, 0x0000000770a00000, 0x00000007c0000000)</span><br><span class="line">  eden space 65536K, 1% used [0x000000076b500000,0x000000076b5a3ee8,0x000000076f500000)</span><br><span class="line">  from space 10752K, 0% used [0x000000076f500000,0x000000076f500000,0x000000076ff80000)</span><br><span class="line">  to   space 10752K, 0% used [0x000000076ff80000,0x000000076ff80000,0x0000000770a00000)</span><br><span class="line"> ParOldGen       total 175104K, used 672K [0x00000006c1e00000, 0x00000006cc900000, 0x000000076b500000)</span><br><span class="line">  object space 175104K, 0% used [0x00000006c1e00000,0x00000006c1ea8070,0x00000006cc900000)</span><br><span class="line"> Metaspace       used 3486K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 385K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>我们能够看到，上述进行了GC收集的行为，将上述的新生代中的两个对象都进行回收了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PSYoungGen: 15490K-&gt;808K(76288K)] 15490K-&gt;816K(251392K)</span><br></pre></td></tr></table></figure>

<p>如果使用引用计数算法，那么这两个对象将会无法回收。而现在两个对象被回收了，说明Java使用的不是引用计数算法来进行标记的。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712103230349.png" alt="image-20200712103230349"></p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</p>
<p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p>
<p>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。Python如何解决循环引用？</p>
<blockquote>
<p>手动解除：很好理解，就是在合适的时机，解除引用关系。 使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</p>
</blockquote>
<h2 id="标记阶段：可达性分析算法"><a href="#标记阶段：可达性分析算法" class="headerlink" title="标记阶段：可达性分析算法"></a>标记阶段：可达性分析算法</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>可达性分析算法：也可以称为 根搜索算法、追踪性垃圾收集</p>
<p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</p>
<p>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>所谓”GCRoots”根集合就是一组必须活跃的引用。</p>
<p>基本思路：</p>
<ul>
<li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li>
<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）</li>
<li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li>
<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li>
</ul>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712104149246.png" alt="image-20200712104149246"></p>
<p>官场上的裙带关系，可达性分析在人类关系网中</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712104312406.png" alt="image-20200712104312406"></p>
<h3 id="GC-Roots可以是哪些？"><a href="#GC-Roots可以是哪些？" class="headerlink" title="GC Roots可以是哪些？"></a>GC Roots可以是哪些？</h3><ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象<ul>
<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
<li>可以理解为栈帧中的本地变量表中所有对象</li>
</ul>
</li>
<li>本地方法栈内JNI（通常说的本地方法）引用的对象方法区中类静态属性引用的对象<ul>
<li>比如：Java类的引用类型静态变量</li>
<li>可以理解为：引用方法区该静态属性的所有对象</li>
</ul>
</li>
<li>方法区中常量引用的对象<ul>
<li>比如：字符串常量池（string Table）里的引用</li>
<li>可以理解为：引用方法区中常量的所有对象</li>
</ul>
</li>
<li>所有被同步锁synchronized持有的对象</li>
<li>Java虚拟机内部的引用。<ul>
<li>基本数据类型对应的Class对象，一些常驻的异常对象（如：Nu11PointerException、outofMemoryError），系统类加载器。</li>
</ul>
</li>
<li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ul>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712104622677.png" alt="image-20200712104622677"></p>
<h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>总结一句话就是，除了堆空间外的一些结构，比如 虚拟机栈、本地方法栈、方法区、字符串常量池 等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析</p>
<p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（PartialGC）。</p>
<p>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GCRoots集合中去考虑，才能保证可达性分析的准确性。</p>
<h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p>
<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p>
<p>这点也是导致GC进行时必须“stop The World”的一个重要原因。</p>
<p>即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p>
<h2 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h2><p>Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p>
<p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</p>
<p>finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p>
<h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><p>永远不要主动调用某个对象的finalize（）方法I应该交给垃圾回收机制调用。理由包括下面三点：</p>
<ul>
<li>在finalize（）时可能会导致对象复活。</li>
<li>finalize（）方法的执行时间是没有保障的，它完全由Gc线程决定，极端情况下，若不发生GC，则finalize（）方法将没有执行机会。<ul>
<li>因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li>
</ul>
</li>
<li>一个糟糕的finalize（）会严重影响Gc的性能。</li>
</ul>
<p>从功能上来说，finalize（）方法与c++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize（）方法在本质上不同于C++中的析构函数。</p>
<p>由于finalize（）方法的存在，虚拟机中的对象一般处于三种可能的状态。</p>
<h3 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h3><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活”自己</strong>，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p>
<ul>
<li>可触及的：从根节点开始，可以到达这个对象。</li>
<li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize（）中复活。</li>
<li>不可触及的：对象的finalize（）被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为<strong>finalize()只会被调用一次</strong>。</li>
</ul>
<p>以上3种状态中，是由于finalize（）方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p>
<h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p>
<ul>
<li>如果对象objA到GC Roots没有引用链，则进行第一次标记。</li>
<li>进行筛选，判断此对象是否有必要执行finalize（）方法<ul>
<li>如果对象objA没有重写finalize（）方法，或者finalize（）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li>
<li>如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。</li>
<li>finalize（）方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712110411885.png" alt="image-20200712110411885"></p>
<p>上图就是我们看到的Finalizer线程</p>
<h3 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h3><p>我们使用重写 finalize()方法，然后在方法的内部，重写将其存放到GC Roots中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 测试Object类中finalize()方法</span><br><span class="line"> * 对象复活场景</span><br><span class="line"> *</span><br><span class="line"> * @author: 陌溪</span><br><span class="line"> * @create: 2020-07-12-11:06</span><br><span class="line"> */</span><br><span class="line">public class CanReliveObj &#123;</span><br><span class="line">    // 类变量，属于GC Roots的一部分</span><br><span class="line">    public static CanReliveObj canReliveObj;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">        System.out.println(&quot;调用当前类重写的finalize()方法&quot;);</span><br><span class="line">        canReliveObj = this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        canReliveObj = new CanReliveObj();</span><br><span class="line">        canReliveObj = null;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(&quot;-----------------第一次gc操作------------&quot;);</span><br><span class="line">        // 因为Finalizer线程的优先级比较低，暂停2秒，以等待它</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">        if (canReliveObj == null) &#123;</span><br><span class="line">            System.out.println(&quot;obj is dead&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;obj is still alive&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----------------第二次gc操作------------&quot;);</span><br><span class="line">        canReliveObj = null;</span><br><span class="line">        System.gc();</span><br><span class="line">        // 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">        if (canReliveObj == null) &#123;</span><br><span class="line">            System.out.println(&quot;obj is dead&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;obj is still alive&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------------第一次gc操作------------</span><br><span class="line">调用当前类重写的finalize()方法</span><br><span class="line">obj is still alive</span><br><span class="line">-----------------第二次gc操作------------</span><br><span class="line">obj is dead</span><br></pre></td></tr></table></figure>

<p>在进行第一次清除的时候，我们会执行finalize方法，然后 对象 进行了一次自救操作，但是因为finalize()方法只会被调用一次，因此第二次该对象将会被垃圾清除。</p>
<h2 id="MAT与JProfiler的GC-Roots溯源"><a href="#MAT与JProfiler的GC-Roots溯源" class="headerlink" title="MAT与JProfiler的GC Roots溯源"></a>MAT与JProfiler的GC Roots溯源</h2><h3 id="MAT是什么？"><a href="#MAT是什么？" class="headerlink" title="MAT是什么？"></a>MAT是什么？</h3><p>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</p>
<p>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</p>
<p>大家可以在<a href="http://www.eclipse.org/mat/%E4%B8%8B%E8%BD%BD%E5%B9%B6%E4%BD%BF%E7%94%A8MAT">http://www.eclipse.org/mat/下载并使用MAT</a></p>
<h3 id="命令行使用-jmap"><a href="#命令行使用-jmap" class="headerlink" title="命令行使用 jmap"></a>命令行使用 jmap</h3><p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712112026317.png" alt="image-20200712112026317"></p>
<h3 id="使用JVIsualVM"><a href="#使用JVIsualVM" class="headerlink" title="使用JVIsualVM"></a>使用JVIsualVM</h3><p>捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。可通过以下方法捕获heap dump：</p>
<p>在左侧“Application”（应用程序）子窗口中右击相应的应用程序，选择Heap Dump（堆Dump）。</p>
<p>在Monitor（监视）子标签页中点击Heap Dump（堆Dump）按钮。本地应用程序的Heap dumps作为应用程序标签页的一个子标签页打开。同时，heap dump在左侧的Application（应用程序）栏中对应一个含有时间戳的节点。</p>
<p>右击这个节点选择save as（另存为）即可将heap dump保存到本地。</p>
<h3 id="使用MAT打开Dump文件"><a href="#使用MAT打开Dump文件" class="headerlink" title="使用MAT打开Dump文件"></a>使用MAT打开Dump文件</h3><p>打开后，我们就可以看到有哪些可以作为GC Roots的对象</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712112512720.png" alt="image-20200712112512720"></p>
<p>里面我们能够看到有一些常用的Java类，然后Thread线程。</p>
<h3 id="JProfiler的GC-Roots溯源"><a href="#JProfiler的GC-Roots溯源" class="headerlink" title="JProfiler的GC Roots溯源"></a>JProfiler的GC Roots溯源</h3><p>我们在实际的开发中，一般不会查找全部的GC Roots，可能只是查找某个对象的整个链路，或者称为GC Roots溯源，这个时候，我们就可以使用JProfiler</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712113256075.png" alt="image-20200712113256075"></p>
<h3 id="如何判断什么原因造成OOM"><a href="#如何判断什么原因造成OOM" class="headerlink" title="如何判断什么原因造成OOM"></a>如何判断什么原因造成OOM</h3><p>当我们程序出现OOM的时候，我们就需要进行排查，我们首先使用下面的例子进行说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 内存溢出排查</span><br><span class="line"> * -Xms8m -Xmx8m -XX:HeapDumpOnOutOfMemoryError</span><br><span class="line"> * @author: 陌溪</span><br><span class="line"> * @create: 2020-07-12-14:56</span><br><span class="line"> */</span><br><span class="line">public class HeapOOM &#123;</span><br><span class="line">    // 创建1M的文件</span><br><span class="line">    byte [] buffer = new byte[1 * 1024 * 1024];</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;HeapOOM&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        int count = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                list.add(new HeapOOM());</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.getStackTrace();</span><br><span class="line">            System.out.println(&quot;count:&quot; + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码就是不断的创建一个1M小字节数组，然后让内存溢出，我们需要限制一下内存大小，同时使用HeapDumpOnOutOfMemoryError将出错时候的dump文件输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms8m -Xmx8m -XX:HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure>

<p>我们将生成的dump文件打开，然后点击Biggest Objects就能够看到超大对象</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712150229048.png" alt="image-20200712150229048"></p>
<p>然后我们通过线程，还能够定位到哪里出现OOM</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712150303710.png" alt="image-20200712150303710"></p>
<h2 id="清除阶段：标记-清除算法"><a href="#清除阶段：标记-清除算法" class="headerlink" title="清除阶段：标记-清除算法"></a>清除阶段：标记-清除算法</h2><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是</p>
<ul>
<li>标记一清除算法（Mark-Sweep）</li>
<li>复制算法（copying）</li>
<li>标记-压缩算法（Mark-Compact）</li>
</ul>
<p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p>
<ul>
<li><p>标记</p>
<p>：Collector从引用根节点开始遍历，</p>
<p><strong>标记所有被引用的对象</strong></p>
<p>。一般是在对象的Header中记录为可达对象。</p>
<ul>
<li><strong>标记的是引用的对象，不是垃圾！！</strong></li>
</ul>
</li>
<li><p><strong>清除</strong>：Collector对堆内存从头到尾进行线性的遍历，如果 发现某个对象在其Header中没有标记为可达对象，则将其回收</p>
</li>
</ul>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712150935078.png" alt="image-20200712150935078"></p>
<h3 id="什么是清除？"><a href="#什么是清除？" class="headerlink" title="什么是清除？"></a>什么是清除？</h3><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p>
<p>关于空闲列表是在为对象分配内存的时候 提过</p>
<ul>
<li>如果内存规整<ul>
<li>采用指针碰撞的方式进行内存分配</li>
</ul>
</li>
<li>如果内存不规整<ul>
<li>虚拟机需要维护一个列表</li>
<li>空闲列表分配</li>
</ul>
</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>标记清除算法的效率不算高</li>
<li>在进行GC的时候，需要停止整个应用程序，用户体验较差</li>
<li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li>
</ul>
<h2 id="清除阶段：复制算法"><a href="#清除阶段：复制算法" class="headerlink" title="清除阶段：复制算法"></a>清除阶段：复制算法</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712151916991.png" alt="image-20200712151916991"></p>
<p>把可达的对象，直接复制到另外一个区域中复制完成后，A区就没有用了，里面的对象可以直接清除掉，其实里面的新生代里面就用到了复制算法</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712152029615.png" alt="image-20200712152029615"></p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul>
<li>没有标记和清除过程，实现简单，运行高效</li>
<li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li>
<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li>
</ul>
<h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><p>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行（老年代大量的对象存活，那么复制的对象将会有很多，效率会很低）</p>
<p>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712152847218.png" alt="image-20200712152847218"></p>
<h2 id="清除阶段：标记-整理算法"><a href="#清除阶段：标记-整理算法" class="headerlink" title="清除阶段：标记-整理算法"></a>清除阶段：标记-整理算法</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p>
<p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JvM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p>
<p>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p>
<h3 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h3><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p>
<p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712153236508.png" alt="image-20200712153236508"></p>
<h3 id="标清和标整的区别"><a href="#标清和标整的区别" class="headerlink" title="标清和标整的区别"></a>标清和标整的区别</h3><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</p>
<p>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p>
<h3 id="标整的优缺点"><a href="#标整的优缺点" class="headerlink" title="标整的优缺点"></a>标整的优缺点</h3><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul>
<li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li>
<li>消除了复制算法当中，内存减半的高额代价。</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>从效率上来说，标记-整理算法要低于复制算法。</li>
<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li>
<li>移动过程中，需要全程暂停用户应用程序。即：STW</li>
</ul>
<h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p>
<p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p>
<table>
<thead>
<tr>
<th></th>
<th>标记清除</th>
<th>标记整理</th>
<th>复制</th>
</tr>
</thead>
<tbody><tr>
<td><strong>速率</strong></td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td><strong>空间开销</strong></td>
<td>少（但会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>通常需要活对象的2倍空间（不堆积碎片）</td>
</tr>
<tr>
<td><strong>移动对象</strong></td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<p>综合我们可以找到，没有最好的算法，只有最合适的算法</p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p>
<p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：string对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p>
<p>目前几乎所有的GC都采用分代手机算法执行垃圾回收的</p>
<p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>
<ul>
<li>年轻代（Young Gen）</li>
</ul>
<p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p>
<p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p>
<ul>
<li>老年代（Tenured Gen）</li>
</ul>
<p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p>
<p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p>
<ul>
<li>Mark阶段的开销与存活对象的数量成正比。</li>
<li>Sweep阶段的开销与所管理区域的大小成正相关。</li>
<li>compact阶段的开销与存活对象的数据成正比。</li>
</ul>
<p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用serial old执行FullGC以达到对老年代内存的整理。</p>
<p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p>
<h2 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the World的状态。在stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p>
<p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>
<p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。<strong>增量收集算法通过对线程间冲突的妥善处理</strong>，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</p>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p>
<h2 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h2><p>一般来说，在相同条件下，堆空间越大，一次Gc时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>
<p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712165318590.png" alt="image-20200712165318590"></p>
<h2 id="写到最后-1"><a href="#写到最后-1" class="headerlink" title="写到最后"></a>写到最后</h2><p>注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</p>
<h1 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h1><h2 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc()的理解"></a>System.gc()的理解</h2><p>在默认情况下，通过system.gc（）者Runtime.getRuntime().gc() 的调用，会显式触发FullGC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p>
<p>然而system.gc() )调用附带一个免责声明，无法保证对垃圾收集器的调用。(不能确保立即生效)</p>
<p>JVM实现者可以通过system.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()</p>
<p>代码演示是否出发GC操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * System.gc()</span><br><span class="line"> *</span><br><span class="line"> * @author: 陌溪</span><br><span class="line"> * @create: 2020-07-12-19:07</span><br><span class="line"> */</span><br><span class="line">public class SystemGCTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new SystemGCTest();</span><br><span class="line">        // 提醒JVM进行垃圾回收</span><br><span class="line">        System.gc();</span><br><span class="line">        //System.runFinalization();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">        System.out.println(&quot;SystemGCTest 执行了 finalize方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果，但是不一定会触发销毁的方法，调用System.runFinalization()会强制调用 失去引用对象的finalize()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SystemGCTest 执行了 finalize方法</span><br></pre></td></tr></table></figure>

<h3 id="手动GC来理解不可达对象的回收"><a href="#手动GC来理解不可达对象的回收" class="headerlink" title="手动GC来理解不可达对象的回收"></a>手动GC来理解不可达对象的回收</h3><p>代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 局部变量回收</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 陌溪</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-07-12-19:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVarGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 触发Minor GC没有回收对象，然后在触发Full GC将该对象存入old区</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 触发YoungGC的时候，已经被回收了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">        buffer = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不会被回收，因为它还存放在局部变量表索引为1的槽中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会被回收，因为它还存放在局部变量表索引为1的槽中，但是后面定义的value把这个槽给替换了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * localvarGC5中的数组已经被回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        localvarGC1();</span><br><span class="line">        <span class="comment">//这里已经出了方法1中的作用域</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalVarGC localVarGC = <span class="keyword">new</span> LocalVarGC();</span><br><span class="line">        localVarGC.localvarGC3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p>
<p>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现ooM的情况。</p>
<p>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Fu11GC操作，这时候会回收大量的内存，供应用程序继续使用。</p>
<p>javadoc中对outofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</p>
<p>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：</p>
<ul>
<li>Java虚拟机的堆内存设置不够。</li>
</ul>
<p>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。</p>
<ul>
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</li>
</ul>
<p>对于老版本的oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space”。</p>
<p>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的ooM有所改观，出现ooM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace”。直接内存不足，也会导致OOM。</p>
<p>这里面隐含着一层意思是，在抛出OutofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p>
<blockquote>
<p>例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。 在java.nio.BIts.reserveMemory（）方法中，我们能清楚的看到，System.gc（）会被调用，以清理空间。</p>
</blockquote>
<p>当然，也不是在任何情况下垃圾收集器都会被触发的</p>
<p>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</p>
<p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致00M，也可以叫做宽泛意义上的“内存泄漏”。</p>
<p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现outofMemory异常，导致程序崩溃。</p>
<p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p>
<blockquote>
<p>买房子：80平的房子，但是有10平是公摊的面积，我们是无法使用这10平的空间，这就是所谓的内存泄漏</p>
</blockquote>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/16_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/images/image-20200712195158470.png" alt="image-20200712195158470"></p>
<p>Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的。后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开，从而导致没有办法被回收。</p>
<h3 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h3><ul>
<li>单例模式</li>
</ul>
<p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p>
<ul>
<li>一些提供close的资源未关闭导致内存泄漏</li>
</ul>
<p>数据库连接（dataSourse.getConnection() ），网络连接（socket）和io连接必须手动close，否则是不能被回收的。</p>
<h2 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h2><p>stop-the-world，简称STw，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p>
<p>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。</p>
<ul>
<li>分析工作必须在一个能确保一致性的快照中进行</li>
<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>
<li>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</li>
</ul>
<p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STw的发生。</p>
<p>STW事件和采用哪款GC无关所有的GC都有这个事件。</p>
<p>哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p>
<p>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p>
<p>开发中不要用system.gc() 会导致stop-the-world的发生。</p>
<h2 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p>
<p>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/16_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/images/image-20200712202522051.png" alt="image-20200712202522051"></p>
<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行（Paralle1）。</p>
<p>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</p>
<p>适合科学计算，后台处理等弱交互场景</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/16_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/images/image-20200712202822129.png" alt="image-20200712202822129"></p>
<h3 id="并发和并行对比"><a href="#并发和并行对比" class="headerlink" title="并发和并行对比"></a>并发和并行对比</h3><p><strong>并发</strong>，指的是多个事情，在同一时间段内同时发生了。</p>
<p><strong>并行</strong>，指的是多个事情，在同一时间点上同时发生了。</p>
<p>并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。</p>
<p>只有在多CPU或者一个CPU多核的情况中，才会发生并行。</p>
<p>否则，看似同时发生的事情，其实都是并发执行的。</p>
<h3 id="垃圾回收的并行与并发-1"><a href="#垃圾回收的并行与并发-1" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h3><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>
<ul>
<li>并行（Paralle1）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。如ParNew、Parallel Scavenge、Parallel old；</li>
<li>串行（Serial）<ul>
<li>相较于并行的概念，单线程执行。</li>
<li>如果内存不够，则程序暂停，启动JM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/16_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/images/image-20200712203607845.png" alt="image-20200712203607845"></p>
<p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>
<p>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。&gt;用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；</p>
<blockquote>
<p>如：CMS、G1</p>
</blockquote>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/16_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/images/image-20200712203815517.png" alt="image-20200712203815517"></p>
<h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。</p>
<p>Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</p>
<p>如何在cc发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p>
<ul>
<li><strong>抢先式中断</strong>：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li>
<li><strong>主动式中断</strong>：设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）</li>
</ul>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？例如线程处于sleep-状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p>
<p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始Gc都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。</p>
<p><strong>执行流程：</strong></p>
<ul>
<li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Relgion，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程</li>
<li>当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；</li>
</ul>
<h2 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h2><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p>
<p>【既偏门又非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？ 在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：</p>
<ul>
<li>强引用（Strong Reference）</li>
<li>软引用（Soft Reference）</li>
<li>弱引用（Weak Reference）</li>
<li>虚引用（Phantom Reference）</li>
</ul>
<p>这4种引用强度依次逐渐减弱。除强引用外，其他3种引用均可以在java.1ang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p>
<p>.<img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/16_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/images/image-20200712205813321.png" alt="image-20200712205813321"></p>
<p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p>
<ul>
<li>强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“object obj=new Object（）”这种引用关系。无论任何情况下，==只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象==。</li>
<li>软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常。</li>
<li>弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li>
<li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。==为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知==。</li>
</ul>
<h2 id="再谈引用：强引用"><a href="#再谈引用：强引用" class="headerlink" title="再谈引用：强引用"></a>再谈引用：强引用</h2><p>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。</p>
<p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p>
<p>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为nu11，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>
<p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。</p>
<h3 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h3><p>强引用的案例说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuffer str = new StringBuffer(&quot;hello mogublog&quot;);</span><br></pre></td></tr></table></figure>

<p>局部变量str指向stringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是stringBuffer实例的强引用对应内存结构：</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/16_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/images/image-20200712211501377.png" alt="image-20200712211501377"></p>
<p>如果此时，在运行一个赋值语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuffer str = new StringBuffer(&quot;hello mogublog&quot;);</span><br><span class="line">StringBuffer str1 = str;</span><br></pre></td></tr></table></figure>

<p>对应的内存结构为:</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/16_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/images/image-20200712211732976.png" alt="image-20200712211732976"></p>
<p>那么我们将 str = null; 则 原来堆中的对象也不会被回收，因为还有其它对象指向该区域</p>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>本例中的两个引用，都是强引用，强引用具备以下特点：</p>
<ul>
<li>强引用可以直接访问目标对象。</li>
<li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</li>
<li>强引用可能导致内存泄漏。</li>
</ul>
<h2 id="再谈引用：-软引用"><a href="#再谈引用：-软引用" class="headerlink" title="再谈引用： 软引用"></a>再谈引用： 软引用</h2><p>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<blockquote>
<p>注意，这里的第一次回收是不可达的对象</p>
</blockquote>
<p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。（mybatis的内部类的源码中使用了软引用）</p>
<p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p>
<p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p>
<blockquote>
<p>一句话概括：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象</p>
</blockquote>
<p>在JDK1.2版之后提供了SoftReference类来实现软引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// 创建一个软引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">//销毁强引用，这是必须的，不然会存在强引用和软引用</span></span><br></pre></td></tr></table></figure>

<p>匿名对象默认为软引用</p>
<h2 id="再谈引用：弱引用"><a href="#再谈引用：弱引用" class="headerlink" title="再谈引用：弱引用"></a>再谈引用：弱引用</h2><blockquote>
<p>发现即回收</p>
</blockquote>
<p>弱引用也是用来描述那些非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>
<p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p>
<p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>
<p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p>
<p>在JDK1.2版之后提供了WeakReference类来实现弱引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 声明强引用</span><br><span class="line">Object obj = new Object();</span><br><span class="line">// 创建一个弱引用</span><br><span class="line">WeakReference&lt;Object&gt; sf = new WeakReference&lt;&gt;(obj);</span><br><span class="line">obj = null; //销毁强引用，这是必须的，不然会存在强引用和弱引用</span><br></pre></td></tr></table></figure>

<p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</p>
<p>面试题：你开发中使用过WeakHashMap吗？</p>
<p>WeakHashMap用来存储图片信息，可以在内存不足的时候，及时回收，避免了OOM</p>
<h2 id="再谈引用：虚引用"><a href="#再谈引用：虚引用" class="headerlink" title="再谈引用：虚引用"></a>再谈引用：虚引用</h2><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个</p>
<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
<p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get（）方法取得对象时，总是null</p>
<p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</p>
<p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p>
<p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p>
<blockquote>
<p>虚引用无法获取到我们的数据</p>
</blockquote>
<p>在JDK1.2版之后提供了PhantomReference类来实现虚引用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 声明强引用</span><br><span class="line">Object obj = new Object();</span><br><span class="line">// 声明引用队列</span><br><span class="line">ReferenceQueue phantomQueue = new ReferenceQueue();</span><br><span class="line">// 声明虚引用（还需要传入引用队列）</span><br><span class="line">PhantomReference&lt;Object&gt; sf = new PhantomReference&lt;&gt;(obj, phantomQueue);</span><br><span class="line">obj = null; </span><br></pre></td></tr></table></figure>

<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p>我们使用一个案例，来结合虚引用，引用队列，finalize进行讲解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author: 陌溪</span><br><span class="line"> * @create: 2020-07-12-21:42</span><br><span class="line"> */</span><br><span class="line">public class PhantomReferenceTest &#123;</span><br><span class="line">    // 当前类对象的声明</span><br><span class="line">    public static PhantomReferenceTest obj;</span><br><span class="line">    // 引用队列</span><br><span class="line">    static ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = null;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">        System.out.println(&quot;调用当前类的finalize方法&quot;);</span><br><span class="line">        obj = this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">            while(true) &#123;</span><br><span class="line">                if (phantomQueue != null) &#123;</span><br><span class="line">                    PhantomReference&lt;PhantomReferenceTest&gt; objt = null;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.getStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (objt != null) &#123;</span><br><span class="line">                        System.out.println(&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t1&quot;);</span><br><span class="line">        thread.setDaemon(true);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        phantomQueue = new ReferenceQueue&lt;&gt;();</span><br><span class="line">        obj = new PhantomReferenceTest();</span><br><span class="line">        // 构造了PhantomReferenceTest对象的虚引用，并指定了引用队列</span><br><span class="line">        PhantomReference&lt;PhantomReferenceTest&gt; phantomReference = new PhantomReference&lt;&gt;(obj, phantomQueue);</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(phantomReference.get());</span><br><span class="line">            // 去除强引用</span><br><span class="line">            obj = null;</span><br><span class="line">            // 第一次进行GC，由于对象可复活，GC无法回收该对象</span><br><span class="line">            System.out.println(&quot;第一次GC操作&quot;);</span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            if (obj == null) &#123;</span><br><span class="line">                System.out.println(&quot;obj 是 null&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;obj 不是 null&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;第二次GC操作&quot;);</span><br><span class="line">            obj = null;</span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            if (obj == null) &#123;</span><br><span class="line">                System.out.println(&quot;obj 是 null&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;obj 不是 null&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">null</span><br><span class="line">第一次GC操作</span><br><span class="line">调用当前类的finalize方法</span><br><span class="line">obj 不是 null</span><br><span class="line">第二次GC操作</span><br><span class="line">追踪垃圾回收过程：PhantomReferenceTest实例被GC了</span><br><span class="line">obj 是 null</span><br></pre></td></tr></table></figure>

<p>从上述运行结果我们知道，第一次尝试获取虚引用的值，发现无法获取的，这是因为虚引用是无法直接获取对象的值，然后进行第一次gc，因为会调用finalize方法，将对象复活了，所以对象没有被回收，但是调用第二次gc操作的时候，因为finalize方法只能执行一次，所以就触发了GC操作，将对象回收了，同时将会触发第二个操作就是 将回收的值存入到引用队列中。</p>
<h2 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h2><p>它用于实现对象的finalize() 方法，也可以称为终结器引用</p>
<p>无需手动编码，其内部配合引用队列使用</p>
<p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象</p>
<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="GC分类与性能指标"><a href="#GC分类与性能指标" class="headerlink" title="GC分类与性能指标"></a>GC分类与性能指标</h2><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</p>
<p>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</p>
<p>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</p>
<blockquote>
<p>Java不同版本新特性</p>
<ul>
<li>语法层面：Lambda表达式、switch、自动拆箱装箱、enum</li>
<li>API层面：Stream API、新的日期时间、Optional、String、集合框架</li>
<li>底层优化：JVM优化、GC的变化、元空间、静态域、字符串常量池位置变化</li>
</ul>
</blockquote>
<h3 id="垃圾收集器分类"><a href="#垃圾收集器分类" class="headerlink" title="垃圾收集器分类"></a>垃圾收集器分类</h3><h4 id="按线程数分"><a href="#按线程数分" class="headerlink" title="按线程数分"></a><strong>按线程数分</strong></h4><p><strong>按线程数分</strong>（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713083030867.png" alt="image-20200713083030867"></p>
<p>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p>
<ul>
<li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中</li>
<li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</li>
</ul>
<p>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“stop-the-world”机制。</p>
<h4 id="按工作模式分"><a href="#按工作模式分" class="headerlink" title="按工作模式分"></a>按工作模式分</h4><p>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。</p>
<ul>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li>
<li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li>
</ul>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713083443486.png" alt="image-20200713083443486"></p>
<h4 id="按碎片处理方式分"><a href="#按碎片处理方式分" class="headerlink" title="按碎片处理方式分"></a>按碎片处理方式分</h4><p>按碎片处理方式分，可分为压缩武垃圾回收器和非压缩式垃圾回收器。</p>
<ul>
<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</li>
<li>非压缩式的垃圾回收器不进行这步操作。</li>
</ul>
<p>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</p>
<h3 id="评估GC的性能指标"><a href="#评估GC的性能指标" class="headerlink" title="评估GC的性能指标"></a>评估GC的性能指标</h3><ul>
<li><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</li>
<li><strong>垃圾收集开销</strong>：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>
<li><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间。</li>
<li><strong>收集频率</strong>：相对于应用程序的执行，收集操作发生的频率。</li>
<li><strong>内存占用</strong>：Java堆区所占的内存大小。</li>
<li><strong>快速</strong>：一个对象从诞生到被回收所经历的时间。</li>
</ul>
<p>吞吐量、暂停时间、内存占用 这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。 这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。 简单来说，主要抓住两点：</p>
<p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。 简单来说，主要抓住两点：</p>
<ul>
<li>吞吐量</li>
<li>暂停时间</li>
</ul>
<h3 id="性能指标：吞吐量"><a href="#性能指标：吞吐量" class="headerlink" title="性能指标：吞吐量"></a>性能指标：吞吐量</h3><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间）</p>
<blockquote>
<p>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
</blockquote>
<p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p>
<p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2+0.2=e.4</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713084726176.png" alt="image-20200713084726176"></p>
<h3 id="性能指标：暂停时间"><a href="#性能指标：暂停时间" class="headerlink" title="性能指标：暂停时间"></a>性能指标：暂停时间</h3><p>“暂停时间”是指一个时间段内应用程序线程暂停，让Gc线程执行的状态</p>
<p>例如，GC期间1ee毫秒的暂停时间意味着在这1e0毫秒期间内没有应用程序线程是活动的。暂停时间优先，意味着尽可能让单次STW的时间最短：0.1+0.1 + 0.1+ 0.1+ 0.1=0.5</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713085306400.png" alt="image-20200713085306400"></p>
<h3 id="吞吐量vs暂停时间"><a href="#吞吐量vs暂停时间" class="headerlink" title="吞吐量vs暂停时间"></a>吞吐量vs暂停时间</h3><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p>
<p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。</p>
<p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p>
<p>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。</p>
<p>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</p>
<p>在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p>
<p>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></p>
<h2 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h2><p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</p>
<p>那么，Java常见的垃圾收集器有哪些？</p>
<blockquote>
<p>GC垃圾收集器是和JVM一脉相承的，它是和JVM进行搭配使用，在不同的使用场景对应的收集器也是有区别</p>
</blockquote>
<h3 id="垃圾回收器发展史"><a href="#垃圾回收器发展史" class="headerlink" title="垃圾回收器发展史"></a>垃圾回收器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。</p>
<ul>
<li>1999年随JDK1.3.1一起来的是串行方式的serialGc，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</li>
<li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布·</li>
<li>Parallel GC在JDK6之后成为HotSpot默认GC。</li>
<li>2012年，在JDK1.7u4版本中，G1可用。</li>
<li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li>
<li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li>
<li>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li>
<li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。·2019年9月，JDK13发布。增强zGC，自动返回未用堆内存给操作系统。</li>
<li>2020年3月，JDK14发布。删除cMs垃圾回收器。扩展zGC在macos和Windows上的应用</li>
</ul>
<h3 id="7种经典的垃圾收集器"><a href="#7种经典的垃圾收集器" class="headerlink" title="7种经典的垃圾收集器"></a>7种经典的垃圾收集器</h3><ul>
<li>串行回收器：Serial、Serial old</li>
<li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li>
<li>并发回收器：CMS、G11</li>
</ul>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713093551365.png" alt="image-20200713093551365"></p>
<h3 id="7款经典收集器与垃圾分代之间的关系"><a href="#7款经典收集器与垃圾分代之间的关系" class="headerlink" title="7款经典收集器与垃圾分代之间的关系"></a>7款经典收集器与垃圾分代之间的关系</h3><p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713093757644.png" alt="image-20200713093757644"></p>
<p>新生代收集器：Serial、ParNew、Paralle1 Scavenge；</p>
<p>老年代收集器：Serial old、Parallel old、CMS；</p>
<p>整堆收集器：G1；</p>
<h3 id="垃圾收集器的组合关系"><a href="#垃圾收集器的组合关系" class="headerlink" title="垃圾收集器的组合关系"></a>垃圾收集器的组合关系</h3><p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713094745366.png" alt="image-20200713094745366"></p>
<ul>
<li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial old、Serial/CMS、ParNew/Serial old、ParNew/CMS、Parallel Scavenge/Serial 0ld、Parallel Scavenge/Parallel 01d、G1；</li>
<li>其中Serial o1d作为CMs出现”Concurrent Mode Failure”失败的后备预案。</li>
<li>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</li>
<li>（绿色虚线）JDK14中：弃用Paralle1 Scavenge和Serialold GC组合（JEP366）</li>
<li>（青色虚线）JDK14中：删除CMs垃圾回收器（JEP363）</li>
</ul>
<p>为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p>
<p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。</p>
<h3 id="如何查看默认垃圾收集器"><a href="#如何查看默认垃圾收集器" class="headerlink" title="如何查看默认垃圾收集器"></a>如何查看默认垃圾收集器</h3><p>-XX:+PrintcommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）</p>
<p>使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID</p>
<h2 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h2><p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</p>
<p>Serial收集器作为HotSpot中client模式下的默认新生代垃圾收集器。</p>
<p>Serial收集器采用复制算法、串行回收和”stop-the-World”机制的方式执行内存回收。</p>
<p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial old收集器。Serial old收集器同样也采用了串行回收和”stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。</p>
<ul>
<li>Serial old是运行在Client模式下默认的老年代的垃圾回收器</li>
<li>Serial 0ld在Server模式下主要有两个用途：<ul>
<li>与新生代的Parallel scavenge配合使用</li>
<li>作为老年代CMS收集器的后备垃圾收集方案</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713100703799.png" alt="image-20200713100703799"></p>
<p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</p>
<p>优势：简单而高效（与其他收集器的单线程比），对于限定单个cPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<p>运行在client模式下的虚拟机是个不错的选择。</p>
<p>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</p>
<p>在HotSpot虚拟机中，使用-XX：+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。</p>
<p>等价于新生代用Serial GC，且老年代用Serial old GC</p>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。</p>
<p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</p>
<h2 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h2><p>如果说serialGC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是serial收集器的多线程版本。</p>
<ul>
<li>Par是Parallel的缩写，New：只能处理的是新生代</li>
</ul>
<p>ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、”stop-the-World”机制。</p>
<p>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713102030127.png" alt="image-20200713102030127"></p>
<ul>
<li>对于新生代，回收次数频繁，使用并行方式高效。</li>
<li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li>
</ul>
<p>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比serial收集器更高效？</p>
<ul>
<li></li>
</ul>
<p>因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作</p>
<p>在程序中，开发人员可以通过选项”-XX：+UseParNewGC”手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p>
<p>-XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数。</p>
<h2 id="Parallel回收器：吞吐量优先"><a href="#Parallel回收器：吞吐量优先" class="headerlink" title="Parallel回收器：吞吐量优先"></a>Parallel回收器：吞吐量优先</h2><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和”Stop the World”机制。</p>
<p>那么Parallel 收集器的出现是否多此一举？</p>
<ul>
<li>和ParNew收集器不同，ParallelScavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器。</li>
<li>自适应调节策略也是Paralle1 Scavenge与ParNew一个重要区别。</li>
</ul>
<p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
<p>Paralle1收集器在JDK1.6时提供了用于执行老年代垃圾收集的Paralle1o1d收集器，用来代替老年代的serialold收集器。</p>
<p>Parallel old收集器采用了标记-压缩算法，但同样也是基于并行回收和”stop-the-World”机制。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713110359441.png" alt="image-20200713110359441"></p>
<p>在程序吞吐量优先的应用场景中，IParalle1收集器和Parallel old收集器的组合，在server模式下的内存回收性能很不错。在Java8中，默认是此垃圾收集器。</p>
<h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>-XX：+UseParallelGC 手动指定年轻代使用Paralle1并行收集器执行内存回收任务。</p>
<p>-XX：+UseParalleloldcc 手动指定老年代都是使用并行回收收集器。</p>
<ul>
<li>分别适用于新生代和老年代。默认jdk8是开启的。</li>
<li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li>
</ul>
<p>-XX:ParallelGcrhreads设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p>
<p>在默认情况下，当CPU数量小于8个，ParallelGcThreads的值等于CPU数量。</p>
<p>当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU核心Count]/8]</p>
<p>-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即STw的时间）。单位是毫秒。</p>
<p>为了尽可能地把停顿时间控制在MaxGCPauseMi11s以内，收集器在工作时会调整Java堆大小或者其他一些参数。 对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。该参数使用需谨慎。</p>
<p>-XX:GCTimeRatio垃圾收集时间占总时间的比例（=1/（N+1））。用于衡量吞吐量的大小。</p>
<p>取值范围（0，100）。默认值99，也就是垃圾回收时间不超过1。</p>
<p>与前一个-xx:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</p>
<p>-XX:+UseAdaptivesizepplicy 设置Parallel scavenge收集器具有自适应调节策略</p>
<p>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</p>
<p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMil1s），让虚拟机自己完成调优工作。</p>
<h2 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h2><p>在JDK1.5时期，Hotspot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：cMS（Concurrent-Mark-Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，<strong>它第一次实现了让垃圾收集线程与用户线程同时工作</strong>。</p>
<p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p>
<p>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p>
<p>CMS的垃圾收集算法采用标记-清除算法，并且也会”stop-the-world”</p>
<p>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</p>
<p>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713205154007.png" alt="image-20200713205154007"></p>
<p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及STW的阶段主要是：初始标记 和 重新标记)</p>
<ul>
<li><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是<strong>标记出GCRoots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</li>
<li><strong>并发标记</strong>（Concurrent-Mark）阶段：从Gc Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li>
<li><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li>
<li><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li>
</ul>
<p>尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。</p>
<p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p>
<p>另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p>
<p>CMS收集器的垃圾收集算法采用的是<strong>标记清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713212230352.png" alt="image-20200713212230352"></p>
<h3 id="CMS为什么不使用标记整理算法？"><a href="#CMS为什么不使用标记整理算法？" class="headerlink" title="CMS为什么不使用标记整理算法？"></a>CMS为什么不使用标记整理算法？</h3><p>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world” 这种场景下使用</p>
<h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><ul>
<li>并发收集</li>
<li>低延迟</li>
</ul>
<h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发FullGC。</li>
<li>CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li>
<li>CMS收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li>
</ul>
<h3 id="设置的参数"><a href="#设置的参数" class="headerlink" title="设置的参数"></a>设置的参数</h3><ul>
<li>-XX：+UseConcMarkSweepGC手动指定使用CMS收集器执行内存回收任务。</li>
</ul>
<p>开启该参数后会自动将-xx：+UseParNewGC打开。即：ParNew（Young区用）+CMS（01d区用）+Serial old的组合。</p>
<ul>
<li>-XX:CMSInitiatingoccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</li>
</ul>
<p>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次cMs回收。JDK6及以上版本默认值为92%</p>
<p>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Ful1Gc的执行次数。</p>
<ul>
<li>-XX：+UseCMSCompactAtFullCollection用于指定在执行完Ful1</li>
</ul>
<p>GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p>
<ul>
<li>-XX:CMSFullGCsBeforecompaction 设置在执行多少次Ful1GC后对内存空间进行压缩整理。</li>
<li>-XX:ParallelcMSThreads 设置cMs的线程数量。</li>
</ul>
<p>CMs默认启动的线程数是（Paralle1GCThreads+3）/4，ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</p>
<h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个Gc有什么不同呢？</p>
<p>请记住以下口令：</p>
<ul>
<li>如果你想要最小化地使用内存和并行开销，请选Serial GC；</li>
<li>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</li>
<li>如果你想要最小化GC的中断或停顿时间，请选CMs GC。</li>
</ul>
<h3 id="JDK后续版本中CMS的变化"><a href="#JDK后续版本中CMS的变化" class="headerlink" title="JDK后续版本中CMS的变化"></a>JDK后续版本中CMS的变化</h3><p><strong>JDK9新特性</strong>：CMS被标记为eprecate了（JEP291）&gt;如果对JDK9及以上版本的HotSpot虚拟机使用参数-XX： +UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</p>
<p>JDK14新特性：删除CMs垃圾回收器（JEP363）移除了CMS垃圾收集器，如果在JDK14中使用 XX：+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</p>
<h2 id="G1回收器：区域化分代式"><a href="#G1回收器：区域化分代式" class="headerlink" title="G1回收器：区域化分代式"></a>G1回收器：区域化分代式</h2><h3 id="既然我们已经有了前面几个强大的GC，为什么还要发布Garbage-First（G1）？"><a href="#既然我们已经有了前面几个强大的GC，为什么还要发布Garbage-First（G1）？" class="headerlink" title="既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？"></a>既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？</h3><p>原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p>
<p>与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p>
<p><strong>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望</strong>。</p>
<h3 id="为什么名字叫-Garbage-First-G1-呢？"><a href="#为什么名字叫-Garbage-First-G1-呢？" class="headerlink" title="为什么名字叫 Garbage First(G1)呢？"></a>为什么名字叫 Garbage First(G1)呢？</h3><p>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</p>
<p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p>
<p>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。</p>
<p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</p>
<p>在JDK1.7版本正式启用，移除了Experimenta1的标识，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Paralle1+Parallel old组合。被orac1e官方称为“全功能的垃圾收集器”。</p>
<p>与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。在jdk8中还不是默认的垃圾回收器，需要使用-xx：+UseG1GC来启用。</p>
<h3 id="G1垃圾收集器的优点"><a href="#G1垃圾收集器的优点" class="headerlink" title="G1垃圾收集器的优点"></a>G1垃圾收集器的优点</h3><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p>
<p><strong>并行与并发</strong></p>
<ul>
<li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li>
<li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>
</ul>
<p><strong>分代收集</strong></p>
<ul>
<li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>
<li>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li>
<li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li>
</ul>
<p>G1所谓的分代，已经不是下面这样的了</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713215105293.png" alt="image-20200713215105293"></p>
<p>而是这样的一个区域</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713215133839.png" alt="image-20200713215133839"></p>
<p><strong>空间整合</strong></p>
<ul>
<li>CMS：“标记-清除”算法、内存碎片、若干次Gc后进行一次碎片整理</li>
<li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li>
</ul>
<p><strong>可预测的停顿时间模型（即：软实时soft real-time）</strong> 这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>
<ul>
<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</li>
<li>相比于CMSGC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
<h3 id="G1垃圾收集器的缺点"><a href="#G1垃圾收集器的缺点" class="headerlink" title="G1垃圾收集器的缺点"></a>G1垃圾收集器的缺点</h3><p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</p>
<p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</p>
<h3 id="G1参数设置"><a href="#G1参数设置" class="headerlink" title="G1参数设置"></a>G1参数设置</h3><ul>
<li>-XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务</li>
<li>-XX:G1HeapRegionSize设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</li>
<li>-XX:MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</li>
<li>-XX:+ParallelGcThread 设置STW工作线程数的值。最多设置为8</li>
<li>-XX:ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1/4左右。</li>
<li>-XX:InitiatingHeapoccupancyPercent 设置触发并发Gc周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</li>
</ul>
<h3 id="G1收集器的常见操作步骤"><a href="#G1收集器的常见操作步骤" class="headerlink" title="G1收集器的常见操作步骤"></a>G1收集器的常见操作步骤</h3><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p>
<ul>
<li>第一步：开启G1垃圾收集器</li>
<li>第二步：设置堆的最大内存</li>
<li>第三步：设置最大的停顿时间</li>
</ul>
<p>G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Fu11GC，在不同的条件下被触发。</p>
<h3 id="G1收集器的适用场景"><a href="#G1收集器的适用场景" class="headerlink" title="G1收集器的适用场景"></a>G1收集器的适用场景</h3><p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p>
<p>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；</p>
<p>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于e.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次Gc停顿时间不会过长）。 用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用61可能比CMS好：</p>
<ul>
<li>超过5e%的Java堆被活动数据占用；</li>
<li>对象分配频率或年代提升频率变化很大；</li>
<li>GC停顿时间过长（长于e.5至1秒）</li>
</ul>
<p>HotSpot垃圾收集器里，除了61以外，其他的垃圾收集器使用内置的JVM线程执行Gc的多线程操作，而G1GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p>
<h3 id="分区Region：化整为零"><a href="#分区Region：化整为零" class="headerlink" title="分区Region：化整为零"></a>分区Region：化整为零</h3><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过</p>
<p>XX:G1HeapRegionsize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p>
<p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713223244886.png" alt="image-20200713223244886"></p>
<p>一个region有可能属于Eden，Survivor或者old/Tenured内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于survivor内存区域，o表示属于01d内存区域。图中空白的表示未使用的内存空间。</p>
<p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过50%region，就放到H。</p>
<p><strong>设置H的原因：</strong>对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Fu11Gc。G1的大多数行为都把H区作为老年代的一部分来看待。</p>
<p>每个Region都是通过指针碰撞来分配空间</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713223509993.png" alt="image-20200713223509993"></p>
<h3 id="G1垃圾回收器的回收过程"><a href="#G1垃圾回收器的回收过程" class="headerlink" title="G1垃圾回收器的回收过程"></a>G1垃圾回收器的回收过程</h3><p>G1GC的垃圾回收过程主要包括如下三个环节：</p>
<ul>
<li>年轻代GC（Young GC）</li>
<li>老年代并发标记过程（Concurrent Marking）</li>
<li>混合回收（Mixed GC）</li>
</ul>
<p>（如果需要，单线程、独占式、高强度的Fu11GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713224113996.png" alt="image-20200713224113996"></p>
<p>顺时针，young gc-&gt;young gc+concurrent mark-&gt;Mixed GC顺序，进行垃圾回收。</p>
<p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年  区间，也有可能是两个区间都会涉及。</p>
<p>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p>
<p>标记完成马上开始混合回收过程。对于一个混合回收期，G1GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p>
<p>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p>
<h3 id="Remembered-Set（记忆集）"><a href="#Remembered-Set（记忆集）" class="headerlink" title="Remembered Set（记忆集）"></a>Remembered Set（记忆集）</h3><p>一个对象被不同区域引用的问题</p>
<p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p>
<p>在其他的分代收集器，也存在这样的问题（而G1更突出）回收新生代也不得不同时扫描老年代？这样的话会降低MinorGC的效率；</p>
<p><strong>解决方法：</strong></p>
<p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：</p>
<p>每个Region都有一个对应的Remembered Set；每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</p>
<p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；如果不同，通过cardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713224716715.png" alt="image-20200713224716715"></p>
<h3 id="G1回收过程-年轻代GC"><a href="#G1回收过程-年轻代GC" class="headerlink" title="G1回收过程-年轻代GC"></a>G1回收过程-年轻代GC</h3><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p>
<p>YGC时，首先G1停止应用程序的执行（stop-The-Wor1d），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713225100632.png" alt="image-20200713225100632"></p>
<p>然后开始如下回收过程：</p>
<ul>
<li>第一阶段，扫描根</li>
</ul>
<p>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p>
<ul>
<li>第二阶段，更新RSet</li>
</ul>
<p>处理dirty card queue（见备注）中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。</p>
<ul>
<li>第三阶段，处理RSet</li>
</ul>
<p>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p>
<ul>
<li>第四阶段，复制对象。</li>
</ul>
<p>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到o1d区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</p>
<ul>
<li>第五阶段，处理引用</li>
</ul>
<p>处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p>
<h3 id="G1回收过程-并发标记过程"><a href="#G1回收过程-并发标记过程" class="headerlink" title="G1回收过程-并发标记过程"></a>G1回收过程-并发标记过程</h3><ul>
<li>初始标记阶段：标记从根节点直接可达的对象。这个阶段是sTw的，并且会触发一次年轻代GC。</li>
<li>根区域扫描（Root Region Scanning）：G1 Gc扫描survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在youngGC之前完成。</li>
<li>并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被youngGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li>
<li>再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li>
<li>独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是sTw的。这个阶段并不会实际上去做垃圾的收集</li>
<li>并发清理阶段：识别并清理完全空闲的区域。</li>
</ul>
<h3 id="G1回收过程-混合回收"><a href="#G1回收过程-混合回收" class="headerlink" title="G1回收过程 - 混合回收"></a>G1回收过程 - 混合回收</h3><p>当越来越多的对象晋升到老年代o1d region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个old GC，除了回收整个Young Region，还会回收一部分的old Region。这里需要注意：<strong>是一部分老年代，而不是全部老年代</strong>。可以选择哪些o1d Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713225810871.png" alt="image-20200713225810871"></p>
<p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收</p>
<p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p>
<p>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，</p>
<p>XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p>
<p>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为1e%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于1e%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</p>
<h3 id="G1回收可选的过程4-Full-GC"><a href="#G1回收可选的过程4-Full-GC" class="headerlink" title="G1回收可选的过程4 - Full GC"></a>G1回收可选的过程4 - Full GC</h3><p>G1的初衷就是要避免Fu11GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（stop-The-world），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>
<p>要避免Fu11GC的发生，一旦发生需要进行调整。什么时候会发生Ful1GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到ful1gc，这种情况可以通过增大内存解决。 导致61Fu11GC的原因可能有两个：</p>
<ul>
<li>EVacuation的时候没有足够的to-space来存放晋升的对象；</li>
<li>并发处理过程完成之前空间耗尽。</li>
</ul>
<h3 id="G1回收的优化建议"><a href="#G1回收的优化建议" class="headerlink" title="G1回收的优化建议"></a>G1回收的优化建议</h3><p>从oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>
<p>年轻代大小</p>
<ul>
<li>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小</li>
<li>固定年轻代的大小会覆盖</li>
</ul>
<p>暂停时间目标暂停时间目标不要太过严苛</p>
<ul>
<li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li>
<li>评估G1GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>
</ul>
<h2 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h2><p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714075738203.png" alt="image-20200714075738203"></p>
<p>GC发展阶段：Seria l=&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC</p>
<p>不同厂商、不同版本的虚拟机实现差距比较大。HotSpot虚拟机在JDK7/8后所有收集器及组合如下图</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714080151020.png" alt="image-20200714080151020"></p>
<h3 id="怎么选择垃圾回收器"><a href="#怎么选择垃圾回收器" class="headerlink" title="怎么选择垃圾回收器"></a>怎么选择垃圾回收器</h3><p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。怎么选择垃圾收集器？</p>
<ul>
<li>优先调整堆的大小让JVM自适应完成。</li>
<li>如果内存小于100M，使用串行收集器</li>
<li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li>
<li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li>
<li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li>
<li>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li>
</ul>
<p>最后需要明确一个观点：</p>
<ul>
<li>没有最好的收集器，更没有万能的收集</li>
<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>
</ul>
<h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。 这里较通用、基础性的部分如下：</p>
<p>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</p>
<p>垃圾收集器工作的基本流程。</p>
<p>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</p>
<h2 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h2><p>通过阅读Gc日志，我们可以了解Java虚拟机内存分配与回收策略。 内存分配与垃圾回收的参数列表</p>
<ul>
<li>-XX:+PrintGc输出GC日志。类似：-verbose:gc</li>
<li>-XX:+PrintGcDetails输出Gc的详细日志</li>
<li>-XX:+PrintGcTimestamps 输出Gc的时间戳（以基准时间的形式）</li>
<li>-XX:+PrintGCDatestamps 输出Gc的时间戳（以日期的形式，如2013-05-04T21：53：59.234+0800）</li>
<li>-XX:+PrintHeapAtGC在进行Gc的前后打印出堆的信息</li>
<li>-Xloggc:../logs/gc.1og日志文件的输出路径</li>
</ul>
<h3 id="verbose-gc"><a href="#verbose-gc" class="headerlink" title="verbose:gc"></a>verbose:gc</h3><p>打开GC日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-verbose:gc</span><br></pre></td></tr></table></figure>

<p>这个只会显示总的GC堆的变化，如下：</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714081610474.png" alt="image-20200714081610474"></p>
<p>参数解析</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714081622526.png" alt="image-20200714081622526"></p>
<h3 id="PrintGCDetails"><a href="#PrintGCDetails" class="headerlink" title="PrintGCDetails"></a>PrintGCDetails</h3><p>打开GC日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-verbose:gc -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<p>输入信息如下</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714081909309.png" alt="image-20200714081909309"></p>
<p>参数解析</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714081925767.png" alt="image-20200714081925767"></p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul>
<li>[GC”和”[Fu11GC”说明了这次垃圾收集的停顿类型，如果有”Fu11”则说明GC发生了”stop The World”</li>
<li>使用Seria1收集器在新生代的名字是Default New Generation，因此显示的是”[DefNew”</li>
<li>使用ParNew收集器在新生代的名字会变成”[ParNew”，意思是”Parallel New Generation”</li>
<li>使用Paralle1 scavenge收集器在新生代的名字是”[PSYoungGen”</li>
<li>老年代的收集和新生代道理一样，名字也是收集器决定的</li>
<li>使用G1收集器的话，会显示为”garbage-first heap”</li>
</ul>
<p>Allocation Failure表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p>
<p>[PSYoungGen：5986K-&gt;696K（8704K）]5986K-&gt;704K（9216K）中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</p>
<p>user代表用户态回收耗时，sys内核态回收耗时，rea实际耗时。由于多核的原因，时间总和可能会超过rea1时间</p>
<h3 id="Young-GC图片"><a href="#Young-GC图片" class="headerlink" title="Young GC图片"></a>Young GC图片</h3><p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714082555688.png" alt="image-20200714082555688"></p>
<h3 id="FullGC图片、"><a href="#FullGC图片、" class="headerlink" title="FullGC图片、"></a>FullGC图片、</h3><p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714082714690.png" alt="image-20200714082714690"></p>
<h3 id="GC回收举例"><a href="#GC回收举例" class="headerlink" title="GC回收举例"></a>GC回收举例</h3><p>我们编写一个程序，用来说明GC收集的过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * GC垃圾收集过程</span><br><span class="line"> * @author: 陌溪</span><br><span class="line"> * @create: 2020-07-14-8:35</span><br><span class="line"> */</span><br><span class="line">public class GCUseTest &#123;</span><br><span class="line">    static final Integer _1MB = 1024 * 1024;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        byte [] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = new byte[2 *_1MB];</span><br><span class="line">        allocation2 = new byte[2 *_1MB];</span><br><span class="line">        allocation3 = new byte[2 *_1MB];</span><br><span class="line">        allocation4 = new byte[4 *_1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们设置JVM启动参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<p>首先我们会将3个2M的数组存放到Eden区，然后后面4M的数组来了后，将无法存储，因为Eden区只剩下2M的剩余空间了，那么将会进行一次Young GC操作，将原来Eden区的内容，存放到Survivor区，但是Survivor区也存放不下，那么就会直接晋级存入Old 区</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714083332238.png" alt="image-20200714083332238"></p>
<p>然后我们将4M对象存入到Eden区中</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714083526790.png" alt="image-20200714083526790"></p>
<p>可以用一些工具去分析这些GC日志</p>
<p>常用的日志分析工具有：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat等</p>
<p><strong>GCViewer</strong></p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714084921184.png" alt="image-20200714084921184"></p>
<p><strong>GC easy</strong></p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714084726824.png" alt="image-20200714084726824"></p>
<h2 id="垃圾回收器的新发展"><a href="#垃圾回收器的新发展" class="headerlink" title="垃圾回收器的新发展"></a>垃圾回收器的新发展</h2><p>GC仍然处于飞速发展之中，目前的默认选项G1GC在不断的进行改进，很多我们原来认为的缺点，例如串行的Fu11GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK10以后，Fu11GC已经是并行运行，在很多场景下，其表现还略优于ParallelGC的并行Ful1GC实现。</p>
<p>即使是SerialGC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在serverless等新的应用场景下，Serial Gc找到了新的舞台。</p>
<p>比较不幸的是CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除</p>
<p>Epsilon:A No-Op GarbageCollector（Epsilon垃圾回收器，”No-Op（无操作）”回收器）<a href="http://openidk.iava.net/iep">http://openidk.iava.net/iep</a> s/318</p>
<p>ZGC:A Scalable Low-Latency Garbage Collector（Experimental）（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段）</p>
<p>现在G1回收器已成为默认回收器好几年了。我们还看到了引入了两个新的收集器：ZGC（JDK11出现）和Shenandoah（Open JDK12）</p>
<blockquote>
<p>主打特点：低停顿时间</p>
</blockquote>
<h3 id="Open-JDK12的Shenandoash-GC"><a href="#Open-JDK12的Shenandoash-GC" class="headerlink" title="Open JDK12的Shenandoash GC"></a>Open JDK12的Shenandoash GC</h3><p>Open JDK12的shenandoash GC：低停顿时间的GC（实验性）</p>
<p>Shenandoah，无疑是众多GC中最孤独的一个。是第一款不由oracle公司团队领导开发的Hotspot垃圾收集器。不可避免的受到官方的排挤。比如号称openJDK和OracleJDk没有区别的Oracle公司仍拒绝在oracleJDK12中支持Shenandoah。</p>
<p>Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，旨在针对JVM上的内存回收实现低停顿的需求。在2014年贡献给OpenJDK。</p>
<p>Red Hat研发Shenandoah团队对外宣称，Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714090608807.png" alt="image-20200714090608807"></p>
<p>这是RedHat在2016年发表的论文数据，测试内容是使用Es对200GB的维基百科数据进行索引。从结果看：</p>
<blockquote>
<p>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。 而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</p>
</blockquote>
<p>总结</p>
<ul>
<li>shenandoah Gc的弱项：高运行负担下的吞吐量下降。</li>
<li>shenandoah GC的强项：低延迟时间。</li>
</ul>
<h3 id="革命性的ZGC"><a href="#革命性的ZGC" class="headerlink" title="革命性的ZGC"></a>革命性的ZGC</h3><p>zGC与shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</p>
<p>《深入理解Java虚拟机》一书中这样定义zGC：2GC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。</p>
<p>ZGC的工作过程可以分为4个阶段：<strong>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</strong> 等。</p>
<p>ZGC几乎在所有地方并发执行的，除了初始标记的是STw的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714091201073.png" alt="image-20200714091201073"></p>
<p>停顿时间对比</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714091401511.png" alt="image-20200714091401511"></p>
<p>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。 未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714093243028.png" alt="image-20200714093243028"></p>
<p>JDK14之前，2GC仅Linux才支持。</p>
<p>尽管许多使用zGc的用户都使用类Linux的环境，但在Windows和macos上，人们也需要zGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，2GC特性被移植到了Windows和macos上。</p>
<p>现在mac或Windows上也能使用zGC了，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+UnlockExperimentalVMOptions-XX：+UseZGC</span><br></pre></td></tr></table></figure>

<h3 id="AliGC"><a href="#AliGC" class="headerlink" title="AliGC"></a>AliGC</h3><p>AliGC是阿里巴巴JVM团队基于G1算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p>
<p><img src="https://gitee.com/hellolvzi/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714093604012.png" alt="image-20200714093604012"></p>
<p>当然，其它厂商也提供了各种别具一格的GC实现，例如比较有名的低延迟GC Zing</p>
]]></content>
      <categories>
        <category>jvm</category>
        <category>jvm理论</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Phaser</title>
    <url>/3937b410.html</url>
    <content><![CDATA[<h1 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">以下从java jdk1<span class="number">.8</span>的api中摘录</span><br></pre></td></tr></table></figure>

<p>​        一个可重复使用的同步屏障，功能类似于CyclicBarrier和CountDownLatch，但支持更灵活的使用。</p>
<h3 id="注册机制"><a href="#注册机制" class="headerlink" title="注册机制"></a>注册机制</h3><p>​        与其他barrier的情况不同，Phaser中的“注册的同步者（parties）”会随时间而变化。Phaser可以通过构造器初始化parties个数，也可以在Phaser运行期间随时加入（register）新的parties，以及在运行期间注销（deregister）parties。运行时可以随时加入、注销parties，只会影响Phaser内部的计数器，它建立任何内部的bookkeeping（账本），因此task不能查询自己是否已经注册了，当然你可以通过实现子类来达成这一设计要求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码  </span></span><br><span class="line">Phaser phaser =<span class="keyword">new</span> Phaser();  </span><br><span class="line">phaser.register();<span class="comment">//parties count: 1  </span></span><br><span class="line">....  </span><br><span class="line">phaser.arriveAndDeregister():<span class="comment">//count : 0;  </span></span><br><span class="line">....  </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>CyclicBarrier、CountDownLatch需要在初始化的构造函数中指定同步者的个数，且运行时无法再次调整。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">12</span>);  </span><br><span class="line"><span class="comment">//count deregister parties after all  </span></span><br><span class="line"><span class="comment">//parties count is 12 all the times  </span></span><br><span class="line"><span class="comment">//if you want change the number of parties, you should create a new instance.  </span></span><br><span class="line">CyclicBarrier cyclicBarrier =<span class="keyword">new</span> CyclicBarrier(<span class="number">12</span>);  </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h3><p>​    类似于CyclicBarrier，Phaser也可以awaited多次，它的arrivedAndAwaitAdvance()方法的效果类似于CyclicBarrier的await()。Phaser的每个周期（generation）都有一个phase数字，phase 从0开始，当所有的已注册的parties都到达后（arrive）将会导致此phase数字自增（advance），当达到Integer.MAX_VALUE后继续从0开始。这个phase数字用于表示当前parties所处于的“阶段周期”，它既可以标记和控制parties的wait行为、唤醒等待的时机。</p>
<h4 id="到达"><a href="#到达" class="headerlink" title="到达"></a>到达</h4><p>​        Phaser中的arrive()、arriveAndDeregister()方法，这两个方法不会阻塞（block），但是会返回相应的phase数字，当此phase中最后一个party也arrive以后，phase数字将会增加，即phase进入下一个周期，同时触发（onAdvance）那些阻塞在上一phase的线程。这一点类似于CyclicBarrier的barrier到达机制；更灵活的是，我们可以通过重写onAdvance方法来实现更多的触发行为。</p>
<h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><p>​    Phaser中的awaitAdvance()方法，需要指定一个phase数字，表示此Thread阻塞直到phase推进到此周期，<code>arriveAndAwaitAdvance()方法阻塞到下一周期开始（或者当前phase结束）。</code>不像CyclicBarrier，即使等待Thread已经interrupted，awaitAdvance方法会继续等待。Phaser提供了Interruptible和Timout的阻塞机制，不过当线程Interrupted或者timout之后将会抛出异常，而不会修改Phaser的内部状态。如果必要的话，你可以在遇到此类异常时，进行相应的恢复操作，通常是在调用forceTermination()方法之后。</p>
<p>Phaser通常在ForJoinPool中执行tasks，它可以在有task阻塞等待advance时，确保其他tasks的充分并行能力。</p>
<h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h4><p>​        Phaser可以进入Termination状态，可以通过isTermination()方法判断；当Phaser被终止后，所有的同步方法将会立即返回（解除阻塞），不需要等到advance（即advance也会解除阻塞），且这些阻塞方法将会返回一个负值的phase值（awaitAdvance方法、arriveAndAwaitAdvance方法）。当然，向一个termination状态的Phaser注册party将不会有效；此时onAdvance()方法也将会返回true（默认实现），即所有的parties都会被deregister，即register个数为0。</p>
<h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><p>​        Phaser可以“分层”，以tree的方式构建Phaser来降低“竞争”。如果一个Phaser中有大量parties，这会导致严重的同步竞争，所以我们可以将它们分组并共享一个parent Phaser，这样可以提高吞吐能力；Phaser中注册和注销parties都会有Child 和parent Phaser自动管理。当Child Phaser中注册的parties变为非0时（在构造函数Phaser(Phaser parent,int parties)，或者register()方法），Child Phaser将会注册到其Parent上；当Child Phaser中的parties变为0时（比如由arrivedAndDegister()方法），那么此时Child Phaser也将从其parent中注销出去。</p>
<h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><p>​        同步的方法只会被register操作调用，对于当前state的监控方法可以在任何时候调用，比如getRegisteredParties()获取已经注册的parties个数，getPhase()获取当前phase周期数等；因为这些方法并非同步，所以只能反映当时的瞬间状态。</p>
<h3 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runTasks</span><span class="params">(List&lt;Runnable&gt; tasks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">1</span>); <span class="comment">// &quot;1&quot; to register self</span></span><br><span class="line">        <span class="comment">// create and start threads</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Runnable task : tasks) &#123;</span><br><span class="line">            phaser.register();</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    phaser.arriveAndAwaitAdvance(); <span class="comment">// await all creation</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// allow threads to start and deregister self</span></span><br><span class="line">        phaser.arriveAndDeregister();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startTasks</span><span class="params">(List&lt;Runnable&gt; tasks, <span class="keyword">final</span> <span class="keyword">int</span> iterations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> phase &gt;= iterations || registeredParties == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        phaser.register();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Runnable task : tasks) &#123;</span><br><span class="line">            phaser.register();</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                        phaser.arriveAndAwaitAdvance();</span><br><span class="line">                    &#125; <span class="keyword">while</span> (!phaser.isTerminated());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        phaser.arriveAndDeregister(); <span class="comment">// deregister self, don&#x27;t wait</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitPhase</span><span class="params">(Phaser phaser, <span class="keyword">int</span> phase)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = phaser.register(); <span class="comment">// assumes caller not already registered</span></span><br><span class="line">        <span class="keyword">while</span> (p &lt; phase) &#123;</span><br><span class="line">            <span class="keyword">if</span> (phaser.isTerminated()) &#123;</span><br><span class="line">                <span class="comment">// ... deal with unexpected termination</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = phaser.arriveAndAwaitAdvance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        phaser.arriveAndDeregister();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><h4 id="public-Phaser"><a href="#public-Phaser" class="headerlink" title="public Phaser()"></a>public Phaser()</h4><p>Creates a new phaser with no initially registered parties, no parent, and initial phase number 0. Any thread using this phaser will need to first register for it.</p>
<p>创建一个没有初始化值得phaser，初始阶段为0，没有parent的phaser（就是可以根据一个phaser来生成一个phaser）,之后任何线程要使用必须先注册。</p>
<h4 id="public-Phaser-int-parties"><a href="#public-Phaser-int-parties" class="headerlink" title="public Phaser(int parties)"></a>public Phaser(int parties)</h4><p>Creates a new phaser with the given number of registered  unarrived parties, no parent, and initial phase number 0.</p>
<p>创建指定数量parties的Phaser，初始阶段为0</p>
<h4 id="public-Phaser-Phaser-parent-int-parties"><a href="#public-Phaser-Phaser-parent-int-parties" class="headerlink" title="public Phaser(Phaser parent,int parties)"></a>public Phaser(Phaser parent,int parties)</h4><p>Creates a new phaser with the given parent and number of  registered unarrived parties. When the given parent is non-null and the given  number of parties is greater than zero, this child phaser is registered with its  parent.</p>
<p>根据phaser创建一个phaser，并且能够指定注册的parties数量</p>
<h4 id="public-Phaser-Phaser-parent"><a href="#public-Phaser-Phaser-parent" class="headerlink" title="public Phaser(Phaser parent)"></a>public Phaser(Phaser parent)</h4><p>相当于Phaser(parent，0)</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPhaser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">static</span> MarriagePhase phaser =  <span class="keyword">new</span> MarriagePhase();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        phaser.bulkRegister(<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Person(<span class="string">&quot;P&quot;</span>+i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Person(<span class="string">&quot;新娘&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Person(<span class="string">&quot;新郎&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MarriagePhase</span> <span class="keyword">extends</span> <span class="title">Phaser</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (phase)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;所有人都到齐了&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;所有人都吃完了&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;所有人都离开了&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;婚礼结束了&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// phrase中的阶段控制主要是这里面的阶段控制</span></span><br><span class="line">            arrive();</span><br><span class="line">            eat();</span><br><span class="line">            leave();</span><br><span class="line">            hug();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arrive</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">                System.out.println(name+<span class="string">&quot;到达现场&quot;</span>);</span><br><span class="line">                <span class="comment">// 阶段控制实际上是这个产生效果，arriveAndAwaitAdvance说明到达了</span></span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">                System.out.println(name+<span class="string">&quot;吃完&quot;</span>);</span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leave</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">                System.out.println(name+<span class="string">&quot;离开&quot;</span>);</span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hug</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;新郎&quot;</span>.equals(name) || <span class="string">&quot;新娘&quot;</span>.equals(name))&#123;</span><br><span class="line">                    Thread.sleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">                    System.out.println(name+<span class="string">&quot;拥抱&quot;</span>);</span><br><span class="line">                    phaser.arriveAndAwaitAdvance();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    phaser.arriveAndDeregister();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">P0到达现场</span><br><span class="line">新郎到达现场</span><br><span class="line">P1到达现场</span><br><span class="line">P2到达现场</span><br><span class="line">新娘到达现场</span><br><span class="line">P3到达现场</span><br><span class="line">P4到达现场</span><br><span class="line">所有人都到齐了</span><br><span class="line">P1吃完</span><br><span class="line">P0吃完</span><br><span class="line">新娘吃完</span><br><span class="line">P3吃完</span><br><span class="line">新郎吃完</span><br><span class="line">P2吃完</span><br><span class="line">P4吃完</span><br><span class="line">所有人都吃完了</span><br><span class="line">P4离开</span><br><span class="line">P3离开</span><br><span class="line">P2离开</span><br><span class="line">新娘离开</span><br><span class="line">P1离开</span><br><span class="line">P0离开</span><br><span class="line">新郎离开</span><br><span class="line">所有人都离开了</span><br><span class="line">新郎拥抱</span><br><span class="line">新娘拥抱</span><br><span class="line">婚礼结束了</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<p>参考文章：</p>
<p><a href="https://blog.csdn.net/m0_37556444/article/details/98784594?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4.no_search_link&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/m0_37556444/article/details/98784594?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4.no_search_link&amp;spm=1001.2101.3001.4242</a></p>
]]></content>
      <categories>
        <category>多线程</category>
        <category>多线程理论篇</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Semaphore</title>
    <url>/4bbf9af.html</url>
    <content><![CDATA[<h1 id="深入理解Semaphore"><a href="#深入理解Semaphore" class="headerlink" title="深入理解Semaphore"></a>深入理解Semaphore</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">以下从java jdk1<span class="number">.8</span>的api中摘录</span><br></pre></td></tr></table></figure>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Semaphore：一个计数信号量。在概念上，信号量维持一组许可证。如果有必要，每个acquire（）都会阻塞，直到许可证可用，然后才能使用它。每个release（）添加许可证（<strong>只要调用这个方法就会添加，在写项目的时候要注意这个问题</strong>），潜在的释放阻塞获取地方。</p>
<ul>
<li>信号量通常用于限制线程数，而不是访问某些（物理或逻辑）资源</li>
</ul>
<p>例如，这是一个使用信号量来控制对一个项目池的访问的类：</p>
<span id="more"></span>

<h2 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h2><p>对这个pool类进行了改造，验证线程池的可用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AVAILABLE = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore available = <span class="keyword">new</span> Semaphore(MAX_AVAILABLE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        available.acquire();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;拿到了一个锁&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> getNextAvailableItem();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putItem</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (markAsUnused(x)) &#123;</span><br><span class="line">            available.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not a particularly efficient data structure; just for demo</span></span><br><span class="line">    <span class="keyword">protected</span> Object[] items = <span class="keyword">new</span> Object[MAX_AVAILABLE];</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_AVAILABLE];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Object <span class="title">getNextAvailableItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> items[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// not reached</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">markAsUnused</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item == items[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                    used[i] = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pool pool = <span class="keyword">new</span> Pool();</span><br><span class="line">        AtomicInteger coutn = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                Object item = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    item = pool.getItem();</span><br><span class="line">                    System.out.println(<span class="string">&quot;                      拿到锁的数量&quot;</span> + coutn.addAndGet(<span class="number">1</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    pool.putItem(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">线程：Thread-<span class="number">199</span>拿到了一个锁</span><br><span class="line">                      拿到锁的数量<span class="number">199</span></span><br><span class="line">                      拿到锁的数量<span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>​        在获得项目前，每个线程必须从信号量获取许可证，以确保某个项目可用。当线程完成该项目后，它将返回到池中，并将许可证返回到信号量，允许另一个线程获取该项目。请注意，当调用acquire（）时，不会保持同步锁定，因为这将阻止某个项目返回到池中。信号量封装了限制对池的访问所需的同步，与保持池本身一致性所需的任何同步分开。</p>
<p>​        信号量被初始化为一个，并且被使用，使得它只有至多一个允许可用，可以用作互斥锁。 这通常被称为<em>二进制信号量</em>  ，因为它只有两个状态：一个许可证可用，或零个许可证可用。 当以这种方式使用时，二进制信号量具有属性（与许多<code>Lock</code>实现不同），“锁”可以由除所有者之外的线程释放（因为信号量没有所有权概念）。  这在某些专门的上下文中是有用的，例如死锁恢复。</p>
<p>​        此类的构造函数可选择接受<em>公平</em>参数。  当设置为false时，此类不会保证线程获取许可的顺序。 特别是，  <em>闯入</em>是允许的，也就是说，一个线程调用<code>acquire()</code>可以提前已经等待线程分配的许可证-在等待线程队列的头部逻辑新的线程将自己。  当公平设置为true时，信号量保证调用<code>acquire</code>方法的线程被选择以按照它们调用这些方法的顺序获得许可（先进先出;  FIFO）。 请注意，FIFO排序必须适用于这些方法中的特定内部执行点。  因此，一个线程可以在另一个线程之前调用<code>acquire</code>  ，但是在另一个线程之后到达排序点，并且类似地从方法返回。 另请注意， 未定义的<code>tryAcquire</code>方法不符合公平性设置，但将采取任何可用的许可证。 </p>
<p>​        通常，用于控制资源访问的信号量应该被公平地初始化，以确保线程没有被访问资源。  当使用信号量进行其他类型的同步控制时，非正常排序的吞吐量优势往往超过公平性。 </p>
<p>本课程还提供了方便的方法，一次acquire和release多个许可证。<strong>当没有公平的使用这些方法是，请注意无限期延期的风险。</strong></p>
<h3 id="Semaphore经常和线程池做对比"><a href="#Semaphore经常和线程池做对比" class="headerlink" title="Semaphore经常和线程池做对比"></a>Semaphore经常和线程池做对比</h3><h4 id="semaphore"><a href="#semaphore" class="headerlink" title="semaphore"></a>semaphore</h4><p>​        semaphore称为信号量，是<code>java.util.concurrent</code>一个并发工具类，用来控制可同时并发的线程数，器内部维护了一组虚拟许可，通过构造器指定许可的数量。线程在执行时，需要通过<code>acquire（）</code>获取许可后才能执行，如果无法获取许可，则线程将一直等待；线程执行完后需要通过<code>release（）</code>释放许可，以使的其他线程可以获取许可。</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>​        线程池也是一种控制任务并发和执行的方式，通过线程复用的方式来减小平凡创建和销毁线程带来的开销。一般线程池课同时工作的线程数量是一定的，超过该数量的线程需要进入线程队列等待，直到有可用的工作线程来执行任务。</p>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>​        使用seamphore，一般是创建了多少线程，实际就会有多少线程并发执行，只是可同时执行的线程数量会受到信号量的限制。但使用线程池，创建的线程只是作为任务（task的复用，线程池实现原理和线程复用）提交给线程池执行，实际工作的线程由线程池创建，并且实际工作的线程数量由线程池自己管理。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>方法：</p>
<h3 id="aquire-（常用）"><a href="#aquire-（常用）" class="headerlink" title="aquire() （常用）"></a><strong>aquire() （常用）</strong></h3><p>从该信号量获取许可证，</p>
<p>获取到了可用的许可证，那么信号量减一，并立即返回执行后续代码</p>
<p>没有获取到可用的许可证，那么当前线程被禁止参与调度，并处于休眠（非公平的一直在尝试，公平的的有队列提醒），直到：</p>
<ul>
<li>一些其他线程调用此信号量的<code>release()</code>方法，当前线程旁边将分配一个许可证</li>
<li>一些其他线程interrupts当前线程</li>
</ul>
<h3 id="acquire（int-permits）"><a href="#acquire（int-permits）" class="headerlink" title="acquire（int permits）"></a>acquire（int permits）</h3><p>从该信号量获取给定数量的许可证，阻止直到所有可用，或线程为interrupted</p>
<h3 id="acquireUniterruptibly"><a href="#acquireUniterruptibly" class="headerlink" title="acquireUniterruptibly()"></a>acquireUniterruptibly()</h3><p>保证未获得许可的方法不能被中断，如果是acquire，为获得线程的方法被中断会抛出异常，但是会继续向下运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcquireInterrput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Service service = <span class="keyword">new</span> Service();</span><br><span class="line">        Thread  a = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            service.testMethod();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        Thread  b = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            service.testMethod();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        b.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        b.interrupt();</span><br><span class="line">        <span class="comment">// 书本上这个输出的的&quot;main中断了a&quot;，我感觉是作者的一个小失误</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main中断了B&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 会报错</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不会报错</span></span><br><span class="line">            <span class="comment">// semaphore.acquireUninterruptibly();</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">&quot; begin timer=&quot;</span> + System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE / <span class="number">50</span>; i++) &#123;</span><br><span class="line">                String newString = <span class="keyword">new</span> String();</span><br><span class="line">                Math.random();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">&quot;   end timer=&quot;</span> + System.currentTimeMillis());</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A begin timer=<span class="number">1631353318421</span></span><br><span class="line">main中断了B</span><br><span class="line">B begin timer=<span class="number">1631353318931</span></span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">998</span>)</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">1304</span>)</span><br><span class="line">	at java.util.concurrent.Semaphore.acquire(Semaphore.java:<span class="number">312</span>)</span><br><span class="line">	at top.bingfabook.one.mysemaphore.AcquireInterrput$Service.testMethod(AcquireInterrput.java:<span class="number">33</span>)</span><br><span class="line">	at top.bingfabook.one.mysemaphore.AcquireInterrput.lambda$main$<span class="number">1</span>(AcquireInterrput.java:<span class="number">17</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line">A   end timer=<span class="number">1631353321910</span></span><br><span class="line">B   end timer=<span class="number">1631353322377</span></span><br></pre></td></tr></table></figure>



<h3 id="acquireUniterruptibly-int-permits"><a href="#acquireUniterruptibly-int-permits" class="headerlink" title="acquireUniterruptibly(int permits)"></a>acquireUniterruptibly(int permits)</h3><p>获取不可中断的，从该信号量获取给定数量的许可证，阻止直到可用。</p>
<h3 id="availablePrmits-（常用）"><a href="#availablePrmits-（常用）" class="headerlink" title="availablePrmits() （常用）"></a><strong>availablePrmits()</strong> （常用）</h3><p>返回信号量中当前可用的许可数</p>
<h3 id="drainPermits"><a href="#drainPermits" class="headerlink" title="drainPermits()"></a>drainPermits()</h3><p>获取并返回所有课立即获取的许可证</p>
<p>drain：排干（v.）</p>
<p><strong>注意，这个方法慎用，因为会获取所有的许可证，而release会增加许可证，有可能造成许可证数量不一致</strong></p>
<h3 id="getQueuedThreads"><a href="#getQueuedThreads" class="headerlink" title="getQueuedThreads()"></a>getQueuedThreads()</h3><p>返回一个包含可能正在等待获取的线程的集合</p>
<h3 id="getQueueLength"><a href="#getQueueLength" class="headerlink" title="getQueueLength()"></a>getQueueLength()</h3><p>返回等待获取线程的数量的估计</p>
<h3 id="hasQueuedThreads"><a href="#hasQueuedThreads" class="headerlink" title="hasQueuedThreads"></a>hasQueuedThreads</h3><p>查询是否还有线程等待获取</p>
<h3 id="isFair"><a href="#isFair" class="headerlink" title="isFair()"></a>isFair()</h3><p> 查看信号量是否为公平</p>
<h3 id="reducePermits-int-reduction"><a href="#reducePermits-int-reduction" class="headerlink" title="reducePermits(int reduction)"></a>reducePermits(int reduction)</h3><p>所有可用许可证的数量</p>
<h3 id="release-（常用）"><a href="#release-（常用）" class="headerlink" title="release()（常用）"></a>release()（常用）</h3><p>释放许可证，将其返回到信号量</p>
<h3 id="release-int-permits"><a href="#release-int-permits" class="headerlink" title="release(int permits)"></a>release(int permits)</h3><p>释放给定数量的许可证，将其返回到信号量</p>
<h3 id="tryAcquire-（常用）"><a href="#tryAcquire-（常用）" class="headerlink" title="tryAcquire()（常用）"></a>tryAcquire()（常用）</h3><p><strong>尝试</strong>从信号量中获取许可证，如果获取不到就立即返回false</p>
<h3 id="tryAcquire-int-permits"><a href="#tryAcquire-int-permits" class="headerlink" title="tryAcquire(int permits)"></a>tryAcquire(int permits)</h3><p><strong>尝试</strong>从信号量中获取指定数量许可证，如果任意一个获取不到就返回false</p>
<h3 id="tryAcquire-long-timeout-TimeUnit-unit"><a href="#tryAcquire-long-timeout-TimeUnit-unit" class="headerlink" title="tryAcquire(long timeout,  TimeUnit unit)"></a>tryAcquire(long timeout,  TimeUnit unit)</h3><p>在指定时间内尝试从信号量中获取许可证，如果时间到了还获取不到就返回false</p>
<h3 id="tryAcquire-int-permits-long-timeout-TimeUnit-unit-（常用）"><a href="#tryAcquire-int-permits-long-timeout-TimeUnit-unit-（常用）" class="headerlink" title="tryAcquire(int permits,  long timeout, TimeUnit unit)（常用）"></a>tryAcquire(int permits,  long timeout, TimeUnit unit)（常用）</h3><p>在指定时间内尝试从信号量中获取指定许可证，如果时间到了还获取不到就返回false</p>
<hr>
<p>构造器：</p>
<h3 id="public-Semaphore-int-permits"><a href="#public-Semaphore-int-permits" class="headerlink" title="public Semaphore(int permits)"></a>public Semaphore(int permits)</h3><p>创建一个 Semaphore与给定数量的许可证和非公平设置。 </p>
<h3 id="public-Semaphore-int-permits-boolean-fair"><a href="#public-Semaphore-int-permits-boolean-fair" class="headerlink" title="public Semaphore(int permits,  boolean fair)"></a>public Semaphore(int permits,  boolean fair)</h3><p>创建一个 Semaphore与给定数量的许可证和给定的公平设置。 </p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>aquire()和release()通常在一起使用，但是releas()方法会无限制的增加许可证的数量，所以我们在某些特定场景下的使用一定要注意：避免执行的线程的数量无限制增加。</p>
<p>一些主要问题就是：<strong>是没有获取到许可证的线程，调用了 release 方法。</strong></p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>《Java高并发编程详解-深入理解并发核心库》 的 3.4.4 小节《扩展 Semaphore 增强 release》:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySemaphorePlus</span> <span class="keyword">extends</span> <span class="title">Semaphore</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义线程安全的、存放Thread类型的队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentLinkedDeque&lt;Thread&gt; queue = <span class="keyword">new</span> ConcurrentLinkedDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySemaphorePlus</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread currentThread = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 当队列中不存在该线程时，调用release方法会将被忽略</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.queue.contains(currentThread)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.release(permits);</span><br><span class="line">        <span class="comment">//成功释放，并且将当前线程从队列中删除</span></span><br><span class="line">        <span class="keyword">this</span>.queue.remove(currentThread);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> acquired = <span class="keyword">super</span>.tryAcquire();</span><br><span class="line">        <span class="keyword">if</span> (acquired) &#123;</span><br><span class="line">            <span class="comment">// 线程成功获取许可证，将其放入队列中</span></span><br><span class="line">            <span class="keyword">this</span>.queue.add(Thread.currentThread());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> acquired;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这样在的情况下，我们调用release方法就不会增加认证书。</p>
<p>在这样的自定义扩展类中，实现了一个重要的队列，该队列为线程安全的队列。</p>
<p>那么，为什么要使用线程安全的队列呢？因为对MySemaphorePlus的操作是由多个线程进行的。该队列主要用于管理操作Semaphore的线程引用，成功获取到许可证的线程将被加入该队列中，同时只有在该队列中的线程才有资格进行许可证的释放操作。这样你就不用担心try….finally语句块的使用会引起没有获取到许可证的线程释放许可证的逻辑错误了。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySemaphore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">8</span>;            <span class="comment">//工人数</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>); <span class="comment">//机器数目</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Worker(i, semaphore).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> num, Semaphore semaphore)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(<span class="string">&quot;工人&quot;</span> + <span class="keyword">this</span>.num + <span class="string">&quot;占用一个机器在生产...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;工人&quot;</span> + <span class="keyword">this</span>.num + <span class="string">&quot;释放出机器&quot;</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">工人<span class="number">1</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">0</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">3</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">2</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">5</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">0</span>释放出机器</span><br><span class="line">工人<span class="number">2</span>释放出机器</span><br><span class="line">工人<span class="number">3</span>释放出机器</span><br><span class="line">工人<span class="number">1</span>释放出机器</span><br><span class="line">工人<span class="number">7</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">5</span>释放出机器</span><br><span class="line">工人<span class="number">4</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">6</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">4</span>释放出机器</span><br><span class="line">工人<span class="number">7</span>释放出机器</span><br><span class="line">工人<span class="number">6</span>释放出机器</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<p>参考文章：</p>
<p>《java并发编程 核心方法与框架》第一章</p>
<p>java jdk1.8 API文档</p>
<p><a href="https://blog.csdn.net/l460133921/article/details/104673169?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.no_search_link">https://blog.csdn.net/l460133921/article/details/104673169?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.no_search_link</a></p>
]]></content>
      <categories>
        <category>多线程</category>
        <category>多线程理论篇</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/a80d0031.html</url>
    <content><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="动态规划题目的特点"><a href="#动态规划题目的特点" class="headerlink" title="动态规划题目的特点"></a>动态规划题目的特点</h2><ul>
<li>计数</li>
<li>求最大最小值</li>
<li>求存在性</li>
</ul>
<p>最后都是得出一个最优值，而不是所有的可能性。</p>
<h2 id="动态规划解题思路"><a href="#动态规划解题思路" class="headerlink" title="动态规划解题思路"></a>动态规划解题思路</h2><p>有2，5，7三种类型的硬币，求用这三种硬币拼出来的总量为27，但是用的硬币个数最小。</p>
<h3 id="组成部分一：确定状态"><a href="#组成部分一：确定状态" class="headerlink" title="组成部分一：确定状态"></a>组成部分一：确定状态</h3><p>也就是说，在解动态规划问题的时候需要开一个数组，数组的每个元素<code>f[i]</code>或者<code>f[i][j]</code>代表什么</p>
<p>确定状态需要两个意识：</p>
<h4 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h4><p>也就是最后存在的解</p>
<p>例如：</p>
<p>这个题一定存在一个解，即<code>K</code>枚硬币组合在一起达到了总量为27</p>
<h5 id="关键点1"><a href="#关键点1" class="headerlink" title="关键点1"></a>关键点1</h5><p>我们不关心前面的<code>k-1</code>枚硬币是怎么拼出来<code>27-aK</code>的（可能有一种拼法，可能有100种拼法），而且我们现在甚至还不知道<code>ak</code>和<code>K</code>，但是我们确定前面的硬币拼出了<code>27-ak</code></p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210908143107655.png" alt="image-20210908143107655" style="zoom:67%;" />

<pre><code>    ##### 关键点2
</code></pre>
<p>因为是最优策略，所以拼出<code>27-ak</code>的硬币数量一定要最小，否则这就不是最优策略了</p>
<p>需要最小的硬币数，所以：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210908145455699.png" alt="image-20210908145455699"></p>
<p>这个时候，我们可以用递归方法解题</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20200711131243857.png" alt="在这里插入图片描述"></p>
<p>但是有一个问题，递归是从上到下进行计算的，这样的话会产生大量的重复运算</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20200711131552928.png" alt="在这里插入图片描述"></p>
<p>所以说，这不是一个好的解法，解决方法就是将计算结果保存下来，改变计算顺序</p>
<p><strong>看到这里是不是感觉好像记忆化递归的逆序，没错！这就是动态规划！</strong></p>
<p>总结：首先思路是递归方法，但是这里面有着大量的重复计算，然后我们进阶为了记忆化递归，但是记忆化递归太过于占据内存，所以有了动态规划。</p>
<h3 id="组成部分二：转移方程"><a href="#组成部分二：转移方程" class="headerlink" title="组成部分二：转移方程"></a>组成部分二：转移方程</h3><p>设状态<code>F[X] =最少用多少枚硬币拼出X</code> </p>
<p>对于任意X，</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210908150944543.png" alt="image-20210908150944543"></p>
<h3 id="组成部分三：初始条件和边界条件"><a href="#组成部分三：初始条件和边界条件" class="headerlink" title="组成部分三：初始条件和边界条件"></a>组成部分三：初始条件和边界条件</h3><p>两个问题：<code>X-2</code>，<code>X-5</code>，<code>X-7</code>小于0怎么办？什么时候停下来？</p>
<p>所以定义初始条件：</p>
<p>那么什么时候定义初始条件，那就是用转移方程计算不出来的，这个时候就需要定义初始条件</p>
<p>在本题中：令<code>F[0] = 0</code></p>
<h3 id="组成部分四：计算顺序"><a href="#组成部分四：计算顺序" class="headerlink" title="组成部分四：计算顺序"></a>组成部分四：计算顺序</h3><ul>
<li>初始条件：f[0] = 0;</li>
<li>然后计算f[1]，f[2]，……，f[27]</li>
<li>当我们计算到f[x]时候，f[x-2]，f[x-5]，f[x-7]都已经得出结果了</li>
</ul>
<p>与递归相比：动态规划优化了太多的时间复杂度，递归往往是指数级别的，而动态规化往往是乘积级别</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>算法思想</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 14- I. 剪绳子</title>
    <url>/a93040e1.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;<span class="number">1</span>并且m&gt;<span class="number">1</span>），每段绳子的长度记为 k[<span class="number">0</span>],k[<span class="number">1</span>]...k[m-<span class="number">1</span>] 。请问 k[<span class="number">0</span>]*k[<span class="number">1</span>]*...*k[m-<span class="number">1</span>] 可能的最大乘积是多少？例如，当绳子的长度是<span class="number">8</span>时，我们把它剪成长度分别为<span class="number">2</span>、<span class="number">3</span>、<span class="number">3</span>的三段，此时得到的最大乘积是<span class="number">18</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入: <span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: <span class="number">2</span> = <span class="number">1</span> + <span class="number">1</span>, <span class="number">1</span> × <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">10</span></span><br><span class="line">输出: <span class="number">36</span></span><br><span class="line">解释: <span class="number">10</span> = <span class="number">3</span> + <span class="number">3</span> + <span class="number">4</span>, <span class="number">3</span> × <span class="number">3</span> × <span class="number">4</span> = <span class="number">36</span></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> &lt;= n &lt;= <span class="number">58</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一个明显的几何均值不等式<br>$$<br>\frac{n_1 + n_2 + … + n_a}{a} \geq \sqrt[a]{n_1 n_2 … n_a}<br>$$<br>这是高中题，结果我完全没有印象了，怀疑我的高中是怎么上的。</p>
<p><strong>推论一</strong>：将绳子 <strong>以相等的长度等分为多段</strong> ，得到的乘积最大。</p>
<p>当长度相等即n1=12=..=na的时候取最大值</p>
<p><strong>推论二：</strong> 尽可能将绳子以长度 3 等分为多段时，乘积最大。</p>
<p><strong>真的想不到！</strong></p>
<p>还是用贪心算法吧</p>
<h3 id="证明过程"><a href="#证明过程" class="headerlink" title="证明过程"></a>证明过程</h3><p><a href="https://zhuanlan.zhihu.com/p/103989923">https://zhuanlan.zhihu.com/p/103989923</a></p>
<p>我感觉证明过程中的柯西归纳法比较容易理解，没有涉及到太多的理论知识，只是设计的非常巧妙</p>
<ol>
<li>先得出在2的n次幂个数的情况下，条件是成立的</li>
<li>然后从X(n+1)开始去一个特殊值，为了后面的推到公式使用</li>
<li>最后代入公式发现，X1到Xn这个公式的租后推导结果与X(n+1)及后面的数值没有关系，所以对任意的数从X1到Xn都是成立的</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>因为我们是要找的最优解，这种一般就是典型的动态规划题目，而且针对本题，动态规划也是最容易理解的</p>
<p>动态规划其实就是记忆化递归的逆序，</p>
<h4 id="动态规划的方程"><a href="#动态规划的方程" class="headerlink" title="动态规划的方程"></a>动态规划的方程</h4><p>假设前面取的长度为j，那么后面取的长度（<code>i-j</code>）分为两种情况</p>
<ol>
<li><p>后面的长度不拆分</p>
<p><code>j * (i - j)</code></p>
</li>
<li><p>后面的长度还是需要拆分</p>
<p><code>j * dp[i - j]</code></p>
</li>
</ol>
<p>$$<br>ropes[i] = max(ropes[i], max(j * (i - j), j * ropes[i - j]))<br>$$</p>
<h4 id="动态规划的初始条件和边界条件"><a href="#动态规划的初始条件和边界条件" class="headerlink" title="动态规划的初始条件和边界条件"></a>动态规划的初始条件和边界条件</h4><p>初始化条件：ropes[2] = 1</p>
<p>边界条件：对长度为n的绳子，切割了n次</p>
<h4 id="计算顺序"><a href="#计算顺序" class="headerlink" title="计算顺序"></a>计算顺序</h4><ul>
<li>初始条件： ropes[2] = 1;</li>
<li>然后计算f[3]，f[4]，……，f[n]</li>
<li>当我们计算到f[n]时候，f[i]，f[i-j]都已经得出结果了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 动态规划基本，定义一个数组，记录每次的数据结果</span></span><br><span class="line">        <span class="keyword">int</span>[] ropes = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        ropes[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++) &#123;</span><br><span class="line">                ropes[i] = Math.max(ropes[i], Math.max(j * (i - j), j * ropes[i - j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ropes[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>贪心算法主要是公式的推导，一般是尝试公式的正确性（或者用数学证明，但是写算法的时候一般都不需要证明）</p>
<p>这个就是上面的思路过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果n &lt; 4 ，直接返回就行</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// n &gt; 4的时候，每次递减3，如果剩余的数小于5，怎不尽兴拆分了，直接全部返回</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            n = n - <span class="number">3</span>;</span><br><span class="line">            res *= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="博客首先发布于："><a href="#博客首先发布于：" class="headerlink" title="博客首先发布于："></a>博客首先发布于：</h1><p><a href="https://lvxiaoyi.top/">https://lvxiaoyi.top/</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 102. 二叉树的层序遍历</title>
    <url>/c7ba20f5.html</url>
    <content><![CDATA[<h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">二叉树：[<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回其层序遍历结果：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个就是树的广度优先遍历，我们需要借助一个<strong>队列</strong>来保存我们的广度的节点，以便第一个节点访问过后，<strong>能够直接访问广度节点而不是再次回溯</strong></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>时间复杂度：O(N)</p>
<p>空间复杂度：O(N）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//记录最后的收集结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> lists;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// BFS中最基本的，就是用一个队列来存放每层的node节点，后续的node节点依次放在队列的后面，当期节点访问过后就弹出队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="comment">// 对队列中的数据一直遍历</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 这里遍历了一层节点</span></span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 记录当前层的节点数量，然后把当前层的节点数据全部拿到，然后添加当前层节点的子节点</span></span><br><span class="line">            <span class="comment">// 这里之所以要加一个for循环，因为想一次性把一层的节点全部放在一个list中</span></span><br><span class="line">            <span class="comment">// 在普通的DFS中，这个for循环是不需要的，直接 while 遍历全部队列</span></span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lists.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 13. 机器人的运动范围</title>
    <url>/8915785d.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">地上有一个m行n列的方格，从坐标 [<span class="number">0</span>,<span class="number">0</span>] 到坐标 [m-<span class="number">1</span>,n-<span class="number">1</span>] 。一个机器人从坐标 [<span class="number">0</span>, <span class="number">0</span>] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为<span class="number">18</span>时，机器人能够进入方格 [<span class="number">35</span>, <span class="number">37</span>] ，因为<span class="number">3</span>+<span class="number">5</span>+<span class="number">3</span>+<span class="number">7</span>=<span class="number">18</span>。但它不能进入方格 [<span class="number">35</span>, <span class="number">38</span>]，因为<span class="number">3</span>+<span class="number">5</span>+<span class="number">3</span>+<span class="number">8</span>=<span class="number">19</span>。请问该机器人能够到达多少个格子？</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：m = <span class="number">2</span>, n = <span class="number">3</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：m = <span class="number">3</span>, n = <span class="number">1</span>, k = <span class="number">0</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= n,m &lt;= <span class="number">100</span></span><br><span class="line"><span class="number">0</span> &lt;= k &lt;= <span class="number">20</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>



<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我第一次想到这个题首先想到的是暴力破解，它不是让寻找次数吗，这样我用暴力破解不是效率最快的吗？</p>
<p>两个for循环遍历，然后在一个if判断，这样不是直接就能找到了。</p>
<p>结果发现，我少了一个重要的条件，就是可达性。机器人是一个坐标一个坐标移动的，如果中间有的坐标到不了，那么后面的一部分坐标也都到达不了。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/1603026306-OdpwLi-Picture1.png" alt="img"></p>
<p>例如：这张图片里面，黄色的位置都是理论上可以到达，但是实际上到达不了的。</p>
<p>如果是用的for循环，肯定会计算错误而且浪费性能。</p>
<p>因为只需要判断这一个点是否满足，所以不需要回溯。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>DFS 是朝一个方向走到底，再回退，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> solve(<span class="number">0</span>, <span class="number">0</span>, m, n, vis, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">boolean</span>[][] vis, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= m || y &gt;= n || vis[x][y] || (getPlaces(x) + getPlaces(y)) &gt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x][y] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 先在横向上一直深度遍历</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + solve(x + <span class="number">1</span>, y, m, n, vis, k) + solve(x, y + <span class="number">1</span>, m, n, vis, k);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getPlaces</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">        s += num % <span class="number">10</span>;</span><br><span class="line">        num = num / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(MN)</p>
<p>空间复杂度：O(MN)</p>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getPlaces</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">        s += num % <span class="number">10</span>;</span><br><span class="line">        num = num / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] poll = queue.poll();</span><br><span class="line">            <span class="keyword">assert</span> poll != <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> x = poll[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = poll[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= m || y &gt;= n || vis[x][y] || (getPlaces(poll[<span class="number">0</span>]) + getPlaces(poll[<span class="number">1</span>])) &gt; k) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">            vis[x][y] = <span class="keyword">true</span>;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x + <span class="number">1</span>, y&#125;);</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y + <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个就是普通的DFS遍历</p>
<h1 id="博客首先发布于："><a href="#博客首先发布于：" class="headerlink" title="博客首先发布于："></a>博客首先发布于：</h1><p><a href="https://lvxiaoyi.top/">https://lvxiaoyi.top/</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 12. 矩阵中的路径</title>
    <url>/9e68b9c9.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 <span class="keyword">true</span> ；否则，返回 <span class="keyword">false</span> 。</span><br><span class="line"></span><br><span class="line">单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">例如，在下面的 <span class="number">3</span>×<span class="number">4</span> 的矩阵中包含单词 <span class="string">&quot;ABCCED&quot;</span>（单词中的字母已标出）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：board = [[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;E&quot;</span>],[<span class="string">&quot;S&quot;</span>,<span class="string">&quot;F&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;S&quot;</span>],[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>,<span class="string">&quot;E&quot;</span>]], word = <span class="string">&quot;ABCCED&quot;</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：board = [[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>],[<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>]], word = <span class="string">&quot;abcd&quot;</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= board.length &lt;= <span class="number">200</span></span><br><span class="line"><span class="number">1</span> &lt;= board[i].length &lt;= <span class="number">200</span></span><br><span class="line">board 和 word 仅由大小写英文字母组成</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/word2.jpg" alt="img"></p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这套题明显是一个矩阵搜索的问题，深度优先遍历的算法，（迷宫的简化版）</p>
<p>首先还是迷宫的那一套解题思路</p>
<ol>
<li>上下左右都进行递归</li>
<li>递归的终止条件<ol>
<li>递归的边界条件</li>
<li>超过矩阵的范围</li>
<li>到了查找的word的次数（长度）</li>
<li>路径上的字符和word的不匹配</li>
<li>不能再一次寻找的过程中折返</li>
</ol>
</li>
<li>回溯<ol>
<li>走过的路径需要标记，放弃的路径需要还原</li>
</ol>
</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="DFS-剪枝"><a href="#DFS-剪枝" class="headerlink" title="DFS + 剪枝"></a>DFS + 剪枝</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="keyword">boolean</span>[][] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="comment">// 每一次遍历都要从根节点重新开始，index要归零</span></span><br><span class="line">                <span class="keyword">if</span> (dfs(board, words, i, j, vis, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] words, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">boolean</span>[][] vis, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//x和y不能超出边界，寻找过程中不能折返</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= board.length || y &lt;  <span class="number">0</span> || y &gt;= board[<span class="number">0</span>].length || vis[x][y])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 路径上的字符和word中的字符要匹配</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (board[x][y] != words[index])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 达到了寻找word的次数，并且之前的路径都匹配到了，直接返回</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (index == words.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x][y] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = dfs(board, words, x + <span class="number">1</span>, y, vis, index + <span class="number">1</span>) ||</span><br><span class="line">            dfs(board, words, x - <span class="number">1</span>, y, vis, index + <span class="number">1</span>) ||</span><br><span class="line">            dfs(board, words, x, y + <span class="number">1</span>, vis, index + <span class="number">1</span>) ||</span><br><span class="line">            dfs(board, words, x, y - <span class="number">1</span>, vis, index + <span class="number">1</span>);</span><br><span class="line">        vis[x][y] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：<br>M, N, 分别为矩阵行列大小， K 为字符串 word 长度。</p>
<p>时间复杂度：O（3^K * MN）</p>
<p>空间复杂度O（k + MN）</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>可以优化上面的空间复杂度，上面的算法中额外申请了MN的二维矩阵，用于存储是否访问过节点，但是这个额外的空间可以不需要</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">            <span class="keyword">boolean</span>[][] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                    <span class="comment">// 每一次遍历都要从根节点重新开始，index要归零</span></span><br><span class="line">                    <span class="keyword">if</span> (dfs(board, words, i, j, <span class="number">0</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] words, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//x和y不能超出边界，寻找过程中不能折返 （这里在走过的路径上把字符全部制空，所以不定不能匹配走过的路径，达到了禁止折返的目的）,路径上的字符和word中的字符要匹配</span></span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= board.length || y &lt; <span class="number">0</span> || y &gt;= board[<span class="number">0</span>].length || board[x][y] != words[index]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 达到了寻找word的次数，并且之前的路径都匹配到了，直接返回</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == words.length - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 走过的路径制空</span></span><br><span class="line">            board[x][y] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">boolean</span> flag = dfs(board, words, x + <span class="number">1</span>, y, index + <span class="number">1</span>) ||</span><br><span class="line">                    dfs(board, words, x - <span class="number">1</span>, y, index + <span class="number">1</span>) ||</span><br><span class="line">                    dfs(board, words, x, y + <span class="number">1</span>, index + <span class="number">1</span>) ||</span><br><span class="line">                    dfs(board, words, x, y - <span class="number">1</span>, index + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 这里也没有用额外的变量保存board[x][y]的值，而是直接用words[index]的值，因为只有前面的路径都匹配，才能走到这一步，所以这个值相当于保存在words中</span></span><br><span class="line">            board[x][y] = words[index];</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="博客首先发布于："><a href="#博客首先发布于：" class="headerlink" title="博客首先发布于："></a>博客首先发布于：</h1><p><a href="https://lvxiaoyi.top/">https://lvxiaoyi.top/</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 189. 旋转数组</title>
    <url>/718916d6.html</url>
    <content><![CDATA[<h1 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a><a href="https://leetcode-cn.com/problems/rotate-array/">189. 旋转数组</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line"></span><br><span class="line">尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</span><br><span class="line">你可以使用空间复杂度为 O(<span class="number">1</span>) 的 原地 算法解决这个问题吗？</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>], k = <span class="number">3</span></span><br><span class="line">输出: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 <span class="number">1</span> 步: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">向右旋转 <span class="number">2</span> 步: [<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">向右旋转 <span class="number">3</span> 步: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入：nums = [-<span class="number">1</span>,-<span class="number">100</span>,<span class="number">3</span>,<span class="number">99</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">99</span>,-<span class="number">1</span>,-<span class="number">100</span>]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 <span class="number">1</span> 步: [<span class="number">99</span>,-<span class="number">1</span>,-<span class="number">100</span>,<span class="number">3</span>]</span><br><span class="line">向右旋转 <span class="number">2</span> 步: [<span class="number">3</span>,<span class="number">99</span>,-<span class="number">1</span>,-<span class="number">100</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">2</span> * <span class="number">104</span></span><br><span class="line">-<span class="number">231</span> &lt;= nums[i] &lt;= <span class="number">231</span> - <span class="number">1</span></span><br><span class="line"><span class="number">0</span> &lt;= k &lt;= <span class="number">105</span></span><br></pre></td></tr></table></figure>



<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果要求空间复杂度为O（1），原地算法完成这个功能，可以先考虑怎么样才能不使用额外的空间翻转部分数组</p>
<p>我可以把一个数组arr[0]和arr[n],位置交换，然后依次交换arr[1]和arr[n-1]，一直到这两个位置相遇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里要取模，因为有可能k比length大</span></span><br><span class="line">        k = k %length;</span><br><span class="line">        <span class="comment">// 先整体翻转</span></span><br><span class="line">        reserve(nums, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 在翻转k的左侧</span></span><br><span class="line">        reserve(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 在翻转k的</span></span><br><span class="line">        reserve(nums, k, length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reserve</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/f1601c3e.html</url>
    <content><![CDATA[<h1 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h1><p>单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。</p>
<p>许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p>
<span id="more"></span>

<p><img src="https://images2018.cnblogs.com/blog/1002892/201809/1002892-20180912131026735-781767905.png" alt="img"></p>
<h1 id="单例模式应用场景"><a href="#单例模式应用场景" class="headerlink" title="单例模式应用场景"></a>单例模式应用场景</h1><p>举一个小例子，在我们的windows桌面上，我们打开了一个回收站，当我们试图再次打开一个新的回收站时，Windows系统并不会为你弹出一个新的回收站窗口。，也就是说在整个系统运行的过程中，系统只维护一个回收站的实例。这就是一个典型的单例模式运用。</p>
<p> 继续说回收站，我们在实际使用中并不存在需要同时打开两个回收站窗口的必要性。假如我每次创建回收站时都需要消耗大量的资源，而每个回收站之间资源是共享的，那么在没有必要多次重复创建该实例的情况下，创建了多个实例，这样做就会给系统造成不必要的负担，造成资源浪费。</p>
<p> 再举一个例子，网站的计数器，一般也是采用单例模式实现，如果你存在多个计数器，每一个用户的访问都刷新计数器的值，这样的话你的实计数的值是难以同步的。但是如果采用单例模式实现就不会存在这样的问题，而且还可以避免线程安全问题。同样多线程的线程池的设计一般也是采用单例模式，这是由于线程池需要方便对池中的线程进行控制</p>
<p> 同样，对于一些应用程序的日志应用，或者web开发中读取配置文件都适合使用单例模式，如HttpApplication 就是单例的典型应用。</p>
<p> 从上述的例子中我们可以总结出适合使用单例模式的场景和优缺点： </p>
<p>  <strong>适用场景：</strong></p>
<ul>
<li><strong>1.需要生成唯一序列的环境</strong></li>
<li><strong>2.需要频繁实例化然后销毁的对象。</strong></li>
<li><strong>3.创建对象时耗时过多或者耗资源过多，但又经常用到的对象。</strong> </li>
<li><strong>4.方便资源相互通信的环境</strong></li>
</ul>
<h1 id="单例模式的优缺点"><a href="#单例模式的优缺点" class="headerlink" title="单例模式的优缺点"></a>单例模式的优缺点</h1><p><strong>优点</strong>：</p>
<ul>
<li>在内存中只有一个对象，节省内存空间；</li>
<li>避免频繁的创建销毁对象，可以提高性能；</li>
<li>避免对共享资源的多重占用，简化访问；</li>
<li>为整个系统提供一个全局访问点。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li> 不适用于变化频繁的对象；</li>
<li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；</li>
<li>如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失；</li>
</ul>
<h1 id="单例模式实现"><a href="#单例模式实现" class="headerlink" title="单例模式实现"></a>单例模式实现</h1><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p><code>jvm加载类的的时候就把单例对象生成</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 饿汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 指向自己实例的私有静态引用，主动创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 以自己实例为返回值的静态的公有方法，静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们知道，<strong>类加载的方式是按需加载，且加载一次</strong>。。因此，在上述单例类被加载时，就会实例化一个对象并交给自己的引用，供系统使用；而且，由于这个类在整个生命周期中只会被加载一次，因此只会创建一个实例，<strong>jvm底层保证了单例</strong>。</p>
<p>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p>
<p>缺点：在类装载的时候就完成实例化，<strong>没有达到Lazy Loading的效果</strong>。如果从始至终从未使用过这个实例，则会造成内存的浪费。</p>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p><code>jvm加载类的的时候不生成单例对象，而是需要的时候才第一次创建，线程不安全</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 懒汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 指向自己实例的私有静态引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 以自己实例为返回值的静态的公有方法，静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 被动创建，在真正需要使用时才去创建</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>们从懒汉式单例可以看到，单例实例被<strong>延迟加载</strong>，即只有在真正使用的时候才会实例化一个对象并交给自己的引用。</p>
<p>这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了if (instance== null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。</p>
<h2 id="线程安全饿汉式之全锁"><a href="#线程安全饿汉式之全锁" class="headerlink" title="线程安全饿汉式之全锁"></a>线程安全饿汉式之全锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 创建单例的具体业务逻辑.....省略</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; </span><br><span class="line">        	instance = <span class="keyword">new</span> Singleton3(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建单例的具体业务逻辑.....省略</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>优点：保证了线程安全和懒加载</p>
<p>缺点：效率低。这种模式保证的线程安全，但是效率特别低，在高并发情况下，每次调用getInstance方法都需要加锁，显然不符合高并发情况的效率。</p>
<h2 id="线程安全饿汉式之部分锁-双重判空检查"><a href="#线程安全饿汉式之部分锁-双重判空检查" class="headerlink" title="线程安全饿汉式之部分锁+双重判空检查"></a>线程安全饿汉式之部分锁+双重判空检查</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance; <span class="comment">// 不使用volatile关键字</span></span><br><span class="line">    <span class="comment">// 双重锁检验</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton4.class) &#123;</span><br><span class="line">                <span class="comment">//这里必须要在使用一次判空检查，在多线程情况下，可能多个线程都判断为空，进入了synchronized</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton4(); <span class="comment">// 第10行</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果发生了重排序（在高并发情况下小概率出现，但是确实会出现）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">instance = <span class="keyword">new</span> Singleton4(); <span class="comment">// 第10行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以分解为以下三个步骤</span></span><br><span class="line"><span class="number">1</span> memory=allocate();<span class="comment">// 分配内存 相当于c的malloc</span></span><br><span class="line"><span class="number">2</span> ctorInstanc(memory) <span class="comment">//初始化对象</span></span><br><span class="line"><span class="number">3</span> s=memory <span class="comment">//设置s指向刚分配的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述三个步骤可能会被重排序为 1-3-2，也就是：</span></span><br><span class="line"><span class="number">1</span> memory=allocate();<span class="comment">// 分配内存 相当于c的malloc</span></span><br><span class="line"><span class="number">3</span> s=memory <span class="comment">//设置s指向刚分配的地址</span></span><br><span class="line"><span class="number">2</span> ctorInstanc(memory) <span class="comment">//初始化对象</span></span><br></pre></td></tr></table></figure>

<p>而一旦假设发生了这样的重排序，比如线程A在第10行执行了步骤1和步骤3，但是步骤2还没有执行完。这个时候线程A执行到了第7行，它会判定instance不为空，然后直接返回了一个未初始化完成的instance！</p>
<p>优点：保证了加锁的效率，线程安全和懒加载</p>
<p>缺点：在高并发情况下，小概率出现实例为空（或者一个默认值）的情况</p>
<h2 id="线程安全饿汉式之双重锁检查"><a href="#线程安全饿汉式之双重锁检查" class="headerlink" title="线程安全饿汉式之双重锁检查"></a>线程安全饿汉式之双重锁检查</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton4 instance; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双重锁检验</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton5.class) &#123;</span><br><span class="line">                <span class="comment">//这里必须要在使用一次判空检查，在多线程情况下，可能多个线程都判断为空，进入了synchronized</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton5(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里使用volatile禁止了instance = new Singleton5(); 中发生的指令重排序，保证了线程安全。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络常见面试题</title>
    <url>/2109f677.html</url>
    <content><![CDATA[<p>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         </p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI与TCP各层的结构和功能，都有哪些协议"><a href="#OSI与TCP各层的结构和功能，都有哪些协议" class="headerlink" title="OSI与TCP各层的结构和功能，都有哪些协议"></a>OSI与TCP各层的结构和功能，都有哪些协议</h2><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/java-interview/1.png?lastModify=1627538183" alt="五层协议的体系结构"></p>
<span id="more"></span>

<p>应用层：</p>
<p><strong>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。</strong>在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 <strong>HTTP协议</strong>，支持电子邮件的 <strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文。</p>
<p>运输层：</p>
<p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<p>网络层：</p>
<p><strong>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。</p>
<p>数据链路层：</p>
<p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装程帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<p>物理层：</p>
<p><strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/java-interview/2.png?lastModify=1627541008" alt="七层体系结构图"></p>
<h2 id="TCP-IP-三次握手、四次挥手"><a href="#TCP-IP-三次握手、四次挥手" class="headerlink" title="TCP/IP 三次握手、四次挥手"></a>TCP/IP 三次握手、四次挥手</h2><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/java-interview/image-20210625174336945.png" alt="image-20210625174336945"></p>
<h3 id="三次握手（建立连接）："><a href="#三次握手（建立连接）：" class="headerlink" title="三次握手（建立连接）："></a><strong>三次握手（建立连接）：</strong></h3><p>一次握手：客户端发送带有SYN标志的数据包</p>
<p>二次握手：服务端发送带有SYN/ACK标志的数据包</p>
<p>三次握手：客户端发送带有ACK标志的数据包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">位码即tcp标志位，有6种标示：SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)Sequence number(顺序号码) Acknowledge number(确认号码)</span><br><span class="line">第一次握手：主机A发送位码为syn＝1，随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；</span><br><span class="line"></span><br><span class="line">第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，syn=1，ack=1，随机产生seq=7654321的包；</span><br><span class="line"></span><br><span class="line">第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。</span><br><span class="line"></span><br><span class="line">FTP协议及时基于此协议。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>三次握⼿的⽬的是建⽴可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，⽽三次握⼿最主要的⽬的就是双⽅确认⾃⼰与对⽅的发送与接收是正常的。</strong></p>
<table>
<thead>
<tr>
<th align="center">握手次数</th>
<th align="center">客户端</th>
<th align="center">服务端</th>
</tr>
</thead>
<tbody><tr>
<td align="center">第一次</td>
<td align="center">什么也不能确定</td>
<td align="center">确定：客户端发送正常，服务端接收正常</td>
</tr>
<tr>
<td align="center">第二次</td>
<td align="center">确定：客户端发送正常、接收正常；服务端发送、接收正常；</td>
<td align="center">确定：客户端发送正常，服务端接收正常</td>
</tr>
<tr>
<td align="center">第三次</td>
<td align="center">确定：客户端发送正常、接收正常；服务端发送、接收正常；</td>
<td align="center">确定：客户端发送正常、接收正常；服务端发送、接收正常；</td>
</tr>
</tbody></table>
<h4 id="为什么三次握手，两次握手行不行"><a href="#为什么三次握手，两次握手行不行" class="headerlink" title="为什么三次握手，两次握手行不行"></a>为什么三次握手，两次握手行不行</h4><p>两次握手无法确定，客户端的接收是否正常（是否需要）。</p>
<p>如果使用两次握手：</p>
<p>客户端在第一次发送请求的时候，因为网络问题阻塞，超过了超时时间还没有收到服务端发送回来的确认请求，则客户端认为请求丢失，再次发送建立连接的请求。</p>
<p>在第二次建立链接顺利完成后，服务端释放了这次的链接，然后这个时候才收到第一次发送的链接（网络阻塞），服务端认为这是一个新的连接，确认建立链接，然后立即发送了请求，那么这次的发送就是无效的而且占用了资源</p>
<h4 id="为什么要回传SYN"><a href="#为什么要回传SYN" class="headerlink" title="为什么要回传SYN"></a>为什么要回传SYN</h4><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
<p><strong>四次挥手（断开连接）</strong></p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/java-interview/image-20210625174607286.png" alt="image-20210625174607286" style="zoom:67%;" />

<p>假设本次由客户端主动断开连接</p>
<p>第一次：客户端发送FIN（告诉服务端，我要关闭链接了）</p>
<p>第二次：服务端收到FIN后，发给服务端一个ACK，确认序号为收到的序号+1。</p>
<p>第三次：服务端关闭与客户端的连接，发送一个FIN给客户端</p>
<p>第四次：客户端发挥ACK确认报文，确认序号为收到的序号+1。</p>
<table>
<thead>
<tr>
<th align="center">握手次数</th>
<th align="center">客户端</th>
<th align="center">服务端</th>
</tr>
</thead>
<tbody><tr>
<td align="center">第一次</td>
<td align="center">确定：客户端已经没有任务了，关闭链接</td>
<td align="center">确定：客户端要关闭链接</td>
</tr>
<tr>
<td align="center">第二次</td>
<td align="center">确定：服务端确认客户端可以关闭链接</td>
<td align="center">确定：客户端要关闭链接</td>
</tr>
<tr>
<td align="center">第三次</td>
<td align="center">确定：服务端也没有任务了，服务端要关闭链接（这个过程可能服务端还有传输任务，所以要把确认过程和关闭过程分为两次握手）</td>
<td align="center">确定：客户端要关闭链接，服务端要关闭链接</td>
</tr>
<tr>
<td align="center">第四次</td>
<td align="center">确定：客户端确认服务端可以关闭链接</td>
<td align="center">确定：客户端关闭链接，服务端要关闭链接</td>
</tr>
<tr>
<td align="center">2ML</td>
<td align="center">ack可能丢失，如果第四次ack丢失服务端会在2ML内在发送一次FIN</td>
<td align="center">正式关闭</td>
</tr>
</tbody></table>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/java-interview/20181120162254477.png" alt="img"></p>
<p>由于TCP连接是全双工的，因此每个方向都必须单独关闭，这个原则是当以防完成它的数据发送任务后，就能发送一个FIN包来终止这个方向的连接。</p>
<p>收到一个FIN包只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后，仍然能发送数据，首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<h3 id="四次挥手过程"><a href="#四次挥手过程" class="headerlink" title="四次挥手过程"></a>四次挥手过程</h3><ul>
<li><strong>第一次挥手</strong>：客户端发送一个FIN包（FIN=1，seq=U）给服务器，用来关闭客户端到服务器端的数据传输，客户端进入FIN_WAIT_1状态（终止等待）</li>
<li><strong>第二次挥手</strong>：服务器端收到FIN包后，发送一个ACK包（ACK=1，ack=u+1，在随机产生一个值v 给seq）给客户端，服务器进入了CLOSE_WAIT状态（关闭等待）</li>
<li><strong>第三次挥手</strong>：服务器端发送一个FIN包（FIN=1，ACK=1，ack=u+1，在随机产生 一个w值给seq）给客户端，用来关闭服务器到客户端的数据传输，服务端进入了LAST_ACK（最后确定）状态</li>
<li><strong>第四次挥手</strong>：客户端接收FIN包，然后进入TIME_WAIT状态，接着发送一个ACK包（ACK=1，seq=u+1, ack = w+1） 给服务端，服务端确定序号，进入CLOSe状态，完成了四次挥手。</li>
</ul>
<h3 id="挥手中的状态"><a href="#挥手中的状态" class="headerlink" title="挥手中的状态"></a>挥手中的状态</h3><ul>
<li>CLOSED：表示初始状态</li>
<li>ESTABLISHED：表示连接已经连接</li>
<li>FIN_WAIT：状态FIN_WAIT_1和FIN_WAIT_2都表示等待对方的FIN报文，这两个状态的区别是，当主动发送方给对方发送了断开请求时，就进入了FIN_WAIT_1状态，而到被动方在回应后，主动发送方就进入了FIN_WAIT_2。</li>
<li><strong>FIN_WAIT_2</strong>：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接</li>
<li>CLOSE_WAIT：这个状态的含义是 表示在等待关闭</li>
<li>LAST_ACK：在被动关闭放发送FIN报文后，最后等待对方的ACK报文，当收到了ACK报文后，就进入了CLOSE状态。</li>
</ul>
<h3 id="为什么TIME-WAIT状态还需要等待2MSL后才能返回CLOSE"><a href="#为什么TIME-WAIT状态还需要等待2MSL后才能返回CLOSE" class="headerlink" title="为什么TIME_WAIT状态还需要等待2MSL后才能返回CLOSE"></a>为什么TIME_WAIT状态还需要等待2MSL后才能返回CLOSE</h3><p>这是因为虽然双方都同意了关闭连接，而且握手的4个报文也都协调和发送完毕，按道理可以直接回到CLOSE状态</p>
<p>但是因为我们需要假设网络是不可靠的，你无法保证你最后发送的ACK报文是会一定被对方收到，因此处于LAST_ACK状态下的socket可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的报文。</p>
<p>详细：<a href="https://blog.csdn.net/qzcsu/article/details/72861891">https://blog.csdn.net/qzcsu/article/details/72861891</a></p>
<hr>
<h2 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h2><table>
<thead>
<tr>
<th></th>
<th>特点</th>
<th></th>
<th></th>
<th>性能</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>是否面向连接</td>
<td>传输可靠性</td>
<td>传输形式</td>
<td>传输效率</td>
<td>所属资源</td>
<td>应用场景</td>
<td>首部字节</td>
</tr>
<tr>
<td>TCP</td>
<td>面向连接</td>
<td>可靠</td>
<td>字节流</td>
<td>慢</td>
<td>多</td>
<td>要求通信数据可靠<br />（如文件和邮件）</td>
<td>20-60</td>
</tr>
<tr>
<td>UDP</td>
<td>无连接</td>
<td>不可靠</td>
<td>数据报文端</td>
<td>快</td>
<td>少</td>
<td>要求通信速度快<br />（如域名转换）</td>
<td>8个字节</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>性能</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>拥塞控制</td>
<td>连接方式</td>
</tr>
<tr>
<td>TCP</td>
<td>有</td>
<td>一对一全双工通信</td>
</tr>
<tr>
<td>UDP</td>
<td>没有<br />在网络拥塞的情况下不会使源数据发送速率降低，适用于实时性（直播和视频会议）</td>
<td>一对一、一对多、多对一和多对多的通讯方式</td>
</tr>
</tbody></table>
<p>UDP在传输数据的时候不需要建立连接，远程主机收到UDP报文后不需要任何确认，但是传输效率快，所属资源少适合直播、电话、视频</p>
<p>TCP是面向连接的，通过三次握手来建立连接，而在在进行数据传递的时候，有去人、窗口、重传、拥塞控制机制，在数据传输完成后还会断开链接来节约系统资源，增大了开销。但是传输可靠，一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
<hr>
<h2 id="说一下什么是XSS-攻击"><a href="#说一下什么是XSS-攻击" class="headerlink" title="说一下什么是XSS 攻击"></a>说一下什么是XSS 攻击</h2><p>XSS（Cross site Scripting）中文名称为：跨站脚本攻击。XSS的重点不在于跨站，而在于脚本攻击。</p>
<p>XSS原理：恶意攻击在web页面会插入一些恶意的script代码。当用户浏览页面的时候，那么嵌入到web页面中的script代码会执行，因此会达到恶意攻击用户的目的。</p>
<p>后端防范XSS攻击：</p>
<p>最简单直接的方法就是添加Filter过滤器。</p>
<p>实现Filter接口，调用filterChain的doFilter方法，在这里面对servletRequest进行Script、style、sql等</p>
<p><a href="https://blog.csdn.net/qq_33578833/article/details/100742137">https://blog.csdn.net/qq_33578833/article/details/100742137</a></p>
<h2 id="TCP协议如果保证可靠传输"><a href="#TCP协议如果保证可靠传输" class="headerlink" title="TCP协议如果保证可靠传输"></a>TCP协议如果保证可靠传输</h2><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><ul>
<li>每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；</li>
<li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li>
</ul>
<p><strong>1) 无差错情况:</strong></p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/java-interview/7.png?lastModify=1627542547" alt="img" style="zoom: 67%;" />

<p><strong>2) 出现差错情况（超时重传）:</strong></p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/java-interview/8.png?lastModify=1627542612" alt="img" style="zoom:67%;" />

<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了），使用自动重传请求ARQ协议或者连续ARQ协议。</p>
<p><strong>3) 确认丢失和确认迟到</strong></p>
<ul>
<li><strong>确认丢失</strong>：确认消息在传输过程丢失<br><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/java-interview/9.png" alt="img"><br>当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：<ol>
<li>丢弃这个重复的M1消息，不向上层交付。</li>
<li>向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>
</ol>
</li>
<li><strong>确认迟到</strong> ：确认消息在传输过程中迟到<br><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/java-interview/10.png" alt="img"><br>A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：<ol>
<li>A收到重复的确认后，直接丢弃。</li>
<li>B收到重复的M1后，也直接丢弃重复的M1。</li>
</ol>
</li>
</ul>
<h3 id="自动重传请求ARQ协议"><a href="#自动重传请求ARQ协议" class="headerlink" title="自动重传请求ARQ协议"></a>自动重传请求ARQ协议</h3><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。</p>
<p><strong>优点：</strong> 简单</p>
<p><strong>缺点：</strong> 信道利用率低</p>
<h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p>
<p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>滑动窗口是接收端进行的流量控制。流量控制是为了控制发送方的发送速率，保证接收方来得及接收信息。发送方和接收方都有一个缓存队列，接收方发送确认报文的时候都会携带上要求发送方的流量窗口大小。当接收方的缓存队列已经满的时候，接收方在发送确认报文的时候，会减小窗口大小，使发送发下一次发送更少的数据。因为这个窗口时动态改变大小的，所以叫滑动窗口。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>就是使用滑动窗口来实现流量控制</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>拥塞控制也是对流量 的控制，是发送方主动发起的。拥塞控制主要是解决网络中的流量过大超过了资源所能利用的部分，对所有的主机、路由器 造成影响。就想一个红绿灯路口的车辆过多就会造成拥塞，这个时候就需要降级车辆的数量、增大数据传输速率。</p>
<p>TCP发送方会维持一个拥塞窗口（cwnd）的状态变量，一次性发送数据量的大小</p>
<p>TCP的拥塞控制采用了三种算法：慢开始、拥塞避免、快重传和快恢复。</p>
<p><strong>慢开始</strong>：慢开始算法的思路是当主机开始发送数据时，如果⽴即把⼤量数据字节注⼊到⽹络，那么可能会引起⽹络阻塞，因为现在还不知道⽹络的符合情况。经验表明，᫾好的⽅法是先探测⼀下，即由⼩到⼤逐渐增⼤发送窗⼝，也就是由⼩到⼤逐渐增⼤拥塞窗⼝数值。cwnd初始值为1，每经过⼀个传播轮次，cwnd加倍。</p>
<p><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗⼝cwnd缓慢增⼤，即每经过⼀个往返时间RTT就把发送放的cwnd加1.</p>
<p><strong>快重传与快恢复：</strong>在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是⼀种拥塞控制算法，它能<strong>快速恢复丢失的数据包</strong>。没有 FRR，如果数据包丢失了，TCP 将会使⽤定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到⼀个不按顺序的数据段，它会⽴即给发送机发送⼀个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并⽴即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地⼯作。当有多个数据信息包在某⼀段很短的时间内丢失时，它则不能很有效地⼯作。</p>
<p>整体流程：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/java-interview/image-20200623214100440.png" alt="image-20200623214100440"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/java-interview/image-20200623220009542.png" alt="image-20200623220009542"></p>
<p>这个几个算法是相互联合在一起的。传输过程最开始使用的慢开始算法，然后到达阈值后使用拥塞避免算法，</p>
<p>为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量，ssthresh的用法如下：</p>
<ul>
<li>当 cwnd &lt; ssthresh时：使用慢开始算法</li>
<li>当cwnd = ssthresh时：采用 慢开始或拥塞避免中的任意一种</li>
<li>当 cwnd &gt; ssthresh时：采用拥塞避免算法</li>
</ul>
<p>在最开始的时候，有一个传输阈值，先进行慢开始算法，每一次传输完成（客户端接受到了ack）则cwnd翻倍，一直到阈值为止</p>
<ul>
<li>如果中间出现了超时（未收到ack）则cwnd变为1，ssthresh变为原来的75%，继续使用慢开始算法，知道cwnd=ssthresh</li>
</ul>
<hr>
<h2 id="浏览器输入URL之后到现界面的过程，用了哪些协议"><a href="#浏览器输入URL之后到现界面的过程，用了哪些协议" class="headerlink" title="浏览器输入URL之后到现界面的过程，用了哪些协议"></a>浏览器输入URL之后到现界面的过程，用了哪些协议</h2><ol>
<li>浏览器查找域名的ip地址——DNS协议</li>
<li>浏览器向web服务器发送一个http请求<ol>
<li>TCP协议建立连接</li>
<li>IP协议，发送数据在网络层使用 ip协议</li>
<li>OSPF（Open Shortest Path First）协议，开放的最短路径优先协议，路由器寻址</li>
<li>ARP：路由器与服务器通信的时候，将ip地址转换为mac地址，需要使用ARP协议</li>
<li>HTTP：在TCP建立完成后，使用HTTP协议访问网页</li>
</ol>
</li>
<li>服务器处理请求（请求 处理请求&amp;它的参数、cookies、生成一个HTML响应）</li>
<li>服务器发回一个HTML响应</li>
<li>浏览器解析显示HTML</li>
</ol>
<hr>
<h2 id="HTTP1-0和HTTP1-1的主要区别"><a href="#HTTP1-0和HTTP1-1的主要区别" class="headerlink" title="HTTP1.0和HTTP1.1的主要区别"></a>HTTP1.0和HTTP1.1的主要区别</h2><p>http1.0最早在网页中使用是1996年就，http1.1在1999年开始广泛应用于现在各大浏览器网络请求中，同时HTTP1.1也是目前使用最广泛的HTTP协议。</p>
<p>主要区别：</p>
<ol>
<li><p>长链接：在HTTP1.0中，默认使用的是短连接，也就是每次请求都要重新建立一次连接。HTTP是基于TCP/IP协议的，每一次建立或断开连接都需要三次握手和四次挥手的开销，如果每次请求都要这样，开销比较大。因此最好维持一个长链接，使用长链接来发送多个请求。HTTP1.1开始，默认使用长链接，默认开启Connection： keep-alive。</p>
<ol>
<li>HTTP-1.1的持续连接有非流水线方式和流水线方式。<ol>
<li>流水线方式：在客户接受到HTTP的响应报文之前能接着发送新的请求报文。</li>
<li>非流水线方式：是客户在收到前一个响应后才能发送下一个请求。</li>
</ol>
</li>
</ol>
</li>
<li><p>错误状态响应吗：在HTTP1.1中新增24个错误状态响应码</p>
<p>例如：</p>
<ol>
<li>409表示请求的资源与资源的当前状态发生冲突</li>
<li>410表示服务器上的某个资源被永久性删除</li>
</ol>
<p>常用：</p>
<p>​    </p>
<table>
<thead>
<tr>
<th>转态码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>4XX</td>
<td>客户端错误</td>
</tr>
<tr>
<td>404</td>
<td>服务器无法找到请求的资源</td>
</tr>
<tr>
<td>400</td>
<td>服务器不理就请求的语法</td>
</tr>
<tr>
<td>403</td>
<td>禁止访问，服务器拒绝访问</td>
</tr>
<tr>
<td>405</td>
<td>资源被禁止，禁用请求中的指定方法</td>
</tr>
<tr>
<td>401</td>
<td>未授权</td>
</tr>
<tr>
<td>415</td>
<td>不支持的媒体类型</td>
</tr>
<tr>
<td>5XX</td>
<td>服务端错误</td>
</tr>
<tr>
<td>2XX</td>
<td>成功</td>
</tr>
</tbody></table>
</li>
<li><p>缓存处理：在HTTP1.0中主要使用header中的If-Modified-Since（文件修改时间）,Expires（文件过期时间）来做为缓存判断的标准，HTTP1.1则引⼊了更多的缓存控制策略例如Entity tag（文件唯一标识符），If-Unmodified-Since, If-Match,If-None-Match（tag的key）等更多可供选择的缓存头来控制缓存策略</p>
<p>​    <a href="https://www.cnblogs.com/echolun/p/9419517.html">https://www.cnblogs.com/echolun/p/9419517.html</a></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/java-interview/2d64ca59052d0c7a7fa594103e40d124.png" alt="img"></p>
</li>
</ol>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/java-interview/2058305a8795359138ec6bfb78b06c35.png" alt="img"></p>
<ol start="4">
<li><p>带宽优化及网络连接的使用：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象发送过来了，并且都不支持断点续传功能。，HTTP1.1则在请求头引⼊了range头域，它允许只请求资源的某个部分，即返回码是206（PartialContent），这样就⽅便了开发者⾃由的选择以便于充分利⽤带宽和连接。</p>
<ol>
<li><strong>断点续传</strong><br>HTTP1.0:不支持断点续传，如果请求被中断，则必须重新再次发送，对于大文件的下载和传输不友好，尤其是在网络不好的情况下<br>HTTP1.1:支持断点续传，利用HTTP消息头使用分块传输编码，将实体主体分块传输。垮掉了还能捡起来，很棒。客户端在发送的时候在发送一个range字段，记录bytes字段，然后从这个位置开始传输</li>
</ol>
</li>
<li><p>Host头处理：<br>HTTP1.0:认为每台服务器都绑定唯一的IP地址，因此请求消息的URL中并没有传递主机名<br>HTTP1.1:随着虚拟机技术的发展，一台物理服务器上可以存在多个虚拟主机，并且共享一个IP地址，这就需要我们在请求时指明是那台主机了。所以HTTP1.1的请求消息和响应消息都应支持Host头域，如果请求消息中没有Host头域，会报错（400）</p>
</li>
</ol>
<hr>
<h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h2><ol>
<li><p><strong>端口</strong>：</p>
<p>http的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使⽤端⼝443。</p>
</li>
<li><p><strong>安全性和资源消耗：</strong> HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p>
<ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等</li>
</ul>
</li>
</ol>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/java-interview/20190509111404989.png" alt="img" style="zoom:67%;" />

<p>上述过程就是两次HTTP请求（第一次非对称加密保证安全，第二次是对称加密保证速率），其详细过程如下：</p>
<p>1.客户端想服务器发起HTTPS的请求，连接到服务器的443端口；</p>
<p>2.服务器将非对称加密的公钥传递给客户端，以证书的形式回传到客户端</p>
<p>3.服务器接受到该公钥进行验证，就是验证2中证书，如果有问题，则HTTPS请求无法继续；如果没有问题，则上述公钥是合格的。（第一次HTTP请求）客户端这个时候随机生成一个私钥，成为client key,客户端私钥，用于对称加密数据的。使用前面的公钥对client key进行非对称加密；</p>
<p>4.进行二次HTTP请求，将加密之后的client key传递给服务器；</p>
<p>5.服务器使用私钥进行解密，得到client key,使用client key对数据进行对称加密</p>
<p>6.将对称加密的数据传递给客户端，客户端使用对称解密，得到服务器发送的数据，完成第二次HTTP请求。</p>
<h4 id="HTTPS为什么要进行证书验证，不验证回出现什么问题"><a href="#HTTPS为什么要进行证书验证，不验证回出现什么问题" class="headerlink" title="HTTPS为什么要进行证书验证，不验证回出现什么问题"></a>HTTPS为什么要进行证书验证，不验证回出现什么问题</h4><p>公钥如果任意在网络中传播，很可能被非法中间商截获然后自己在颁布自己的公钥给客户端，然后中间的传输就是用的非法中间商的公钥和私钥。</p>
<p>这个时候就需要验证公钥的合法性（验证证书）。</p>
<ul>
<li>服务器端先把自己的公钥给证书颁发机构，向证书颁发机构申请证书</li>
<li>证书颁发机构自己也有一堆公钥和私钥。机构利用自己的私钥来解密Key1，通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给服务端。</li>
<li>当客户端向服务端请求通信的时候，服务端不再直接返回自己的公钥，而是把自己申请的证书返回给客户端。</li>
<li>客户端收到证书以后，要做的第一件事就是验证证书的真伪，需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥，所以客户端只需要知道是哪个机构颁发的证书，就可以从本地找到对应的机构公钥，解密出证书签名。</li>
</ul>
<h2 id="ping的过程"><a href="#ping的过程" class="headerlink" title="ping的过程"></a>ping的过程</h2><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>状态码分类：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1**</td>
<td><strong>信息</strong>，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td>2**</td>
<td><strong>成功</strong>，操作被成功接收并处理</td>
</tr>
<tr>
<td>3**</td>
<td><strong>重定向</strong>，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td>4**</td>
<td><strong>请求错误</strong>，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td>5**</td>
<td><strong>服务器错误</strong>，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
<p>常见状态码：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态码英文名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>Continue</td>
<td>客户端应当继续发送请求</td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocols</td>
<td>切换协议（只能切换到更高级的协议，例如，切换到HTTP的新版本协议）。</td>
</tr>
<tr>
<td><strong>200</strong></td>
<td><strong>OK</strong></td>
<td><strong>请求成功。一般用于GET与POST请求</strong></td>
</tr>
<tr>
<td><strong>201</strong></td>
<td><strong>Created</strong></td>
<td><strong>已创建。成功请求并创建了新的资源</strong></td>
</tr>
<tr>
<td><strong>202</strong></td>
<td><strong>Accepted</strong></td>
<td><strong>已接受。已经接受请求，但未处理完成</strong></td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information</td>
<td>非授权信息。请求成功。但返回的实体头部元信息不在原始的服务器，而是一个副本（来自本地或者第三方的拷贝）</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>无内容。服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。在未更新网页的情况下，可确保浏览器继续显示当前文档。</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content</td>
<td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td>部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td>300</td>
<td>Multiple Choices</td>
<td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td><strong>301</strong></td>
<td><strong>Moved Permanently</strong></td>
<td><strong>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</strong></td>
</tr>
<tr>
<td><strong>302</strong></td>
<td><strong>Found</strong></td>
<td><strong>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</strong></td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td><strong>400</strong></td>
<td><strong>Bad Request</strong></td>
<td><strong>客户端请求的语法错误，服务器无法理解</strong></td>
</tr>
<tr>
<td><strong>401</strong></td>
<td><strong>Unauthorized</strong></td>
<td><strong>请求要求用户的身份认证（没有权限）</strong></td>
</tr>
<tr>
<td><strong>402</strong></td>
<td><strong>Payment Required</strong></td>
<td><strong>保留，将来使用</strong></td>
</tr>
<tr>
<td><strong>403</strong></td>
<td><strong>Forbidden</strong></td>
<td><strong>服务器理解请求客户端的请求，但是拒绝执行此请求（权限不足）</strong></td>
</tr>
<tr>
<td><strong>404</strong></td>
<td><strong>Not Found</strong></td>
<td><strong>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</strong></td>
</tr>
<tr>
<td><strong>405</strong></td>
<td><strong>Method Not Allowed</strong></td>
<td><strong>客户端请求中的方法被禁止</strong></td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td><strong>408</strong></td>
<td><strong>Request Time-out</strong></td>
<td><strong>服务器等待客户端发送的请求时间过长，超时</strong></td>
</tr>
<tr>
<td><strong>500</strong></td>
<td><strong>Internal Server Error</strong></td>
<td><strong>服务器内部错误，无法完成请求</strong></td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td><strong>502</strong></td>
<td><strong>Bad Gateway</strong></td>
<td><strong>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</strong></td>
</tr>
<tr>
<td><strong>503</strong></td>
<td><strong>Service Unavailable</strong></td>
<td><strong>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</strong></td>
</tr>
<tr>
<td><strong>504</strong></td>
<td><strong>Gateway Time-out</strong></td>
<td><strong>充当网关或代理的服务器，未及时从远端服务器获取请求</strong></td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version not supported</td>
<td>服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>计算机网络基础</category>
      </categories>
  </entry>
  <entry>
    <title>netty基础-2</title>
    <url>/a9c392ea.html</url>
    <content><![CDATA[<h1 id="Netty-概述"><a href="#Netty-概述" class="headerlink" title="Netty 概述"></a>Netty 概述</h1><h2 id="原生-NIO-存在的问题"><a href="#原生-NIO-存在的问题" class="headerlink" title="原生 NIO 存在的问题"></a>原生 NIO 存在的问题</h2><ol>
<li><code>NIO</code> 的类库和 <code>API</code> 繁杂，使用麻烦：需要熟练掌握 <code>Selector</code>、<code>ServerSocketChannel</code>、<code>SocketChannel</code>、<code>ByteBuffer</code>等。</li>
<li>需要具备其他的额外技能：要熟悉 <code>Java</code> 多线程编程，因为 <code>NIO</code> 编程涉及到 <code>Reactor</code> 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 <code>NIO</code> 程序。</li>
<li>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。</li>
<li><code>JDK NIO</code> 的 <code>Bug</code>：例如臭名昭著的 <code>Epoll Bug</code>，它会导致 <code>Selector</code> 空轮询，最终导致 <code>CPU100%</code>。直到 <code>JDK1.7</code> 版本该问题仍旧存在，没有被根本解决。</li>
</ol>
<span id="more"></span>

<h2 id="Netty-官网说明"><a href="#Netty-官网说明" class="headerlink" title="Netty 官网说明"></a>Netty 官网说明</h2><p>官网：<a href="https://netty.io/">https://netty.io/</a></p>
<p>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</p>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0001.png" alt="img"></p>
<h2 id="Netty-的优点"><a href="#Netty-的优点" class="headerlink" title="Netty 的优点"></a>Netty 的优点</h2><p><code>Netty</code> 对 <code>JDK</code> 自带的 <code>NIO</code> 的 <code>API</code> 进行了封装，解决了上述问题。</p>
<ol>
<li>设计优雅：适用于各种传输类型的统一 <code>API</code> 阻塞和非阻塞 <code>Socket</code>；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型-单线程，一个或多个线程池。</li>
<li>使用方便：详细记录的 <code>Javadoc</code>，用户指南和示例；没有其他依赖项，<code>JDK5（Netty3.x）</code>或 <code>6（Netty4.x）</code>就足够了。</li>
<li>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</li>
<li>安全：完整的 <code>SSL/TLS</code> 和 <code>StartTLS</code> 支持。</li>
<li>社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 <code>Bug</code> 可以被及时修复，同时，更多的新功能会被加入。</li>
</ol>
<h2 id="Netty-版本说明"><a href="#Netty-版本说明" class="headerlink" title="Netty 版本说明"></a>Netty 版本说明</h2><ol>
<li><code>Netty</code> 版本分为 <code>Netty 3.x</code> 和 <code>Netty 4.x</code>、<code>Netty 5.x</code></li>
<li>因为 <code>Netty 5</code> 出现重大 <code>bug</code>，已经被官网废弃了，目前推荐使用的是 <code>Netty 4.x</code>的稳定版本</li>
<li>目前在官网可下载的版本 <code>Netty 3.x</code>、<code>Netty 4.0.x</code> 和 <code>Netty 4.1.x</code></li>
<li>在本套课程中，我们讲解 <code>Netty4.1.x</code> 版本</li>
<li><code>Netty</code> 下载地址：<a href="https://bintray.com/netty/downloads/netty/">https://bintray.com/netty/downloads/netty/</a></li>
</ol>
<h1 id="Netty-高性能架构设计"><a href="#Netty-高性能架构设计" class="headerlink" title="Netty 高性能架构设计"></a>Netty 高性能架构设计</h1><h2 id="线程模型基本介绍"><a href="#线程模型基本介绍" class="headerlink" title="线程模型基本介绍"></a>线程模型基本介绍</h2><ol>
<li><p>不同的线程模式，对程序的性能有很大影响，为了搞清 <code>Netty</code> 线程模式，我们来系统的讲解下各个线程模式，最后看看 <code>Netty</code> 线程模型有什么优越性。</p>
</li>
<li><p>目前存在的线程模型有：传统阻塞 <code>I/O</code> 服务模型 和<code>Reactor</code> 模式</p>
</li>
<li><p>根据<br>Reactor的数量和处理资源池线程的数量不同，有3 种典型的实现</p>
<ul>
<li>单 <code>Reactor</code> 单线程；</li>
<li>单 <code>Reactor</code> 多线程；</li>
<li>主从 <code>Reactor</code>多线程</li>
</ul>
</li>
<li><p><code>Netty</code> 线程模式（<code>Netty</code> 主要基于主从 <code>Reactor</code> 多线程模型做了一定的改进，其中主从 <code>Reactor</code> 多线程模型有多个 <code>Reactor</code>）</p>
</li>
</ol>
<h2 id="传统阻塞-I-O-服务模型"><a href="#传统阻塞-I-O-服务模型" class="headerlink" title="传统阻塞 I/O 服务模型"></a>传统阻塞 I/O 服务模型</h2><h3 id="工作原理图"><a href="#工作原理图" class="headerlink" title="工作原理图"></a>工作原理图</h3><ol>
<li>黄色的框表示对象，蓝色的框表示线程</li>
<li>白色的框表示方法（<code>API</code>）</li>
</ol>
<h3 id="模型特点"><a href="#模型特点" class="headerlink" title="模型特点"></a>模型特点</h3><ol>
<li>采用阻塞 <code>IO</code> 模式获取输入的数据</li>
<li>每个连接都需要独立的线程完成数据的输入，业务处理，数据返回</li>
</ol>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ol>
<li>当并发数很大，就会创建大量的线程，占用很大系统资源</li>
<li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在 Handler对象中的<code>read</code> 操作，导致上面的处理线程资源浪费</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0002.png" alt="img"></p>
<h2 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h2><h3 id="针对传统阻塞-I-O-服务模型的-2-个缺点，解决方案："><a href="#针对传统阻塞-I-O-服务模型的-2-个缺点，解决方案：" class="headerlink" title="针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案："></a>针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案：</h3><p>基于 <code>I/O</code> 复用模型：多个连接共用一个阻塞对象<code>ServiceHandler</code>，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。</p>
<p><code>Reactor</code> 在不同书中的叫法：</p>
<ol>
<li>反应器模式</li>
<li>分发者模式（Dispatcher）</li>
<li>通知者模式（notifier）</li>
<li>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。（解决了当并发数很大时，会创建大量线程，占用很大系统资源）</li>
<li>基于 <code>I/O</code> 复用模型：多个客户端进行连接，先把连接请求给<code>ServiceHandler</code>。多个连接共用一个阻塞对象<code>ServiceHandler</code>。假设，当C1连接没有数据要处理时，C1客户端只需要阻塞于<code>ServiceHandler</code>，C1之前的处理线程便可以处理其他有数据的连接，不会造成线程资源的浪费。当C1连接再次有数据时，<code>ServiceHandler</code>根据线程池的空闲状态，将请求分发给空闲的线程来处理C1连接的任务。（解决了线程资源浪费的那个问题）</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0003.png" alt="img"></p>
<h3 id="I-O-复用结合线程池，就是-Reactor-模式基本设计思想，如图"><a href="#I-O-复用结合线程池，就是-Reactor-模式基本设计思想，如图" class="headerlink" title="I/O 复用结合线程池，就是 Reactor 模式基本设计思想，如图"></a>I/O 复用结合线程池，就是 Reactor 模式基本设计思想，如图</h3><p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0004.png" alt="img"></p>
<p>对上图说明：</p>
<ol>
<li><code>Reactor</code> 模式，通过一个或多个输入同时传递给服务处理器（ServiceHandler）的模式（基于事件驱动）</li>
<li>服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程，因此 <code>Reactor</code> 模式也叫 <code>Dispatcher</code> 模式</li>
<li><code>Reactor</code> 模式使用 <code>IO</code> 复用监听事件，收到事件后，分发给某个线程（进程），这点就是网络服务器高并发处理关键</li>
</ol>
<blockquote>
<p>原先有多个Handler阻塞，现在只用一个ServiceHandler阻塞</p>
</blockquote>
<h3 id="Reactor-模式中核心组成"><a href="#Reactor-模式中核心组成" class="headerlink" title="Reactor 模式中核心组成"></a>Reactor 模式中核心组成</h3><ol>
<li><code>Reactor（也就是那个ServiceHandler）</code>：<code>Reactor</code> 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理线程来对 <code>IO</code> 事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；</li>
<li><code>Handlers（处理线程EventHandler）</code>：处理线程执行 <code>I/O</code> 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。<code>Reactor</code> 通过调度适当的处理线程来响应 <code>I/O</code> 事件，处理程序执行非阻塞操作。</li>
</ol>
<h3 id="Reactor-模式分类"><a href="#Reactor-模式分类" class="headerlink" title="Reactor 模式分类"></a>Reactor 模式分类</h3><p>根据 <code>Reactor</code> 的数量和处理资源池线程的数量不同，有 <code>3</code> 种典型的实现</p>
<ol>
<li>单 <code>Reactor</code> 单线程</li>
<li>单 <code>Reactor</code> 多线程</li>
<li>主从 <code>Reactor</code> 多线程</li>
</ol>
<h2 id="单-Reactor-单线程"><a href="#单-Reactor-单线程" class="headerlink" title="单 Reactor 单线程"></a>单 Reactor 单线程</h2><p>原理图，并使用 <code>NIO</code> 群聊系统验证</p>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0005.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0005.png" alt="img"></p>
<h3 id="方案说明"><a href="#方案说明" class="headerlink" title="方案说明"></a>方案说明</h3><ol>
<li><code>Select</code> 是前面 <code>I/O</code> 复用模型介绍的标准网络编程 <code>API</code>，可以实现应用程序通过一个阻塞对象监听多路连接请求</li>
<li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后通过 <code>Dispatch</code> 进行分发</li>
<li>如果是建立连接请求事件，则由 <code>Acceptor</code> 通过 <code>Accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理连接完成后的后续业务处理</li>
<li>如果不是建立连接事件，则 <code>Reactor</code> 会分发调用连接对应的 <code>Handler</code> 来响应</li>
<li><code>Handler</code> 会完成 <code>Read</code> → 业务处理 → <code>Send</code> 的完整业务流程</li>
</ol>
<p>结合实例：服务器端用一个线程通过多路复用搞定所有的 <code>IO</code> 操作（包括连接，读、写等），编码简单，清晰明了，但是如果客户端连接数量较多，将无法支撑，前面的 <code>NIO</code> 案例就属于这种模型。</p>
<h3 id="方案优缺点分析"><a href="#方案优缺点分析" class="headerlink" title="方案优缺点分析"></a>方案优缺点分析</h3><ol>
<li>优点：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</li>
<li>缺点：性能问题，只有一个线程，无法完全发挥多核 <code>CPU</code> 的性能。<code>Handler</code>在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li>
<li>缺点：可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li>
<li>使用场景：客户端的数量有限，业务处理非常快速，比如 <code>Redis</code> 在业务处理的时间复杂度 <code>O(1)</code> 的情况</li>
</ol>
<h2 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor 多线程"></a>单 Reactor 多线程</h2><h3 id="方案说明-1"><a href="#方案说明-1" class="headerlink" title="方案说明"></a>方案说明</h3><p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0006.png" alt="img"></p>
<ol>
<li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后，通过 <code>Dispatch</code> 进行分发</li>
<li>如果是建立连接请求，则由 <code>Acceptor</code> 通过 <code>accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理完成连接后的各种事件</li>
<li>如果不是连接请求，则由 <code>Reactor</code> 分发调用连接对应的 <code>handler</code> 来处理（也就是说连接已经建立，后续客户端再来请求，那基本就是数据请求了，直接调用之前为这个连接创建好的handler来处理）</li>
<li><code>handler</code> 只负责响应事件，不做具体的业务处理（这样不会使handler阻塞太久），通过 <code>read</code> 读取数据后，会分发给后面的 <code>worker</code> 线程池的某个线程处理业务。【业务处理是最费时的，所以将业务处理交给线程池去执行】</li>
<li><code>worker</code> 线程池会分配独立线程完成真正的业务，并将结果返回给 <code>handler</code></li>
<li><code>handler</code> 收到响应后，通过 <code>send</code> 将结果返回给 <code>client</code></li>
</ol>
<h3 id="方案优缺点分析-1"><a href="#方案优缺点分析-1" class="headerlink" title="方案优缺点分析"></a>方案优缺点分析</h3><ol>
<li>优点：可以充分的利用多核 <code>cpu</code> 的处理能力</li>
<li>缺点：多线程数据共享和访问比较复杂。<code>Reactor</code> 承担所有的事件的监听和响应，它是单线程运行，在高并发场景容易出现性能瓶颈。也就是说<code>Reactor</code>主线程承担了过多的事</li>
</ol>
<h2 id="主从-Reactor-多线程"><a href="#主从-Reactor-多线程" class="headerlink" title="主从 Reactor 多线程"></a>主从 Reactor 多线程</h2><h3 id="工作原理图-1"><a href="#工作原理图-1" class="headerlink" title="工作原理图"></a>工作原理图</h3><p>针对单 <code>Reactor</code> 多线程模型中，<code>Reactor</code> 在单线程中运行，高并发场景下容易成为性能瓶颈，可以让 <code>Reactor</code> 在多线程中运行</p>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0007.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0008.jpg" alt="img"></p>
<blockquote>
<p>SubReactor是可以有多个的，如果只有一个SubReactor的话那和<code>单 Reactor 多线程</code>就没什么区别了。</p>
</blockquote>
<ol>
<li><code>Reactor</code> 主线程 <code>MainReactor</code> 对象通过 <code>select</code> 监听连接事件，收到事件后，通过 <code>Acceptor</code> 处理连接事件</li>
<li>当 <code>Acceptor</code> 处理连接事件后，<code>MainReactor</code> 将连接分配给 <code>SubReactor</code></li>
<li><code>subreactor</code> 将连接加入到连接队列进行监听，并创建 <code>handler</code> 进行各种事件处理</li>
<li>当有新事件发生时，<code>subreactor</code> 就会调用对应的 <code>handler</code> 处理</li>
<li><code>handler</code> 通过 <code>read</code> 读取数据，分发给后面的 <code>worker</code> 线程处理</li>
<li><code>worker</code> 线程池分配独立的 <code>worker</code> 线程进行业务处理，并返回结果</li>
<li><code>handler</code> 收到响应的结果后，再通过 <code>send</code> 将结果返回给 <code>client</code></li>
<li><code>Reactor</code> 主线程可以对应多个 <code>Reactor</code> 子线程，即 <code>MainRecator</code> 可以关联多个 <code>SubReactor</code></li>
</ol>
<h3 id="Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解"><a href="#Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解" class="headerlink" title="Scalable IO in Java 对 Multiple Reactors 的原理图解"></a>Scalable IO in Java 对 Multiple Reactors 的原理图解</h3><p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0009.jpg" alt="img"></p>
<h3 id="方案优缺点说明"><a href="#方案优缺点说明" class="headerlink" title="方案优缺点说明"></a>方案优缺点说明</h3><ol>
<li>优点：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</li>
<li>优点：父线程与子线程的数据交互简单，<code>Reactor</code> 主线程只需要把新连接传给子线程，子线程无需返回数据。</li>
<li>缺点：编程复杂度较高</li>
</ol>
<p>结合实例：这种模型在许多项目中广泛使用，包括 <code>Nginx</code> 主从 <code>Reactor</code> 多进程模型，<code>Memcached</code> 主从多线程，<code>Netty</code> 主从多线程模型的支持</p>
<h2 id="Reactor-模式小结"><a href="#Reactor-模式小结" class="headerlink" title="Reactor 模式小结"></a>Reactor 模式小结</h2><h3 id="3-种模式用生活案例来理解"><a href="#3-种模式用生活案例来理解" class="headerlink" title="3 种模式用生活案例来理解"></a>3 种模式用生活案例来理解</h3><ol>
<li>单 <code>Reactor</code> 单线程，前台接待员和服务员是同一个人，全程为顾客服</li>
<li>单 <code>Reactor</code> 多线程，<code>1</code> 个前台接待员，多个服务员，接待员只负责接待</li>
<li>主从 <code>Reactor</code> 多线程，多个前台接待员，多个服务生</li>
</ol>
<h3 id="Reactor-模式具有如下的优点"><a href="#Reactor-模式具有如下的优点" class="headerlink" title="Reactor 模式具有如下的优点"></a>Reactor 模式具有如下的优点</h3><ol>
<li>响应快，不必为单个同步时间所阻塞，虽然 <code>Reactor</code> 本身依然是同步的（比如你第一个SubReactor阻塞了，我可以调下一个 SubReactor为客户端服务）</li>
<li>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销</li>
<li>扩展性好，可以方便的通过增加 <code>Reactor</code> 实例个数来充分利用 <code>CPU</code> 资源</li>
<li>复用性好，<code>Reactor</code> 模型本身与具体事件处理逻辑无关，具有很高的复用性</li>
</ol>
<h2 id="Netty-模型"><a href="#Netty-模型" class="headerlink" title="Netty 模型"></a>Netty 模型</h2><blockquote>
<p>讲解netty的时候采用的是先写代码体验一下，再细讲里面的原理。前面看不懂的可以先不用纠结，先往后面看，后面基本都会讲清楚</p>
</blockquote>
<h3 id="工作原理示意图1-简单版"><a href="#工作原理示意图1-简单版" class="headerlink" title="工作原理示意图1 - 简单版"></a>工作原理示意图1 - 简单版</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Netty` 主要基于主从 `Reactors` 多线程模型（如图）做了一定的改进，其中主从 `Reactor` 多线程模型有多个 `Reactor</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0010.png" alt="img"></p>
<p><strong>对上图说明</strong></p>
<ol>
<li><code>BossGroup</code> 线程维护 <code>Selector</code>，只关注 <code>Accecpt</code></li>
<li>当接收到 <code>Accept</code> 事件，获取到对应的 <code>SocketChannel</code>，封装成 <code>NIOScoketChannel</code> 并注册到 <code>Worker</code> 线程（事件循环），并进行维护</li>
<li>当 <code>Worker</code> 线程监听到 <code>Selector</code> 中通道发生自己感兴趣的事件后，就进行处理（就由 <code>handler</code>），注意 <code>handler</code> 已经加入到通道</li>
</ol>
<h3 id="工作原理示意图2-进阶版"><a href="#工作原理示意图2-进阶版" class="headerlink" title="工作原理示意图2 - 进阶版"></a>工作原理示意图2 - 进阶版</h3><p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0011.png" alt="img"></p>
<p><code>BossGroup</code>有点像主<code>Reactor</code> 可以有多个，<code>WorkerGroup</code>则像<code>SubReactor</code>一样可以有多个。</p>
<h3 id="工作原理示意图3-详细版"><a href="#工作原理示意图3-详细版" class="headerlink" title="工作原理示意图3 - 详细版"></a>工作原理示意图3 - 详细版</h3><p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0012.png" alt="img"></p>
<ol>
<li><p><code>Netty</code> 抽象出两组线程池 ，<code>BossGroup</code> 专门负责接收客户端的连接，<code>WorkerGroup</code> 专门负责网络的读写</p>
</li>
<li><p><code>BossGroup</code> 和 <code>WorkerGroup</code> 类型都是 <code>NioEventLoopGroup</code></p>
</li>
<li><p><code>NioEventLoopGroup</code> 相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是 <code>NioEventLoop</code></p>
</li>
<li><p><code>NioEventLoop</code> 表示一个不断循环的执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code> 的网络通讯</p>
</li>
<li><p><code>NioEventLoopGroup</code> 可以有多个线程，即可以含有多个 <code>NioEventLoop</code></p>
</li>
<li><p>每个BossGroup下面的NioEventLoop循环执行的步骤有 3步</p>
<ul>
<li>轮询 <code>accept</code> 事件</li>
<li>处理 <code>accept</code> 事件，与 <code>client</code> 建立连接，生成 <code>NioScocketChannel</code>，并将其注册到某个 <code>workerGroup</code> <code>NIOEventLoop</code> 上的 <code>Selector</code></li>
<li>继续处理任务队列的任务，即 <code>runAllTasks</code></li>
</ul>
</li>
<li><p>每个WorkerGroupNIOEventLoop循环执行的步骤</p>
<ul>
<li>轮询 <code>read</code>，<code>write</code> 事件</li>
<li>处理 <code>I/O</code> 事件，即 <code>read</code>，<code>write</code> 事件，在对应 <code>NioScocketChannel</code> 处理</li>
<li>处理任务队列的任务，即 <code>runAllTasks</code></li>
</ul>
</li>
<li><p>每个 <code>Worker</code> <code>NIOEventLoop</code> 处理业务时，会使用 <code>pipeline</code>（管道），<code>pipeline</code> 中包含了 <code>channel（通道）</code>，即通过 <code>pipeline</code> 可以获取到对应通道，管道中维护了很多的处理器。（这个点目前只是简单的讲，后面重点说）</p>
</li>
</ol>
<h3 id="Netty-快速入门实例-TCP-服务"><a href="#Netty-快速入门实例-TCP-服务" class="headerlink" title="Netty 快速入门实例 - TCP 服务"></a>Netty 快速入门实例 - TCP 服务</h3><p>实例要求：使用 <code>IDEA</code> 创建 <code>Netty</code> 项目</p>
<ol>
<li><code>Netty</code> 服务器在 <code>6668</code> 端口监听，客户端能发送消息给服务器”hello,服务器~”</li>
<li>服务器可以回复消息给客户端”hello,客户端~”</li>
<li>目的：对 <code>Netty</code> 线程模型有一个初步认识，便于理解 <code>Netty</code> 模型理论</li>
<li><ol>
<li>编写服务端</li>
<li>编写客户端</li>
<li>对 <code>netty</code> 程序进行分析，看看 <code>netty</code> 模型特点</li>
<li>说明：创建 <code>Maven</code> 项目，并引入 <code>Netty</code> 包</li>
</ol>
</li>
<li>代码如下</li>
</ol>
<h4 id="NettyServer"><a href="#NettyServer" class="headerlink" title="NettyServer"></a>NettyServer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建BossGroup 和 WorkerGroup</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. 创建两个线程组 bossGroup 和 workerGroup</span></span><br><span class="line">        <span class="comment">//2. bossGroup 只是处理连接请求 , 真正的和客户端业务处理，会交给 workerGroup完成</span></span><br><span class="line">        <span class="comment">//3. 两个都是无限循环</span></span><br><span class="line">        <span class="comment">//4. bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数</span></span><br><span class="line">        <span class="comment">//   默认实际 cpu核数 * 2</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端的启动对象，配置参数</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用链式编程来进行设置</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup) <span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">//使用NioSocketChannel 作为服务器的通道实现</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) <span class="comment">// 设置线程队列等待连接个数</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>) <span class="comment">//设置保持活动连接状态</span></span><br><span class="line"><span class="comment">//                    .handler(null) // 该 handler对应 bossGroup , childHandler 对应 workerGroup</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<span class="comment">//创建一个通道初始化对象(匿名对象)</span></span><br><span class="line">                        <span class="comment">//给pipeline 设置处理器</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;客户socketchannel hashcode=&quot;</span> + ch.hashCode()); <span class="comment">//可以使用一个集合管理 SocketChannel， 再推送消息时，可以将业务加入到各个channel 对应的 NIOEventLoop 的 taskQueue 或者 scheduleTaskQueue</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;); <span class="comment">// 给我们的workerGroup 的 EventLoop 对应的管道设置处理器</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;.....服务器 is ready...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绑定一个端口并且同步生成了一个 ChannelFuture 对象（也就是立马返回这样一个对象）</span></span><br><span class="line">            <span class="comment">//启动服务器(并绑定端口)</span></span><br><span class="line">            ChannelFuture cf = bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给cf 注册监听器，监控我们关心的事件</span></span><br><span class="line"></span><br><span class="line">            cf.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (cf.isSuccess()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口 6668 成功&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口 6668 失败&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//对关闭通道事件  进行监听</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NettyServerHandler"><a href="#NettyServerHandler" class="headerlink" title="NettyServerHandler"></a>NettyServerHandler</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明</span></span><br><span class="line"><span class="comment">1. 我们自定义一个Handler 需要继承netty 规定好的某个HandlerAdapter(规范)</span></span><br><span class="line"><span class="comment">2. 这时我们自定义一个Handler , 才能称为一个handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据事件(这里我们可以读取客户端发送的消息)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span></span><br><span class="line"><span class="comment">    2. Object msg: 就是客户端发送的数据 默认Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器读取线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; channle =&quot;</span> + ctx.channel());</span><br><span class="line">        System.out.println(<span class="string">&quot;server ctx =&quot;</span> + ctx);</span><br><span class="line">        System.out.println(<span class="string">&quot;看看channel 和 pipeline的关系&quot;</span>);</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        ChannelPipeline pipeline = ctx.pipeline(); <span class="comment">//本质是一个双向链表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 msg 转成一个 ByteBuf</span></span><br><span class="line">        <span class="comment">//ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.</span></span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发送消息是:&quot;</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端地址:&quot;</span> + channel.remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//writeAndFlush 是 write + flush</span></span><br><span class="line">        <span class="comment">//将数据写入到缓存，并刷新</span></span><br><span class="line">        <span class="comment">//一般讲，我们对这个发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵1&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发生异常后, 一般是需要关闭通道</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NettyClient"><a href="#NettyClient" class="headerlink" title="NettyClient"></a>NettyClient</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            <span class="comment">//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(group) <span class="comment">//设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel.class) <span class="comment">// 设置客户端通道的实现类(反射)</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyClientHandler()); <span class="comment">//加入自己的处理器</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端 ok..&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动客户端去连接服务器端</span></span><br><span class="line">            <span class="comment">//关于 ChannelFuture 要分析，涉及到netty的异步模型</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//对关闭通道事件  进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NettyClientHandler"><a href="#NettyClientHandler" class="headerlink" title="NettyClientHandler"></a>NettyClientHandler</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通道就绪就会触发该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;client &quot;</span> + ctx);</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello, server: (&gt;^ω^&lt;)喵&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通道有读取事件时，会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器回复的消息:&quot;</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器的地址： &quot;</span>+ ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="任务队列中的-Task-有-3-种典型使用场景"><a href="#任务队列中的-Task-有-3-种典型使用场景" class="headerlink" title="任务队列中的 Task 有 3 种典型使用场景"></a>任务队列中的 Task 有 3 种典型使用场景</h3><ol>
<li>用户程序自定义的普通任务【举例说明】</li>
<li>用户自定义定时任务</li>
<li>非当前 <code>Reactor</code> 线程调用 <code>Channel</code> 的各种方法<br>例如在<strong>推送系统</strong>的业务线程里面，根据用户的标识，找到对应的 <code>Channel</code> 引用，然后调用 <code>Write</code> 类方法向该用户推送消息，就会进入到这种场景。最终的 <code>Write</code> 会提交到任务队列中后被异步消费</li>
</ol>
<p>前两种的代码举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明</span></span><br><span class="line"><span class="comment"> * 1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范)</span></span><br><span class="line"><span class="comment"> * 2. 这时我们自定义一个Handler , 才能称为一个handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span></span><br><span class="line"><span class="comment">     * 2. Object msg: 就是客户端发送的数据 默认Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比如这里我们有一个非常耗时长的业务-&gt; 异步执行 -&gt; 提交该channel 对应的</span></span><br><span class="line">        <span class="comment">// NIOEventLoop 的 taskQueue中,</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解决方案1 用户程序自定义的普通任务</span></span><br><span class="line"></span><br><span class="line">        ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵2&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">                    System.out.println(<span class="string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;发生异常&quot;</span> + ex.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵3&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">                    System.out.println(<span class="string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;发生异常&quot;</span> + ex.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解决方案2 : 用户自定义定时任务 -》 该任务是提交到 scheduleTaskQueue中</span></span><br><span class="line"></span><br><span class="line">        ctx.channel().eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵4&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">                    System.out.println(<span class="string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;发生异常&quot;</span> + ex.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;go on ...&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(&quot;服务器读取线程 &quot; + Thread.currentThread().getName() + &quot; channle =&quot; + ctx.channel());</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;server ctx =&quot; + ctx);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;看看channel 和 pipeline的关系&quot;);</span></span><br><span class="line"><span class="comment">//        Channel channel = ctx.channel();</span></span><br><span class="line"><span class="comment">//        ChannelPipeline pipeline = ctx.pipeline(); //本质是一个双向链接, 出站入站</span></span><br><span class="line"><span class="comment">//        </span></span><br><span class="line"><span class="comment">//        //将 msg 转成一个 ByteBuf</span></span><br><span class="line"><span class="comment">//        //ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.</span></span><br><span class="line"><span class="comment">//        ByteBuf buf = (ByteBuf) msg;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;客户端发送消息是:&quot; + buf.toString(CharsetUtil.UTF_8));</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;客户端地址:&quot; + channel.remoteAddress());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//writeAndFlush 是 write + flush</span></span><br><span class="line">        <span class="comment">//将数据写入到缓存，并刷新</span></span><br><span class="line">        <span class="comment">//一般讲，我们对这个发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵1&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常, 一般是需要关闭通道</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方案再说明"><a href="#方案再说明" class="headerlink" title="方案再说明"></a>方案再说明</h3><ol>
<li><code>Netty</code> 抽象出两组线程池，<code>BossGroup</code> 专门负责接收客户端连接，<code>WorkerGroup</code> 专门负责网络读写操作。</li>
<li><code>NioEventLoop</code> 表示一个不断循环执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code>网络通道。</li>
<li><code>NioEventLoop</code> 内部采用串行化设计，从消息的 <strong>读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送</strong>，始终由 <code>IO</code> 线程 <code>NioEventLoop</code> 负责</li>
</ol>
<ul>
<li><code>NioEventLoopGroup</code> 下包含多个 <code>NioEventLoop</code></li>
<li>每个 <code>NioEventLoop</code> 中包含有一个 <code>Selector</code>，一个 <code>taskQueue</code></li>
<li>每个 <code>NioEventLoop</code> 的 <code>Selector</code> 上可以注册监听多个 <code>NioChannel</code></li>
<li>每个 <code>NioChannel</code> 只会绑定在唯一的 <code>NioEventLoop</code> 上</li>
<li>每个 <code>NioChannel</code> 都绑定有一个自己的 <code>ChannelPipeline</code></li>
</ul>
<h2 id="异步模型"><a href="#异步模型" class="headerlink" title="异步模型"></a>异步模型</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。</li>
<li><code>Netty</code> 中的 <code>I/O</code> 操作是异步的，包括 <code>Bind、Write、Connect</code> 等操作会首先简单的返回一个 <code>ChannelFuture</code>。</li>
<li>调用者并不能立刻获得结果，而是通过 <code>Future-Listener</code> 机制，用户可以方便的主动获取或者通过通知机制获得 <code>IO</code> 操作结果。</li>
<li><code>Netty</code> 的异步模型是建立在 <code>future</code> 和 <code>callback</code> 的之上的。<code>callback</code> 就是回调。重点说 <code>Future</code>，它的核心思想是：假设一个方法 <code>fun</code>，计算过程可能非常耗时，等待 <code>fun</code> 返回显然不合适。那么可以在调用 <code>fun</code> 的时候，立马返回一个 <code>Future</code>，后续可以通过 <code>Future</code> 去监控方法 <code>fun</code> 的处理过程（即：<code>Future-Listener</code> 机制）</li>
</ol>
<h3 id="Future-说明"><a href="#Future-说明" class="headerlink" title="Future 说明"></a>Future 说明</h3><ol>
<li>表示异步的执行结果,可以通过它提供的方法来检测执行是否完成，比如检索计算等等。</li>
<li><code>ChannelFuture</code> 是一个接口：<code>public interface ChannelFuture extends Future&lt;Void&gt;</code> 我们可以添加监听器，当监听的事件发生时，就会通知到监听器。</li>
</ol>
<h3 id="工作原理示意图"><a href="#工作原理示意图" class="headerlink" title="工作原理示意图"></a>工作原理示意图</h3><p>下面第一张图就是管道，中间会经过多个handler</p>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0013.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0014.png" alt="img"></p>
<p>说明：</p>
<ol>
<li>在使用 <code>Netty</code> 进行编程时，拦截操作和转换出入站数据只需要您提供 <code>callback</code> 或利用 <code>future</code> 即可。这使得链式操作简单、高效，并有利于编写可重用的、通用的代码。</li>
<li><code>Netty</code> 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来。</li>
</ol>
<h3 id="Future-Listener-机制"><a href="#Future-Listener-机制" class="headerlink" title="Future-Listener 机制"></a>Future-Listener 机制</h3><ol>
<li>当 <code>Future</code> 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 <code>ChannelFuture</code> 来获取操作执行的状态，注册监听函数来执行完成后的操作。</li>
<li>常见有如下操作<ul>
<li>通过 <code>isDone</code> 方法来判断当前操作是否完成；</li>
<li>通过 <code>isSuccess</code> 方法来判断已完成的当前操作是否成功；</li>
<li>通过 <code>getCause</code> 方法来获取已完成的当前操作失败的原因；</li>
<li>通过 <code>isCancelled</code> 方法来判断已完成的当前操作是否被取消；</li>
<li>通过 <code>addListener</code> 方法来注册监听器，当操作已完成（<code>isDone</code>方法返回完成），将会通知指定的监听器；如果 <code>Future</code> 对象已完成，则通知指定的监听器</li>
</ul>
</li>
</ol>
<p>举例说明<br>演示：绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//绑定一个端口并且同步,生成了一个ChannelFuture对象</span></span><br><span class="line"><span class="comment">//启动服务器(并绑定端口)</span></span><br><span class="line">ChannelFuture cf = bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"><span class="comment">//给cf注册监听器，监控我们关心的事件</span></span><br><span class="line">cf.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span> <span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (cf.isSuccess()) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;监听端口6668成功&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;监听端口6668失败&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="快速入门实例-HTTP服务"><a href="#快速入门实例-HTTP服务" class="headerlink" title="快速入门实例 - HTTP服务"></a>快速入门实例 - HTTP服务</h2><ol>
<li>实例要求：使用 <code>IDEA</code> 创建 <code>Netty</code> 项目</li>
<li><code>Netty</code> 服务器在 <code>6668</code> 端口监听，浏览器发出请求 <code>http://localhost:6668/</code></li>
<li>服务器可以回复消息给客户端”Hello!我是服务器5”,并对特定请求资源进行过滤。</li>
<li>目的：<code>Netty</code> 可以做 <code>Http</code> 服务开发，并且理解 <code>Handler</code> 实例和客户端及其请求的关系。</li>
<li>看老师代码演示</li>
</ol>
<h3 id="TestServer"><a href="#TestServer" class="headerlink" title="TestServer"></a>TestServer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).childHandler(<span class="keyword">new</span> TestServerInitializer());</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line">            </span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TestServerInitializer"><a href="#TestServerInitializer" class="headerlink" title="TestServerInitializer"></a>TestServerInitializer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向管道加入处理器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到管道</span></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入一个netty 提供的httpServerCodec codec =&gt;[coder - decoder]</span></span><br><span class="line">        <span class="comment">//HttpServerCodec 说明</span></span><br><span class="line">        <span class="comment">//1. HttpServerCodec 是netty 提供的处理http的 编-解码器</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;MyHttpServerCodec&quot;</span>,<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        <span class="comment">//2. 增加一个自定义的handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;MyTestHttpServerHandler&quot;</span>, <span class="keyword">new</span> TestHttpServerHandler());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;ok~~~~&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TestHttpServerHandler"><a href="#TestHttpServerHandler" class="headerlink" title="TestHttpServerHandler"></a>TestHttpServerHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明</span></span><br><span class="line"><span class="comment">1. SimpleChannelInboundHandler 是 ChannelInboundHandlerAdapter</span></span><br><span class="line"><span class="comment">2. HttpObject 客户端和服务器端相互通讯的数据被封装成 HttpObject</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//channelRead0 读取客户端数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;对应的channel=&quot;</span> + ctx.channel() + <span class="string">&quot; pipeline=&quot;</span> + ctx</span><br><span class="line">        .pipeline() + <span class="string">&quot; 通过pipeline获取channel&quot;</span> + ctx.pipeline().channel());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;当前ctx的handler=&quot;</span> + ctx.handler());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断 msg 是不是 httprequest请求</span></span><br><span class="line">        <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;ctx 类型=&quot;</span>+ctx.getClass());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;pipeline hashcode&quot;</span> + ctx.pipeline().hashCode() + <span class="string">&quot; TestHttpServerHandler hash=&quot;</span> + <span class="keyword">this</span>.hashCode());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;msg 类型=&quot;</span> + msg.getClass());</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端地址&quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取到</span></span><br><span class="line">            HttpRequest httpRequest = (HttpRequest) msg;</span><br><span class="line">            <span class="comment">//获取uri, 过滤指定的资源</span></span><br><span class="line">            URI uri = <span class="keyword">new</span> URI(httpRequest.uri());</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath())) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请求了 favicon.ico, 不做响应&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//回复信息给浏览器 [http协议]</span></span><br><span class="line"></span><br><span class="line">            ByteBuf content = Unpooled.copiedBuffer(<span class="string">&quot;hello, 我是服务器&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//构造一个http的相应，即 httpresponse</span></span><br><span class="line">            FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line"></span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将构建好 response返回</span></span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Netty-核心模块组件"><a href="#Netty-核心模块组件" class="headerlink" title="Netty 核心模块组件"></a>Netty 核心模块组件</h1><h2 id="Bootstrap、ServerBootstrap"><a href="#Bootstrap、ServerBootstrap" class="headerlink" title="Bootstrap、ServerBootstrap"></a>Bootstrap、ServerBootstrap</h2><ol>
<li><code>Bootstrap</code> 意思是引导，一个 <code>Netty</code> 应用通常由一个 <code>Bootstrap</code> 开始，主要作用是配置整个 <code>Netty</code> 程序，串联各个组件，<code>Netty</code> 中 <code>Bootstrap</code> 类是客户端程序的启动引导类，<code>ServerBootstrap</code> 是服务端启动引导类。</li>
<li>常见的方法有<ul>
<li><code>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code>，该方法用于服务器端，用来设置两个 <code>EventLoop</code></li>
<li><code>public B group(EventLoopGroup group)</code>，该方法用于客户端，用来设置一个 <code>EventLoop</code></li>
<li><code>public B channel(Class&lt;? extends C&gt; channelClass)</code>，该方法用来设置一个服务器端的通道实现</li>
<li><code>public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value)</code>，用来给 <code>ServerChannel</code> 添加配置</li>
<li><code>public &lt;T&gt; ServerBootstrap childOption(ChannelOption&lt;T&gt; childOption, T value)</code>，用来给接收到的通道添加配置</li>
<li><code>public ServerBootstrap childHandler(ChannelHandler childHandler)</code>，该方法用来设置业务处理类（自定义的<code>handler</code>）</li>
<li><code>public ChannelFuture bind(int inetPort)</code>，该方法用于服务器端，用来设置占用的端口号</li>
<li><code>public ChannelFuture connect(String inetHost, int inetPort)</code>，该方法用于客户端，用来连接服务器端</li>
</ul>
</li>
</ol>
<h2 id="Future、ChannelFuture"><a href="#Future、ChannelFuture" class="headerlink" title="Future、ChannelFuture"></a>Future、ChannelFuture</h2><p><code>Netty</code> 中所有的 <code>IO</code> 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 <code>Future</code> 和 <code>ChannelFutures</code>，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</p>
<p>常见的方法有</p>
<ul>
<li><code>Channel channel()</code>，返回当前正在进行 <code>IO</code> 操作的通道</li>
<li><code>ChannelFuture sync()</code>，等待异步操作执行完毕</li>
</ul>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><ol>
<li><p><code>Netty</code> 网络通信的组件，能够用于执行网络 <code>I/O</code> 操作。</p>
</li>
<li><p>通过 <code>Channel</code> 可获得当前网络连接的通道的状态</p>
</li>
<li><p>通过 <code>Channel</code> 可获得网络连接的配置参数（例如接收缓冲区大小）</p>
</li>
<li><p><code>Channel</code> 提供异步的网络 <code>I/O</code> 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 <code>I/O</code> 调用都将立即返回，并且不保证在调用结束时所请求的 <code>I/O</code> 操作已完成</p>
</li>
<li><p>调用立即返回一个 <code>ChannelFuture</code> 实例，通过注册监听器到 <code>ChannelFuture</code> 上，可以 <code>I/O</code> 操作成功、失败或取消时回调通知调用方</p>
</li>
<li><p>支持关联 <code>I/O</code> 操作与对应的处理程序</p>
</li>
<li><p>不同协议、不同的阻塞类型的连接都有不同的Channel类型与之对应，常用的Channel类型：</p>
<ul>
<li><code>NioSocketChannel</code>，异步的客户端 <code>TCP</code> <code>Socket</code> 连接。</li>
<li><code>NioServerSocketChannel</code>，异步的服务器端 <code>TCP</code> <code>Socket</code> 连接。</li>
<li><code>NioDatagramChannel</code>，异步的 <code>UDP</code> 连接。</li>
<li><code>NioSctpChannel</code>，异步的客户端 <code>Sctp</code> 连接。</li>
<li><code>NioSctpServerChannel</code>，异步的 <code>Sctp</code> 服务器端连接，这些通道涵盖了 <code>UDP</code> 和 <code>TCP</code> 网络 <code>IO</code> 以及文件 <code>IO</code>。</li>
</ul>
</li>
</ol>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><ol>
<li><code>Netty</code> 基于 <code>Selector</code> 对象实现 <code>I/O</code> 多路复用，通过 <code>Selector</code> 一个线程可以监听多个连接的 <code>Channel</code> 事件。</li>
<li>当向一个 <code>Selector</code> 中注册 <code>Channel</code> 后，<code>Selector</code> 内部的机制就可以自动不断地查询（<code>Select</code>）这些注册的 <code>Channel</code> 是否有已就绪的 <code>I/O</code> 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 <code>Channel</code></li>
</ol>
<h2 id="ChannelHandler-及其实现类"><a href="#ChannelHandler-及其实现类" class="headerlink" title="ChannelHandler 及其实现类"></a>ChannelHandler 及其实现类</h2><ol>
<li><code>ChannelHandler</code> 是一个接口，处理 <code>I/O</code> 事件或拦截 <code>I/O</code> 操作，并将其转发到其 <code>ChannelPipeline</code>（业务处理链）中的下一个处理程序。</li>
<li><code>ChannelHandler</code> 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</li>
<li><code>ChannelHandler</code> 及其实现类一览图（后）</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0015.png" alt="img"></p>
<ol>
<li>我们经常需要自定义一个 <code>Handler</code> 类去继承 <code>ChannelInboundHandlerAdapter</code>，然后通过重写相应方法实现业务逻辑，我们接下来看看一般都需要重写哪些方法</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0016.png" alt="img"></p>
<h2 id="Pipeline-和-ChannelPipeline"><a href="#Pipeline-和-ChannelPipeline" class="headerlink" title="Pipeline 和 ChannelPipeline"></a>Pipeline 和 ChannelPipeline</h2><p><code>ChannelPipeline</code> 是一个重点：</p>
<ol>
<li><code>ChannelPipeline</code> 是一个 <code>Handler</code> 的集合，它负责处理和拦截 <code>inbound</code> 或者 <code>outbound</code> 的事件和操作，相当于一个贯穿 <code>Netty</code> 的链。（也可以这样理解：<code>ChannelPipeline</code> 是保存 <code>ChannelHandler</code> 的 <code>List</code>，用于处理或拦截 <code>Channel</code> 的入站事件和出站操作）</li>
<li><code>ChannelPipeline</code> 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 <code>Channel</code> 中各个的 <code>ChannelHandler</code> 如何相互交互</li>
<li>在 <code>Netty</code> 中每个 <code>Channel</code> 都有且仅有一个 <code>ChannelPipeline</code> 与之对应，它们的组成关系如下</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0017.png" alt="img"></p>
<ol>
<li>常用方法<br><code>ChannelPipeline addFirst(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的第一个位置<code>ChannelPipeline addLast(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的最后一个位置</li>
</ol>
<blockquote>
<p>想要更清楚的了解pipeline，可以对之前的代码进行debug，看一下pipeline里究竟有什么东西。</p>
</blockquote>
<p>从head看一下debug</p>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0018.jpg" alt="img"></p>
<ul>
<li><code>TestServerInitializer</code>和<code>HttpServerCodec</code>这些东西本身也是<code>handler</code></li>
<li>一般来说事件从客户端往服务器走我们称为出站，反之则是入站。</li>
</ul>
<h2 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h2><ol>
<li>保存 <code>Channel</code> 相关的所有上下文信息，同时关联一个 <code>ChannelHandler</code> 对象</li>
<li>即 <code>ChannelHandlerContext</code> 中包含一个具体的事件处理器 <code>ChannelHandler</code>，同时 <code>ChannelHandlerContext</code> 中也绑定了对应的 <code>pipeline</code> 和 <code>Channel</code> 的信息，方便对 <code>ChannelHandler</code> 进行调用。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0019.jpg" alt="img"></p>
<ol>
<li>常用方法</li>
</ol>
<ul>
<li><code>ChannelFuture close()</code>，关闭通道</li>
<li><code>ChannelOutboundInvoker flush()</code>，刷新</li>
<li><code>ChannelFuture writeAndFlush(Object msg)</code>，将数据写到</li>
<li><code>ChannelPipeline</code> 中当前 <code>ChannelHandler</code> 的下一个 <code>ChannelHandler</code> 开始处理（出站）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0020.png" alt="img"></p>
<h2 id="ChannelOption"><a href="#ChannelOption" class="headerlink" title="ChannelOption"></a>ChannelOption</h2><ol>
<li><code>Netty</code> 在创建 <code>Channel</code> 实例后，一般都需要设置 <code>ChannelOption</code> 参数。</li>
<li><code>ChannelOption</code> 参数如下：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0021.png" alt="img"></p>
<h2 id="EventLoopGroup-和其实现类-NioEventLoopGroup"><a href="#EventLoopGroup-和其实现类-NioEventLoopGroup" class="headerlink" title="EventLoopGroup 和其实现类 NioEventLoopGroup"></a>EventLoopGroup 和其实现类 NioEventLoopGroup</h2><ol>
<li><code>EventLoopGroup</code> 是一组 <code>EventLoop</code> 的抽象，<code>Netty</code> 为了更好的利用多核 <code>CPU</code> 资源，一般会有多个 <code>EventLoop</code> 同时工作，每个 <code>EventLoop</code> 维护着一个 <code>Selector</code> 实例。</li>
<li><code>EventLoopGroup</code> 提供 <code>next</code> 接口，可以从组里面按照一定规则获取其中一个 <code>EventLoop</code> 来处理任务。在 <code>Netty</code> 服务器端编程中，我们一般都需要提供两个 <code>EventLoopGroup</code>，例如：<code>BossEventLoopGroup</code> 和 <code>WorkerEventLoopGroup</code>。</li>
<li>通常一个服务端口即一个 <code>ServerSocketChannel</code> 对应一个 <code>Selector</code> 和一个 <code>EventLoop</code> 线程。<code>BossEventLoop</code> 负责接收客户端的连接并将 <code>SocketChannel</code> 交给 <code>WorkerEventLoopGroup</code> 来进行 <code>IO</code> 处理，如下图所示</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0022.png" alt="img"></p>
<ol>
<li>常用方法<br><code>public NioEventLoopGroup()</code>，构造方法<br><code>public Future&lt;?&gt; shutdownGracefully()</code>，断开连接，关闭线程</li>
</ol>
<h2 id="Unpooled-类"><a href="#Unpooled-类" class="headerlink" title="Unpooled 类"></a>Unpooled 类</h2><ol>
<li><code>Netty</code> 提供一个专门用来操作缓冲区（即 <code>Netty</code> 的数据容器）的工具类</li>
<li>常用方法如下所示</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0023.png" alt="img"></p>
<ol>
<li>举例说明 <code>Unpooled</code> 获取 <code>Netty</code> 的数据容器 <code>ByteBuf</code> 的基本使用</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0024.png" alt="img"></p>
<p>案例 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyByteBuf01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个ByteBuf</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. 创建 对象，该对象包含一个数组arr , 是一个byte[10]</span></span><br><span class="line">        <span class="comment">//2. 在netty 的buffer中，不需要使用flip 进行反转</span></span><br><span class="line">        <span class="comment">//   底层维护了 readerindex 和 writerIndex</span></span><br><span class="line">        <span class="comment">//3. 通过 readerindex 和  writerIndex 和  capacity， 将buffer分成三个区域</span></span><br><span class="line">        <span class="comment">// 0---readerindex 已经读取的区域</span></span><br><span class="line">        <span class="comment">// readerindex---writerIndex ， 可读的区域</span></span><br><span class="line">        <span class="comment">// writerIndex -- capacity, 可写的区域</span></span><br><span class="line">        ByteBuf buffer = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            buffer.writeByte(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;capacity=&quot;</span> + buffer.capacity());<span class="comment">//10</span></span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line"><span class="comment">//        for(int i = 0; i&lt;buffer.capacity(); i++) &#123;</span></span><br><span class="line">        	  <span class="comment">//这个方法readerindex不会变</span></span><br><span class="line"><span class="comment">//            System.out.println(buffer.getByte(i));</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">            <span class="comment">//这个方法readerindex会变</span></span><br><span class="line">            System.out.println(buffer.readByte());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例 2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyByteBuf02</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ByteBuf</span></span><br><span class="line">        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">&quot;hello,world!&quot;</span>, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用相关的方法</span></span><br><span class="line">        <span class="keyword">if</span> (byteBuf.hasArray()) &#123; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] content = byteBuf.array();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将 content 转成字符串</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(content, Charset.forName(<span class="string">&quot;utf-8&quot;</span>)));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;byteBuf=&quot;</span> + byteBuf);</span><br><span class="line"></span><br><span class="line">            System.out.println(byteBuf.arrayOffset()); <span class="comment">// 0</span></span><br><span class="line">            System.out.println(byteBuf.readerIndex()); <span class="comment">// 0</span></span><br><span class="line">            System.out.println(byteBuf.writerIndex()); <span class="comment">// 12</span></span><br><span class="line">            System.out.println(byteBuf.capacity()); <span class="comment">// 36</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//System.out.println(byteBuf.readByte()); //</span></span><br><span class="line">            System.out.println(byteBuf.getByte(<span class="number">0</span>)); <span class="comment">// 104</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len = byteBuf.readableBytes(); <span class="comment">//可读的字节数  12</span></span><br><span class="line">            System.out.println(<span class="string">&quot;len=&quot;</span> + len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用for取出各个字节</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>) byteBuf.getByte(i));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//按照某个范围读取</span></span><br><span class="line">            System.out.println(byteBuf.getCharSequence(<span class="number">0</span>, <span class="number">4</span>, Charset.forName(<span class="string">&quot;utf-8&quot;</span>)));</span><br><span class="line">            System.out.println(byteBuf.getCharSequence(<span class="number">4</span>, <span class="number">6</span>, Charset.forName(<span class="string">&quot;utf-8&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Netty-应用实例-群聊系统"><a href="#Netty-应用实例-群聊系统" class="headerlink" title="Netty 应用实例-群聊系统"></a>Netty 应用实例-群聊系统</h2><p>实例要求：</p>
<ol>
<li>编写一个 <code>Netty</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>实现多人群聊</li>
<li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li>
<li>客户端：通过 <code>channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li>
<li>目的：进一步理解 <code>Netty</code> 非阻塞网络编程机制</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0025.png" alt="img"></p>
<p>代码如下：</p>
<h3 id="GroupChatServer"><a href="#GroupChatServer" class="headerlink" title="GroupChatServer"></a>GroupChatServer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port; <span class="comment">//监听端口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写run方法，处理客户端的请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">//8个NioEventLoop</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//获取到pipeline</span></span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//向pipeline加入解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            <span class="comment">//向pipeline加入编码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            <span class="comment">//加入自己的业务处理handler</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> GroupChatServerHandler());</span><br><span class="line"></span><br><span class="line">                        &#125;-</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;netty 服务器启动&quot;</span>);</span><br><span class="line">            ChannelFuture channelFuture = b.bind(port).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//监听关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> GroupChatServer(<span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GroupChatServerHandler"><a href="#GroupChatServerHandler" class="headerlink" title="GroupChatServerHandler"></a>GroupChatServerHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.ChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.DefaultChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这样写还要自己遍历Channel</span></span><br><span class="line">    <span class="comment">//public static List&lt;Channel&gt; channels = new ArrayList&lt;Channel&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用一个hashmap 管理私聊（私聊本案例并未实现，只是提供个思路）</span></span><br><span class="line">    <span class="comment">//public static Map&lt;String, Channel&gt; channels = new HashMap&lt;String,Channel&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个channle 组，管理所有的channel</span></span><br><span class="line">    <span class="comment">//GlobalEventExecutor.INSTANCE) 是全局的事件执行器，是一个单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelGroup  channelGroup = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//handlerAdded 表示连接建立，一旦连接，第一个被执行</span></span><br><span class="line">    <span class="comment">//将当前channel 加入到  channelGroup</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">//将该客户加入聊天的信息推送给其它在线的客户端</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//该方法会将 channelGroup 中所有的channel 遍历，并发送消息，我们不需要自己遍历</span></span><br><span class="line"></span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;[客户端]&quot;</span> + channel.remoteAddress() + <span class="string">&quot; 加入聊天&quot;</span> + sdf.format(<span class="keyword">new</span> java.util.Date()) + <span class="string">&quot; \n&quot;</span>);</span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//私聊如何实现</span></span><br><span class="line"><span class="comment">//         channels.put（&quot;userid100&quot;,channel）;</span></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//断开连接, 将xx客户离开信息推送给当前在线的客户</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;[客户端]&quot;</span> + channel.remoteAddress() + <span class="string">&quot; 离开了\n&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;channelGroup size&quot;</span> + channelGroup.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示channel 处于活动状态, 提示 xx上线</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//这个是给服务端看的，客户端上面已经提示xxx加入群聊了</span></span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot; 上线了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示channel 处于不活动状态, 提示 xx离线了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot; 离线了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据，转发给在线的每一个客户端</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到当前channel</span></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">//这时我们遍历channelGroup, 根据不同的情况，回送不同的消息</span></span><br><span class="line"></span><br><span class="line">        channelGroup.forEach(ch -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(channel != ch) &#123; <span class="comment">//不是当前的channel,转发消息</span></span><br><span class="line">                ch.writeAndFlush(<span class="string">&quot;[客户]&quot;</span> + channel.remoteAddress() + <span class="string">&quot; 发送了消息&quot;</span> + msg + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//回显自己发送的消息给自己</span></span><br><span class="line">                ch.writeAndFlush(<span class="string">&quot;[自己]发送了消息&quot;</span> + msg + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//关闭通道</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GroupChatClient"><a href="#GroupChatClient" class="headerlink" title="GroupChatClient"></a>GroupChatClient</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//得到pipeline</span></span><br><span class="line">                        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                        <span class="comment">//加入相关handler</span></span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">                        <span class="comment">//加入自定义的handler</span></span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> GroupChatClientHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        ChannelFuture channelFuture = bootstrap.connect(host, port).sync();</span><br><span class="line">        <span class="comment">//得到channel</span></span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line">            System.out.println(<span class="string">&quot;-------&quot;</span> + channel.localAddress()+ <span class="string">&quot;--------&quot;</span>);</span><br><span class="line">            <span class="comment">//客户端需要输入信息，创建一个扫描器</span></span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">                String msg = scanner.nextLine();</span><br><span class="line">                <span class="comment">//通过channel 发送到服务器端</span></span><br><span class="line">                channel.writeAndFlush(msg + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GroupChatClient(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GroupChatClientHandler"><a href="#GroupChatClientHandler" class="headerlink" title="GroupChatClientHandler"></a>GroupChatClientHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从服务器拿到的数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Netty-心跳检测机制案例"><a href="#Netty-心跳检测机制案例" class="headerlink" title="Netty 心跳检测机制案例"></a>Netty 心跳检测机制案例</h2><p>实例要求：</p>
<ol>
<li>编写一个 <code>Netty</code> 心跳检测机制案例,当服务器超过 <code>3</code> 秒没有读时，就提示读空闲</li>
<li>当服务器超过 <code>5</code> 秒没有写操作时，就提示写空闲</li>
<li>实现当服务器超过 <code>7</code> 秒没有读或者写操作时，就提示读写空闲</li>
<li>代码如下：</li>
</ol>
<h3 id="MyServer"><a href="#MyServer" class="headerlink" title="MyServer"></a>MyServer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.heartbeat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">//8个NioEventLoop</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup);</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            <span class="comment">//在bossGroup增加一个日志处理器</span></span><br><span class="line">            serverBootstrap.handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                    <span class="comment">//加入一个netty 提供 IdleStateHandler</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    说明</span></span><br><span class="line"><span class="comment">                    1. IdleStateHandler 是netty 提供的处理空闲状态的处理器</span></span><br><span class="line"><span class="comment">                    2. long readerIdleTime : 表示多长时间没有读, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">                    3. long writerIdleTime : 表示多长时间没有写, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">                    4. long allIdleTime : 表示多长时间没有读写, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    5. 文档说明</span></span><br><span class="line"><span class="comment">                    triggers an &#123;@link IdleStateEvent&#125; when a &#123;@link Channel&#125; has not performed</span></span><br><span class="line"><span class="comment">                   read, write, or both operation for a while.</span></span><br><span class="line"><span class="comment">                    6. 当 IdleStateEvent 触发后 , 就会传递给管道 的下一个handler去处理，通过调用(触发)</span></span><br><span class="line"><span class="comment">                   下一个handler 的 userEventTiggered , 在该方法中去处理 IdleStateEvent(读空闲，写空闲，读写空闲)</span></span><br><span class="line"><span class="comment">                    7.handlerRemoved有时候是无法感知连接断掉，所以还是需要心跳包的检测来判断连接是否还有效</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>, TimeUnit.SECONDS));</span><br><span class="line">                    <span class="comment">//加入一个对空闲检测进一步处理的handler(自定义)</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动服务器</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyServerHandler"><a href="#MyServerHandler" class="headerlink" title="MyServerHandler"></a>MyServerHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.heartbeat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt 事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将  evt 向下转型 IdleStateEvent</span></span><br><span class="line">            IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">            String eventType = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (event.state()) &#123;</span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                  eventType = <span class="string">&quot;读空闲&quot;</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;写空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;读写空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot;--超时时间--&quot;</span> + eventType);</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器做相应处理..&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果发生空闲，我们关闭通道</span></span><br><span class="line">           <span class="comment">// ctx.channel().close();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Netty-通过-WebSocket-编程实现服务器和客户端长连接"><a href="#Netty-通过-WebSocket-编程实现服务器和客户端长连接" class="headerlink" title="Netty 通过 WebSocket 编程实现服务器和客户端长连接"></a>Netty 通过 WebSocket 编程实现服务器和客户端长连接</h2><p>实例要求：</p>
<ol>
<li><code>Http</code> 协议是无状态的，浏览器和服务器间的请求响应一次，下一次会重新创建连接。</li>
<li>要求：实现基于 <code>WebSocket</code> 的长连接的全双工的交互</li>
<li>改变 <code>Http</code> 协议多次请求的约束，实现长连接了，服务器可以发送消息给浏览器</li>
<li>客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</li>
<li>运行界面</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0026.png" alt="img"></p>
<h3 id="MyServer-1"><a href="#MyServer-1" class="headerlink" title="MyServer"></a>MyServer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.websocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.heartbeat.MyServerHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpObjectAggregator;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">//8个NioEventLoop</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup);</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//因为基于http协议，使用http的编码和解码器</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                    <span class="comment">//http是以块方式写，添加ChunkedWriteHandler处理器</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    说明</span></span><br><span class="line"><span class="comment">                    1. http数据在传输过程中是分段, HttpObjectAggregator ，就是可以将多个段聚合</span></span><br><span class="line"><span class="comment">                    2. 这就就是为什么，当浏览器发送大量数据时，就会发出多次http请求</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">8192</span>));</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    说明</span></span><br><span class="line"><span class="comment">                    1. 对应websocket ，它的数据是以 帧(frame) 形式传递</span></span><br><span class="line"><span class="comment">                    2. 可以看到WebSocketFrame 下面有六个子类</span></span><br><span class="line"><span class="comment">                    3. 浏览器请求时 ws://localhost:7000/hello 表示请求的uri</span></span><br><span class="line"><span class="comment">                    4. WebSocketServerProtocolHandler 核心功能是将 http协议升级为 ws协议 , 保持长连接</span></span><br><span class="line"><span class="comment">                    5. 是通过一个 状态码 101</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">&quot;/hello&quot;</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//自定义的handler ，处理业务逻辑</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> MyTextWebSocketFrameHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动服务器</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyTextWebSocketFrameHandler"><a href="#MyTextWebSocketFrameHandler" class="headerlink" title="MyTextWebSocketFrameHandler"></a>MyTextWebSocketFrameHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.websocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.TextWebSocketFrame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里 TextWebSocketFrame 类型，表示一个文本帧(frame)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTextWebSocketFrameHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器收到消息 &quot;</span> + msg.text());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回复消息</span></span><br><span class="line">        ctx.channel().writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">&quot;服务器时间&quot;</span> + LocalDateTime.now() + <span class="string">&quot; &quot;</span> + msg.text()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当web客户端连接后， 触发方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//id 表示唯一的值，LongText 是唯一的 ShortText 不是唯一</span></span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asShortText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;handlerRemoved 被调用&quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常发生 &quot;</span> + cause.getMessage());</span><br><span class="line">        ctx.close(); <span class="comment">//关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hello-html"><a href="#hello-html" class="headerlink" title="hello.html"></a>hello.html</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTML</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var socket;</span><br><span class="line">    //判断当前浏览器是否支持websocket</span><br><span class="line">    if(window.WebSocket) &#123;</span><br><span class="line">        //go on</span><br><span class="line">        socket = new WebSocket(&quot;ws://localhost:7000/hello2&quot;);</span><br><span class="line">        //相当于channelReado, ev 收到服务器端回送的消息</span><br><span class="line">        socket.onmessage = function (ev) &#123;</span><br><span class="line">            var rt = document.getElementById(&quot;responseText&quot;);</span><br><span class="line">            rt.value = rt.value + &quot;\n&quot; + ev.data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //相当于连接开启(感知到连接开启)</span><br><span class="line">        socket.onopen = function (ev) &#123;</span><br><span class="line">            var rt = document.getElementById(&quot;responseText&quot;);</span><br><span class="line">            rt.value = &quot;连接开启了..&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //相当于连接关闭(感知到连接关闭)</span><br><span class="line">        socket.onclose = function (ev) &#123;</span><br><span class="line"></span><br><span class="line">            var rt = document.getElementById(&quot;responseText&quot;);</span><br><span class="line">            rt.value = rt.value + &quot;\n&quot; + &quot;连接关闭了..&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        alert(&quot;当前浏览器不支持websocket&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //发送消息到服务器</span><br><span class="line">    function send(message) &#123;</span><br><span class="line">        if(!window.socket) &#123; //先判断socket是否创建好</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(socket.readyState == WebSocket.OPEN) &#123;</span><br><span class="line">            //通过socket 发送消息</span><br><span class="line">            socket.send(message)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            alert(&quot;连接没有开启&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">    &lt;form onsubmit=&quot;return false&quot;&gt;</span><br><span class="line">        &lt;textarea name=&quot;message&quot; style=&quot;height: 300px; width: 300px&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; value=&quot;发生消息&quot; onclick=&quot;send(this.form.message.value)&quot;&gt;</span><br><span class="line">        &lt;textarea id=&quot;responseText&quot; style=&quot;height: 300px; width: 300px&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; value=&quot;清空内容&quot; onclick=&quot;document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到并不是发一次数据，连接就关闭了，而是可以继续发送。</p>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_002/0027.png" alt="img"></p>
<p>参考：</p>
<p><strong>视频：</strong><a href="https://www.bilibili.com/video/BV1DJ411m7NR?from=search&amp;seid=7455267981675039441">https://www.bilibili.com/video/BV1DJ411m7NR?from=search&amp;seid=7455267981675039441</a></p>
<p><strong>文章链接:</strong> <a href="https://imlql.cn/post/3f9283e7.html">https://imlql.cn/post/3f9283e7.html</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>netty</category>
      </categories>
  </entry>
  <entry>
    <title>netty基础-1</title>
    <url>/30cac350.html</url>
    <content><![CDATA[<h1 id="Netty简介"><a href="#Netty简介" class="headerlink" title="Netty简介"></a>Netty简介</h1><h2 id="Netty-的介绍"><a href="#Netty-的介绍" class="headerlink" title="Netty 的介绍"></a>Netty 的介绍</h2><ol>
<li><code>Netty</code> 是由 <code>JBOSS</code> 提供的一个 <code>Java</code> 开源框架，现为 <code>Github</code> 上的独立项目。</li>
<li><code>Netty</code> 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 <code>IO</code> 程序。</li>
<li><code>Netty</code> 主要针对在 <code>TCP</code> 协议下，面向 <code>Client</code> 端的高并发应用，或者 <code>Peer-to-Peer</code> 场景下的大量数据持续传输的应用。</li>
<li><code>Netty</code> 本质是一个 <code>NIO</code> 框架，适用于服务器通讯相关的多种应用场景。</li>
<li>要透彻理解 <code>Netty</code>，需要先学习 <code>NIO</code>，这样我们才能阅读 <code>Netty</code> 的源码。</li>
</ol>
<span id="more"></span>

<p>相对简单的一个体系图</p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0001.png"><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/0001.png" alt="img"></a></p>
<h2 id="Netty-的应用场景"><a href="#Netty-的应用场景" class="headerlink" title="Netty 的应用场景"></a>Netty 的应用场景</h2><h3 id="互联网行业"><a href="#互联网行业" class="headerlink" title="互联网行业"></a>互联网行业</h3><ol>
<li>互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 <code>RPC</code> 框架必不可少，<code>Netty</code> 作为异步高性能的通信框架，往往作为基础通信组件被这些 <code>RPC</code> 框架使用。</li>
<li>典型的应用有：阿里分布式服务框架 <code>Dubbo</code> 的 <code>RPC</code> 框 架使用 <code>Dubbo</code> 协议进行节点间通信，<code>Dubbo</code> 协议默认使用 <code>Netty</code> 作为基础通信组件，用于实现各进程节点之间的内部通信。</li>
</ol>
<h3 id="游戏行业"><a href="#游戏行业" class="headerlink" title="游戏行业"></a>游戏行业</h3><ol>
<li>无论是手游服务端还是大型的网络游戏，<code>Java</code> 语言得到了越来越广泛的应用。</li>
<li><code>Netty</code> 作为高性能的基础通信组件，提供了 <code>TCP/UDP</code> 和 <code>HTTP</code> 协议栈，方便定制和开发私有协议栈，账号登录服务器。</li>
<li>地图服务器之间可以方便的通过 <code>Netty</code> 进行高性能的通信。</li>
</ol>
<h3 id="大数据领域"><a href="#大数据领域" class="headerlink" title="大数据领域"></a>大数据领域</h3><ol>
<li>经典的 <code>Hadoop</code> 的高性能通信和序列化组件 <code>Avro</code> 的 <code>RPC</code> 框架，默认采用 <code>Netty</code> 进行跨界点通信。</li>
<li>它的 <code>NettyService</code> 基于 <code>Netty</code> 框架二次封装实现。</li>
</ol>
<h3 id="其它开源项目使用到-Netty"><a href="#其它开源项目使用到-Netty" class="headerlink" title="其它开源项目使用到 Netty"></a>其它开源项目使用到 Netty</h3><p>网址：<a href="https://netty.io/wiki/related-projects.html">https://netty.io/wiki/related-projects.html</a></p>
<h2 id="Netty-的学习资料参考"><a href="#Netty-的学习资料参考" class="headerlink" title="Netty 的学习资料参考"></a>Netty 的学习资料参考</h2><p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0002.png"><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/0002.png" alt="img"></a></p>
<h1 id="Java-BIO编程"><a href="#Java-BIO编程" class="headerlink" title="Java BIO编程"></a>Java BIO编程</h1><h2 id="I-O-模型"><a href="#I-O-模型" class="headerlink" title="I/O 模型"></a>I/O 模型</h2><ol>
<li><code>I/O</code> 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能。</li>
<li><code>Java</code> 共支持 <code>3</code> 种网络编程模型 <code>I/O</code> 模式：<code>BIO</code>、<code>NIO</code>、<code>AIO</code>。</li>
<li><code>Java BIO</code>：同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。【简单示意图】</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0003.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0003.png" alt="img"></a></p>
<ol>
<li><code>Java NIO</code>：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 <code>I/O</code> 请求就进行处理。【简单示意图】</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0004.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0004.png" alt="img"></a></p>
<ol>
<li><code>Java AIO(NIO.2)</code>：异步非阻塞，<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</li>
<li>我们依次展开讲解。</li>
</ol>
<h2 id="BIO、NIO、AIO-使用场景分析"><a href="#BIO、NIO、AIO-使用场景分析" class="headerlink" title="BIO、NIO、AIO 使用场景分析"></a>BIO、NIO、AIO 使用场景分析</h2><ol>
<li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，但程序简单易理解。</li>
<li><code>NIO</code> 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，<code>JDK1.4</code> 开始支持。</li>
<li><code>AIO</code> 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 <code>OS</code> 参与并发操作，编程比较复杂，<code>JDK7</code> 开始支持。</li>
</ol>
<h2 id="Java-BIO-基本介绍"><a href="#Java-BIO-基本介绍" class="headerlink" title="Java BIO 基本介绍"></a>Java BIO 基本介绍</h2><ol>
<li><code>Java BIO</code> 就是传统的 <code>Java I/O</code> 编程，其相关的类和接口在 <code>java.io</code>。</li>
<li><code>BIO(BlockingI/O)</code>：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）。【后有应用实例】</li>
<li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，程序简单易理解。</li>
</ol>
<h2 id="Java-BIO-工作机制"><a href="#Java-BIO-工作机制" class="headerlink" title="Java BIO 工作机制"></a>Java BIO 工作机制</h2><p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0005.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0005.png" alt="img"></a></p>
<p>对 <code>BIO</code> 编程流程的梳理</p>
<ol>
<li>服务器端启动一个 <code>ServerSocket</code>。</li>
<li>客户端启动 <code>Socket</code> 对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯。</li>
<li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝。</li>
<li>如果有响应，客户端线程会等待请求结束后，再继续执行。</li>
</ol>
<h2 id="Java-BIO-应用实例"><a href="#Java-BIO-应用实例" class="headerlink" title="Java BIO 应用实例"></a>Java BIO 应用实例</h2><p>实例说明：</p>
<ol>
<li>使用 <code>BIO</code> 模型编写一个服务器端，监听 <code>6666</code> 端口，当有客户端连接时，就启动一个线程与之通讯。</li>
<li>要求使用线程池机制改善，可以连接多个客户端。</li>
<li>服务器端可以接收客户端发送的数据（<code>telnet</code> 方式即可）。</li>
<li>代码演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//线程池机制</span></span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1. 创建一个线程池</span></span><br><span class="line">        <span class="comment">//2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class="line">        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//创建ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器启动了&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//监听，等待客户端连接</span></span><br><span class="line">            System.out.println(<span class="string">&quot;等待连接....&quot;</span>);</span><br><span class="line">            <span class="comment">//会阻塞在accept()</span></span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;连接到一个客户端&quot;</span>);</span><br><span class="line">            <span class="comment">//就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class="line">            newCachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//我们重写</span></span><br><span class="line">                    <span class="comment">//可以和客户端通讯</span></span><br><span class="line">                    handler(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个handler方法，和客户端通讯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//通过socket获取输入流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="comment">//循环的读取客户端发送的数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                System.out.println(<span class="string">&quot;read....&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">                <span class="keyword">if</span> (read != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, read));<span class="comment">//输出客户端发送的数据</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭和client的连接&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0006.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0006.png" alt="img"></a></p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ol>
<li>每个请求都需要创建独立的线程，与对应的客户端进行数据 <code>Read</code>，业务处理，数据 <code>Write</code>。</li>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 <code>Read</code> 操作上，造成线程资源浪费。</li>
</ol>
<h1 id="Java-NIO编程"><a href="#Java-NIO编程" class="headerlink" title="Java NIO编程"></a>Java NIO编程</h1><h2 id="Java-NIO-基本介绍"><a href="#Java-NIO-基本介绍" class="headerlink" title="Java NIO 基本介绍"></a>Java NIO 基本介绍</h2><ol>
<li><code>Java NIO</code> 全称 <code>Java non-blocking IO</code>，是指 <code>JDK</code> 提供的新 <code>API</code>。从 <code>JDK1.4</code> 开始，<code>Java</code> 提供了一系列改进的输入/输出的新特性，被统称为 <code>NIO</code>（即 <code>NewIO</code>），是同步非阻塞的。</li>
<li><code>NIO</code> 相关类都被放在 <code>java.nio</code> 包及子包下，并且对原 <code>java.io</code> 包中的很多类进行改写。【基本案例】</li>
<li><code>NIO</code> 有三大核心部分：**<code>Channel</code>（通道）、<code>Buffer</code>（缓冲区）、<code>Selector</code>（选择器）** 。</li>
<li><code>NIO</code> 是<strong>面向缓冲区，或者面向块编程</strong>的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。</li>
<li><code>Java NIO</code> 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。【后面有案例说明】</li>
<li>通俗理解：<code>NIO</code> 是可以做到用一个线程来处理多个操作的。假设有 <code>10000</code> 个请求过来,根据实际情况，可以分配 <code>50</code> 或者 <code>100</code> 个线程来处理。不像之前的阻塞 <code>IO</code> 那样，非得分配 <code>10000</code> 个。</li>
<li><code>HTTP 2.0</code> 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 <code>HTTP 1.1</code> 大了好几个数量级。</li>
<li>案例说明 <code>NIO</code> 的 <code>Buffer</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.IntBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//举例说明 Buffer 的使用(简单说明)</span></span><br><span class="line">        <span class="comment">//创建一个 Buffer，大小为 5，即可以存放 5 个 int</span></span><br><span class="line">        IntBuffer intBuffer = IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向buffer存放数据</span></span><br><span class="line">        <span class="comment">//intBuffer.put(10);</span></span><br><span class="line">        <span class="comment">//intBuffer.put(11);</span></span><br><span class="line">        <span class="comment">//intBuffer.put(12);</span></span><br><span class="line">        <span class="comment">//intBuffer.put(13);</span></span><br><span class="line">        <span class="comment">//intBuffer.put(14);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intBuffer.capacity(); i++) &#123;</span><br><span class="line">            intBuffer.put(i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如何从 buffer 读取数据</span></span><br><span class="line">        <span class="comment">//将 buffer 转换，读写切换(!!!)</span></span><br><span class="line">        intBuffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (intBuffer.hasRemaining()) &#123;</span><br><span class="line">            System.out.println(intBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NIO-和-BIO-的比较"><a href="#NIO-和-BIO-的比较" class="headerlink" title="NIO 和 BIO 的比较"></a>NIO 和 BIO 的比较</h2><ol>
<li><code>BIO</code> 以流的方式处理数据，而 <code>NIO</code> 以块的方式处理数据，块 <code>I/O</code> 的效率比流 <code>I/O</code> 高很多。</li>
<li><code>BIO</code> 是阻塞的，<code>NIO</code> 则是非阻塞的。</li>
<li><code>BIO</code> 基于字节流和字符流进行操作，而 <code>NIO</code> 基于 <code>Channel</code>（通道）和 <code>Buffer</code>（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<code>Selector</code>（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。</li>
<li>Buffer和Channel之间的数据流向是双向的</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0007.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0007.png" alt="img"></a></p>
<p>推荐文章：<a href="https://blog.csdn.net/vtopqx/article/details/88115899">https://blog.csdn.net/vtopqx/article/details/88115899</a></p>
<h2 id="NIO-三大核心原理示意图"><a href="#NIO-三大核心原理示意图" class="headerlink" title="NIO 三大核心原理示意图"></a>NIO 三大核心原理示意图</h2><p>一张图描述 <code>NIO</code> 的 <code>Selector</code>、<code>Channel</code> 和 <code>Buffer</code> 的关系。</p>
<h3 id="Selector、Channel-和-Buffer-关系图（简单版）"><a href="#Selector、Channel-和-Buffer-关系图（简单版）" class="headerlink" title="Selector、Channel 和 Buffer 关系图（简单版）"></a>Selector、Channel 和 Buffer 关系图（简单版）</h3><p>关系图的说明:</p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0008.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0008.png" alt="img"></a></p>
<ol>
<li>每个 <code>Channel</code> 都会对应一个 <code>Buffer</code>。</li>
<li><code>Selector</code> 对应一个线程，一个线程对应多个 <code>Channel</code>（连接）。</li>
<li>该图反应了有三个 <code>Channel</code> 注册到该 <code>Selector</code> //程序</li>
<li>程序切换到哪个 <code>Channel</code> 是由事件决定的，<code>Event</code> 就是一个重要的概念。</li>
<li><code>Selector</code> 会根据不同的事件，在各个通道上切换。</li>
<li><code>Buffer</code> 就是一个内存块，底层是有一个数组。</li>
<li>数据的读取写入是通过 <code>Buffer</code>，这个和 <code>BIO</code>是不同的，<code>BIO</code> 中要么是输入流，或者是输出流，不能双向，但是 <code>NIO</code> 的 <code>Buffer</code> 是可以读也可以写，需要 <code>flip</code> 方法切换 <code>Channel</code> 是双向的，可以返回底层操作系统的情况，比如 <code>Linux</code>，底层的操作系统通道就是双向的。</li>
</ol>
<h2 id="缓冲区（Buffer）"><a href="#缓冲区（Buffer）" class="headerlink" title="缓冲区（Buffer）"></a>缓冲区（Buffer）</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>缓冲区（<code>Buffer</code>）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，可以理解成是一个<strong>容器对象（含数组）</strong>，该对象提供了一组方法，可以更轻松地使用内存块，，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。<code>Channel</code> 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 <code>Buffer</code>，如图:【后面举例说明】</p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0009.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0009.png" alt="img"></a></p>
<h3 id="Buffer-类及其子类"><a href="#Buffer-类及其子类" class="headerlink" title="Buffer 类及其子类"></a>Buffer 类及其子类</h3><ol>
<li>在 <code>NIO</code> 中，<code>Buffer</code> 是一个顶层父类，它是一个抽象类，类的层级关系图：</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0010.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0010.png" alt="img"></a></p>
<ol>
<li><code>Buffer</code> 类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息：</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0011.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0011.png" alt="img"></a></p>
<ol>
<li><code>Buffer</code> 类相关方法一览</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0013.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0013.png" alt="img"></a></p>
<h3 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h3><p>从前面可以看出对于 <code>Java</code> 中的基本数据类型（<code>boolean</code> 除外），都有一个 <code>Buffer</code> 类型与之相对应，最常用的自然是 <code>ByteBuffer</code> 类（二进制数据），该类的主要方法如下：</p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0014.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0014.png" alt="img"></a></p>
<h2 id="通道（Channel）"><a href="#通道（Channel）" class="headerlink" title="通道（Channel）"></a>通道（Channel）</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li><p>NIO的通道类似于流，但有些区别如下：</p>
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲:</li>
</ul>
</li>
<li><p><code>BIO</code> 中的 <code>Stream</code> 是单向的，例如 <code>FileInputStream</code> 对象只能进行读取数据的操作，而 <code>NIO</code> 中的通道（<code>Channel</code>）是双向的，可以读操作，也可以写操作。</p>
</li>
<li><p><code>Channel</code> 在 <code>NIO</code> 中是一个接口 <code>public interface Channel extends Closeable&#123;&#125;</code></p>
</li>
<li><p>常用的 <code>Channel</code> 类有：**<code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code> 和 <code>SocketChannel</code>**。【<code>ServerSocketChanne</code> 类似 <code>ServerSocket</code>、<code>SocketChannel</code> 类似 <code>Socket</code>】</p>
</li>
<li><p><code>FileChannel</code> 用于文件的数据读写，<code>DatagramChannel</code> 用于 <code>UDP</code> 的数据读写，<code>ServerSocketChannel</code> 和 <code>SocketChannel</code> 用于 <code>TCP</code> 的数据读写。</p>
</li>
<li><p>图示</p>
</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0015.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0015.png" alt="img"></a></p>
<h3 id="FileChannel-类"><a href="#FileChannel-类" class="headerlink" title="FileChannel 类"></a>FileChannel 类</h3><p><code>FileChannel</code> 主要用来对本地文件进行 <code>IO</code> 操作，常见的方法有</p>
<ul>
<li><code>public int read(ByteBuffer dst)</code>，从通道读取数据并放到缓冲区中</li>
<li><code>public int write(ByteBuffer src)</code>，把缓冲区的数据写到通道中</li>
<li><code>public long transferFrom(ReadableByteChannel src, long position, long count)</code>，从目标通道中复制数据到当前通道</li>
<li><code>public long transferTo(long position, long count, WritableByteChannel target)</code>，把数据从当前通道复制给目标通道</li>
</ul>
<h3 id="应用实例1-本地文件写数据"><a href="#应用实例1-本地文件写数据" class="headerlink" title="应用实例1 - 本地文件写数据"></a>应用实例1 - 本地文件写数据</h3><p>实例要求：</p>
<ol>
<li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 “hello,尚硅谷” 写入到 <code>file01.txt</code> 中</li>
<li>文件不存在就创建</li>
<li>代码演示</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;hello,尚硅谷&quot;</span>;</span><br><span class="line">        <span class="comment">//创建一个输出流 -&gt; channel</span></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\file01.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过 fileOutputStream 获取对应的 FileChannel</span></span><br><span class="line">        <span class="comment">//这个 fileChannel 真实类型是 FileChannelImpl</span></span><br><span class="line">        FileChannel fileChannel = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个缓冲区 ByteBuffer</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 str 放入 byteBuffer</span></span><br><span class="line">        byteBuffer.put(str.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对 byteBuffer 进行 flip</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 byteBuffer 数据写入到 fileChannel</span></span><br><span class="line">        fileChannel.write(byteBuffer);</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用实例2-本地文件读数据"><a href="#应用实例2-本地文件读数据" class="headerlink" title="应用实例2 - 本地文件读数据"></a>应用实例2 - 本地文件读数据</h3><p>实例要求：</p>
<ol>
<li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 <code>file01.txt</code> 中的数据读入到程序，并显示在控制台屏幕</li>
<li>假定文件已经存在</li>
<li>代码演示</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建文件的输入流</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;d:\\file01.txt&quot;</span>);</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过 fileInputStream 获取对应的 FileChannel -&gt; 实际类型 FileChannelImpl</span></span><br><span class="line">        FileChannel fileChannel = fileInputStream.getChannel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建缓冲区</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="keyword">int</span>)file.length());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将通道的数据读入到 Buffer</span></span><br><span class="line">        fileChannel.read(byteBuffer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将 byteBuffer 的字节数据转成 String</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用实例3-使用一个-Buffer-完成文件读取、写入"><a href="#应用实例3-使用一个-Buffer-完成文件读取、写入" class="headerlink" title="应用实例3 - 使用一个 Buffer 完成文件读取、写入"></a>应用实例3 - 使用一个 Buffer 完成文件读取、写入</h3><p>实例要求：</p>
<ol>
<li>使用 <code>FileChannel</code>（通道）和方法 <code>read、write</code>，完成文件的拷贝</li>
<li>拷贝一个文本文件 <code>1.txt</code>，放在项目下即可</li>
<li>代码演示</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0016.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0016.png" alt="img"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">        FileChannel fileChannel01 = fileInputStream.getChannel();</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;2.txt&quot;</span>);</span><br><span class="line">        FileChannel fileChannel02 = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">//循环读取</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里有一个重要的操作，一定不要忘了</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public final Buffer clear() &#123;</span></span><br><span class="line"><span class="comment">                position = 0;</span></span><br><span class="line"><span class="comment">                limit = capacity;</span></span><br><span class="line"><span class="comment">                mark = -1;</span></span><br><span class="line"><span class="comment">                return this;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            byteBuffer.clear(); <span class="comment">//清空 buffer</span></span><br><span class="line">            <span class="keyword">int</span> read = fileChannel01.read(byteBuffer);</span><br><span class="line">            System.out.println(<span class="string">&quot;read = &quot;</span> + read);</span><br><span class="line">            <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123; <span class="comment">//表示读完</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将 buffer 中的数据写入到 fileChannel02--2.txt</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            fileChannel02.write(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭相关的流</span></span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用实例4-拷贝文件-transferFrom-方法"><a href="#应用实例4-拷贝文件-transferFrom-方法" class="headerlink" title="应用实例4 - 拷贝文件 transferFrom 方法"></a>应用实例4 - 拷贝文件 transferFrom 方法</h3><ol>
<li>实例要求：</li>
<li>使用 <code>FileChannel</code>（通道）和方法 <code>transferFrom</code>，完成文件的拷贝</li>
<li>拷贝一张图片</li>
<li>代码演示</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建相关流</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\a.jpg&quot;</span>);</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\a2.jpg&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取各个流对应的 FileChannel</span></span><br><span class="line">        FileChannel sourceCh = fileInputStream.getChannel();</span><br><span class="line">        FileChannel destCh = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用 transferForm 完成拷贝</span></span><br><span class="line">        destCh.transferFrom(sourceCh, <span class="number">0</span>, sourceCh.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭相关通道和流</span></span><br><span class="line">        sourceCh.close();</span><br><span class="line">        destCh.close();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于-Buffer-和-Channel-的注意事项和细节"><a href="#关于-Buffer-和-Channel-的注意事项和细节" class="headerlink" title="关于 Buffer 和 Channel 的注意事项和细节"></a>关于 Buffer 和 Channel 的注意事项和细节</h3><ol>
<li><code>ByteBuffer</code> 支持类型化的 <code>put</code> 和 <code>get</code>，<code>put</code> 放入的是什么数据类型，<code>get</code> 就应该使用相应的数据类型来取出，否则可能有 <code>BufferUnderflowException</code> 异常。【举例说明】</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOByteBufferPutGet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个 Buffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类型化方式放入数据</span></span><br><span class="line">        buffer.putInt(<span class="number">100</span>);</span><br><span class="line">        buffer.putLong(<span class="number">9</span>);</span><br><span class="line">        buffer.putChar(<span class="string">&#x27;尚&#x27;</span>);</span><br><span class="line">        buffer.putShort((<span class="keyword">short</span>) <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        System.out.println(buffer.getInt());</span><br><span class="line">        System.out.println(buffer.getLong());</span><br><span class="line">        System.out.println(buffer.getChar());</span><br><span class="line">        System.out.println(buffer.getShort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>可以将一个普通 <code>Buffer</code> 转成只读 <code>Buffer</code>【举例说明】</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadOnlyBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个 buffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">            buffer.put((<span class="keyword">byte</span>) i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到一个只读的 Buffer</span></span><br><span class="line">        ByteBuffer readOnlyBuffer = buffer.asReadOnlyBuffer();</span><br><span class="line">        System.out.println(readOnlyBuffer.getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        <span class="keyword">while</span> (readOnlyBuffer.hasRemaining()) &#123;</span><br><span class="line">            System.out.println(readOnlyBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        readOnlyBuffer.put((<span class="keyword">byte</span>) <span class="number">100</span>); <span class="comment">//ReadOnlyBufferException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>NIO</code> 还提供了 <code>MappedByteBuffer</code>，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由 <code>NIO</code> 来完成。【举例说明】</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.MappedByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明 1.MappedByteBuffer 可让文件直接在内存（堆外内存）修改,操作系统不需要拷贝一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBufferTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">//获取对应的通道</span></span><br><span class="line">        FileChannel channel = randomAccessFile.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数 1:FileChannel.MapMode.READ_WRITE 使用的读写模式</span></span><br><span class="line"><span class="comment">         * 参数 2：0：可以直接修改的起始位置</span></span><br><span class="line"><span class="comment">         * 参数 3:5: 是映射到内存的大小（不是索引位置），即将 1.txt 的多少个字节映射到内存</span></span><br><span class="line"><span class="comment">         * 可以直接修改的范围就是 0-5</span></span><br><span class="line"><span class="comment">         * 实际类型 DirectByteBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        mappedByteBuffer.put(<span class="number">0</span>, (<span class="keyword">byte</span>) <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">3</span>, (<span class="keyword">byte</span>) <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">5</span>, (<span class="keyword">byte</span>) <span class="string">&#x27;Y&#x27;</span>);<span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"></span><br><span class="line">        randomAccessFile.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;修改成功~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>前面我们讲的读写操作，都是通过一个 <code>Buffer</code> 完成的，<code>NIO</code> 还支持通过多个 <code>Buffer</code>（即 <code>Buffer</code>数组）完成读写操作，即 <code>Scattering</code> 和 <code>Gathering</code>【举例说明】</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scattering：将数据写入到 buffer 时，可以采用 buffer 数组，依次写入 [分散]</span></span><br><span class="line"><span class="comment"> * Gathering：从 buffer 读取数据时，可以采用 buffer 数组，依次读</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScatteringAndGatheringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用 ServerSocketChannel 和 SocketChannel 网络</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="number">7000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定端口到 socket，并启动</span></span><br><span class="line">        serverSocketChannel.socket().bind(inetSocketAddress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建 buffer 数组</span></span><br><span class="line">        ByteBuffer[] byteBuffers = <span class="keyword">new</span> ByteBuffer[<span class="number">2</span>];</span><br><span class="line">        byteBuffers[<span class="number">0</span>] = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">        byteBuffers[<span class="number">1</span>] = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等客户端连接 (telnet)</span></span><br><span class="line">        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> messageLength = <span class="number">8</span>; <span class="comment">//假定从客户端接收 8 个字节</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环的读取</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> byteRead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (byteRead &lt; messageLength) &#123;</span><br><span class="line">                <span class="keyword">long</span> l = socketChannel.read(byteBuffers);</span><br><span class="line">                byteRead += l; <span class="comment">//累计读取的字节数</span></span><br><span class="line">                System.out.println(<span class="string">&quot;byteRead = &quot;</span> + byteRead);</span><br><span class="line">                <span class="comment">//使用流打印,看看当前的这个 buffer 的 position 和 limit</span></span><br><span class="line">                Arrays.asList(byteBuffers).stream().map(buffer -&gt; <span class="string">&quot;position = &quot;</span> + buffer.position() + <span class="string">&quot;, limit = &quot;</span> + buffer.limit()).forEach(System.out::println);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将所有的 buffer 进行 flip</span></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip());</span><br><span class="line">            <span class="comment">//将数据读出显示到客户端</span></span><br><span class="line">            <span class="keyword">long</span> byteWirte = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (byteWirte &lt; messageLength) &#123;</span><br><span class="line">                <span class="keyword">long</span> l = socketChannel.write(byteBuffers);<span class="comment">//</span></span><br><span class="line">                byteWirte += l;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将所有的buffer进行clear</span></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(buffer -&gt; &#123;</span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;byteRead = &quot;</span> + byteRead + <span class="string">&quot;, byteWrite = &quot;</span> + byteWirte + <span class="string">&quot;, messagelength = &quot;</span> + messageLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>buffer的分散和聚合，适用于消息的分工合作</p>
<p>分散度：</p>
<p>从一个channel的一个分散读是读数据进入不止一个buffer的一个读操作。因此，这个channel的“分散”这些数据从这个channel中到多个buffer中。</p>
<p>如果你有一个头和体，并且这个头是固定大小的（例如是128字节），然后这个分散读将会工作的很好。</p>
<p>聚集写：</p>
<p>一个聚集写到一个channel中是来自于不止一个buffer写数据进入一个单独的channel的一个写操作。因此，这个channel的“聚集”这个数据从多个buffer中到一个channel中。</p>
<p>一个聚集写操作通过动态可变大小的消息部分会工作的很好，跟分散读取正好相反。</p>
<h2 id="Selector（选择器）"><a href="#Selector（选择器）" class="headerlink" title="Selector（选择器）"></a>Selector（选择器）</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li><code>Java</code> 的 <code>NIO</code>，用非阻塞的 <code>IO</code> 方式。可以用一个线程，处理多个的客户端连接，就会使用到 <code>Selector</code>（选择器）。</li>
<li><code>Selector</code> 能够检测多个注册的通道上是否有事件发生（注意：多个 <code>Channel</code> 以事件的方式可以注册到同一个 <code>Selector</code>），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</li>
<li>只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</li>
<li>避免了多线程之间的上下文切换导致的开销。</li>
</ol>
<h3 id="Selector-示意图和特点说明"><a href="#Selector-示意图和特点说明" class="headerlink" title="Selector 示意图和特点说明"></a>Selector 示意图和特点说明</h3><p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0017.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0017.png" alt="img"></a></p>
<p>说明如下：</p>
<ol>
<li><code>Netty</code> 的 <code>IO</code> 线程 <code>NioEventLoop</code> 聚合了 <code>Selector</code>（选择器，也叫多路复用器），可以同时并发处理成百上千个客户端连接。</li>
<li>当线程从某客户端 <code>Socket</code> 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</li>
<li>线程通常将非阻塞 <code>IO</code> 的空闲时间用于在其他通道上执行 <code>IO</code> 操作，所以单独的线程可以管理多个输入和输出通道。</li>
<li>由于读写操作都是非阻塞的，这就可以充分提升 <code>IO</code> 线程的运行效率，避免由于频繁 <code>I/O</code> 阻塞导致的线程挂起。</li>
<li>一个 <code>I/O</code> 线程可以并发处理 <code>N</code> 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 <code>I/O</code> 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</li>
</ol>
<h3 id="Selector-类相关方法"><a href="#Selector-类相关方法" class="headerlink" title="Selector 类相关方法"></a>Selector 类相关方法</h3><p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0018.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0018.png" alt="img"></a></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p><code>NIO</code> 中的 <code>ServerSocketChannel</code> 功能类似 <code>ServerSocket</code>、<code>SocketChannel</code> 功能类似 <code>Socket</code>。</p>
</li>
<li><p>Selector相关方法说明</p>
<ul>
<li><code>selector.select();</code> //阻塞</li>
<li><code>selector.select(1000);</code> //阻塞 1000 毫秒，在 1000 毫秒后返回</li>
<li><code>selector.wakeup();</code> //唤醒 selector</li>
<li><code>selector.selectNow();</code> //不阻塞，立马返还</li>
</ul>
</li>
</ol>
<h2 id="NIO-非阻塞网络编程原理分析图"><a href="#NIO-非阻塞网络编程原理分析图" class="headerlink" title="NIO 非阻塞网络编程原理分析图"></a>NIO 非阻塞网络编程原理分析图</h2><p><code>NIO</code> 非阻塞网络编程相关的（<code>Selector</code>、<code>SelectionKey</code>、<code>ServerScoketChannel</code> 和 <code>SocketChannel</code>）关系梳理图</p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0019.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0019.png" alt="img"></a></p>
<p>对上图的说明：</p>
<ol>
<li>当客户端连接时，会通过 <code>ServerSocketChannel</code> 得到 <code>SocketChannel</code>。</li>
<li><code>Selector</code> 进行监听 <code>select</code> 方法，返回有事件发生的通道的个数。</li>
<li>将 <code>socketChannel</code> 注册到 <code>Selector</code> 上，<code>register(Selector sel, int ops)</code>，一个 <code>Selector</code> 上可以注册多个 <code>SocketChannel</code>。</li>
<li>注册后返回一个 <code>SelectionKey</code>，会和该 <code>Selector</code> 关联（集合）。</li>
<li>进一步得到各个 <code>SelectionKey</code>（有事件发生）。</li>
<li>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code>，方法 <code>channel()</code>。</li>
<li>可以通过得到的 <code>channel</code>，完成业务处理。</li>
<li>直接看后面代码吧</li>
</ol>
<h2 id="NIO-非阻塞网络编程快速入门"><a href="#NIO-非阻塞网络编程快速入门" class="headerlink" title="NIO 非阻塞网络编程快速入门"></a>NIO 非阻塞网络编程快速入门</h2><p>案例：</p>
<ol>
<li>编写一个 <code>NIO</code> 入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>目的：理解 <code>NIO</code> 非阻塞网络编程机制</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ServerSocketChannel -&gt; ServerSocket</span></span><br><span class="line"></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到一个Selecor对象</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定一个端口6666, 在服务器端监听</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>));</span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把 serverSocketChannel 注册到  selector 关心 事件为 OP_ACCEPT       pos_1</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;注册后的selectionkey 数量=&quot;</span> + selector.keys().size()); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环等待客户端连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里我们等待1秒，如果没有事件发生, 返回</span></span><br><span class="line">            <span class="keyword">if</span>(selector.select(<span class="number">1000</span>) == <span class="number">0</span>) &#123; <span class="comment">//没有事件发生</span></span><br><span class="line">                System.out.println(<span class="string">&quot;服务器等待了1秒，无连接&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果返回的&gt;0, 就获取到相关的 selectionKey集合</span></span><br><span class="line">            <span class="comment">//1.如果返回的&gt;0， 表示已经获取到关注的事件</span></span><br><span class="line">            <span class="comment">//2. selector.selectedKeys() 返回关注事件的集合</span></span><br><span class="line">            <span class="comment">//   通过 selectionKeys 反向获取通道</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            System.out.println(<span class="string">&quot;selectionKeys 数量 = &quot;</span> + selectionKeys.size());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历 Set&lt;SelectionKey&gt;, 使用迭代器遍历</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                <span class="comment">//获取到SelectionKey</span></span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line">                <span class="comment">//根据key 对应的通道发生的事件做相应处理</span></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable()) &#123; <span class="comment">//如果是 OP_ACCEPT, 有新的客户端连接</span></span><br><span class="line">                    <span class="comment">//该该客户端生成一个 SocketChannel</span></span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接成功 生成了一个 socketChannel &quot;</span> + socketChannel.hashCode());</span><br><span class="line">                    <span class="comment">//将  SocketChannel 设置为非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//将socketChannel 注册到selector, 关注事件为 OP_READ， 同时给socketChannel</span></span><br><span class="line">                    <span class="comment">//关联一个Buffer</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接后 ，注册的selectionkey 数量=&quot;</span> + selector.keys().size()); <span class="comment">//2,3,4..</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(key.isReadable()) &#123;  <span class="comment">//发生 OP_READ</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//通过key 反向获取到对应channel</span></span><br><span class="line">                    SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//获取到该channel关联的buffer</span></span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer)key.attachment();</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;form 客户端 &quot;</span> + <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//手动从集合中移动当前的selectionKey, 防止重复操作</span></span><br><span class="line">                keyIterator.remove();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pos1：</p>
<p>1、对操作系统有一定了解的同学，就会大概知道这里监听的是一个Accept通道。这个通道的<br>作用就是监听，实际建立连接了还会有一个通道。<br>2、简单说一下为什么。因为客户端发请求的时候，服务器这边是肯定要先有一个监听通道，<br>监听某个端口是否有客户端要建立链接，如果有客户端想要建立链接，那么会再创建一个和<br>客户端真正通信的通道。<br>3、如果有其它客户端还想要建立链接，这个Accept监听端口监听到了，就会再创建几个真正<br>的通信通道。<br>4、也就是Server的一个端口可以建立多个TCP连接，因为IP层协议通过<br>目标地址+端口+源地址+源端口四个信息识别一个上下文</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到一个网络通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//提供服务器端的ip 和 端口</span></span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="keyword">if</span> (!socketChannel.connect(inetSocketAddress)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;因为连接需要时间，客户端不会阻塞，可以做其它工作..&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...如果连接成功，就发送数据</span></span><br><span class="line">        String str = <span class="string">&quot;hello, 尚硅谷~&quot;</span>;</span><br><span class="line">        <span class="comment">//Wraps a byte array into a buffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(str.getBytes());</span><br><span class="line">        <span class="comment">//发送数据，将 buffer 数据写入 channel</span></span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际执行效果可以复制代码去试下</p>
<h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><ol>
<li><p>SelectionKey ，表示Selector 和网络通道的注册关系，共四种：</p>
<ul>
<li><code>int OP_ACCEPT</code>：有新的网络连接可以 <code>accept</code>，值为 <code>16</code></li>
<li><code>int OP_CONNECT</code>：代表连接已经建立，值为 <code>8</code></li>
<li><code>int OP_READ</code>：代表读操作，值为 <code>1</code></li>
<li><code>int OP_WRITE</code>：代表写操作，值为 <code>4</code></li>
</ul>
</li>
</ol>
<p>源码中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>SelectionKey</code> 相关方法</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0020.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0020.png" alt="img"></a></p>
<h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><ol>
<li><code>ServerSocketChannel</code> 在服务器端监听新的客户端 <code>Socket</code> 连接，<strong>负责监听，不负责实际的读写操作</strong></li>
<li>相关方法如下</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0021.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0021.png" alt="img"></a></p>
<h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><ol>
<li><code>SocketChannel</code>，网络 <code>IO</code> 通道，<strong>具体负责进行读写操作</strong>。<code>NIO</code> 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</li>
<li>相关方法如下</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0022.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0022.png" alt="img"></a></p>
<h2 id="NIO网络编程应用实例-群聊系统"><a href="#NIO网络编程应用实例-群聊系统" class="headerlink" title="NIO网络编程应用实例 - 群聊系统"></a>NIO网络编程应用实例 - 群聊系统</h2><p>实例要求：</p>
<ol>
<li>编写一个 <code>NIO</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>实现多人群聊</li>
<li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li>
<li>客户端：通过 <code>Channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li>
<li>目的：进一步理解 <code>NIO</code> 非阻塞网络编程机制</li>
<li>示意图分析和代码</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0023.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0023.png" alt="img"></a></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 服务端：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.nio.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Channel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenChannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//初始化工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">//ServerSocketChannel</span></span><br><span class="line">            listenChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            listenChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            <span class="comment">//设置非阻塞模式</span></span><br><span class="line">            listenChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//将该 listenChannel 注册到 selector</span></span><br><span class="line">            listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//循环处理</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = selector.select();</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123; <span class="comment">//有事件处理</span></span><br><span class="line">                    <span class="comment">// 遍历得到 selectionKey 集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        <span class="comment">//取出 selectionkey</span></span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        <span class="comment">//监听到 accept</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            SocketChannel sc = listenChannel.accept();</span><br><span class="line">                            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="comment">//将该 sc 注册到 seletor</span></span><br><span class="line">                            sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                            <span class="comment">//提示</span></span><br><span class="line">                            System.out.println(sc.getRemoteAddress() + <span class="string">&quot; 上线 &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;<span class="comment">//通道发送read事件，即通道是可读的状态</span></span><br><span class="line">                            <span class="comment">// 处理读(专门写方法..)</span></span><br><span class="line">                            readData(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//当前的 key 删除，防止重复处理</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//发生异常处理....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取客户端消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        SocketChannel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到 channel</span></span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//创建 buffer</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">int</span> count = channel.read(buffer);</span><br><span class="line">            <span class="comment">//根据 count 的值做处理</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//把缓存区的数据转成字符串</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                <span class="comment">//输出该消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;form客户端:&quot;</span> + msg);</span><br><span class="line">                <span class="comment">//向其它的客户端转发消息(去掉自己),专门写一个方法来处理</span></span><br><span class="line">                sendInfoToOtherClients(msg, channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">&quot;离线了..&quot;</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="comment">//关闭通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">                e2.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转发消息给其它客户(通道)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendInfoToOtherClients</span><span class="params">(String msg, SocketChannel self)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发消息中...&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历所有注册到 selector 上的 SocketChannel,并排除 self</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey key : selector.keys()) &#123;</span><br><span class="line">            <span class="comment">//通过 key 取出对应的 SocketChannel</span></span><br><span class="line">            Channel targetChannel = key.channel();</span><br><span class="line">            <span class="comment">//排除自己</span></span><br><span class="line">            <span class="keyword">if</span> (targetChannel <span class="keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel != self) &#123;</span><br><span class="line">                <span class="comment">//转型</span></span><br><span class="line">                SocketChannel dest = (SocketChannel) targetChannel;</span><br><span class="line">                <span class="comment">//将 msg 存储到 buffer</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">//将 buffer 的数据写入通道</span></span><br><span class="line">                dest.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建服务器对象</span></span><br><span class="line">        GroupChatServer groupChatServer = <span class="keyword">new</span> GroupChatServer();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.nio.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义相关的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String HOST = <span class="string">&quot;127.0.0.1&quot;</span>;<span class="comment">//服务器的ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>;<span class="comment">//服务器端口</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器,完成初始化工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(HOST, PORT));</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//将 channel 注册到selector</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">//得到 username</span></span><br><span class="line">        username = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(username + <span class="string">&quot; is ok...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInfo</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        info = username + <span class="string">&quot; 说：&quot;</span> + info;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取从服务器端回复的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> readChannels = selector.select();</span><br><span class="line">            <span class="keyword">if</span> (readChannels &gt; <span class="number">0</span>) &#123;<span class="comment">//有可以用的通道</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        <span class="comment">//得到相关的通道</span></span><br><span class="line">                        SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">//得到一个 Buffer</span></span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//读取</span></span><br><span class="line">                        sc.read(buffer);</span><br><span class="line">                        <span class="comment">//把读到的缓冲区的数据转成字符串</span></span><br><span class="line">                        String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                        System.out.println(msg.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                iterator.remove(); <span class="comment">//删除当前的 selectionKey,防止重复操作</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//System.out.println(&quot;没有可以用的通道...&quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动我们客户端</span></span><br><span class="line">        GroupChatClient chatClient = <span class="keyword">new</span> GroupChatClient();</span><br><span class="line">        <span class="comment">//启动一个线程,每个 3 秒，读取从服务器发送数据</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    chatClient.readInfo();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据给服务器端</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            chatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NIO与零拷贝"><a href="#NIO与零拷贝" class="headerlink" title="NIO与零拷贝"></a>NIO与零拷贝</h2><blockquote>
<p>1、尚硅谷这里的零拷贝感觉讲的感觉有点问题，但是为了笔记的完整性，任然保留了这里的笔记。不过笔者考虑再写一篇零拷贝。</p>
<p>2、而且这里课件的图也看不太清</p>
<p>3、读者可以将我写的零拷贝和尚硅谷这里讲的零拷贝对照着看，取长补短</p>
</blockquote>
<h3 id="零拷贝基本介绍"><a href="#零拷贝基本介绍" class="headerlink" title="零拷贝基本介绍"></a>零拷贝基本介绍</h3><ol>
<li>零拷贝是网络编程的关键，很多性能优化都离不开。</li>
<li>在 <code>Java</code> 程序中，常用的零拷贝有 <code>mmap</code>（内存映射）和 <code>sendFile</code>。那么，他们在 <code>OS</code> 里，到底是怎么样的一个的设计？我们分析 <code>mmap</code> 和 <code>sendFile</code> 这两个零拷贝</li>
<li>另外我们看下 <code>NIO</code> 中如何使用零拷贝</li>
</ol>
<h3 id="传统-IO-数据读写"><a href="#传统-IO-数据读写" class="headerlink" title="传统 IO 数据读写"></a>传统 IO 数据读写</h3><p><code>Java</code> 传统 <code>IO</code> 和网络编程的一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) file.length()];</span><br><span class="line">raf.read(arr);</span><br><span class="line"></span><br><span class="line">Socket socket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>).accept();</span><br><span class="line">socket.getOutputStream().write(arr);</span><br></pre></td></tr></table></figure>

<h3 id="传统-IO-模型"><a href="#传统-IO-模型" class="headerlink" title="传统 IO 模型"></a>传统 IO 模型</h3><p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0024.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0024.png" alt="img"></a></p>
<p><strong>DMA</strong>：<code>direct memory access</code> 直接内存拷贝（不使用 <code>CPU</code>）</p>
<h3 id="mmap-优化"><a href="#mmap-优化" class="headerlink" title="mmap 优化"></a>mmap 优化</h3><ol>
<li><code>mmap</code> 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。如下图</li>
<li><code>mmap</code> 示意图</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0025.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0025.png" alt="img"></a></p>
<h3 id="sendFile-优化"><a href="#sendFile-优化" class="headerlink" title="sendFile 优化"></a>sendFile 优化</h3><ol>
<li><code>Linux2.1</code> 版本提供了 <code>sendFile</code> 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 <code>SocketBuffer</code>，同时，由于和用户态完全无关，就减少了一次上下文切换</li>
<li>示意图和小结</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0026.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0026.png" alt="img"></a></p>
<ol>
<li>提示：零拷贝从操作系统角度，是没有 <code>cpu</code> 拷贝</li>
<li><code>Linux在2.4</code> 版本中，做了一些修改，避免了从内核缓冲区拷贝到 <code>Socketbuffer</code> 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。具体如下图和小结：</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0027.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_001/0027.png" alt="img"></a></p>
<ol>
<li>这里其实有一次 <code>cpu</code> 拷贝 <code>kernel buffer</code> -&gt; <code>socket buffer</code> 但是，拷贝的信息很少，比如 <code>lenght</code>、<code>offset</code> 消耗低，可以忽略</li>
</ol>
<h3 id="零拷贝的再次理解"><a href="#零拷贝的再次理解" class="headerlink" title="零拷贝的再次理解"></a>零拷贝的再次理解</h3><ol>
<li>我们说零拷贝，是从操作系统的角度来说的。因为内核缓冲区之间，没有数据是重复的（只有 <code>kernel buffer</code> 有一份数据）。</li>
<li>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 <code>CPU</code> 缓存伪共享以及无 <code>CPU</code> 校验和计算。</li>
</ol>
<h3 id="mmap-和-sendFile-的区别"><a href="#mmap-和-sendFile-的区别" class="headerlink" title="mmap 和 sendFile 的区别"></a>mmap 和 sendFile 的区别</h3><ol>
<li><code>mmap</code> 适合小数据量读写，<code>sendFile</code> 适合大文件传输。</li>
<li><code>mmap</code> 需要 <code>4</code> 次上下文切换，<code>3</code> 次数据拷贝；<code>sendFile</code> 需要 <code>3</code> 次上下文切换，最少 <code>2</code> 次数据拷贝。</li>
<li><code>sendFile</code> 可以利用 <code>DMA</code> 方式，减少 <code>CPU</code> 拷贝，<code>mmap</code> 则不能（必须从内核拷贝到 <code>Socket</code>缓冲区）。</li>
</ol>
<h3 id="NIO-零拷贝案例"><a href="#NIO-零拷贝案例" class="headerlink" title="NIO 零拷贝案例"></a>NIO 零拷贝案例</h3><p>案例要求：</p>
<ol>
<li>使用传统的 <code>IO</code> 方法传递一个大文件</li>
<li>使用 <code>NIO</code> 零拷贝方式传递（<code>transferTo</code>）一个大文件</li>
<li>看看两种传递方式耗时时间分别是多少</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NewIOServer.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.nio.zerocopy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="number">7001</span>);</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建buffer</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            <span class="keyword">int</span> readcount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != readcount) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    readcount = socketChannel.read(byteBuffer);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    <span class="comment">// ex.printStackTrace();</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                byteBuffer.rewind(); <span class="comment">//倒带 position = 0 mark 作废</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NewIOClient.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.nio.zerocopy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">7001</span>));</span><br><span class="line">        String filename = <span class="string">&quot;protoc-3.6.1-win32.zip&quot;</span>;</span><br><span class="line">        <span class="comment">//得到一个文件channel</span></span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> FileInputStream(filename).getChannel();</span><br><span class="line">        <span class="comment">//准备发送</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//在 linux 下一个 transferTo 方法就可以完成传输</span></span><br><span class="line">        <span class="comment">//在 windows 下一次调用 transferTo 只能发送 8m, 就需要分段传输文件,而且要主要</span></span><br><span class="line">        <span class="comment">//传输时的位置=》课后思考...</span></span><br><span class="line">        <span class="comment">//transferTo 底层使用到零拷贝</span></span><br><span class="line">        <span class="keyword">long</span> transferCount = fileChannel.transferTo(<span class="number">0</span>, fileChannel.size(), socketChannel);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送的总的字节数 = &quot;</span> + transferCount + <span class="string">&quot; 耗时: &quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        fileChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-AIO-基本介绍"><a href="#Java-AIO-基本介绍" class="headerlink" title="Java AIO 基本介绍"></a>Java AIO 基本介绍</h2><ol>
<li><code>JDK7</code> 引入了 <code>AsynchronousI/O</code>，即 <code>AIO</code>。在进行 <code>I/O</code> 编程中，常用到两种模式：<code>Reactor</code> 和 <code>Proactor</code>。<code>Java</code> 的 <code>NIO</code> 就是 <code>Reactor</code>，当有事件触发时，服务器端得到通知，进行相应的处理</li>
<li><code>AIO</code> 即 <code>NIO2.0</code>，叫做异步不阻塞的 <code>IO</code>。<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li>
<li>目前 <code>AIO</code> 还没有广泛应用，<code>Netty</code> 也是基于 <code>NIO</code>，而不是 <code>AIO</code>，因此我们就不详解 <code>AIO</code> 了，有兴趣的同学可以参考<a href="http://www.52im.net/thread-306-1-1.html">《Java新一代网络编程模型AIO原理及Linux系统AIO介绍》</a></li>
</ol>
<h2 id="BIO、NIO、AIO-对比表"><a href="#BIO、NIO、AIO-对比表" class="headerlink" title="BIO、NIO、AIO 对比表"></a>BIO、NIO、AIO 对比表</h2><table>
<thead>
<tr>
<th></th>
<th>BIO</th>
<th>NIO</th>
<th>AIO</th>
</tr>
</thead>
<tbody><tr>
<td>IO模型</td>
<td>同步阻塞</td>
<td>同步非阻塞（多路复用）</td>
<td>异步非阻塞</td>
</tr>
<tr>
<td>编程难度</td>
<td>简单</td>
<td>复杂</td>
<td>复杂</td>
</tr>
<tr>
<td>可靠性</td>
<td>差</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>吞吐量</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
</tbody></table>
<p><strong>举例说明</strong></p>
<ol>
<li>同步阻塞：到理发店理发，就一直等理发师，直到轮到自己理发。</li>
<li>同步非阻塞：到理发店理发，发现前面有其它人理发，给理发师说下，先干其他事情，一会过来看是否轮到自己.</li>
<li>异步非阻塞：给理发师打电话，让理发师上门服务，自己干其它事情，理发师自己来家给你理发</li>
</ol>
<p>参考：</p>
<p><strong>视频：</strong><a href="https://www.bilibili.com/video/BV1DJ411m7NR?from=search&amp;seid=7455267981675039441">https://www.bilibili.com/video/BV1DJ411m7NR?from=search&amp;seid=7455267981675039441</a></p>
<p><strong>文章链接:</strong> <a href="https://imlql.cn/post/3f9283e7.html">https://imlql.cn/post/3f9283e7.html</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>netty</category>
      </categories>
  </entry>
  <entry>
    <title>Jmeter基础一</title>
    <url>/60bbc03b.html</url>
    <content><![CDATA[<h1 id="Jmeter介绍"><a href="#Jmeter介绍" class="headerlink" title="Jmeter介绍"></a>Jmeter介绍</h1><h1 id="Jmeter入门"><a href="#Jmeter入门" class="headerlink" title="Jmeter入门"></a>Jmeter入门</h1>]]></content>
      <categories>
        <category>测试</category>
        <category>Jmeter</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>协程</title>
    <url>/bb1e53b0.html</url>
    <content><![CDATA[<h1 id="进程和线程的痛点"><a href="#进程和线程的痛点" class="headerlink" title="进程和线程的痛点"></a>进程和线程的痛点</h1><ol>
<li>线程之间的通讯要设计到同步锁</li>
<li>涉及到线程上下文切换</li>
<li>涉及到阻塞状态和运行状态切换</li>
</ol>
<span id="more"></span>

<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p><strong>协程，英文Coroutines，是一种比线程更加轻量级的存在。</strong>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/6765e36cc4604fba897976638af03524.jpeg" alt="img"></p>
<p>最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</p>
<p>这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
<p>由于Java的原生语法中并没有实现协程（某些开源框架实现了协程，但是很少被使用），比较多的是python、lua中使用协程</p>
<p>具体了解推荐：</p>
<p><a href="https://blog.csdn.net/zheng199172/article/details/88800275">https://blog.csdn.net/zheng199172/article/details/88800275</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272">https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程1</title>
    <url>/cfe2d636.html</url>
    <content><![CDATA[<h1 id="线程、进程、协程-纤程"><a href="#线程、进程、协程-纤程" class="headerlink" title="线程、进程、协程/纤程"></a>线程、进程、协程/纤程</h1><p>进程是资源分配的基本单位，一个进程中包括过个线程，各个进程之间互不影响</p>
<p>线程是资源调度的基本单位，线程之间共享进程的部分资源</p>
<p>协程：协程是一种程序组件，一个线程中可以有多个协程，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<span id="more"></span>

<p>协程优势：</p>
<ol>
<li>协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</li>
<li>就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</li>
</ol>
<h1 id="创建或者启动线程的几种方式"><a href="#创建或者启动线程的几种方式" class="headerlink" title="创建或者启动线程的几种方式"></a>创建或者启动线程的几种方式</h1><p>总：</p>
<p>一共有三种方式</p>
<ul>
<li><p>继承Thread类</p>
</li>
<li><p>实现Runnable接口</p>
</li>
<li><p>实现CallAble接口</p>
</li>
</ul>
<p>分：</p>
<ul>
<li><p>继承Thread类</p>
</li>
<li><p>实现Runnable接口</p>
</li>
<li><p>实现CallAble接口</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/25 18:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HowToCreateThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyCall())).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;继承Thread线程&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;实现Runnable接口&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCall</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;实现Callable接口&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="sleep、wait、yield、join、await、park的作用"><a href="#sleep、wait、yield、join、await、park的作用" class="headerlink" title="sleep、wait、yield、join、await、park的作用"></a>sleep、wait、yield、join、await、park的作用</h1><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>sleep方法是属于Thread类中的方法，sleep过程中线程不会释放锁，只会阻塞线程，让出cpu给其他线程，但是监控状态依然保持着，当指定的时间到了后又会自动进入cpu争夺（如果有锁但是没有释放，则立即恢复运行；如果没有锁，则会进入等待队列，等待cpu的调度），可中断，sleep给其他线程运行机会时不会考虑线程的优先级，因此会给低优先级的线程以运行机会</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/25 20:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread1()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread2()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread1 start&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread1 end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 start&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有加sleep的情况下运行结果</span></span><br><span class="line">thread1 start</span><br><span class="line">thread2 start</span><br><span class="line">thread2 end</span><br><span class="line">thread1 end</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 加sleep的情况下运行结果</span></span><br><span class="line">thread1 start</span><br><span class="line">thread1 end</span><br><span class="line">thread2 start</span><br><span class="line">thread2 end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明在有锁的情况下，调用sleep方法不会释放锁，也就是不会退出cpu资源</p>
<h3 id="说一下sleep-0-有什么用"><a href="#说一下sleep-0-有什么用" class="headerlink" title="说一下sleep(0)有什么用"></a>说一下sleep(0)有什么用</h3><p>sleep通常用在没有加锁的多线程上，Sleep(0)是指CPU交出当前线程的执行权，进入就绪队列，这个时候操作系统重新计算优先级，然后竞争cpu的使用权</p>
<p>应用场景：</p>
<ul>
<li>如果当前线程比较耗时占用cpu资源，可以在结尾处加上sleep(0)，这样可以提高整体的执行效率</li>
<li>保证线程同步，线程池工作的时候，主线程使用sleep(0)来等待线程池中所有线程都完成运行。当在线程池中的线程非常多的时候，使用该方法减少线程上下文的切换，节省cpu的开销</li>
</ul>
<p>推荐文章：<a href="https://blog.csdn.net/qiaoquan3/article/details/56281092/?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.essearch_pc_relevant&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/qiaoquan3/article/details/56281092/?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.essearch_pc_relevant&amp;spm=1001.2101.3001.4242</a></p>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>wait方法是属于object类中，wait过程中线程会释放对象锁，只有当其他线程调用notify才能唤醒次线程。wait使用时必须先获取对象锁，即必须在synchronized修饰的代码块中使用，那么响应的notify方法同样必须在synchronized修饰的代码块中使用，如果没有在synchronized修饰的代码块中使用时3会抛出IllegalMonitorStateException的异常</p>
<p>wait方法用notify唤醒后不一定继续执行后续内容，因为wait会释放锁，然后进入等待池（WaitSet，是一个双向循环链表。在调用wait的时候，会做两件事，想将吱声加入到waitset中，然后释放掉对象锁持有的锁），在被notify唤醒后，进入锁池（EntryList，唤醒后加入到对象的moitor对象的EntryList中），这个时候会尝试获取该对象的锁，如果获取成功后才会接着<strong>按照wait方法之后路径继续执行</strong>，没有拿到锁就进入阻塞状态</p>
<p>虚假唤醒：notify/notifyAll时唤醒的线程并不一定是满足真正可以执行的条件了。比如对象o，不满足A条件时发出o.wait（），然后不满足条件B时也发出o.wait；然后条件B满足了，发出o.notify()，唤醒对象o的等待池里的对象，但是唤醒的线程有可能是因为条件A进入等待的线程，这时把他唤醒条件A还是不满足。这是底层系统决定的一个小遗憾。为了避免这种情况，判断调用o.wait（）的条件时必须使用while，而不是if，这样在虚假唤醒后会继续判断是否满足A条件，不满足说明是虚假唤醒又会调用o.wait()。</p>
<p>moitor：是对象头监听锁的数据结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/25 21:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWait</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread1()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread2()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread1 start&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread1 end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 start&quot;</span>);</span><br><span class="line">                obj.notify();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有加wait的情况下运行结果</span></span><br><span class="line">thread1 start</span><br><span class="line">thread2 start</span><br><span class="line">thread2 end</span><br><span class="line">thread1 end</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 加wait的情况下运行结果</span></span><br><span class="line">thread1 start</span><br><span class="line">thread2 start</span><br><span class="line">thread2 end<span class="comment">//因为加有锁的缘故， obj.notify()虽然唤醒了thread1但是不会运行thread1，要等待当前锁释放掉</span></span><br><span class="line">thread1 end</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 注释掉MyThread2的synchronized (obj) 后，并且程序陷入死循环</span></span><br><span class="line">thread1 start</span><br><span class="line">thread2 start</span><br><span class="line">Exception in thread <span class="string">&quot;Thread-1&quot;</span> java.lang.IllegalMonitorStateException</span><br><span class="line">	at java.lang.Object.notify(Native Method)</span><br><span class="line">	at top.thread1.ThreadWait$MyThread2.run(ThreadWait.java:<span class="number">37</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure>



<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>和sleep一样都是Thread类的方法，都是暂停当前正在执行的线程对象，不会释放资源锁，和sleep不同的是yield方法不会让线程进入阻塞状态，而是让线程重新进入就绪状态，它只需要等待重新获取cpu执行时间，所以yield（）的线程有可能在进入到可执行状态后马上又被执行。还有一点和sleep不同的是yield方法只能使同优先级或更高优先级的线程有执行的机会，不会发生优先级重排。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/25 21:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadYidle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread3()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread1()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread2()).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread1 start&quot;</span>);</span><br><span class="line">                Thread.yield();</span><br><span class="line">                System.out.println(<span class="string">&quot;thread1 end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 start&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread3 start&quot;</span>);</span><br><span class="line">                Thread.yield();</span><br><span class="line">                System.out.println(<span class="string">&quot;thread3 end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有加yield的情况下运行结果</span></span><br><span class="line">thread3 start</span><br><span class="line">thread3 end</span><br><span class="line">thread1 start</span><br><span class="line">thread1 end</span><br><span class="line">thread2 start</span><br><span class="line">thread2 end</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 有yield的情况下运行结果</span></span><br><span class="line">thread3 start</span><br><span class="line">thread3 end</span><br><span class="line">thread1 start</span><br><span class="line">thread1 end</span><br><span class="line">thread2 start</span><br><span class="line">thread2 end</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>等待调用join方法的线程结束之后，程序在继续执行，相当于让另一个线程加入当前线程，另一个线程执行完毕，在接着执行这个线程，相当于串行。一般用于等待异步线程执行完结果之后才能继续运行的场景。例如：主线程创建并启动了子线程，如果子线程中药进行大量耗时运算计算某个数据值，而主线程要获取这个数据值才能运行，这时要用到join方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/25 21:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread1());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread2());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;count:&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread1 start&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread1 end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 start&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有加入join</span></span><br><span class="line">thread1 start</span><br><span class="line">count:<span class="number">10</span></span><br><span class="line">thread1 end</span><br><span class="line">thread2 start</span><br><span class="line">thread2 end</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入join</span></span><br><span class="line">thread1 start</span><br><span class="line">thread1 end</span><br><span class="line">thread2 start</span><br><span class="line">thread2 end</span><br><span class="line">count:<span class="number">20</span></span><br></pre></td></tr></table></figure>



<h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>Condition的方法，用于线程的阻塞，是执行在代码块中，可以通过方法释放锁，在唤醒后就进入就绪状态</p>
<h2 id="park"><a href="#park" class="headerlink" title="park"></a>park</h2><p>是LockSupport.park()调用的，但是真正调用者是Unsafe类的native方法。可以使用LockSupport.unpark()方法唤醒，然后一定会执行后续内容（但是wait方法用notify唤醒后不一定继续执行后续内容）。</p>
<p>park()可以在任意位置运行、不需要抛出异常。park在执行前执行了unpark（）方法，线程不会被阻塞，直接跳过park，继续执行后续内容（而wait之前执行了notify方法，则直接抛出异常）</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTY0ODkzOC8yMDE5MTAvMTY0ODkzOC0yMDE5MTAzMTAwMDM0MDIxOC0xMzI1MDc0OTg3LnBuZw.png" alt="aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTY0ODkzOC8yMDE5MTAvMTY0ODkzOC0yMDE5MTAzMTAwMDM0MDIxOC0xMzI1MDc0OTg3LnBuZw"></p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/ywlmsm1224811/article/details/94022647">https://blog.csdn.net/ywlmsm1224811/article/details/94022647</a></p>
<p><a href="https://blog.csdn.net/asdasdasd123123123/article/details/107814280">https://blog.csdn.net/asdasdasd123123123/article/details/107814280</a></p>
<h1 id="java线程的状态及主要转化方式"><a href="#java线程的状态及主要转化方式" class="headerlink" title="java线程的状态及主要转化方式"></a>java线程的状态及主要转化方式</h1><h2 id="操作系统中的线程状态转换和生命周期"><a href="#操作系统中的线程状态转换和生命周期" class="headerlink" title="操作系统中的线程状态转换和生命周期"></a><strong>操作系统中的线程状态转换和生命周期</strong></h2><p>线程的生命周期和java线程的转态：<a href="https://www.cnblogs.com/duanxz/p/3733179.html">https://www.cnblogs.com/duanxz/p/3733179.html</a></p>
<p>首先我们来看看操作系统中的线程状态转换。</p>
<blockquote>
<p>在现在的操作系统中，线程是被视为轻量级进程的，所以<strong>操作系统线程的状态其实和操作系统进程的状态是一致的</strong>。</p>
</blockquote>
<p><img src="https://gblobscdn.gitbook.com/assets%2F-L_5HvtIhTFW9TQlOF8e%2F-L_5TIKcBFHWPtY3OwUo%2F-L_5TJM1VhwmwbNGzqwJ%2F%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png?alt=media" alt="img"></p>
<h3 id="系统进程-线程转换图"><a href="#系统进程-线程转换图" class="headerlink" title="系统进程/线程转换图"></a>系统进程/线程转换图</h3><p>操作系统线程主要有以下三个状态：</p>
<ul>
<li>就绪状态(ready)：线程正在等待使用CPU，经调度程序调用之后可进入running状态。</li>
<li>执行状态(running)：线程正在使用CPU。</li>
<li>等待状态(waiting): 线程经过等待事件的调用或者正在等待其他资源（如I/O）。  </li>
</ul>
<h3 id="线程的生命周期："><a href="#线程的生命周期：" class="headerlink" title="线程的生命周期："></a>线程的生命周期：</h3><ul>
<li><h3 id="新建（NEW）"><a href="#新建（NEW）" class="headerlink" title="新建（NEW）"></a>新建（NEW）</h3><ul>
<li>new关键字创建了一个线程之后，该线程就处于新建状态</li>
<li>JVM为线程分配内存，初始化成员变量值</li>
</ul>
</li>
<li><h3 id="就绪（RUNNABLE）"><a href="#就绪（RUNNABLE）" class="headerlink" title="就绪（RUNNABLE）"></a>就绪（RUNNABLE）</h3><ul>
<li>当线程对象调用了start()方法之后，该线程处于就绪状态</li>
<li>JVM为线程创建方法栈和程序计数器，等待线程调度器调度</li>
</ul>
</li>
<li><h3 id="运行（RUNNING）"><a href="#运行（RUNNING）" class="headerlink" title="运行（RUNNING）"></a>运行（RUNNING）</h3><ul>
<li>就绪状态的线程获得CPU资源，开始运行run()方法，该线程进入运行状态</li>
</ul>
</li>
<li><h3 id="阻塞（BLOCKED）"><a href="#阻塞（BLOCKED）" class="headerlink" title="阻塞（BLOCKED）"></a>阻塞（BLOCKED）</h3><ul>
<li><p>当发生如下情况时，线程将会进入阻塞状态</p>
<blockquote>
<p>线程调用sleep()方法主动放弃所占用的处理器资源</p>
<p>线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞</p>
<p>线程试图获得一个同步锁（同步监视器），但该同步锁正被其他线程所持有。 </p>
<p>线程在等待某个通知（notify）</p>
<p>程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法</p>
</blockquote>
</li>
</ul>
</li>
<li><h3 id="死亡（TERMINTED）"><a href="#死亡（TERMINTED）" class="headerlink" title="死亡（TERMINTED）"></a>死亡（TERMINTED）</h3><ul>
<li><p>线程会以如下3种方式结束，结束后就处于死亡状态：</p>
<blockquote>
<p>run()或call()方法执行完成，线程正常结束</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>线程抛出一个未捕获的Exception或Error。</p>
<p>调用该线程stop()方法来结束该线程，该方法容易导致死锁，不推荐使用。</p>
</blockquote>
<p>​     </p>
<h2 id="Java线程的6个状态"><a href="#Java线程的6个状态" class="headerlink" title="Java线程的6个状态"></a><strong>Java线程的6个状态</strong></h2><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/thread-2-img/285763-20200617223221933-644434653.png" alt="img"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/thread-2-img/285763-20191022085010399-1732523132.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Thread.State 源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NEW（新建）"><a href="#NEW（新建）" class="headerlink" title="NEW（新建）"></a><strong>NEW</strong>（新建）</h3><p>处于NEW状态的线程此时尚未启动。这里的尚未启动指的是还没调用Thread实例的start()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testStateNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;&#125;);</span><br><span class="line">    System.out.println(thread.getState()); <span class="comment">// 输出 NEW </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，只是创建了线程而并没有调用start()方法，此时线程处于NEW状态。</p>
<p><strong>关于start()的两个引申问题</strong></p>
<ol>
<li>反复调用同一个线程的start()方法是否可行？</li>
<li>假如一个线程执行完毕（此时处于TERMINATED状态），再次调用这个线程的start()方法是否可行？</li>
</ol>
<p>要分析这两个问题，我们先来看看start()的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在start()内部，这里有一个threadStatus的变量。如果它不等于0，调用start()是会直接抛出异常的。</p>
<p>我们接着往下看，有一个native的<code>start0()</code>方法。这个方法里并没有对<strong>threadStatus</strong>的处理。到了这里我们仿佛就拿这个threadStatus没辙了，我们通过debug的方式再看一下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStartMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;&#125;);</span><br><span class="line">    thread.start(); <span class="comment">// 第一次调用</span></span><br><span class="line">    thread.start(); <span class="comment">// 第二次调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我是在start()方法内部的最开始打的断点，叙述下在我这里打断点看到的结果：</p>
<ul>
<li>第一次调用时threadStatus的值是0。</li>
<li>第二次调用时threadStatus的值不为0。</li>
</ul>
<p>查看当前线程状态的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Thread.getState方法源码：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// get current thread state</span></span><br><span class="line">    <span class="keyword">return</span> sun.misc.VM.toThreadState(threadStatus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sun.misc.VM 源码：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> State <span class="title">toThreadState</span><span class="params">(<span class="keyword">int</span> var0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((var0 &amp; <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> State.RUNNABLE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((var0 &amp; <span class="number">1024</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> State.BLOCKED;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((var0 &amp; <span class="number">16</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> State.WAITING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((var0 &amp; <span class="number">32</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> State.TIMED_WAITING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((var0 &amp; <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> State.TERMINATED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (var0 &amp; <span class="number">1</span>) == <span class="number">0</span> ? State.NEW : State.RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，我们结合上面的源码可以得到引申的两个问题的结果：</p>
<blockquote>
<p>两个问题的答案都是不可行，在调用一次start()之后，threadStatus的值会改变（threadStatus !=0），此时再次调用start()方法会抛出IllegalThreadStateException异常。</p>
<p>比如，threadStatus为2代表当前线程状态为TERMINATED。</p>
</blockquote>
<h3 id="RUNNABLE（就绪和运行）"><a href="#RUNNABLE（就绪和运行）" class="headerlink" title="RUNNABLE（就绪和运行）"></a><strong>RUNNABLE（就绪和运行）</strong></h3><p>表示当前线程正在运行中。处于RUNNABLE状态的线程在Java虚拟机中运行，也有可能在等待其他系统资源（比如I/O）。</p>
<p><strong>Java中线程的RUNNABLE状态</strong></p>
<p>看了操作系统线程的几个状态之后我们来看看Thread源码里对RUNNABLE状态的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="line"> * state is executing in the Java virtual machine but it may</span><br><span class="line"> * be waiting for other resources from the operating system</span><br><span class="line"> * such as processor.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java线程的<strong>RUNNABLE</strong>状态其实是包括了传统操作系统线程的<strong>ready</strong>和<strong>running</strong>两个状态的。</p>
<p>当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</p>
<p>因为就绪状态是进入运行状态的唯一入口，也就是说：在线程进入到运行状态执行，首先必须处于就绪状态，所以java把Runnable状态包括了传统的就绪和运行</p>
</blockquote>
<h3 id="BLOCKED（阻塞）"><a href="#BLOCKED（阻塞）" class="headerlink" title="BLOCKED（阻塞）"></a><strong>BLOCKED（阻塞）</strong></h3><p>阻塞状态。处于BLOCKED状态的线程正等待锁的释放以进入同步区。</p>
<blockquote>
<p>处于运行状态中的线程由于某种（当线程处于运行状态时，试图获得某个对象的同步锁时，如果该对象的同步锁已经被其他线程占用，Java虚拟机就会把这个线程放到这个对象的锁池中，这涉及到“线程同步”的内容。【线程在获取synchronized同步锁失败(因为锁被其它线程所占用)】）原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态。 </p>
</blockquote>
<p>我们用BLOCKED状态举个生活中的例子：</p>
<blockquote>
<p>假如今天你下班后准备去食堂吃饭。你来到食堂仅有的一个窗口，发现前面已经有个人在窗口前了，此时你必须得等前面的人从窗口离开才行。 假设你是线程t2，你前面的那个人是线程t1。此时t1占有了锁（食堂唯一的窗口），t2正在等待锁的释放，所以此时t2就处于BLOCKED状态。</p>
</blockquote>
<h3 id="WAITING（无限期等待）"><a href="#WAITING（无限期等待）" class="headerlink" title="WAITING（无限期等待）"></a><strong>WAITING（无限期等待）</strong></h3><p>等待状态。处于等待状态的线程变成RUNNABLE状态需要其他线程唤醒。</p>
<p>调用如下3个方法会使线程进入等待状态：</p>
<ul>
<li>没有设置timeout参数的Object.wait()：使当前线程处于等待状态直到另一个线程唤醒它；</li>
<li>没有设置timeout参数的Thread.join()：等待线程执行完毕，底层调用的是Object实例的wait方法；</li>
<li>LockSupport.park()：除非获得调用许可，否则禁用当前线程进行线程调度。  </li>
</ul>
<p>我们延续上面的例子继续解释一下WAITING状态：</p>
<blockquote>
<p>你等了好几分钟现在终于轮到你了，突然你们有一个“不懂事”的经理突然来了。你看到他你就有一种不祥的预感，果然，他是来找你的。</p>
<p>他把你拉到一旁叫你待会儿再吃饭，说他下午要去作报告，赶紧来找你了解一下项目的情况。你心里虽然有一万个不愿意但是你还是从食堂窗口走开了。</p>
<p>此时，假设你还是线程t2，你的经理是线程t1。虽然你此时都占有锁（窗口）了，“不速之客”来了你还是得释放掉锁。此时你t2的状态就是WAITING。然后经理t1获得锁，进入RUNNABLE状态。</p>
<p>要是经理t1不主动唤醒你t2（notify、notifyAll..），可以说你t2只能一直等待了。</p>
</blockquote>
<h3 id="TIMED-WAITING（限期等待）"><a href="#TIMED-WAITING（限期等待）" class="headerlink" title="TIMED_WAITING（限期等待）"></a><strong>TIMED_WAITING（限期等待）</strong></h3><p>超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。</p>
<p>调用如下方法会使线程进入超时等待状态：</p>
<ul>
<li>Thread.sleep(long millis)：使当前线程睡眠指定时间；</li>
<li>设置了timeout参数的Object.wait(long timeout)：线程休眠指定时间，等待期间可以通过notify()/notifyAll()唤醒；</li>
<li>设置了timeout参数的Thread.join(long millis)：等待当前线程最多执行millis毫秒，如果millis为0，则会一直执行；</li>
<li>LockSupport.parkNanos(long nanos)： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；</li>
<li>LockSupport.parkUntil(long deadline)：同上，也是禁止线程进行调度指定时间；</li>
</ul>
<p>我们继续延续上面的例子来解释一下TIMED_WAITING状态：</p>
<blockquote>
<p>到了第二天中午，又到了饭点，你还是到了窗口前。</p>
<p>突然间想起你的同事叫你等他一起，他说让你等他十分钟他改个bug。</p>
<p>好吧，你说那你就等等吧，你就离开了窗口。很快十分钟过去了，你见他还没来，你想都等了这么久了还不来，那你还是先去吃饭好了。</p>
<p>这时你还是线程t1，你改bug的同事是线程t2。t2让t1等待了指定时间，t1先主动释放了锁。此时t1等待期间就属于TIMED_WATING状态。</p>
<p>t1等待10分钟后，就自动唤醒，拥有了去争夺锁的资格。</p>
</blockquote>
<h3 id="TERMINATED（死亡）"><a href="#TERMINATED（死亡）" class="headerlink" title="TERMINATED（死亡）"></a><strong>TERMINATED</strong>（死亡）</h3><p>终止状态。此时线程已执行完毕。</p>
<blockquote>
<p>线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p>
</blockquote>
<h2 id="线程状态的转换"><a href="#线程状态的转换" class="headerlink" title="线程状态的转换"></a><strong>线程状态的转换</strong></h2><p>根据上面关于线程状态的介绍我们可以得到下面的<strong>线程状态转换图</strong>： <img src="https://firebasestorage.googleapis.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-L_5HvtIhTFW9TQlOF8e%2F-L_5TIKcBFHWPtY3OwUo%2F-L_5TJM7CvFzBq6T_50d%2F%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png?generation=1551665550335701&alt=media" alt="线程状态转换图"></p>
<h3 id="BLOCKED与RUNNABLE状态的转换"><a href="#BLOCKED与RUNNABLE状态的转换" class="headerlink" title="BLOCKED与RUNNABLE状态的转换"></a><strong>BLOCKED与RUNNABLE状态的转换</strong></h3><p>我们在上面说到：处于BLOCKED状态的线程是因为在等待锁的释放。假如这里有两个线程a和b，a线程提前获得了锁并且暂未释放锁，此时b就处于BLOCKED状态。我们先来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockedTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread a = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            testMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    Thread b = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            testMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a.start();</span><br><span class="line">    b.start();</span><br><span class="line">    System.out.println(a.getName() + <span class="string">&quot;:&quot;</span> + a.getState()); <span class="comment">// 输出？</span></span><br><span class="line">    System.out.println(b.getName() + <span class="string">&quot;:&quot;</span> + b.getState()); <span class="comment">// 输出？</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步方法争夺锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初看之下，大家可能会觉得线程a会先调用同步方法，同步方法内又调用了Thread.sleep()方法，必然会输出TIMED_WAITING，而线程b因为等待线程a释放锁所以必然会输出BLOCKED。</p>
<p>其实不然，有两点需要值得大家注意，一是<strong>在测试方法blockedTest()内还有一个main线程</strong>，二是<strong>启动线程后执行run方法还是需要消耗一定时间的</strong>。不打断点的情况下，上面代码中都应该输出<strong>RUNNABLE</strong>。</p>
<blockquote>
<p>测试方法的main线程只保证了a，b两个线程调用start()方法（转化为RUNNABLE状态），还没等两个线程真正开始争夺锁，就已经打印此时两个线程的状态（RUNNABLE）了。</p>
</blockquote>
<p>这时你可能又会问了，要是我想要打印出BLOCKED状态我该怎么处理呢？其实就处理下测试方法里的main线程就可以了，你让它“休息一会儿”，打断点或者调用Thread.sleep方法就行。</p>
<p>这里需要注意的是main线程休息的时间，要保证在线程争夺锁的时间内，不要等到前一个线程锁都释放了你再去争夺锁，此时还是得不到BLOCKED状态的。</p>
<p>我们把上面的测试方法blockedTest()改动一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockedTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;    ······    a.start();    Thread.sleep(<span class="number">1000L</span>); <span class="comment">// 需要注意这里main线程休眠了1000毫秒，而testMethod()里休眠了2000毫秒    b.start();    System.out.println(a.getName() + &quot;:&quot; + a.getState()); // 输出？    System.out.println(b.getName() + &quot;:&quot; + b.getState()); // 输出？&#125;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，由于main线程休眠，所以线程a的run()方法跟着执行，线程b再接着执行。</p>
<p>在线程a执行run()调用testMethod()之后，线程a休眠了2000ms（注意这里是没有释放锁的），main线程休眠完毕，接着b线程执行的时候是争夺不到锁的，所以这里输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a:TIMED_WAITINGb:BLOCKED</span><br></pre></td></tr></table></figure>

<h3 id="WAITING状态与RUNNABLE状态的转换"><a href="#WAITING状态与RUNNABLE状态的转换" class="headerlink" title="WAITING状态与RUNNABLE状态的转换"></a><strong>WAITING状态与RUNNABLE状态的转换</strong></h3><p>根据转换图我们知道有3个方法可以使线程从RUNNABLE状态转为WAITING状态。我们主要介绍下**Object.wait()<strong>和</strong>Thread.join()**。 <strong>Object.wait()</strong></p>
<blockquote>
<p>调用wait()方法前线程必须持有对象的锁。</p>
<p>线程调用wait()方法时，会释放当前的锁，直到有其他线程调用notify()/notifyAll()方法唤醒等待锁的线程。</p>
<p>需要注意的是，其他线程调用notify()方法只会唤醒单个等待锁的线程，如有有多个线程都在等待这个锁的话不一定会唤醒到之前调用wait()方法的线程。</p>
<p>同样，调用notifyAll()方法唤醒所有等待锁的线程之后，也不一定会马上把时间片分给刚才放弃锁的那个线程，具体要看系统的调度。</p>
</blockquote>
<p><strong>Thread.join()</strong></p>
<blockquote>
<p>调用join()方法不会释放锁，会一直等待当前线程执行完毕（转换为TERMINATED状态）。</p>
</blockquote>
<p>我们再把上面的例子线程启动那里改变一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockedTest</span><span class="params">()</span> </span>&#123;    ······    a.start();    a.join();    b.start();    System.out.println(a.getName() + <span class="string">&quot;:&quot;</span> + a.getState()); <span class="comment">// 输出 TERMINATED    System.out.println(b.getName() + &quot;:&quot; + b.getState());&#125;</span></span><br></pre></td></tr></table></figure>

<p>要是没有调用join方法，main线程不管a线程是否执行完毕都会继续往下走。</p>
<p>a线程启动之后马上调用了join方法，这里main线程就会等到a线程执行完毕，所以这里a线程打印的状态固定是<strong>TERMIATED</strong>。</p>
<p>至于b线程的状态，有可能打印RUNNABLE（尚未进入同步方法），也有可能打印TIMED_WAITING（进入了同步方法）。</p>
<h3 id="TIMED-WAITING与RUNNABLE状态转换"><a href="#TIMED-WAITING与RUNNABLE状态转换" class="headerlink" title="TIMED_WAITING与RUNNABLE状态转换"></a><strong>TIMED_WAITING与RUNNABLE状态转换</strong></h3><p>TIMED_WAITING与WAITING状态类似，只是TIMED_WAITING状态等待的时间是指定的。</p>
<p><strong>Thread.sleep(long)</strong></p>
<blockquote>
<p>使当前线程睡眠指定时间。需要注意这里的“睡眠”只是暂时使线程停止执行，并不会释放锁。时间到后，线程会重新进入RUNNABLE状态。</p>
</blockquote>
<p><strong>Object.wait(long)</strong></p>
<blockquote>
<p>wait(long)方法使线程进入TIMED_WAITING状态。这里的wait(long)方法与无参方法wait()相同的地方是，都可以通过其他线程调用notify()或notifyAll()方法来唤醒。</p>
<p>不同的地方是，有参方法wait(long)就算其他线程不来唤醒它，经过指定时间long之后它会自动唤醒，拥有去争夺锁的资格。</p>
</blockquote>
<p><strong>Thread.join(long)</strong></p>
<blockquote>
<p>join(long)使当前线程执行指定时间，并且使线程进入TIMED_WAITING状态。</p>
<p>我们再来改一改刚才的示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blockedTest</span><span class="params">()</span> </span>&#123;······a.start();a.join(<span class="number">1000L</span>);b.start();System.out.println(a.getName() + <span class="string">&quot;:&quot;</span> + a.getState()); <span class="comment">// 输出 TIEMD_WAITINGSystem.out.println(b.getName() + &quot;:&quot; + b.getState());&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里调用a.join(1000L)，因为是指定了具体a线程执行的时间的，并且执行时间是小于a线程sleep的时间，所以a线程状态输出TIMED_WAITING。</p>
</blockquote>
<p>b线程状态仍然不固定（RUNNABLE或BLOCKED）。</p>
<h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a><strong>线程中断</strong></h2><blockquote>
<p>在某些情况下，我们在线程启动后发现并不需要它继续执行下去时，需要中断线程。目前在Java里还没有安全直接的方法来停止线程，但是Java提供了线程中断机制来处理需要中断线程的情况。</p>
<p>线程中断机制是一种协作机制。需要注意，通过中断操作并不能直接终止一个线程，而是通知需要被中断的线程自行处理。</p>
</blockquote>
<p>简单介绍下Thread类里提供的关于线程中断的几个方法：</p>
<ul>
<li>Thread.interrupt()：中断线程。这里的中断线程并不会立即停止线程，而是设置线程的中断状态为true（默认是flase）；</li>
<li>Thread.interrupted()：测试当前线程是否被中断。线程的中断状态受这个方法的影响，意思是调用一次使线程中断状态设置为true，连续调用两次会使得这个线程的中断状态重新转为false；</li>
<li>Thread.isInterrupted()：测试当前线程是否被中断。与上面方法不同的是调用这个方法并不会影响线程的中断状态。</li>
</ul>
<blockquote>
<p>在线程中断机制里，当其他线程通知需要被中断的线程后，线程中断的状态被设置为true，但是具体被要求中断的线程要怎么处理，完全由被中断线程自己而定，可以在合适的实际处理中断请求，也可以完全不处理继续执行下去。</p>
</blockquote>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>一般不推荐直接中断（interrupt）线程，而是让线程正常结束，如果发生了死锁（或者锁的时间特别长，需要打断），则<strong>使用interrupt()后，必须要在catch中处理</strong>，避免线程的数据不一致问题</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="为什么需要加锁"><a href="#为什么需要加锁" class="headerlink" title="为什么需要加锁"></a>为什么需要加锁</h2><p>多个线程对某个数据的操作，在大多数情况下都不是原子性的，例如多个线程同时进行i++；</p>
<p>第一个线程读取当前值为0，然后把0拿到自己的线程栈中进行操作，然后把操作后的数据放回原来的线程共享资源区</p>
<p>第二个线程在在第一个线程对数据++的时候，读取共享资源区的值，发现是0，然后把0拿到自己的线程栈中，进行++操作，然后写入线程共享资源区</p>
<p>这个时候，第一个线程i++后放回去为1，然后第二个线程又放回去也是1，就直接把原来的数据覆盖了，造成了多线程情况下的数据不一致</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>一般用于加类锁、对象锁、方法锁，看上面案例（创建线程的几种方式）</p>
<p>jvm没有规定synchronized具体应该怎么实现，这个说hospot虚拟机中的synchronized底层实现</p>
<ol>
<li>添加对象锁<ol>
<li>第一种方法是锁的<code>new Object()</code>对象</li>
<li>但是第一种方法比较麻烦，我们项目中通常使用<code>synchronized(this)</code></li>
</ol>
</li>
<li>添加方法锁<ol>
<li>在普通方法上上添加synchronized，相当于在本方法代码块中添加synchronized（this）</li>
<li>在类中的静态方法上加锁，没有this引用的存在，所以当锁一个静态方法的时候，相当于锁的事当前类的class对象</li>
</ol>
</li>
<li>添加类锁<ol>
<li>在static方法上添加synchronized，相当于在本方法代码块中添加synchronized（当前类.class）</li>
</ol>
</li>
<li>在线程的<code>run</code>方法上添加锁，相当于保证线程run方法的原子性，只有一个run方法的执行完毕后，另一个线程的run方法才能执行</li>
</ol>
<h3 id="使用主要事项（面试题）"><a href="#使用主要事项（面试题）" class="headerlink" title="使用主要事项（面试题）"></a>使用主要事项（面试题）</h3><ol>
<li><p>synchronized方法能与非synchronized同时运行吗</p>
<p>能，但是会<strong>带来一些问题</strong></p>
<p>如果在synchronized方法中调用非加锁方法，那么非加锁方法是不需要等待的，是一个异步执行，那么在这个方法中有可能会出现脏读，但是如果项目中对这个脏读数据不是特别看重，没有业务影响那么就不用管。如果有影响，那么这个非加锁方法需要加上synchronized，避免脏读，但是会减低效率。</p>
</li>
<li><p>synchronized是可冲入锁</p>
<p>一个synchronized方法可以调用另一个synchronized方法，如果是不可重入的，那么这个就发生死锁了。</p>
<p>一个synchronized方法可以调用另一个synchronized方法，第二个发现这是一个线程调用，那么就可重入，但是每加锁一次就要解锁一次。</p>
</li>
<li><p>同步方法和非同步方法是可以同时调用的</p>
</li>
<li><p>同步现异常，默认锁是会被释放的，会被其他线程运行**</p>
</li>
<li><p><strong>synchronized不能锁基本数据类型和String（不推荐）</strong></p>
</li>
</ol>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20191022154451548.png" alt="在这里插入图片描述"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20190323150237752.png" alt="img"></p>
<ol start="6">
<li><p>对业务写方法加锁，对业务读方法不加锁，容易产生脏读问题（读到了写过程中还没有完成的数据，或者回滚前的数据）</p>
<ol>
<li>这个要具体看业务逻辑，是不需要绝对避免脏读，如果需要则需要添加读锁</li>
</ol>
</li>
<li><p>出现异常情况下，默认情况下锁会被释放</p>
<ol>
<li><p>如果一个synchronized方法中出现异常，会立即释放这个线程的锁（这个线程后续就不会执行了），然后其他线程就可能进入同步代码块，并且有可能访问到异常产生的数据</p>
</li>
<li><p>所以多线程中一定要做好异常处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; start&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; count = &quot;</span> + count);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = <span class="number">1</span> / <span class="number">0</span>; <span class="comment">//此处抛出异常，锁将会被释放。要想锁不被释放，可以在这里进行catch，然后循环继续</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedException se = <span class="keyword">new</span> SynchronizedException();</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                se.m();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t1 start</span><br><span class="line">t1 count = <span class="number">1</span></span><br><span class="line">t1 count = <span class="number">2</span></span><br><span class="line">t1 count = <span class="number">3</span></span><br><span class="line">t1 count = <span class="number">4</span></span><br><span class="line">t1 count = <span class="number">5</span></span><br><span class="line"><span class="comment">// t1到这个地方就结束了，下面都是t2的执行</span></span><br><span class="line">t2 start</span><br><span class="line">t2 count = <span class="number">6</span></span><br><span class="line">Exception in thread <span class="string">&quot;t1&quot;</span> java.lang.ArithmeticException: / by zero</span><br><span class="line">	at top.thread1.SynchronizedException.m(SynchronizedException.java:<span class="number">19</span>)</span><br><span class="line">	at top.thread1.SynchronizedException$<span class="number">1.</span>run(SynchronizedException.java:<span class="number">31</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line">t2 count = <span class="number">7</span></span><br><span class="line">t2 count = <span class="number">8</span></span><br><span class="line">t2 count = <span class="number">9</span></span><br><span class="line">t2 count = <span class="number">10</span></span><br><span class="line">t2 count = <span class="number">11</span></span><br><span class="line">t2 count = <span class="number">12</span></span><br><span class="line">t2 count = <span class="number">13</span></span><br><span class="line">t2 count = <span class="number">14</span></span><br><span class="line">t2 count = <span class="number">15</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p><strong>volatile其实并不能称之为锁</strong></p>
<p>volatile的作用主要是：</p>
<ol>
<li>保证线程可见性（intel中的mesi，缓存一致性协议）</li>
<li>禁止指令重排（内存屏障）</li>
</ol>
<p>注意：</p>
<p>只能保证线程的可见性（一个线程对共享变量的修改，另一个线程可以感知到），不能保证线程操作中的原子性（<strong>一个或者多个操作在 CPU 执行的过程中不被中断</strong>）</p>
<p>例如用volatile修饰一个变量i，执行i++操作，可见性是保证i被修改后立即通知其他线程，从主存中读取。但是i++的操作是不是原子性的</p>
<p>i++的过程分为三步：</p>
<ol>
<li>从主存中读取i的值</li>
<li>对值进行计算</li>
<li>把最新的值写入内存</li>
</ol>
<p>如果有多个线程同时读取了i的值都是0，这个时候都没有修改，所以都进行计算操作，这个时候就不是一个线程安全的操作，可能这一步后三个线程执行了i++，但是最后的结果都是1；</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**volatile关键字，使一个变量在多个线程中可见；但是volatile并不能保证多个线程共同修改running变量时所带来不一致的问题，即volatile不能完全代替synchronized</span></span><br><span class="line"><span class="comment"> * A、B线程都用到一个变量，java默认是A线程中保留一份copy，这样如果线程B修改了该变量，则线程A未必知道。</span></span><br><span class="line"><span class="comment"> * 使用volatile关键字，会强制让所有的线程都去读变量的修改后的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileVisible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;  <span class="comment">//对比一下有无volatile的情况下，整个程序运行结果的区别</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m start&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(running) &#123;  <span class="comment">//死循环。只有running=false时，才能执行后面的语句</span></span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;m end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VolatileVisible vt = <span class="keyword">new</span> VolatileVisible();</span><br><span class="line">        <span class="keyword">new</span> Thread(vt::m,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        vt.running = <span class="keyword">false</span>;  <span class="comment">//若running不被volatile关键字修饰时，线程“看不见”running被修改了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20190323211236996.png" alt="img"></p>
<h3 id="volatile不具备原子性"><a href="#volatile不具备原子性" class="headerlink" title="volatile不具备原子性"></a>volatile不具备原子性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*10个线程分别执行10000次count++，count是对象vna的成员变量，按理来说最终count=100000，</span></span><br><span class="line"><span class="comment">  但是最终每次执行结果都不一样，count一直小于100000，说明volatile不具备原子性*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileNoAtomic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            count ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;    count:&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VolatileNoAtomic vna = <span class="keyword">new</span> VolatileNoAtomic();</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(vna::m, <span class="string">&quot;thread&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        threads.forEach(o-&gt;o.start());</span><br><span class="line">        threads.forEach((o)-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//join()方法阻塞调用此方法的线程,直到线程t完成，此线程再继续。通常用于在main()主线程内，等待其它线程完成再结束main()主线程。</span></span><br><span class="line">                o.join(); <span class="comment">//相当于在main线程中同步o线程，o执行完了，main线程才有执行的机会</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(vna.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread0    count:<span class="number">16643</span></span><br><span class="line">thread2    count:<span class="number">18129</span></span><br><span class="line">thread1    count:<span class="number">17557</span></span><br><span class="line">thread4    count:<span class="number">19623</span></span><br><span class="line">thread7    count:<span class="number">26401</span></span><br><span class="line">thread6    count:<span class="number">28233</span></span><br><span class="line">thread3    count:<span class="number">32328</span></span><br><span class="line">thread5    count:<span class="number">44810</span></span><br><span class="line">thread8    count:<span class="number">46183</span></span><br><span class="line">thread9    count:<span class="number">45814</span></span><br><span class="line"><span class="number">46183</span></span><br></pre></td></tr></table></figure>



<p>推荐文章：</p>
<p>可见性、有序性和原子性：<a href="https://zhuanlan.zhihu.com/p/296301631">https://zhuanlan.zhihu.com/p/296301631</a></p>
<p><a href="https://blog.csdn.net/qq_32222165/article/details/106571793">https://blog.csdn.net/qq_32222165/article/details/106571793</a></p>
<h3 id="synchronized保证的可见性和原子性"><a href="#synchronized保证的可见性和原子性" class="headerlink" title="synchronized保证的可见性和原子性"></a>synchronized保证的可见性和原子性</h3><p>参考上面案例，在m方法加上<code>synchronized</code>方法，去掉原来的volatile</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread0    count:<span class="number">10000</span></span><br><span class="line">thread7    count:<span class="number">20000</span></span><br><span class="line">thread6    count:<span class="number">30000</span></span><br><span class="line">thread5    count:<span class="number">40000</span></span><br><span class="line">thread4    count:<span class="number">50000</span></span><br><span class="line">thread3    count:<span class="number">60000</span></span><br><span class="line">thread1    count:<span class="number">70000</span></span><br><span class="line">thread2    count:<span class="number">80000</span></span><br><span class="line">thread9    count:<span class="number">90000</span></span><br><span class="line">thread8    count:<span class="number">100000</span></span><br><span class="line"><span class="number">100000</span></span><br></pre></td></tr></table></figure>



<h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>在Java中通常实现锁有<strong>两种方式，一种是synchronized关键字，另一种是Lock</strong>。(synchronized在jdk1.5之后做了优化，性能提升了很多，只是<strong>使用ReentrantLock更灵活</strong>一些)。</p>
<p>synchronized本身就是一个可重入锁</p>
<table>
<thead>
<tr>
<th>tips</th>
<th>synchronized（关键字）</th>
<th>Lock（接口）</th>
</tr>
</thead>
<tbody><tr>
<td>实现</td>
<td>基于JVM层面实现（JVM控制锁的获取和释放）</td>
<td>基于JDK层面实现（我们可以借助JDK源码理解）</td>
</tr>
<tr>
<td>使用</td>
<td>不用我们手动释放锁</td>
<td>需要手动上锁和释放锁（finally中unlock）</td>
</tr>
<tr>
<td>锁获取超时</td>
<td>不支持。拿不到锁就一直在那等着，等到“死”。</td>
<td>支持。可以设置超时时间，时间过了没拿到就放弃，即Lock可以知道线程有没有拿到锁。</td>
</tr>
<tr>
<td>获取锁响应中断</td>
<td>不支持。</td>
<td>支持。可以设置是否可以被打断。</td>
</tr>
<tr>
<td>释放锁的条件</td>
<td>满足一个即可：①占有锁的线程执行完毕②占有锁的线程异常退出③占有锁的线程进入waiting状态释放锁</td>
<td>调用unlock()方法，或者时间到期</td>
</tr>
<tr>
<td>公平与否</td>
<td>非公平锁。（公平指的是哪个线程等的时间长就把锁交给谁）</td>
<td>默认为非公平锁，可以设置为公平锁（排队等候）。</td>
</tr>
</tbody></table>
<h4 id="lockInteruptibly"><a href="#lockInteruptibly" class="headerlink" title="lockInteruptibly"></a>lockInteruptibly</h4><p>ReentrantLock的中断和非中断加锁模式的区别在于：</p>
<p>：线程尝试获取锁操作失败后，在等待过程中，如果该线程被其他线程中断了，它是如何响应中断请求的。lock方法会忽略中断请求，继续获取锁直到成功；而lockInterruptibly则直接抛出中断异常来立即响应中断，由上层调用者处理中断。</p>
<p>lock()适用于锁获取操作不受中断影响的情况，此时可以忽略中断请求正常执行加锁操作，因为该操作仅仅记录了中断状态（通过Thread.currentThread().interrupt()操作，只是恢复了中断状态为true，并没有对中断进行响应)。</p>
<p>如果要求被中断线程不能参与锁的竞争操作，则此时应该使用lockInterruptibly方法，一旦检测到中断请求，立即返回不再参与锁的竞争并且取消锁获取操作（即finally中的cancelAcquire操作）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ReentrantLock可调用lockInterruptibly()方法，对线程的interrupt()方法作出响应，在一个线程等待的过程中，可以被打断。</span></span><br><span class="line"><span class="comment"> * ReentrantLock的lock()方法是不能被打断的，即锁用lock()方法锁定，线程调用interrupt()方法是毫无作用的</span></span><br><span class="line"><span class="comment"> * lock方法仅仅是加锁过程中不可中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockInterruptibly</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;  t1 start...  &quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);  <span class="comment">//t1不停的运行，睡死了</span></span><br><span class="line">                System.out.print(<span class="string">&quot;  t1 end...  &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; t1-interrupted! &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lockInterruptibly();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// lock.lock(); //不能对interrupt()方法作出响应</span></span><br><span class="line">                    System.out.print(<span class="string">&quot;  t2 start...  &quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                    System.out.print(<span class="string">&quot;  t2 end...   &quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;  t2-interrupted!  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t1.interrupt();  <span class="comment">//打断t1的等待</span></span><br><span class="line">        t2.interrupt();  <span class="comment">//打断t2的等待</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReentrantLock可以指定为公平锁"><a href="#ReentrantLock可以指定为公平锁" class="headerlink" title="ReentrantLock可以指定为公平锁"></a>ReentrantLock可以指定为公平锁</h4><p>参数为true的时候表示为公平锁</p>
<p><code>ReentrantLock lock = new ReentrantLock(true);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*ReentrantLock可以指定为公平锁，构造方法中将fair属性设置为true即为公平锁，fair默认为false*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockFair</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>); <span class="comment">//参数为true表示为公平锁，可对比输出结果</span></span><br><span class="line">    AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.print(Thread.currentThread().getName() + <span class="string">&quot;-获得锁;   &quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (count.addAndGet(<span class="number">1</span>) == <span class="number">4</span>) &#123;</span><br><span class="line">                    count.set(<span class="number">0</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;\r&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLockFair r1 = <span class="keyword">new</span> ReentrantLockFair();</span><br><span class="line">        <span class="comment">// 这里我选择使用四个线程，因为我的处理器为4核，这样能够基本上保证一核处理一个线程，就是为了演示出公平和非公平</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(r1).start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 线程顺序启动</span></span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line">Thread-<span class="number">1</span>-获得锁;   Thread-<span class="number">1</span>-获得锁;   Thread-<span class="number">1</span>-获得锁;   Thread-<span class="number">1</span>-获得锁;   </span><br><span class="line">Thread-<span class="number">1</span>-获得锁;   Thread-<span class="number">2</span>-获得锁;   Thread-<span class="number">2</span>-获得锁;   Thread-<span class="number">2</span>-获得锁;   </span><br><span class="line">Thread-<span class="number">2</span>-获得锁;   Thread-<span class="number">2</span>-获得锁;   Thread-<span class="number">3</span>-获得锁;   Thread-<span class="number">3</span>-获得锁;   </span><br><span class="line">Thread-<span class="number">4</span>-获得锁;   Thread-<span class="number">3</span>-获得锁;   Thread-<span class="number">4</span>-获得锁;   Thread-<span class="number">4</span>-获得锁;   </span><br><span class="line">Thread-<span class="number">3</span>-获得锁;   Thread-<span class="number">4</span>-获得锁;   Thread-<span class="number">4</span>-获得锁;   Thread-<span class="number">3</span>-获得锁;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line">Thread-<span class="number">1</span>-获得锁;   Thread-<span class="number">2</span>-获得锁;   Thread-<span class="number">3</span>-获得锁;   Thread-<span class="number">4</span>-获得锁;   </span><br><span class="line">Thread-<span class="number">1</span>-获得锁;   Thread-<span class="number">2</span>-获得锁;   Thread-<span class="number">3</span>-获得锁;   Thread-<span class="number">4</span>-获得锁;   </span><br><span class="line">Thread-<span class="number">1</span>-获得锁;   Thread-<span class="number">2</span>-获得锁;   Thread-<span class="number">3</span>-获得锁;   Thread-<span class="number">4</span>-获得锁;   </span><br><span class="line">Thread-<span class="number">1</span>-获得锁;   Thread-<span class="number">2</span>-获得锁;   Thread-<span class="number">3</span>-获得锁;   Thread-<span class="number">4</span>-获得锁;   </span><br><span class="line">Thread-<span class="number">1</span>-获得锁;   Thread-<span class="number">2</span>-获得锁;   Thread-<span class="number">3</span>-获得锁;   Thread-<span class="number">4</span>-获得锁;  </span><br></pre></td></tr></table></figure>


<h1 id="原子性操作"><a href="#原子性操作" class="headerlink" title="原子性操作"></a>原子性操作</h1><p>原子变量类 (Atomics)是基于CAS实现的能够保障对共享变量进行read-modify-write更新操作的原子性和可见性的一组工具类。所谓的read-modify-write更新操作，是指对共享变量的更新不是一个简单的赋值操作，而是变量的新值依赖于变量的旧值，例如自增操作 “count++”。由于volatile无法保障自增操作的原子性，而原子变量类的内部实现通常借助一个volatile变量并保障对该变量的read-modify-write更新操作的原子性，因此它可以被看作增强型的volatile变量。原子变量类一共有12个，可以被分为4组：<br><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20190217225840420.png" alt="img"></p>
<h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>主要为因为在多线程下，i++不是一个原子性的操作，所以java提供了一个AtomicInteger</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li><p>Compare And Set（比较并交换）</p>
</li>
<li><p>cas（value,expected,newValue）</p>
<ul>
<li>cpu指令级别的执行（原子性）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(value == expected)&#123;</span><br><span class="line">	value = newValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ABA问题</p>
<p>如果知识一个值是没有影响的，但是如果是一个对象，可能会造成影响，这个值（地址）指向的是一个对象，这个对象没有发生改变，但是对象里面的引用发生了改变 ，这个时候如果恰好有对应的逻辑操作，就会出现问题</p>
</li>
</ul>
<h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><p>可以直接操作虚拟机中的内存 ，所有的Atomic的类底层都是通过unsafe来完成的。</p>
<p>但是Unsafe在jdk1.9的时候已经关闭了，不能运行Unsafe</p>
<p><a href="https://blog.csdn.net/zyzzxycj/article/details/89877863">https://blog.csdn.net/zyzzxycj/article/details/89877863</a></p>
<h1 id="LongAdder和Sync和Atomic"><a href="#LongAdder和Sync和Atomic" class="headerlink" title="LongAdder和Sync和Atomic"></a>LongAdder和Sync和Atomic</h1><p>LongAdder内部使用了分段锁，将单一的CAS操作分散为对数组Cells中多个元祖的CAS</p>
<p>在高并发（千、万级并发以上）LongAdder的效率大于Atomi大于Sync</p>
<p><a href="https://www.jianshu.com/p/ec045c38ef0c">https://www.jianshu.com/p/ec045c38ef0c</a></p>
<h1 id="juc"><a href="#juc" class="headerlink" title="juc"></a>juc</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCyclicBarrier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在写入数据...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);      <span class="comment">//以睡眠来模拟写入数据操作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;写入数据完毕，等待其他线程写入完毕&quot;</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;所有线程写入完毕，继续处理其他任务...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">线程Thread-<span class="number">1</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">0</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">2</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">3</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">2</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">0</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">1</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">3</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="额外操作"><a href="#额外操作" class="headerlink" title="额外操作"></a>额外操作</h3><p>线程都到达barrier状态后，会从四个线程中选择一个线程去执行Runnable方法，其他线程如果没有后续则死亡。</p>
<p>只需要在创建CyclicBarrier的时候，提供一个后续运行的run的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(n, () -&gt; System.out.println(<span class="string">&quot;当前线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;统一执行方法&quot;</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">线程Thread-<span class="number">1</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">2</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">0</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">3</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">0</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">2</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">3</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-<span class="number">1</span>写入数据完毕，等待其他线程写入完毕</span><br><span class="line">    <span class="comment">// 只有一个线程会执行这个方法，其他线程因为程序运行完毕而死亡</span></span><br><span class="line">当前线程Thread-<span class="number">1</span>统一执行方法</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br></pre></td></tr></table></figure>

<h3 id="等待指定的时间"><a href="#等待指定的时间" class="headerlink" title="等待指定的时间"></a>等待指定的时间</h3><p> 在4个线程中故意让最后一个线程启动延迟，在前面三个线程都到达了barrier之后，等待了指定的时间发现第四个线程还没有达到barrier，就抛出异常并继续执行后面的任务，不在等待第四个线程，但是第四个线程在时间到了后还是会继续执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCyclicBarrierAwaitTime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger stock = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; N - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在写入数据...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);      <span class="comment">//以睡眠来模拟写入数据操作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;库存销售数量：&quot;</span> + stock.getAndAdd(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await(<span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;    线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;等待超时&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;所有线程写入完毕，继续处理其他任务...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">线程Thread-<span class="number">0</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">2</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">1</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">0</span>库存销售数量：<span class="number">1</span></span><br><span class="line">线程Thread-<span class="number">2</span>库存销售数量：<span class="number">2</span></span><br><span class="line">线程Thread-<span class="number">1</span>库存销售数量：<span class="number">0</span></span><br><span class="line">线程Thread-<span class="number">3</span>正在写入数据...</span><br><span class="line">    线程Thread-<span class="number">1</span>等待超时</span><br><span class="line">    线程Thread-<span class="number">2</span>等待超时</span><br><span class="line">Thread-<span class="number">2</span>所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-<span class="number">1</span>所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-<span class="number">0</span>所有线程写入完毕，继续处理其他任务...</span><br><span class="line">java.util.concurrent.TimeoutException</span><br><span class="line">	at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">257</span>)</span><br><span class="line">	at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">435</span>)</span><br><span class="line">	at top.thread1.mycyclibarrier.MyCyclicBarrierAwaitTime$Writer.run(MyCyclicBarrierAwaitTime.java:<span class="number">51</span>)</span><br><span class="line">线程Thread-<span class="number">3</span>库存销售数量：<span class="number">3</span></span><br><span class="line">    线程Thread-<span class="number">3</span>等待超时</span><br><span class="line">Thread-<span class="number">3</span>所有线程写入完毕，继续处理其他任务...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CyclicBarrier重用"><a href="#CyclicBarrier重用" class="headerlink" title="CyclicBarrier重用"></a>CyclicBarrier重用</h3><p>初次的4个线程越过barrier状态后，又可以用来进行新一轮的使用。而CountDownLatch无法进行重复使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCyclicBarrierAwaitTime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger stock = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; N - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在写入数据...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);      <span class="comment">//以睡眠来模拟写入数据操作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;库存销售数量：&quot;</span> + stock.getAndAdd(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await(<span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;    线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;等待超时&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;所有线程写入完毕，继续处理其他任务...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">3</span>所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-<span class="number">2</span>所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-<span class="number">1</span>所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-<span class="number">0</span>所有线程写入完毕，继续处理其他任务...</span><br><span class="line">CyclicBarrier重用</span><br><span class="line">线程Thread-<span class="number">4</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">5</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">6</span>正在写入数据...</span><br><span class="line">线程Thread-<span class="number">7</span>正在写入数据...</span><br></pre></td></tr></table></figure>



<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>被称为信号量，或者许可证</p>
<p>可以<strong>控制同时访问的线程数</strong>，通过acquire()获取一个<code>许可</code>，如果没有就等待，而release释放一个许可，只有拿到许可证的线程才能接着向下执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySemaphore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">8</span>;            <span class="comment">//工人数</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>); <span class="comment">//机器数目</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Worker(i, semaphore).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> num, Semaphore semaphore)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(<span class="string">&quot;工人&quot;</span> + <span class="keyword">this</span>.num + <span class="string">&quot;占用一个机器在生产...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;工人&quot;</span> + <span class="keyword">this</span>.num + <span class="string">&quot;释放出机器&quot;</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">工人<span class="number">1</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">0</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">3</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">2</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">5</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">0</span>释放出机器</span><br><span class="line">工人<span class="number">2</span>释放出机器</span><br><span class="line">工人<span class="number">3</span>释放出机器</span><br><span class="line">工人<span class="number">1</span>释放出机器</span><br><span class="line">工人<span class="number">7</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">5</span>释放出机器</span><br><span class="line">工人<span class="number">4</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">6</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">4</span>释放出机器</span><br><span class="line">工人<span class="number">7</span>释放出机器</span><br><span class="line">工人<span class="number">6</span>释放出机器</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h2><p>具有设置多重屏障的功能，相当于CountDownLatch和CyclicBarrier的结合体。</p>
<p>例如：</p>
<p>我们需要控制线程的启动时机，让线程同时启动，我们通常使用CountDownLatch实现，可以用Phasert代替；</p>
<p>我们系统某些任务在某一个阶段同时执行，然后在所有任务执行完成后，同时进入下一个阶段继续执行，可以使用CyclicBarrier和reset实现，但是也可以使用Phaser代替；</p>
<h3 id="Phaser（）"><a href="#Phaser（）" class="headerlink" title="Phaser（）"></a>Phaser（）</h3><p>无参构造方法，创建一个Phaser对象。默认parties个数为0。后续可以通过register()/bulkRegister()方法来修改新的parties。在每个Phaser实例内部，会持有几个状态数据：终止状态、已经注册的parties个数、当前phase下已到达的parties个数、当前phaser阶段数。</p>
<h3 id="Phaser（int-parties）"><a href="#Phaser（int-parties）" class="headerlink" title="Phaser（int parties）"></a>Phaser（int parties）</h3><p>有参构造方法，一个Phaser对象，并初始一定数量的parties，相当于在初始化Phaser实例后，在register此数量的parties。</p>
<h3 id="arrive（）"><a href="#arrive（）" class="headerlink" title="arrive（）"></a>arrive（）</h3><p>一直阻塞，等待当前phase下其他parties到达。parties必须大于0，如果使用Phaser（）创建实例，parties没有被register具体的值，调用此方法将会抛出异常。此方法同时返回当前phase周期数，如果Phaser实例已经终止，则返回负数。</p>
<h3 id="awaitAdvance-int-phase"><a href="#awaitAdvance-int-phase" class="headerlink" title="awaitAdvance(int phase)"></a>awaitAdvance(int phase)</h3><p>阻塞方法，等待phase周期数下其他所有的prties都到达，参数指定了当前阻塞的phase周期阶段数。如果指定的phase与phaser实例当前的phase不一致，会立即返回。可以这样来使用awaitAdvance（arrive()）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPhaser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">static</span> MarriagePhase phaser =  <span class="keyword">new</span> MarriagePhase();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        phaser.bulkRegister(<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Person(<span class="string">&quot;P&quot;</span>+i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Person(<span class="string">&quot;新娘&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Person(<span class="string">&quot;新郎&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MarriagePhase</span> <span class="keyword">extends</span> <span class="title">Phaser</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (phase)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;所有人都到齐了&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;所有人都吃完了&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;所有人都离开了&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;婚礼结束了&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// phrase中的阶段控制主要是这里面的阶段控制</span></span><br><span class="line">            arrive();</span><br><span class="line">            eat();</span><br><span class="line">            leave();</span><br><span class="line">            hug();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arrive</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">                System.out.println(name+<span class="string">&quot;到达现场&quot;</span>);</span><br><span class="line">                <span class="comment">// 阶段控制实际上是这个产生效果，arriveAndAwaitAdvance说明到达了</span></span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">                System.out.println(name+<span class="string">&quot;吃完&quot;</span>);</span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leave</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">                System.out.println(name+<span class="string">&quot;离开&quot;</span>);</span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hug</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;新郎&quot;</span>.equals(name) || <span class="string">&quot;新娘&quot;</span>.equals(name))&#123;</span><br><span class="line">                    Thread.sleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">                    System.out.println(name+<span class="string">&quot;拥抱&quot;</span>);</span><br><span class="line">                    phaser.arriveAndAwaitAdvance();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    phaser.arriveAndDeregister();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">P0到达现场</span><br><span class="line">新郎到达现场</span><br><span class="line">P1到达现场</span><br><span class="line">P2到达现场</span><br><span class="line">新娘到达现场</span><br><span class="line">P3到达现场</span><br><span class="line">P4到达现场</span><br><span class="line">所有人都到齐了</span><br><span class="line">P1吃完</span><br><span class="line">P0吃完</span><br><span class="line">新娘吃完</span><br><span class="line">P3吃完</span><br><span class="line">新郎吃完</span><br><span class="line">P2吃完</span><br><span class="line">P4吃完</span><br><span class="line">所有人都吃完了</span><br><span class="line">P4离开</span><br><span class="line">P3离开</span><br><span class="line">P2离开</span><br><span class="line">新娘离开</span><br><span class="line">P1离开</span><br><span class="line">P0离开</span><br><span class="line">新郎离开</span><br><span class="line">所有人都离开了</span><br><span class="line">新郎拥抱</span><br><span class="line">新娘拥抱</span><br><span class="line">婚礼结束了</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>phrase源码分析文章推荐：<a href="https://segmentfault.com/a/1190000019685090?utm_source=tag-newest">https://segmentfault.com/a/1190000019685090?utm_source=tag-newest</a></p>
<h2 id="exchanger"><a href="#exchanger" class="headerlink" title="exchanger"></a>exchanger</h2><h1 id="常用的并发工具类"><a href="#常用的并发工具类" class="headerlink" title="常用的并发工具类"></a>常用的并发工具类</h1><p>闭锁：CountDownLatch</p>
<p>​        闭锁允许一个线程或多个线程等待特定的情况，同步完成线程中其他任务</p>
<p>回环栅栏：CyclicBarrier</p>
<p>​        CycliBarrier和CountDownLatch都可以协同多个线程，让指定数量的线程等待其他所有的线程都满足某个条件之后继续执行。CyclicBarrier可以重复使用（reset），而CountDownLatch只能使用一次，如果还需要使用，必须重新new一个CountDownLatch对象。构造方法CyclicBarrier（int，Runnable）所有线程达到屏障后，执行Runnable。</p>
<p>信号量：Semaphore</p>
<p>​        信号量用来访问同时访问特定资源的线程数量。</p>
<p>交换者：Exchanger</p>
<p>​        Exchanger交换者用于在两个线程之间传输数据，被调用后等待另一个线程到达交换点，然后相互交换数据。</p>
<h1 id="实现线程通信"><a href="#实现线程通信" class="headerlink" title="实现线程通信"></a>实现线程通信</h1><p>实现一个容器，提供两个方法add、size，线程1添加10个元素到容器，线程2监控元素的个数，当个数为5个时，线程2提供并结束。</p>
<h2 id="方案1使用volatile"><a href="#方案1使用volatile" class="headerlink" title="方案1使用volatile"></a>方案1使用volatile</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainerVolatile</span> </span>&#123;</span><br><span class="line">     ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyContainerVolatile myContainerVolatile = <span class="keyword">new</span> MyContainerVolatile();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                myContainerVolatile.add(<span class="keyword">new</span> Object());</span><br><span class="line">                System.out.println(<span class="string">&quot;add-&quot;</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (myContainerVolatile.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210909101839474.png" alt="image-20210909101839474"></p>
<p>如果没有添加volatile，那么第二个线程会一直等待，因为第二个线程一直在进行计算，它不会去住内存中再次读取数据（除非cpu有空闲）</p>
<p>所以需要添加一个volatile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volatile ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add-<span class="number">0</span></span><br><span class="line">add-<span class="number">1</span></span><br><span class="line">add-<span class="number">2</span></span><br><span class="line">add-<span class="number">3</span></span><br><span class="line">add-<span class="number">4</span></span><br><span class="line">t2结束</span><br><span class="line">add-<span class="number">5</span></span><br><span class="line">add-<span class="number">6</span></span><br><span class="line">add-<span class="number">7</span></span><br><span class="line">add-<span class="number">8</span></span><br><span class="line">add-<span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>优势：保证的线程的通讯</p>
<p>劣势：线程2的cpu在一直空转，浪费性能。</p>
<h2 id="方案2使用wait和notify"><a href="#方案2使用wait和notify" class="headerlink" title="方案2使用wait和notify"></a>方案2使用wait和notify</h2><blockquote>
<p>当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。</p>
<p>当 notify/notifyAll() 被执行时，会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完synchronized 代码块的代码或是中途遇到wait() ，再次释放锁。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*wait会释放锁，notify则不会。t1中notify唤醒t2，本线程不会释放锁，会一直执行下去直至被wait或synchronized代码块结束*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainerVolatile2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyContainerVolatile myContainerVolatile = <span class="keyword">new</span> MyContainerVolatile();</span><br><span class="line">        <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot; ***线程t2启动*** &quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (myContainerVolatile.size() != <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot; ***线程t2阻塞了*** &quot;</span>);</span><br><span class="line">                        lock.wait();</span><br><span class="line">                        System.out.println(<span class="string">&quot; ***线程t2继续往下运行了*** &quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot; ***线程t2唤醒了t1*** &quot;</span>);</span><br><span class="line">                lock.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot; ***线程t2结束了*** &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; ***线程t1启动*** &quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    myContainerVolatile.add(<span class="keyword">new</span> Object());</span><br><span class="line">                    System.out.println(<span class="string">&quot;add-&quot;</span> + i);</span><br><span class="line">                    <span class="keyword">if</span> (myContainerVolatile.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> ***线程t2启动*** </span><br><span class="line"> ***线程t2阻塞了*** </span><br><span class="line"> ***线程t1启动*** </span><br><span class="line">add-<span class="number">0</span></span><br><span class="line">add-<span class="number">1</span></span><br><span class="line">add-<span class="number">2</span></span><br><span class="line">add-<span class="number">3</span></span><br><span class="line">add-<span class="number">4</span></span><br><span class="line"> ***线程t2继续往下运行了*** </span><br><span class="line"> ***线程t2唤醒了t1*** </span><br><span class="line"> ***线程t2结束了*** </span><br><span class="line">add-<span class="number">5</span></span><br><span class="line">add-<span class="number">6</span></span><br><span class="line">add-<span class="number">7</span></span><br><span class="line">add-<span class="number">8</span></span><br><span class="line">add-<span class="number">9</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="方案3使用CountDownLatch的await和countdown方法"><a href="#方案3使用CountDownLatch的await和countdown方法" class="headerlink" title="方案3使用CountDownLatch的await和countdown方法"></a>方案3使用CountDownLatch的<code>await</code>和<code>countdown</code>方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainerVolatile3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyContainerVolatile3 myContainerVolatile = <span class="keyword">new</span> MyContainerVolatile3();</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; ***线程t2启动*** &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (myContainerVolatile.size() != <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot; ***线程t2阻塞了*** &quot;</span>);</span><br><span class="line">                    latch.await();</span><br><span class="line">                    System.out.println(<span class="string">&quot; ***线程t2继续往下运行了*** &quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot; ***线程t2唤醒了t1*** &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; ***线程t2结束了*** &quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; ***线程t1启动*** &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                myContainerVolatile.add(<span class="keyword">new</span> Object());</span><br><span class="line">                System.out.println(<span class="string">&quot;add-&quot;</span> + i);</span><br><span class="line">                <span class="keyword">if</span> (myContainerVolatile.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> ***线程t2启动*** </span><br><span class="line"> ***线程t2阻塞了*** </span><br><span class="line"> ***线程t1启动*** </span><br><span class="line">add-<span class="number">0</span></span><br><span class="line">add-<span class="number">1</span></span><br><span class="line">add-<span class="number">2</span></span><br><span class="line">add-<span class="number">3</span></span><br><span class="line">add-<span class="number">4</span></span><br><span class="line"> ***线程t2继续往下运行了*** </span><br><span class="line"> ***线程t2唤醒了t1*** </span><br><span class="line"> ***线程t2结束了*** </span><br><span class="line">add-<span class="number">5</span></span><br><span class="line">add-<span class="number">6</span></span><br><span class="line">add-<span class="number">7</span></span><br><span class="line">add-<span class="number">8</span></span><br><span class="line">add-<span class="number">9</span></span><br></pre></td></tr></table></figure>

<h1 id="实现线程安全队列"><a href="#实现线程安全队列" class="headerlink" title="实现线程安全队列"></a>实现线程安全队列</h1><h2 id="方案1wait和notify实现"><a href="#方案1wait和notify实现" class="headerlink" title="方案1wait和notify实现"></a>方案1wait和notify实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*写一个固定容量的同步容器，拥有put和get方法，以及getCount方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用。</span></span><br><span class="line"><span class="comment"> * wait和notifyAll方法来实习。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerCustomerWaitNotifyAll</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> LinkedList&lt;Object&gt; list = <span class="keyword">new</span> LinkedList&lt;Object&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> MAX = <span class="number">10</span>; <span class="comment">//最多十个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (list.size() == MAX) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;被阻塞了，队列满了&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(t);</span><br><span class="line">        System.out.println(<span class="string">&quot;生产者：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;生产了了一个,当前队列中还剩余&quot;</span> + list.size() + <span class="string">&quot;    唤醒了消费线程&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll(); <span class="comment">//通知消费者进程进行消费</span></span><br><span class="line">        <span class="comment">//notify只叫醒一个，叫醒的可能还是生产者，所有线程一直wait，程序就卡死了，所以用notifyAll</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (list.size() == <span class="number">0</span>) &#123;  <span class="comment">//</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;      消费者：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;被阻塞了，队列空了&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t = list.removeFirst();</span><br><span class="line">        System.out.println(<span class="string">&quot;      消费者：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;消费了一个,当前队列中还剩余&quot;</span> + list.size() + <span class="string">&quot;     唤醒了生产线程&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();  <span class="comment">//通知生产者进程进行生产</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerCustomerWaitNotifyAll pc = <span class="keyword">new</span> ProducerCustomerWaitNotifyAll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  <span class="comment">//10个消费者</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;  <span class="comment">//每个消费者最多消费5个</span></span><br><span class="line">                    pc.get();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;c&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//启动生产者线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123; <span class="comment">//2个生产者</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">25</span>; j++) &#123;  <span class="comment">//每个生产者最多生产25个</span></span><br><span class="line">                    pc.put(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;p&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      消费者：c0被阻塞了，队列空了</span><br><span class="line">      消费者：c3被阻塞了，队列空了</span><br><span class="line">      消费者：c5被阻塞了，队列空了</span><br><span class="line">      消费者：c4被阻塞了，队列空了</span><br><span class="line">      消费者：c2被阻塞了，队列空了</span><br><span class="line">      消费者：c1被阻塞了，队列空了</span><br><span class="line">      消费者：c8被阻塞了，队列空了</span><br><span class="line">      消费者：c7被阻塞了，队列空了</span><br><span class="line">      消费者：c6被阻塞了，队列空了</span><br><span class="line">      消费者：c9被阻塞了，队列空了</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">1</span>    唤醒了消费线程</span><br><span class="line">      消费者：c9消费了一个,当前队列中还剩余<span class="number">0</span>     唤醒了生产线程</span><br><span class="line">      消费者：c9被阻塞了，队列空了</span><br><span class="line">      消费者：c6被阻塞了，队列空了</span><br><span class="line">      消费者：c7被阻塞了，队列空了</span><br><span class="line">      消费者：c8被阻塞了，队列空了</span><br><span class="line">      消费者：c1被阻塞了，队列空了</span><br><span class="line">      消费者：c2被阻塞了，队列空了</span><br><span class="line">      消费者：c4被阻塞了，队列空了</span><br><span class="line">      消费者：c5被阻塞了，队列空了</span><br><span class="line">      消费者：c3被阻塞了，队列空了</span><br><span class="line">      消费者：c0被阻塞了，队列空了</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">1</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">2</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">3</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">4</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">5</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">6</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">7</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">8</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">9</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">10</span>    唤醒了消费线程</span><br><span class="line">生产者：p1被阻塞了，队列满了</span><br><span class="line">      消费者：c0消费了一个,当前队列中还剩余<span class="number">9</span>     唤醒了生产线程</span><br><span class="line">      消费者：c0消费了一个,当前队列中还剩余<span class="number">8</span>     唤醒了生产线程</span><br><span class="line">      消费者：c0消费了一个,当前队列中还剩余<span class="number">7</span>     唤醒了生产线程</span><br><span class="line">      消费者：c0消费了一个,当前队列中还剩余<span class="number">6</span>     唤醒了生产线程</span><br><span class="line">      消费者：c0消费了一个,当前队列中还剩余<span class="number">5</span>     唤醒了生产线程</span><br><span class="line">      消费者：c3消费了一个,当前队列中还剩余<span class="number">4</span>     唤醒了生产线程</span><br><span class="line">      消费者：c3消费了一个,当前队列中还剩余<span class="number">3</span>     唤醒了生产线程</span><br><span class="line">      消费者：c3消费了一个,当前队列中还剩余<span class="number">2</span>     唤醒了生产线程</span><br><span class="line">      消费者：c3消费了一个,当前队列中还剩余<span class="number">1</span>     唤醒了生产线程</span><br><span class="line">      消费者：c3消费了一个,当前队列中还剩余<span class="number">0</span>     唤醒了生产线程</span><br><span class="line">      消费者：c5被阻塞了，队列空了</span><br><span class="line">      消费者：c4被阻塞了，队列空了</span><br><span class="line">      消费者：c2被阻塞了，队列空了</span><br><span class="line">      消费者：c1被阻塞了，队列空了</span><br><span class="line">      消费者：c8被阻塞了，队列空了</span><br><span class="line">      消费者：c7被阻塞了，队列空了</span><br><span class="line">      消费者：c6被阻塞了，队列空了</span><br><span class="line">      消费者：c9被阻塞了，队列空了</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">1</span>    唤醒了消费线程</span><br><span class="line">      消费者：c9消费了一个,当前队列中还剩余<span class="number">0</span>     唤醒了生产线程</span><br><span class="line">      消费者：c9被阻塞了，队列空了</span><br><span class="line">      消费者：c6被阻塞了，队列空了</span><br><span class="line">      消费者：c7被阻塞了，队列空了</span><br><span class="line">      消费者：c8被阻塞了，队列空了</span><br><span class="line">      消费者：c1被阻塞了，队列空了</span><br><span class="line">      消费者：c2被阻塞了，队列空了</span><br><span class="line">      消费者：c4被阻塞了，队列空了</span><br><span class="line">      消费者：c5被阻塞了，队列空了</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">1</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">2</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">3</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">4</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">5</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">6</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">7</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">8</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">9</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">10</span>    唤醒了消费线程</span><br><span class="line">生产者：p1被阻塞了，队列满了</span><br><span class="line">      消费者：c5消费了一个,当前队列中还剩余<span class="number">9</span>     唤醒了生产线程</span><br><span class="line">      消费者：c5消费了一个,当前队列中还剩余<span class="number">8</span>     唤醒了生产线程</span><br><span class="line">      消费者：c5消费了一个,当前队列中还剩余<span class="number">7</span>     唤醒了生产线程</span><br><span class="line">      消费者：c5消费了一个,当前队列中还剩余<span class="number">6</span>     唤醒了生产线程</span><br><span class="line">      消费者：c5消费了一个,当前队列中还剩余<span class="number">5</span>     唤醒了生产线程</span><br><span class="line">      消费者：c4消费了一个,当前队列中还剩余<span class="number">4</span>     唤醒了生产线程</span><br><span class="line">      消费者：c4消费了一个,当前队列中还剩余<span class="number">3</span>     唤醒了生产线程</span><br><span class="line">      消费者：c4消费了一个,当前队列中还剩余<span class="number">2</span>     唤醒了生产线程</span><br><span class="line">      消费者：c4消费了一个,当前队列中还剩余<span class="number">1</span>     唤醒了生产线程</span><br><span class="line">      消费者：c4消费了一个,当前队列中还剩余<span class="number">0</span>     唤醒了生产线程</span><br><span class="line">      消费者：c2被阻塞了，队列空了</span><br><span class="line">      消费者：c1被阻塞了，队列空了</span><br><span class="line">      消费者：c8被阻塞了，队列空了</span><br><span class="line">      消费者：c7被阻塞了，队列空了</span><br><span class="line">      消费者：c6被阻塞了，队列空了</span><br><span class="line">      消费者：c9被阻塞了，队列空了</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">1</span>    唤醒了消费线程</span><br><span class="line">      消费者：c9消费了一个,当前队列中还剩余<span class="number">0</span>     唤醒了生产线程</span><br><span class="line">      消费者：c9被阻塞了，队列空了</span><br><span class="line">      消费者：c6被阻塞了，队列空了</span><br><span class="line">      消费者：c7被阻塞了，队列空了</span><br><span class="line">      消费者：c8被阻塞了，队列空了</span><br><span class="line">      消费者：c1被阻塞了，队列空了</span><br><span class="line">      消费者：c2被阻塞了，队列空了</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">1</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">2</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">3</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">4</span>    唤醒了消费线程</span><br><span class="line">生产者：p1生产了了一个,当前队列中还剩余<span class="number">5</span>    唤醒了消费线程</span><br><span class="line">      消费者：c2消费了一个,当前队列中还剩余<span class="number">4</span>     唤醒了生产线程</span><br><span class="line">      消费者：c2消费了一个,当前队列中还剩余<span class="number">3</span>     唤醒了生产线程</span><br><span class="line">      消费者：c2消费了一个,当前队列中还剩余<span class="number">2</span>     唤醒了生产线程</span><br><span class="line">      消费者：c2消费了一个,当前队列中还剩余<span class="number">1</span>     唤醒了生产线程</span><br><span class="line">      消费者：c2消费了一个,当前队列中还剩余<span class="number">0</span>     唤醒了生产线程</span><br><span class="line">      消费者：c1被阻塞了，队列空了</span><br><span class="line">      消费者：c8被阻塞了，队列空了</span><br><span class="line">      消费者：c7被阻塞了，队列空了</span><br><span class="line">      消费者：c6被阻塞了，队列空了</span><br><span class="line">      消费者：c9被阻塞了，队列空了</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">1</span>    唤醒了消费线程</span><br><span class="line">      消费者：c9消费了一个,当前队列中还剩余<span class="number">0</span>     唤醒了生产线程</span><br><span class="line">      消费者：c9被阻塞了，队列空了</span><br><span class="line">      消费者：c6被阻塞了，队列空了</span><br><span class="line">      消费者：c7被阻塞了，队列空了</span><br><span class="line">      消费者：c8被阻塞了，队列空了</span><br><span class="line">      消费者：c1被阻塞了，队列空了</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">1</span>    唤醒了消费线程</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">2</span>    唤醒了消费线程</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">3</span>    唤醒了消费线程</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">4</span>    唤醒了消费线程</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">5</span>    唤醒了消费线程</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">6</span>    唤醒了消费线程</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">7</span>    唤醒了消费线程</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">8</span>    唤醒了消费线程</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">9</span>    唤醒了消费线程</span><br><span class="line">      消费者：c1消费了一个,当前队列中还剩余<span class="number">8</span>     唤醒了生产线程</span><br><span class="line">      消费者：c1消费了一个,当前队列中还剩余<span class="number">7</span>     唤醒了生产线程</span><br><span class="line">      消费者：c1消费了一个,当前队列中还剩余<span class="number">6</span>     唤醒了生产线程</span><br><span class="line">      消费者：c1消费了一个,当前队列中还剩余<span class="number">5</span>     唤醒了生产线程</span><br><span class="line">      消费者：c1消费了一个,当前队列中还剩余<span class="number">4</span>     唤醒了生产线程</span><br><span class="line">      消费者：c8消费了一个,当前队列中还剩余<span class="number">3</span>     唤醒了生产线程</span><br><span class="line">      消费者：c8消费了一个,当前队列中还剩余<span class="number">2</span>     唤醒了生产线程</span><br><span class="line">      消费者：c8消费了一个,当前队列中还剩余<span class="number">1</span>     唤醒了生产线程</span><br><span class="line">      消费者：c8消费了一个,当前队列中还剩余<span class="number">0</span>     唤醒了生产线程</span><br><span class="line">      消费者：c8被阻塞了，队列空了</span><br><span class="line">      消费者：c7被阻塞了，队列空了</span><br><span class="line">      消费者：c6被阻塞了，队列空了</span><br><span class="line">      消费者：c9被阻塞了，队列空了</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">1</span>    唤醒了消费线程</span><br><span class="line">      消费者：c9消费了一个,当前队列中还剩余<span class="number">0</span>     唤醒了生产线程</span><br><span class="line">      消费者：c6被阻塞了，队列空了</span><br><span class="line">      消费者：c7被阻塞了，队列空了</span><br><span class="line">      消费者：c8被阻塞了，队列空了</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">1</span>    唤醒了消费线程</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">2</span>    唤醒了消费线程</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">3</span>    唤醒了消费线程</span><br><span class="line">      消费者：c8消费了一个,当前队列中还剩余<span class="number">2</span>     唤醒了生产线程</span><br><span class="line">      消费者：c7消费了一个,当前队列中还剩余<span class="number">1</span>     唤醒了生产线程</span><br><span class="line">      消费者：c7消费了一个,当前队列中还剩余<span class="number">0</span>     唤醒了生产线程</span><br><span class="line">      消费者：c7被阻塞了，队列空了</span><br><span class="line">      消费者：c6被阻塞了，队列空了</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">1</span>    唤醒了消费线程</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">2</span>    唤醒了消费线程</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">3</span>    唤醒了消费线程</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">4</span>    唤醒了消费线程</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">5</span>    唤醒了消费线程</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">6</span>    唤醒了消费线程</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">7</span>    唤醒了消费线程</span><br><span class="line">生产者：p0生产了了一个,当前队列中还剩余<span class="number">8</span>    唤醒了消费线程</span><br><span class="line">      消费者：c6消费了一个,当前队列中还剩余<span class="number">7</span>     唤醒了生产线程</span><br><span class="line">      消费者：c6消费了一个,当前队列中还剩余<span class="number">6</span>     唤醒了生产线程</span><br><span class="line">      消费者：c6消费了一个,当前队列中还剩余<span class="number">5</span>     唤醒了生产线程</span><br><span class="line">      消费者：c6消费了一个,当前队列中还剩余<span class="number">4</span>     唤醒了生产线程</span><br><span class="line">      消费者：c6消费了一个,当前队列中还剩余<span class="number">3</span>     唤醒了生产线程</span><br><span class="line">      消费者：c7消费了一个,当前队列中还剩余<span class="number">2</span>     唤醒了生产线程</span><br><span class="line">      消费者：c7消费了一个,当前队列中还剩余<span class="number">1</span>     唤醒了生产线程</span><br><span class="line">      消费者：c7消费了一个,当前队列中还剩余<span class="number">0</span>     唤醒了生产线程</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="方案2Lock和Condition实现"><a href="#方案2Lock和Condition实现" class="headerlink" title="方案2Lock和Condition实现"></a>方案2Lock和Condition实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerCustomerLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> LinkedList&lt;Object&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> MAX = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition producer = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition consumer = lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object t)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() == MAX) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;被阻塞了，容器满了&quot;</span>);</span><br><span class="line">                producer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(t);</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;生产了了一个,当前容器中还剩余&quot;</span> + list.size() + <span class="string">&quot;    唤醒了消费线程&quot;</span>);</span><br><span class="line">            producer.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">null</span>;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() == <span class="number">0</span>) &#123;  <span class="comment">//</span></span><br><span class="line">                System.out.println(<span class="string">&quot;      消费者：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;被阻塞了，容器空了&quot;</span>);</span><br><span class="line">                consumer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            obj = list.removeFirst();</span><br><span class="line">            System.out.println(<span class="string">&quot;      消费者：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;消费了一个,当前容器中还剩余&quot;</span> + list.size() + <span class="string">&quot;     唤醒了生产线程&quot;</span>);</span><br><span class="line">            producer.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerCustomerWaitNotifyAll pc = <span class="keyword">new</span> ProducerCustomerWaitNotifyAll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  <span class="comment">//10个消费者</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;  <span class="comment">//每个消费者最多消费5个</span></span><br><span class="line">                    pc.get();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;c&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//启动生产者线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123; <span class="comment">//2个生产者</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">25</span>; j++) &#123;  <span class="comment">//每个生产者最多生产25个</span></span><br><span class="line">                    pc.put(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;p&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现两个线程交替执行"><a href="#实现两个线程交替执行" class="headerlink" title="实现两个线程交替执行"></a>实现两个线程交替执行</h1><p><a href="https://www.cnblogs.com/dolphin0520/p/3920397.html">https://www.cnblogs.com/dolphin0520/p/3920397.html</a></p>
<p>参考文章：<a href="https://blog.csdn.net/zl_StepByStep/article/details/88760572">https://blog.csdn.net/zl_StepByStep/article/details/88760572</a></p>
]]></content>
      <categories>
        <category>多线程</category>
        <category>多线程理论篇</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>偏向锁四秒延迟探究</title>
    <url>/77ed6e38.html</url>
    <content><![CDATA[<p>在项目中发现偏向锁并不是立即生效的，而是有着一个默认延迟，下面深入探究一下，为什么偏向锁有着四秒延迟，以及怎么调优</p>
<span id="more"></span>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/26 17:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JOL</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           28 f2 5a 03 (00101000 11110010 01011010 00000011) (56291880)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>

<p>然后我们发现，我们明明添加了synchronized，为什么第二次的打印信息为00</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210826172322380.png" alt="image-20210826172322380"></p>
<p>不应该是01吗，开始jvm是使用的偏向锁，偏向锁是101啊</p>
<h1 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h1><p>原因：</p>
<p>创建一个对象后，jvm偏向锁的启动是有4秒延时的（默认），这个时候为匿名偏向，因为在开始创建的过程中肯定有大量的线程参与竞争（内存分配的竞争等等），这个时候如果立即打开偏向锁的话，肯定是有性能浪费的（锁竞争过程、锁撤掉），所以打开偏向锁的效率不是一定会提升效率。</p>
<p>这个时候我们，在代码最前面添加睡眠5秒钟</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/26 17:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JOL</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210826172904965.png" alt="image-20210826172904965"></p>
<p>这个时候状态为101，才升级为偏向锁</p>
<h2 id="调整默认参数"><a href="#调整默认参数" class="headerlink" title="调整默认参数"></a>调整默认参数</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">jvm中设置立即打开偏向锁</span></span><br><span class="line">-XX:BiasedLockingStartupDelay=0</span><br></pre></td></tr></table></figure>



<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210826173209886.png" alt="image-20210826173209886" style="zoom:67%;" />

<p>然后注释掉睡眠5秒钟</p>
<p>打印：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210826173301227.png" alt="image-20210826173301227"></p>
]]></content>
      <categories>
        <category>多线程</category>
        <category>多线程理论篇</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile的底层实现</title>
    <url>/db022879.html</url>
    <content><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h2><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210827154138917.png" alt="image-20210827154138917"><span id="more"></span></p>
<h2 id="cpu读取数据"><a href="#cpu读取数据" class="headerlink" title="cpu读取数据"></a>cpu读取数据</h2><ol>
<li><p>三级缓存</p>
</li>
<li><p>cpu读取数据的时候，先从寄存器中读取数据，如果没有然后从L1（一级缓存）中读取数据，如果没有然后从L2（二级缓存总读取数据），如果没有然后从L3中读取数据，L3中没有，从内存中读取数据，内存中还没有从磁盘中读取数据，拿到数据后在一级一级放回（L3到L2到L1到寄存器）</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210827154320590.png" alt="image-20210827154320590"></p>
</li>
</ol>
<h2 id="cpu线程切换"><a href="#cpu线程切换" class="headerlink" title="cpu线程切换"></a>cpu线程切换</h2><ol>
<li>每个线程独占cpu寄存器中的数据，当第二个线程执行的之后，把寄存器中的数据保存起来，然后读取第二个线程的数据到寄存器，然后执行第二个线程</li>
<li>一核两线程cpu是，一核内有两个寄存器，在两个线程切换的时候，不需要切换寄存器中的数据</li>
</ol>
<img src="C:/Users/Think/AppData/Roaming/Typora/typora-user-images/image-20210826203900185.png" alt="image-20210826203900185" style="zoom:50%;" />

<h2 id="cpu缓存意义"><a href="#cpu缓存意义" class="headerlink" title="cpu缓存意义"></a>cpu缓存意义</h2><ul>
<li><p>时间局部性：如果某个数据被访问，那么在不久的将来它很有可能会被再次访问。</p>
</li>
<li><p>空间局部性：如果某个数据被访问，那么与它相邻的数据很快也能被访问。</p>
<h2 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h2></li>
</ul>
<h3 id="按块预读取（也叫缓存行）（cache-line）"><a href="#按块预读取（也叫缓存行）（cache-line）" class="headerlink" title="按块预读取（也叫缓存行）（cache line）"></a>按块预读取（也叫缓存行）（cache line）</h3><p>缓存在读取的数据的时候并不是只拿需要的数据，这样缓存的意义也就没有了，获取一个数据的时候，其周边的数据也会顺便拿过来，这如果当这个数据执行完成后，马上会旁边的数据的情况下，可以立即从最近的缓存中直接拿到，而不用再次逐级读取</p>
<p>缓存行经过实践后一般缓存行大小为<strong>64BIt(字节)</strong></p>
<img src="C:/Users/Think/AppData/Roaming/Typora/typora-user-images/image-20210826204905874.png" alt="image-20210826204905874" style="zoom:50%;" />

<h3 id="缓存一致性："><a href="#缓存一致性：" class="headerlink" title="缓存一致性："></a>缓存一致性：</h3><p>两个核一个用到了x，一个用到了y，但是都把周边的数据读取到了缓存中，当核1执行完x的逻辑后，接着执行y的逻辑，这个时候两个核内的数据并没有同步，这个就是</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="intel的cpu"><a href="#intel的cpu" class="headerlink" title="intel的cpu"></a>intel的cpu</h5><p>因特尔通常使用MESI协议保证缓存一致性。也就是一个核对数据更改后，通知另一个cpu把这个数据状态改为<code>Invalid</code>状态，然后该核执行的时候要到缓存中再次读取数据。</p>
<p>推荐文章：<a href="https://www.cnblogs.com/z00377750/p/9180644.html">https://www.cnblogs.com/z00377750/p/9180644.html</a></p>
<p>然后项目在运行过程中，如果有大量的这样的缓存行，高并发情况下<strong>频繁写</strong>会造成效率的降低。</p>
<h5 id="解决方案：缓存行对齐"><a href="#解决方案：缓存行对齐" class="headerlink" title="解决方案：缓存行对齐"></a>解决方案：缓存行对齐</h5><p>让X和Y这个连个数据不在一个缓存行中，及在XY数据中间添加无用的数据，这样反而在高并发情况下<strong>频繁写</strong>会增加运行效率。</p>
<p>例如：</p>
<ul>
<li><p>disruptor（世界上最快的单机MQ）中的RingBuffer；</p>
</li>
<li><p>jdk1.7中的集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongWithPadding</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> value;<span class="comment">//8个字节</span></span><br><span class="line">	<span class="keyword">long</span> p0, p1, p2, p3, p4, p5, p6;<span class="comment">//7*8=56个字节，然后下一个value必然独占一个缓存行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>然后在jdk1.8中添加了一个注解<code>@sun.misc.Contended</code>，对某字段加上该注解则表示该字段会单独占用一个<strong>缓存行</strong>（Cache Line）</p>
<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>主要适用于<strong>频繁写</strong>的<strong>共享数据</strong>上。如果不是频繁写的数据，那么 CPU 缓存行被锁的几率就不多，所以没必要使用了，否则不仅占空间还会浪费 CPU 访问操作数据的时间。</p>
<h2 id="java线程内存模型"><a href="#java线程内存模型" class="headerlink" title="java线程内存模型"></a>java线程内存模型</h2><ul>
<li>java线程内存模型和CPU缓存模型类似，是基于CPU缓存模型来建立的，<br>java线程内存模型是标准化的，屏蔽掉了底层不同计算机的区别。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200615155252495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIyMDc1OTEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>重排序是cpu内部的优化过程。</p>
<p>加入有三条指令，指令1，指令2，指令3；如果顺序执行，我必须等待指令1执行完毕，然后才能执行指令3，这样如果指令1在等待有个状态，就会造成cpu资源利用率下降。所以在执行指令1的通知，也可以执行执行2，指令3，只要保证最后执行的结果是争取的，那么这个就是可以的</p>
<p>在java中这个是非常常见的，例如有一个程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(isStart) &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &gt; <span class="number">100000L</span>; i++)&#123;</span><br><span class="line">		i = (i + <span class="number">9</span>) / <span class="number">3</span>; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个并不是等待if（isStart）判断为ture后，才开始执行里面的for循环，在指令重排后，有可能是里面的for循环先执行，然后执行到一半后在进行判断，如果这个判断为false，则丢弃这个计算for循环的结果。这个指令重排是cpu内部做的，为的就是提高效率</p>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>一旦内存数据被推送到缓存，就会有消息协议来确保所有的缓存会对所有的共享数据同步并保持一致。这个使内存数据对CPU核可见的技术被称为<strong>内存屏障或内存栅栏</strong>。</p>
<p>大多数的内存屏障都是复杂的话题。在不同的CPU架构上内存屏障的实现非常不一样。</p>
<h1 id="volatile底层实现"><a href="#volatile底层实现" class="headerlink" title="volatile底层实现"></a>volatile底层实现</h1><p>volatile的作用是</p>
<ol>
<li>内存可见性</li>
<li>禁止指令重排序</li>
</ol>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p><strong>volatile 是怎么实现共享变量在多个线程之间工作内存的可见性的呢?</strong></p>
<h3 id="JMM的8种数据原子操作："><a href="#JMM的8种数据原子操作：" class="headerlink" title="JMM的8种数据原子操作："></a>JMM的8种数据原子操作：</h3><p>read 读取，作用于主内存把变量从主内存中读取到本本地内存。<br>load 加载，把从主内存中读取的变量加载到本地内存的变量副本中<br>use 使用，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个<br>需要使用变量的值的字节码指令时将会执行这个操作。、<br>assign 赋值 它把一个从执行引擎接收到的值赋值给工作内存的变量，<br>每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。<br>store 存储 ，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。<br>write 写入 ，它把store操作从工作内存中一个变量的值传送到主内存的变量中。<br>lock 锁定 ：作用于主内存的变量，把一个变量标识为一条线程独占状态。<br>unlock 解锁：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20200615160905272.png" alt="在这里插入图片描述"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20200615142955206.png" alt="在这里插入图片描述"></p>
<p>线程1：先把initFlag变量read读取出来，再load载入工作内存，use使用线程1执行代码!initFlag<br>线程2：先把initFlag变量read读取出来，再load载入工作内存，use使用线程2执行代码initFlag=true，<br>再assign重新赋值，store存储并写入主内存，write写入到主内存中的变量。(线程2对缓存行lock加锁，<br>write写入主内存后会解锁unlock，防止initFlag还未write写入主内存就被线程1读取为false）。<br>线程1：因为initFlag被volatile修饰，使用MESI缓存一致性协议，线程1cpu总线嗅探机制监听到了<br>initFlag值的修改，线程1中initFlag=false失效变为true退出循环继续执行，<br>体现了多线程同步运行共享变量副本的可见性。如果initFlag没有被volatile修饰，<br>线程1将感知不到initFlag的变化，一直循环下去停止不了。</p>
<p><img src="https://img-blog.csdnimg.cn/20200615161340679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIyMDc1OTEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="jmm缓存不一致的问题解决办法"><a href="#jmm缓存不一致的问题解决办法" class="headerlink" title="jmm缓存不一致的问题解决办法"></a>jmm缓存不一致的问题解决办法</h3><h4 id="总线加锁-性能太低-："><a href="#总线加锁-性能太低-：" class="headerlink" title="总线加锁(性能太低)："></a>总线加锁(性能太低)：</h4><p>cpu从主内存读取数据到高速缓存，会在总线对这个数据加锁，这样其它cpu没法去读或写这个数据，直到这个cpu使用完数据释放锁之后其它cpu才能读取该数据，导致结果：改并行为串行。</p>
<h4 id="MESI缓存一致性协议"><a href="#MESI缓存一致性协议" class="headerlink" title="MESI缓存一致性协议"></a>MESI缓存一致性协议</h4><p>多个cpu从主内存读取同一个数据到各自的高速缓存,当其中某个cpu修改了缓存里的数据，该数据会马上同步回主内存,其它cpu通过总线嗅探机制可以感知到数据的变化从而将自己缓存里的数据失效。</p>
<h2 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h2><h3 id="为什么要禁止"><a href="#为什么要禁止" class="headerlink" title="为什么要禁止"></a>为什么要禁止</h3><p>为了提高程序执行的性能，编译器和执行器（处理器）通常会对指令做一些优化（重排序）</p>
<ol>
<li>编译器重排序。编译器在不改变单线程语义的前提下，可以重新安排语句的执行顺序；</li>
<li>处理器重排序。如果不存在数据依赖性，处理器可以改变语句对机器指令的执行顺序</li>
</ol>
<p>现在的操作系统执行命令一般都是流水线式的执行，为了保证cpu的执行效率。</p>
<p>volatile底层是通过lock前缀指令、内存屏障来实现的</p>
<p>参考：</p>
<p>多线程：<a href="https://www.bilibili.com/video/BV1aQ4y1P7Me?p=9&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1aQ4y1P7Me?p=9&amp;spm_id_from=pageDriver</a></p>
<p>可见性：<a href="https://blog.csdn.net/qq_22075913/article/details/106758864">https://blog.csdn.net/qq_22075913/article/details/106758864</a></p>
<p>重排序：<a href="https://blog.csdn.net/ljheee/article/details/82317448">https://blog.csdn.net/ljheee/article/details/82317448</a></p>
<p>内存屏障：<a href="http://ifeve.com/memory-barriers-or-fences/">http://ifeve.com/memory-barriers-or-fences/</a></p>
]]></content>
      <categories>
        <category>多线程</category>
        <category>多线程理论篇</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>hospot虚拟机中的synchronized底层实现</title>
    <url>/cbd84e4c.html</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="synchronized作用"><a href="#synchronized作用" class="headerlink" title="synchronized作用"></a>synchronized作用</h2><ul>
<li>原子性：synchronized保证语句块内操作是原子的</li>
<li>可见性：synchronized保证可见性（通过“在执行unlock之前，必须先把此变量同步回主内存”实现）</li>
<li>有序性：synchronized保证有序性（通过“一个变量在同一时刻只允许一条线程对其进行lock操作”）</li>
</ul>
<h2 id="synchronized的使用"><a href="#synchronized的使用" class="headerlink" title="synchronized的使用"></a>synchronized的使用</h2><ul>
<li>修饰实例方法，对当前实例对象加锁</li>
<li>修饰静态方法，多当前类的Class对象加锁</li>
<li>修饰代码块，对synchronized括号内的对象加锁</li>
</ul>
<span id="more"></span>

<h2 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h2><p>内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。</p>
<p>用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。</p>
<p>为什么要有用户态和内核态？</p>
<p>在最初的时候，没有这样的权限划分，程序可以访问所有的内容，这样很容易就直接把系统卡死，影响其他程序的运行，所以后来添加了访问限制。</p>
<p>由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 – 用户态和内核态。</p>
<p>现在操作系统中一般都是用户态向内核态（操作系统）获取资源，内核态获取cpu等等这个底层资源</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h2 id="理解Java对象头"><a href="#理解Java对象头" class="headerlink" title="理解Java对象头"></a>理解Java对象头</h2><p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20190310224348833.jpg" alt="在这里插入图片描述"></p>
<p>实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</p>
<p>填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</p>
<p>HotSpot虚拟机的对象头分为两部分信息，第一部分用于存储对象自身运行时数据，如哈希码、GC分代年龄等，这部分数据的长度在32位和64位的虚拟机中分别为32位和64位。官方称为Mark Word。另一部分用于存储指向对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分存储数组长度。</p>
<p>虚拟机位数    对象头结构    描述<br>32位/64位    Mark Word    存储对象的哈希码、GC分代年龄、锁信息等<br>32位/64位    Class MetaData Address    指向对象类型数据的指针<br>32位/64位    数组长度    如果是数组对象的话，有这一部分，否则没有<br>由于对象头的信息是与对象自身定义的数据没有关系的额外存储成本，因此考虑到JVM的空间效率，Mark Word 被设计成为一个非固定的数据结构，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间。</p>
<h2 id="锁的状态码"><a href="#锁的状态码" class="headerlink" title="锁的状态码"></a>锁的状态码</h2><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210826152109346.png" alt="image-20210826152109346"></p>
<h3 id="虚拟机中判断锁的状态"><a href="#虚拟机中判断锁的状态" class="headerlink" title="虚拟机中判断锁的状态"></a>虚拟机中判断锁的状态</h3><table>
<thead>
<tr>
<th>锁标志位</th>
<th>锁</th>
<th>偏向锁位</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td><strong>轻量级锁</strong>（自旋锁、无锁）</td>
<td></td>
<td>指向线程栈中lock Record的指针</td>
</tr>
<tr>
<td>10</td>
<td><strong>重量级锁</strong></td>
<td></td>
<td>指向互斥锁（重量级锁）的指针</td>
</tr>
<tr>
<td>11</td>
<td><strong>GC标记信息</strong></td>
<td></td>
<td>CMS过程用到的标记信息</td>
</tr>
<tr>
<td>01</td>
<td>看偏向锁，偏向锁为0，<strong>无锁</strong></td>
<td>0</td>
<td>当前线程指针javaThread</td>
</tr>
<tr>
<td>01</td>
<td>看偏向锁，偏向锁为1，<strong>偏向锁</strong></td>
<td>1</td>
<td>当前线程指针javaThread</td>
</tr>
</tbody></table>
<h3 id="上图内容"><a href="#上图内容" class="headerlink" title="上图内容"></a>上图内容</h3><ol>
<li><p>hashcode，这里面存放的是原始的hashcode，不是重写的hashcode</p>
</li>
<li><p>分代年龄</p>
<ol>
<li>虚拟机中有新生代和老年代，这个就是这个分代年龄<ol>
<li>在PS、PO、G1默认15次（这里的分代年龄为4bit，最大为16，所以15次就是最大值）还没有回收，从新生代转移到老年代</li>
<li>CMS默认是6次</li>
</ol>
</li>
</ol>
</li>
<li><p>Epoch，偏向锁撤销，调优内容</p>
</li>
<li><p>在锁转化的过程中，记录信息越来越少，那原来的信息呢（hashcode、分代年龄）</p>
<ol>
<li>这个信息都记录到当前线程的线程栈（在加锁情况下，只有这一个线程在使用）中，也就是Lock Record，所以轻量级锁和重量级锁会有指针</li>
</ol>
</li>
</ol>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="JVM对synchronized的锁优化"><a href="#JVM对synchronized的锁优化" class="headerlink" title="JVM对synchronized的锁优化"></a>JVM对synchronized的锁优化</h2><p>Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的。而操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。</p>
<p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”：锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁可以升级但不能降级。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210826151316460.png" alt="image-20210826151316460"></p>
<h3 id="1、偏向锁"><a href="#1、偏向锁" class="headerlink" title="1、偏向锁"></a>1、偏向锁</h3><p>偏向锁是JDK1.6中引用的优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的性能。</p>
<h4 id="偏向锁的获取："><a href="#偏向锁的获取：" class="headerlink" title="偏向锁的获取："></a>偏向锁的获取：</h4><p>判断是否为可偏向状态<br>如果为可偏向状态，则判断线程ID是否是当前线程，如果是进入同步块；<br>如果线程ID并未指向当前线程，利用CAS操作竞争锁，如果竞争成功，<strong>将Mark Word中线程ID更新为当前线程ID</strong>，进入同步块<br>如果竞争失败，等待全局安全点，准备撤销偏向锁，根据线程是否处于活动状态，决定是转换为无锁状态还是升级为轻量级锁。<br>当锁对象第一次被线程获取的时候，虚拟机会把对象头中的锁标志位设置为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word中，如果CAS操作成功。持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。</p>
<h4 id="偏向锁的释放："><a href="#偏向锁的释放：" class="headerlink" title="偏向锁的释放："></a>偏向锁的释放：</h4><p>偏向锁使用了遇到竞争才释放锁的机制。<strong>偏向锁的撤销需要等待全局安全点</strong>，然后它会首先暂停拥有偏向锁的线程，然后判断线程是否还活着，如果线程还活着，则升级为轻量级锁，否则，将锁设置为无锁状态。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20190311190530462.png" alt="在这里插入图片描述"></p>
<p>注意：</p>
<p>创建一个对象后，jvm偏向锁的启动是有4秒延时的（默认），这个时候为匿名偏向，因为在开始创建的过程中肯定有大量的线程参与竞争（内存分配的竞争等等），这个时候如果立即打开偏向锁的话，肯定是有性能浪费的（锁竞争过程、锁撤掉），所以打开偏向锁的效率不是一定会提升效率。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">jvm中设置立即打开偏向锁</span></span><br><span class="line">-xx:BiasedLockingstartupDelay=0</span><br></pre></td></tr></table></figure>





<h3 id="2、轻量级锁"><a href="#2、轻量级锁" class="headerlink" title="2、轻量级锁"></a>2、轻量级锁</h3><p>轻量级锁也是在JDK1.6中引入的新型锁机制。它不是用来替换重量级锁的，它的本意是在没有多线程竞争的情况下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
<h4 id="加锁过程："><a href="#加锁过程：" class="headerlink" title="加锁过程："></a>加锁过程：</h4><p>在代码进入同步块的时候，如果此对象没有被锁定（锁标志位为“01”状态），虚拟机首先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储对象目前Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）。然后虚拟机使用CAS操作尝试将对象的Mark Word更新为指向锁记录（Lock Record）的指针。如果更新成功，那么这个线程就拥有了该对象的锁，并且对象的Mark Word标志位转变为“00”，即表示此对象处于轻量级锁定状态；如果更新失败，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块中执行，否则说明这个锁对象已经被其他线程占有了。<strong>如果有两条以上的线程竞争同一个锁，那轻量级锁不再有效，要膨胀为重量级锁，锁标志变为“10”</strong>，Mark Word中存储的就是指向重量级锁的指针，而后面等待的线程也要进入阻塞状态。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20190311190732602.jpg" alt="在这里插入图片描述"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20190311190736763.jpg" alt="在这里插入图片描述"></p>
<h4 id="锁升级过程："><a href="#锁升级过程：" class="headerlink" title="锁升级过程："></a>锁升级过程：</h4><p>jdk1.6之前：</p>
<p>CAS某线程自旋次数大于10次（默认）<strong>或者</strong>竞争的线程数超过cpu总核数的一半（例如：8核cpu超过了4个线程），升级为重量级锁。</p>
<p>可以进行jvm调优</p>
<p>jdk1.6后：</p>
<p>自适应升级</p>
<h4 id="解锁过程："><a href="#解锁过程：" class="headerlink" title="解锁过程："></a>解锁过程：</h4><p>如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作将对象当前的Mark Word与线程栈帧中的Displaced Mark Word交换回来，如果替换成功，整个同步过程就完成了。如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。</p>
<p>如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁比传统重量级锁开销更大。</p>
<h3 id="3、重量级锁"><a href="#3、重量级锁" class="headerlink" title="3、重量级锁"></a>3、重量级锁</h3><p>Synchronized的重量级锁是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的。而操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。</p>
<p>但是如果是多线程高兵发的情况下，需要加锁，这个时候无意使用Synchronized是最好的的。</p>
<p>如果是单纯的cas在多线程情况下，大量的线程在自旋，这个自旋操作是需要占据cpu资源的。但是如果用的重量级锁，这个时候是放在一个wait队列中，轮到那个线程，cpu调度哪个线程，后续的那个线程是不占局cpu资源的，这个时候无疑重量级锁的效率更高。</p>
<p>总结：</p>
<p>线程少或者线程运行时间少，适用于自旋锁</p>
<p>线程多或者线程运行时间长，应用与重量级锁</p>
<h3 id="4、自旋锁"><a href="#4、自旋锁" class="headerlink" title="4、自旋锁"></a>4、自旋锁</h3><p>互斥同步对性能影响最大的是阻塞的实现，挂起线程和恢复线程的操作都需要转入到内核态中完成，这些操作给系统的并发性能带来很大的压力。<br>于是在阻塞之前，我们让线程执行一个忙循环（自旋），看看持有锁的线程是否释放锁，如果很快释放锁，则没有必要进行阻塞。</p>
<h3 id="5、锁消除"><a href="#5、锁消除" class="headerlink" title="5、锁消除"></a>5、锁消除</h3><p>锁消除是指虚拟机即时编译器（JIT）在运行时，对一些代码上要求同步，但是检测到不可能发生数据竞争的锁进行消除。</p>
<h3 id="6、锁粗化"><a href="#6、锁粗化" class="headerlink" title="6、锁粗化"></a>6、锁粗化</h3><p>如果虚拟机检测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p>
<h2 id="jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。"><a href="#jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。" class="headerlink" title="jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。"></a>jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。</h2><p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。</p>
<p>代码块的同步是利用monitorenter和monitorexit这两个字节码指令。它们分别位于同步代码块的开始和结束位置。当jvm执行到monitorenter指令时，当前线程试图获取monitor对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取monitor对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。</p>
<p>这里要注意：</p>
<p>synchronized是可重入的，所以不会自己把自己锁死<br>synchronized锁一旦被一个线程持有，其他试图获取该锁的线程将被阻塞。<br>关于ACC_SYNCHRONIZED 、monitorenter、monitorexit指令，可以看一下下面的反编译代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;    <span class="comment">//这个是同步方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;		<span class="comment">//这个是同步代码块</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用javap -verbose SynchronizedDemo反编译后得到</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20190310221443337.jpg"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20190311182248435.jpg" alt="在这里插入图片描述"></p>
<p>我们看到对于同步方法，反编译后得到ACC_SYNCHRONIZED 标志，对于同步代码块反编译后得到monitorenter和monitorexit指令。</p>
<h1 id="synchronized是否支持锁重入"><a href="#synchronized是否支持锁重入" class="headerlink" title="synchronized是否支持锁重入"></a>synchronized是否支持锁重入</h1><p>支持</p>
<p>最简单的理解：在继承中，父类的A方法是synchronized方法，子类重写了A方法，调用父类方法super.A()，这个时候要是不支持可重入是不是立即发生了死锁。</p>
<p>每次上锁都要进行一次解锁，所以在每次执行synchronized方法后，在本地方法栈中都要生成一个Lock Record，在锁释放后弹出一个LR</p>
<p>————————————————<br>参考：</p>
<p><a href="https://www.bilibili.com/video/BV1aQ4y1P7Me?from=search&amp;seid=16212058743276143027">https://www.bilibili.com/video/BV1aQ4y1P7Me?from=search&amp;seid=16212058743276143027</a></p>
<p><a href="https://blog.csdn.net/weixin_38481963/article/details/88384493">https://blog.csdn.net/weixin_38481963/article/details/88384493</a></p>
<p><a href="https://www.cnblogs.com/maxigang/p/9041080.html">https://www.cnblogs.com/maxigang/p/9041080.html</a></p>
]]></content>
      <categories>
        <category>多线程</category>
        <category>多线程理论篇</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>ReentrantLock底层实现原理</title>
    <url>/9682c195.html</url>
    <content><![CDATA[<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>　　AbstarctQueuedSynchronizer简称AQS，是一个用于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建的，例如ReentrantLock，Semphore，CountDownLatch，ReentrantReadWriteLock，FutureTask等。AQS解决了在实现同步容器时大量的细节问题。</p>
<p>　　AQS使用一个FIFO队列表示排队等待锁的线程，队列头结点称作“哨兵节点”或者“哑结点”，它不与任何线程关联。其他的节点与等待线程关联，每个阶段维护一个等待状态waitStatus。如图：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ce6ff22c8092c17d3abb1f9fbea71e9f.png" alt="img"></p>
<p>　　AQS中还有一个表示状态的字段state，例如ReentrantLock用它来表示线程重入锁的次数，Semphore用它表示剩余的许可数量，FutureTask用它表示任务的状态。对state变量值的更新都采用CAS操作保证更新操作的原子性。</p>
<p>　　AbstractQueuedSynchronized继承了AbstractOwnableSynchronized，这个类只有一个变量：exclusiveOwnerThread，表示当前占用该锁的线程，并且提供了相应的get，set方法。</p>
<p>　　理解AQS可以帮助我们更好的理解JUC包中的同步容器。</p>
<h1 id="3-lock-与unlock-实现原理"><a href="#3-lock-与unlock-实现原理" class="headerlink" title="3 lock()与unlock()实现原理"></a>3 lock()与unlock()实现原理</h1><h2 id="3-1-基础知识"><a href="#3-1-基础知识" class="headerlink" title="3.1 基础知识"></a>3.1 基础知识</h2><p>　　ReentrantLock是Lock的默认实现之一。那么Lock()和unlock(）是怎样实现的呢？首先我们要弄清楚几个概念</p>
<p>　　1、可重入锁。可重入锁是指一个线程可以多次获取同一把锁。ReentrantLock和Synchronized都是可重入锁。</p>
<p>　　2、可中断锁。可中断锁是指线程尝试获取锁的过程是否可以响应终端。synchronized是不可中断锁，而ReentrantLock则提供了中断功能。</p>
<p>　　3、公平锁与非公平锁。公平所指多个线程同时尝试获取同一把锁时，获取锁的顺序按照线程达到的顺序，而非公平锁则允许线程“插队”。synchronized是非公平锁，而ReentrantLock的默认实现是非公平锁，但是也可以设置为公平锁。</p>
<p>　　4、CAS操作(CompareAndSwap)。CAS操作简单的说就是比较并交换。CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。” Java并发包(java.util.concurrent)中大量使用了CAS操作,涉及到并发的地方都调用了sun.misc.Unsafe类方法进行CAS操作。</p>
<h2 id="3-2-内部结构"><a href="#3-2-内部结构" class="headerlink" title="3.2 内部结构"></a>3.2 内部结构</h2><p>　　ReentrantLock提供了两个构造器，分别是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　默认构造器初始化为NonfairSync对象，即非公平锁，而带参数的构造器可以指定使用公平锁和非公平锁。由lock()和unlock的源码可以看到，它们只是分别调用了sync对象的lock()和release(1)方法。</p>
<p>　　Sync是ReentrantLock的内部类，它的结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/af20efacac9b820186f627faae35e79d.png" alt="img"></p>
<p>可以看到Sync扩展了AbstractQueuedSynchronizer。</p>
<h2 id="3-3-NonfairSync"><a href="#3-3-NonfairSync" class="headerlink" title="3.3 NonfairSync"></a>3.3 NonfairSync</h2><p>　　我们从源代码出发，分析非公平锁获取锁和释放锁的过程。 </p>
<h3 id="3-3-1-lock"><a href="#3-3-1-lock" class="headerlink" title="3.3.1 lock()"></a>3.3.1 lock()</h3><p>　　lock()源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　首先用一个CAS操作，判断state是否是0（表示当前锁未被占用），如果是0则把它置为1，并且设置当前线程为该锁的独占线程，表示获取锁成功。当多个线程同时尝试占用同一个锁时，CAS操作只能保证一个线程操作成功，剩下的只能乖乖的去排队啦。</p>
<p>　　“非公平”即体现在这里，如果占用锁的线程刚释放锁，state置为0，而排队等待锁的线程还未唤醒时，新来的线程就直接抢占了该锁，那么就“插队”了。</p>
<p>　　若当前有三个线程去竞争锁，假设线程A的CAS操作成功了，拿到了锁开开心心的返回了，那么线程B和C则设置state失败，走到了else里面。我们往下看acquire。</p>
<p><strong>acquire(arg)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1. 第一步。尝试去获取锁。如果尝试获取锁成功，方法直接返回。</strong></p>
<p><strong>tryAcquire(arg)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取当前线程</span></span><br><span class="line">  <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">  <span class="comment">//获取state变量值</span></span><br><span class="line">  <span class="keyword">int</span> c = getState();</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">//没有线程占用锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">      <span class="comment">//占用锁成功,设置独占线程为当前线程</span></span><br><span class="line">      setExclusiveOwnerThread(current);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">//当前线程已经占用该锁</span></span><br><span class="line">    <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">    <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">    <span class="comment">// 更新state值为新的重入次数</span></span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取锁失败</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　非公平锁tryAcquire的流程是：检查state字段，若为0，表示锁未被占用，那么尝试占用，若不为0，检查当前锁是否被自己占用，若被自己占用，则更新state字段，表示重入锁的次数。如果以上两点都没有成功，则获取锁失败，返回false。</p>
<p><strong>2. *<em>第二步，入队。*</em></strong></p>
<p>　　由于上文中提到线程A已经占用了锁，所以B和C执行tryAcquire失败，并且入等待队列。如果线程A拿着锁死死不放，那么B和C就会被挂起。</p>
<p>先看下入队的过程。</p>
<p>先看addWaiter(Node.EXCLUSIVE)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> \* 将新节点和当前线程关联并且入队列</span></span><br><span class="line"><span class="comment"> \* <span class="doctag">@param</span> mode 独占/共享</span></span><br><span class="line"><span class="comment"> \* <span class="doctag">@return</span> 新节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//初始化节点,设置关联线程和模式(独占 or 共享)</span></span><br><span class="line">  Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">  <span class="comment">// 获取尾节点引用</span></span><br><span class="line">  Node pred = tail;</span><br><span class="line">  <span class="comment">// 尾节点不为空,说明队列已经初始化过</span></span><br><span class="line">  <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">    node.prev = pred;</span><br><span class="line">    <span class="comment">// 设置新节点为尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">      pred.next = node;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 尾节点为空,说明队列还未初始化,需要初始化head节点并入队新节点</span></span><br><span class="line">  enq(node);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B、C线程同时尝试入队列，由于队列尚未初始化，tail==null，故至少会有一个线程会走到enq(node)。我们假设同时走到了enq(node)里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> \* 初始化队列并且入队新节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//开始自旋</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">      <span class="comment">// 如果tail为空,则新建一个head节点,并且tail指向head</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">        tail = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node.prev = t;</span><br><span class="line">      <span class="comment">// tail不为空,将新节点入队</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">        t.next = node;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这里体现了经典的自旋+CAS组合来实现非阻塞的原子操作。由于compareAndSetHead的实现使用了unsafe类提供的CAS操作，所以只有一个线程会创建head节点成功。假设线程B成功，之后B、C开始第二轮循环，此时tail已经不为空，两个线程都走到else里面。假设B线程compareAndSetTail成功，那么B就可以返回了，C由于入队失败还需要第三轮循环。最终所有线程都可以成功入队。</p>
<p><strong><img src="https://img-blog.csdnimg.cn/img_convert/9ac680bd18e755afea8799ca225841aa.png" alt="img"></strong></p>
<p>\3. <strong>第三步，挂起。</strong></p>
<p>　　B和C相继执行acquireQueued(final Node node, int arg)。这个方法让已经入队的线程尝试获取锁，若失败则会被挂起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 已经入队的线程尝试获取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>; <span class="comment">//标记是否成功获取锁</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>; <span class="comment">//标记线程是否被中断过</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">//获取前驱节点</span></span><br><span class="line">      <span class="comment">//如果前驱是head,即该结点已成老二，那么便有资格去尝试获取锁</span></span><br><span class="line">      <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        setHead(node); <span class="comment">// 获取成功,将当前节点设置为head节点</span></span><br><span class="line">        p.next = <span class="keyword">null</span>; <span class="comment">// 原head节点出队,在某个时间点被GC回收</span></span><br><span class="line">        failed = <span class="keyword">false</span>; <span class="comment">//获取成功</span></span><br><span class="line">        <span class="keyword">return</span> interrupted; <span class="comment">//返回是否被中断过</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断获取失败后是否可以挂起,若可以则挂起</span></span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">          parkAndCheckInterrupt())</span><br><span class="line">        <span class="comment">// 线程若被中断,设置interrupted为true</span></span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　code里的注释已经很清晰的说明了acquireQueued的执行流程。假设B和C在竞争锁的过程中A一直持有锁，那么它们的tryAcquire操作都会失败，因此会走到第2个if语句中。我们再看下shouldParkAfterFailedAcquire和parkAndCheckInterrupt都做了哪些事吧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断当前线程获取锁失败之后是否需要挂起.</span><br><span class="line"> */</span><br><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    //前驱节点的状态</span><br><span class="line">    int ws = pred.waitStatus;</span><br><span class="line">    if (ws == Node.SIGNAL)</span><br><span class="line">        // 前驱节点状态为signal,返回true</span><br><span class="line">        return true;</span><br><span class="line">    // 前驱节点状态为CANCELLED</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        // 从队尾向前寻找第一个状态不为CANCELLED的节点</span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 将前驱节点的状态设置为SIGNAL</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 挂起当前线程,返回线程中断状态并重置</span><br><span class="line"> */</span><br><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　线程入队后能够挂起的前提是，它的前驱节点的状态为SIGNAL，它的含义是“Hi，前面的兄弟，如果你获取锁并且出队后，记得把我唤醒！”。所以shouldParkAfterFailedAcquire会先判断当前节点的前驱是否状态符合要求，若符合则返回true，然后调用parkAndCheckInterrupt，将自己挂起。如果不符合，再看前驱节点是否&gt;0(CANCELLED)，若是那么向前遍历直到找到第一个符合要求的前驱，若不是则将前驱节点的状态设置为SIGNAL。</p>
<p>　　 整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心挂起，需要去找个安心的挂起点，同时可以再尝试下看有没有机会去尝试竞争锁。</p>
<p>　　最终队列可能会如下图所示</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d7d4cc5bda6089ed0755637795385786.png" alt="img"></p>
<p>　　线程B和C都已经入队，并且都被挂起。当线程A释放锁的时候，就会去唤醒线程B去获取锁啦。</p>
<h3 id="3-3-2-unlock"><a href="#3-3-2-unlock" class="headerlink" title="3.3.2 unlock()"></a>3.3.2 unlock()</h3><p>　　unlock相对于lock就简单很多。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">      unparkSuccessor(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　　　如果理解了加锁的过程，那么解锁看起来就容易多了。流程大致为先尝试释放锁，若释放成功，那么查看头结点的状态是否为SIGNAL，如果是则唤醒头结点的下个节点关联的线程，如果释放失败那么返回false表示解锁失败。这里我们也发现了，每次都只唤起头结点的下一个节点关联的线程。</p>
<p>　　最后我们再看下tryRelease的执行过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> \* 释放当前线程占用的锁</span></span><br><span class="line"><span class="comment"> \* <span class="doctag">@param</span> releases</span></span><br><span class="line"><span class="comment"> \* <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 计算释放后state值</span></span><br><span class="line">  <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">  <span class="comment">// 如果不是当前线程占用锁,那么抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">  <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 锁被重入次数为0,表示释放成功</span></span><br><span class="line">    free = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 清空独占线程</span></span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新state值</span></span><br><span class="line">  setState(c);</span><br><span class="line">  <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这里入参为1。tryRelease的过程为：当前释放锁的线程若不持有锁，则抛出异常。若持有锁，计算释放后的state值是否为0，若为0表示锁已经被成功释放，并且则清空独占线程，最后更新state值，返回free。 </p>
<h3 id="3-3-3-小结"><a href="#3-3-3-小结" class="headerlink" title="3.3.3 小结"></a>3.3.3 小结</h3><p>  用一张流程图总结一下非公平锁的获取锁的过程。 </p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a3fc82bc9772bfd3ebf1b1d241f30844.png" alt="img"></p>
<h2 id="3-4-FairSync"><a href="#3-4-FairSync" class="headerlink" title="3.4 FairSync"></a>3.4 FairSync</h2><p>  公平锁和非公平锁不同之处在于，公平锁在获取锁的时候，不会先去检查state状态，而是直接执行aqcuire(1)，这里不再赘述。 </p>
<h1 id="4-超时机制"><a href="#4-超时机制" class="headerlink" title="4 超时机制"></a>4 超时机制</h1><p>　　在ReetrantLock的tryLock(long timeout, TimeUnit unit) 提供了超时获取锁的功能。它的语义是在指定的时间内如果获取到锁就返回true，获取不到则返回false。这种机制避免了线程无限期的等待锁释放。那么超时的功能是怎么实现的呢？我们还是用非公平锁为例来一探究竟。</p>
<p>还是调用了内部类里面的方法。我们继续向前探究：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">  <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">    doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的语义是：如果线程被中断了，那么直接抛出InterruptedException。如果未中断，先尝试获取锁，获取成功就直接返回，获取失败则进入doAcquireNanos。tryAcquire我们已经看过，这里重点看一下doAcquireNanos做了什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> \* 在有限的时间内去竞争锁</span></span><br><span class="line"><span class="comment"> \* <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// 起始时间</span></span><br><span class="line">  <span class="keyword">long</span> lastTime = System.nanoTime();</span><br><span class="line">  <span class="comment">// 线程入队</span></span><br><span class="line">  <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 又是自旋!</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 获取前驱节点</span></span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">      <span class="comment">// 如果前驱是头节点并且占用锁成功,则将当前节点变成头结点</span></span><br><span class="line">      <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        setHead(node);</span><br><span class="line">        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        failed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果已经超时,返回false</span></span><br><span class="line">      <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 超时时间未到,且需要挂起</span></span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">          nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">        <span class="comment">// 阻塞当前线程直到超时时间到期</span></span><br><span class="line">        LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">      <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">      <span class="comment">// 更新nanosTimeout</span></span><br><span class="line">      nanosTimeout -= now - lastTime;</span><br><span class="line">      lastTime = now;</span><br><span class="line">      <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="comment">//相应中断</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　doAcquireNanos的流程简述为：线程先入等待队列，然后开始自旋，尝试获取锁，获取成功就返回，失败则在队列里找一个安全点把自己挂起直到超时时间过期。这里为什么还需要循环呢？因为当前线程节点的前驱状态可能不是SIGNAL，那么在当前这一轮循环中线程不会被挂起，然后更新超时时间，开始新一轮的尝试。</p>
]]></content>
      <categories>
        <category>多线程</category>
        <category>多线程理论篇</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JOL使用</title>
    <url>/9fbd3b67.html</url>
    <content><![CDATA[<p>查看普通java对象的内部布局工具JOL(JAVA OBJECT LAYOUT)</p>
<p>使用此工具可以查看new出来的一个java对象的内部布局,以及一个普通的java对象占用多少字节。</p>
<span id="more"></span>

<h1 id="导入依赖或者jar包"><a href="#导入依赖或者jar包" class="headerlink" title="导入依赖或者jar包"></a>导入依赖或者jar包</h1><ul>
<li>可以选择导入pom依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jol/jol-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以使用jar包</p>
<p>地址：<a href="https://mvnrepository.com/artifact/org.openjdk.jol/jol-core/0.9">https://mvnrepository.com/artifact/org.openjdk.jol/jol-core/0.9</a></p>
</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/26 17:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JOL</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>打印：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           28 f2 5a 03 (00101000 11110010 01011010 00000011) (56291880)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>

<p>前面两行是java对象头的Mark Word共占8个字节,第三行是java对象头的Klass Pointer类指针,本来也是占8个字节,因JDK默认开启类指针压缩所以占4个字节,总共12个字节,又因12不能被8整除,所有最后又加了四个空字节.所以java中new一个空对象总共占16个字节.</p>
<p>涉及内容：jVM对象的内存布局，请看博客：</p>
]]></content>
      <categories>
        <category>多线程</category>
        <category>多线程理论篇</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>CAS</title>
    <url>/969d9481.html</url>
    <content><![CDATA[<p>CAS：compar and swap，是一种自旋锁</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210826103838080.png" alt="image-20210826103838080" style="zoom:33%;" />

<p>属于乐观锁，是解决多线程并行情况下使用锁造成性能损耗的一种机制，CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值。CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。</p>
<span id="more"></span>

<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>加入有三个线程，线程A读取内存中数据为0，然后i++，线程B读取内存中数据位0，然后i++，线程A运行比较慢，线程B把1写入内存，然后有一个线程C，读取内存中数据位1，进行i–操作，然后把0写入内存，这个时候线程A才运行完毕，然后读取内存中数据位0，认为没有发生修改，则把1写入数据。</p>
<p>这个时候线程A认为内存中0的数据没有修改，写入内存了，但是这个数据确实发生了修改。这就是ABA问题</p>
<p>解决方案：</p>
<ol>
<li>不管<ul>
<li>这个一个值，我不在在乎，你想改就改，我要的是最终的值</li>
</ul>
</li>
<li>添加版本<ul>
<li>这是一个引用，应用的地址没有发生改变，但是这个地址指向的对象内容可能已经改变了，这个时候添加版本号解决</li>
<li>在值上添加一个版本号，（可以是线程id）在比较的时候会比较值和版本号，如果这两个都一样，则会赋值</li>
</ul>
</li>
</ol>
<p>CAS在java中的底层实现是native，是用的C++实现的（下面为linuxX86操作系统的实现）</p>
<ol>
<li><p>Unsafe_CompareAnSwapINT</p>
</li>
<li><p>调用Atomic的cmpxchg</p>
</li>
<li><p>调用汇编码<code>__asm__</code></p>
</li>
<li><p>调用cmpxchg1，（如果是多核cpu执行这个方法会添加lock）</p>
</li>
<li><p>最终实现： <code>lock cmpxchg 指令</code></p>
<p>在多核cpu情况下，如果没有加锁，执行还不是原子性的，有可能被其他核干扰，所以添加了lock解决，总线嗅探（Bus Snooping）技术。这个策略总线嗅探，本质上就是把所有的读写请求都通过总线（Bus）广播给所有的CPU核心，然后让各个核心去“嗅探”这些请求，再根据本地的情况进行响应。</p>
</li>
</ol>
<p> synchronized和violate的底层实现都是<code>lock cmpxchg 指令</code></p>
<p>硬件：lock指定在执行后面指令的时候锁定一个北桥信号（不采用锁总线的方式）</p>
<p>推荐文章：</p>
<p>cpu底层cas原理：<a href="https://blog.csdn.net/weixin_30691871/article/details/100004896">https://blog.csdn.net/weixin_30691871/article/details/100004896</a></p>
]]></content>
      <categories>
        <category>多线程</category>
        <category>多线程理论篇</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>百万数据快速插入数据库</title>
    <url>/859f2ea9.html</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/zl1zl2zl3/article/details/105007492?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control">https://blog.csdn.net/zl1zl2zl3/article/details/105007492?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一直有一种说法：<strong>批量插入大量数据到MySQL数据库，不要使用Mybatis、Hibernate之类的ORM框架</strong>，原因一般都是说<strong>性能不好</strong>，至于为什么不好好像没几个人能讲清楚的。</p>
<p>批量插入大量数据最优的方式是什么？网上也是众说纷纭。不如自己动手测试一下吧！</p>
<h1 id="场景介绍"><a href="#场景介绍" class="headerlink" title="场景介绍"></a>场景介绍</h1><p>前几天公司项目进行压力测试，测试某个功能在大数据量（千万级）的情况下是否能够正常运行，可是项目还没有正式上线运营，数据库里只有少量开发时用的假数据。</p>
<p>没有数据怎么测试啊？这可愁坏测试的小姐姐们了，向我求助让我尽快往数据库中导入1000万数据给她们测试用。</p>
<p>于是接到任务：<strong>快速往MySQL数据库中导入1000万数据</strong></p>
<h1 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h1><p>啥也不说了，抓紧时间开搞！</p>
<p><strong>首先交代一下电脑环境：</strong></p>
<ul>
<li>操作系统：WIN10（专业版）</li>
<li>开发工具：IntelliJ IDEA Ultimate（2019.2.1）</li>
<li>项目框架：Spring Boot（2.2.5.RELEASE）</li>
<li>数据库：MySQL（5.7.27）</li>
</ul>
<p><strong>项目配置步骤：</strong></p>
<p>1、使用IDEA的Spring Initializr插件新建Spring Boot的项目，打开pom.xml，添加一些必要的Maven依赖，主要是mybatis-spring-boot-starter和mysql-connector-java；</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AxLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzI5MjlmYzEwMTU2ZjRjZTQ4MWUwOTQ1ZGFhZWVmZDJh?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p>2、MySQL中新建一张user表，为了方便演示只保留id、昵称、年龄3个字段，建表语句；</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2VmMzhmZTE1NTE3YTQ5NTA5MDhmMzczYWNlNTMwY2Rl?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p>3、再次打开pom.xml文件，添加mybatis generator插件用于自动生成mapper映射文件；</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2U5ZjIwZDQ3ZTljNjQwZmFiYWIxOGFhMGE2OWU3ZDhk?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p>4、上一步添加了mybatis generator插件之后还不能直接使用，还需要在项目resources目录下新建一个配置文件generatorConfig.xml，里面主要需要配置数据库连接信息、Model文件生成目录、Mapper文件生成目录、以及xml文件生成目录；</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AxLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2U1ZDQ5MzFhOWVhMTRmYmY4MzIwYmI0MTUyNzZmNWM1?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p>5、打开resources目录下的application.properties（或是application.yml）文件，添加一下mybatis相关配置和项目数据库连接配置；</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3A5LnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzJjNDI3OWRkZmRiNTQ3OTA5ZGQ3ZGI4NDFkODIxN2U0?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p>6、展示一下项目的完整结构</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3A5LnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzQyMWNkMDkyNTYxNTQxYzQ5ZDNhYjcxOGI3OGZhN2Nj?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<h1 id="Mybatis为什么慢？"><a href="#Mybatis为什么慢？" class="headerlink" title="Mybatis为什么慢？"></a>Mybatis为什么慢？</h1><p>首先我们用Mybatis来测试一下，看看插入1000万条数据需要多长时间。</p>
<p><strong>实现步骤：</strong></p>
<p>1、在UserMapper.java和UserMapper.xml文件中实现批量插入方法；</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzMwMzU3ZmVhNmMwZTQwZTk4YTAxOGU0MWNjOTE3MzY3?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p>2、新建一个Test测试类实现随机生成1000万用户记录，并调用上步已经实现的批量插入方法将数据插入到MySQL数据库；</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AxLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzYwNjI3OGUzY2QzYzRlNDA5YmI4ZTUyYzAzMmIxZmQ1?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p>接下来就是正式测试了，没想到中间出了不少问题，在这里说明一下并附上解决方案。</p>
<blockquote>
<p>问题一：Java堆内存爆了！</p>
</blockquote>
<p><strong>原因分析：</strong>由于要生成1000万条用户记录，需要申请大量Java的堆内存，已经超出JVM设置的最大堆内存大小，导致<strong>OutOfMemoryError</strong>报错：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AxLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzY3MThjYWM4YzRhMDQ0ZTY4NzFmYTYxZGNkNGNiOGZm?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p><strong>解决办法：</strong>增加堆内存。</p>
<p>JVM设置堆内存有两个参数：</p>
<ol>
<li><strong>-Xms</strong> 用于设置堆内存初始值，一般建议设置为和最大值一样；</li>
<li><strong>-Xmx</strong> 用于设置堆内存最大值，默认值为物理内存的1/4；</li>
</ol>
<p>因为我的电脑是32G内存，也就是说默认最大堆内存有8G，8G都不够的话，那我直接来个20G试试，IDEA菜单栏依次打开Run -&gt; Edit Configurations：</p>
<p><strong>修改步骤：</strong></p>
<ol>
<li>选中我们的测试类</li>
<li>在右边找到VM options选项，输入-Xms20480m -Xmx20480m</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzZlZGQwYjQ2OGJkMzRlMGRhNzQ5NWU3YWJmMDYxMjVl?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<blockquote>
<p>问题二：MySQL报错：Packet for query is too large</p>
</blockquote>
<p><strong>原因分析：</strong>因为发送到MySQL的数据量过大，超出了设置的最大值，导致报错：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AxLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2I5YTJjZmRlZjVjNjQwYzE4MDg3MGIwMDQ2N2UyNDE3?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p><strong>解决方案：</strong>修改MySQL服务器max_allowed_packet属性。</p>
<p><strong>修改步骤：</strong></p>
<ol>
<li><p>直接在MySQL安装目录下找到my.ini文件，在[mysqld]下面添加一行<strong>max_allowed_packet = 4G</strong></p>
</li>
<li><p>通过MySQL客户端工具修改，这里以我常用的MySQL Workbench客户端来修改，菜单栏找到Server -&gt; Options File，点击切换Networking标签：</p>
</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3A5LnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2M3NTI3MjU4N2Q0YTQ2OGU4MTViODdlM2QwODU0Nzc4?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<blockquote>
<p>Tip：不论哪种方式，修改完都要记得重启MySQL，否则修改不生效哦。</p>
</blockquote>
<p>我们来看下执行结果：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzFlY2Y3NWUxODU2NzQzOTY4NmQ0MmVmNDQxZjIxODU4?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p><strong>结果：</strong></p>
<p>使用Mybatis插入1000万条数据到MySQL数据库共花费了<strong>199.8秒</strong>！</p>
<p>这结果是快还是慢？我们来具体分析一下耗时分布情况。</p>
<p><strong>分析：</strong></p>
<p>方法：</p>
<p>JDBC驱动中有一个profileSQL属性，可以跟踪记录SQL执行时间，附上官方文档介绍：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2FiMGNmOWVlMDBmZjQxMGRhMDIwZTExN2E1NzI2NTI4?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p>所以我们需要将数据库连接加上profileSQL=true属性。</p>
<p>再次看下执行结果：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AxLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzk1Zjg3YTg1Y2M3MDQyN2E5ZjQ4NzFmZjYxNTY1NjUy?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p>其中，duration指的是SQL执行的时间，也就是说<strong>MySQL服务器执行具体SQL语句的时间其实只有82.3秒，</strong>我们上面统计到Mybatis插入1000万条数据花了近200秒的时间，那么<strong>这中间的100多秒都干嘛去了？</strong></p>
<p>分析控制台输出的日志之后我发现了蹊跷所在：从程序调用Mybatis的批量插入方法开始，到MySQL服务器执行SQL，这中间正好差了100多秒，会是巧合吗？</p>
<p>打断点Debug追踪到Mybatis解析SQL语句的方法：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2JiYjkzMTQwMjUwYTQxYmVhMzE5NWI0MTQ3YmFkOTMz?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p>这parse方法首先会读取我们xml文件里的SQL模版拿到参数及参数类型信息，拼接生成SQL语句。</p>
<p><strong>每条数据循环一次，那1000W条数据就要循环解析1000万次，不慢才怪！</strong></p>
<h1 id="JdbcTemplate让我眼前一亮"><a href="#JdbcTemplate让我眼前一亮" class="headerlink" title="JdbcTemplate让我眼前一亮"></a>JdbcTemplate让我眼前一亮</h1><p>接下来使用Spring框架的JdbcTemplate来测试一下。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li>同样的我们新建一个测试类，并用JdbcTemplate实现一个批量插入方法；</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2FmNDQyOTBkYTVjNjRjMTg4YjRhY2IzYWZiNGViMGZi?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p>接下来就可以开始测试了，果然中间又出现了了问题。</p>
<blockquote>
<p>问题一：调用JdbcTemplate的batchUpdate批量操作方法，结果却一条条的插数据？</p>
</blockquote>
<p>首先看下控制台输出日志：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzI0NGMzMDJkMTIzNTQ2MGViNzNlMTY1OWI2MWM4NmEw?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p>可以看到JdbcTemplate是将我们的数据一条条的发送到MySQL服务器的，每个插入耗时1毫秒，那么1秒钟可以插入1000条记录，那么1000万条数据就需要10000秒，大约需要2.78个小时。</p>
<p><strong>原因分析：</strong>JDBC驱动默认不支持批量操作，会将SQL语句分拆再一条条发往MySQL服务器执行，打断点跟踪一下代码，看看是不是这样：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AxLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2U3ZjA3MGExMmZhNDRjN2I4ZmJkZWVmNDJhYTVlYzlk?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p>分析一下代码：</p>
<ul>
<li><p>首先执行步骤1判断rewriteBatchedStatements属性，为false的话直接执行步骤5的逻辑：串行执行SQL语句，也就是一条条顺序执行；</p>
</li>
<li><p>如果rewriteBatchedStatements为true，那么首先会执行步骤2：判断是否为insert语句，结果为true则会改写SQL执行批量插入操作；</p>
</li>
<li><p>如果不是insert语句，再继续根据JDBC驱动版本以及数据量大小判断是否需要执行批量操作；</p>
</li>
</ul>
<blockquote>
<p>Tip：对于非insert的批量操作语句，如果数据量小于3条，那也只会一条条顺序执行，不会进行合并批量执行。</p>
</blockquote>
<p>附上rewriteBatchedStatements官方文档：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AxLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2VjZGRiMTBlYzA3ZjRiZWI5MTQwY2NiZGY0ZTEwYzM2?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p>大概看了一下，跟我们上面分析的一样，标示是否让JDBC驱动使用批量模式去改写SQL语句。</p>
<p><strong>解决方案：</strong>数据库连接上加上rewriteBatchedStatements=true属性，开启批量操作支持。</p>
<p>再次看下执行结果：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzIxNzNhMjU2ODkyNDQyNjhiNjEyZGQyNWJkY2ZkYWZi?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p><strong>结果：</strong></p>
<p>使用JdbcTemplate插入1000万条数据到MySQL数据库共花费了<strong>80.1秒</strong>！</p>
<p><strong>分析：</strong></p>
<p>一开始由于没有开启批量操作支持，所以导致MySQL只能一条条插入数据，原因在于我对JDBC驱动不够了解，看来以后还得加强学习。</p>
<p>开启批量操作支持后，通过日志可以观察到真正的SQL执行时间只有67.9秒，但整个插入操作用了80.1秒，中间差的10多秒中应该就是消耗在了改写SQL语句上了。</p>
<p>总得来说，JdbcTemplate批量插入大量数据的效率还不错，让我有眼前一亮的感觉。</p>
<h1 id="原生JDBC就是快啊！"><a href="#原生JDBC就是快啊！" class="headerlink" title="原生JDBC就是快啊！"></a>原生JDBC就是快啊！</h1><p>早有耳闻批量插入大量数据必须使用原生JDBC，百闻不如一见，接下来我就使用原生JDBC的方式来测试一下。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li>同样的，我们新建一个测试类，并使用原生JDBC的方式实现一个批量插入方法；</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AxLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2U0ZDgzODg2ZGVhMTRjYmViNWE2NDY2YjJjOTkzYWE0?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p>接下来就可以测试了，别担心，这次肯定不会再出问题了。</p>
<p>来看下执行结果：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3A5LnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzYyYjdmM2E4NDI5ZDQ1MmFiYzM3OGNmOWJhZTZjZjNi?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p><strong>结果：</strong>使用原生JDBC的方式插入1000万条数据到MySQL数据库共花费了<strong>58.9秒</strong>！</p>
<p><strong>分析：</strong></p>
<p>原生JDBC写起来还是既简单又舒适啊，都多少年没写过了，但是<strong>越是简单的东西它越好用。</strong></p>
<p>通过输出日志，我们可以看到整个方法执行时间为58.9秒，而SQL真正的执行时间为46.8秒，中间同样相差了10多秒，同样也是花在了改写SQL语句上，这一结果正好与上面JdbcTemplate的执行结果互相佐证，证明了我们的分析是正确的。</p>
<h1 id="存储过程行不行？"><a href="#存储过程行不行？" class="headerlink" title="存储过程行不行？"></a>存储过程行不行？</h1><p>最后使用存储过程的方式来试一下，说实话工作以来很少写存储过程，只好临时恶补了一波知识。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li>首先编写批量插入的存储过程，功能其实很简单，接收一个外部传入的表示循环次数的参数，进行循环插入数据；</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AxLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2Y1YWJjYzQ2ZTBkZDQwYWI5MmI0M2U1NTQwMzFiMjZi?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p>接下来我们调用存储过程，执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL batchInsert(10000000);</span><br></pre></td></tr></table></figure>

<p>等待执行完成，看下耗时情况：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzZmMjg2NTRlNTQwMDQzZjRiZmFiZjE2YWZhOGYxMzNi?x-oss-process=image/format,png" alt="如何快速向数据库插1000万数据？4种方法对比，它简单却速度最快"></p>
<p><strong>结果：</strong></p>
<p>调用存储过程向MySQL数据库中批量插入1000万数据需要<strong>141.1秒</strong>。</p>
<p><strong>分析：</strong></p>
<p>存储过程需要141.1秒的时间我还是比较惊讶的，本来我对存储过程还是比较期待的。</p>
<p>仔细想想，其实存储过程用在这个场景并没有发挥出它的优势，时间长点也不奇怪。</p>
<p>为什么这么说？</p>
<p>首先我们来看看存储过程的一些特点：</p>
<ol>
<li>可以封装一些复杂的业务逻辑，外部直接调用存储过程即可；</li>
<li>存储过程只在创建时编译一次，以后每次执行存储过程都不需再重新编译，使用存储过程可提高执行速度；</li>
<li>将操作直接放到数据库端执行，可以减少客户端与服务端进行网络通讯开销，提高通信效率；</li>
</ol>
<p>其次我们再来看看存储过程用在我们场景是否合适：</p>
<ol>
<li>我们使一次性提交所有数据，所以不存在多次通信增加耗时的操作，在这里存储过程的优势没有发挥出来；</li>
<li>在存储过程的insert语句中，我们使用了concat函数来拼接字符串，函数运算会降低SQL执行效率；</li>
</ol>
<p>所以说存储过程在我们这个业务场景并没有发挥出它的优势。</p>
<h1 id="越简单越快"><a href="#越简单越快" class="headerlink" title="越简单越快"></a>越简单越快</h1><p>面对<strong>快速往MySQL数据库中导入1000万数据</strong>这个问题，我们通过<strong>Mybatis</strong>、<strong>JdbcTemplate</strong>、<strong>原生JDBC</strong>以及<strong>存储过程</strong>4种方式分别进行测试，得出了最终结果：</p>
<p>插入速度：<strong>原生JDBC &gt; JdbcTemplate &gt; 存储过程 &gt; Mybatis</strong></p>
<p><strong>结果分析：</strong></p>
<p>Mybatis由于封装程度较高，底层有一个SQL模版解析和SQL拼接的过程，所以导致速度较慢；</p>
<p>存储过程一来由于本应用场景不太适合没有发挥出优势，二来由于SQL语句中加入了函数运算拖累了执行效率；</p>
<p>JdbcTemplate是Spring框架为了方便开发者调用对原生JDBC的一个轻度封装，虽然有点小插曲，但整体来看插入效率还可以；</p>
<p>原生JDBC是最最最基础的插入方式了，每个人刚学Java的时候应该都学过，没有过多花里胡哨的封装，简单实用。</p>
<p><strong>总结：</strong></p>
<p>越简单越实用，<strong>原生JDBC</strong>第一名实至名归！</p>
]]></content>
      <categories>
        <category>多线程</category>
        <category>多线程实战篇</category>
      </categories>
      <tags>
        <tag>多线程实战</tag>
      </tags>
  </entry>
  <entry>
    <title>lua基础教程2-基础语法</title>
    <url>/ef2fc5a3.html</url>
    <content><![CDATA[<h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h1><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>推荐菜鸟教程或者W3Cschool</p>
<p><a href="https://www.w3cschool.cn/lua/lua-basic-syntax.html">https://www.w3cschool.cn/lua/lua-basic-syntax.html</a></p>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="交互式编程"><a href="#交互式编程" class="headerlink" title="交互式编程"></a>交互式编程</h2><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(<span class="string">&quot;Hello World！&quot;</span>)</span><br><span class="line">Hello World！</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>

<h2 id="脚本式编程"><a href="#脚本式编程" class="headerlink" title="脚本式编程"></a>脚本式编程</h2><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">#!/usr/<span class="keyword">local</span>/bin/lua</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World！&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>两个减号是单行注释:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--</span><br></pre></td></tr></table></figure>

<h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--[[</span><br><span class="line"> 多行注释</span><br><span class="line"> 多行注释</span><br><span class="line"> --]]</span><br></pre></td></tr></table></figure>

<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>Lua 标示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上0个或多个字母，下划线，数字（0到9）。</p>
<p>最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的。</p>
<p>Lua 不允许使用特殊字符如 @, $, 和 % 来定义标示符。 Lua 是一个区分大小写的编程语言。因此在 Lua 中 W3c 与 w3c 是两个不同的标示符。以下列出了一些正确的标示符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mohd         zara      abc     move_name    a_123</span><br><span class="line">myname50     _temp     j       a23b9        retVal</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><p>以下列出了 Lua 的保留关键字。保留关键字不能作为常量或变量或其他用户自定义标示符：</p>
<table>
<thead>
<tr>
<th>and</th>
<th>break</th>
<th>do</th>
<th>else</th>
</tr>
</thead>
<tbody><tr>
<td>elseif</td>
<td>end</td>
<td>false</td>
<td>for</td>
</tr>
<tr>
<td>function</td>
<td>if</td>
<td>in</td>
<td>local</td>
</tr>
<tr>
<td>nil</td>
<td>not</td>
<td>or</td>
<td>repeat</td>
</tr>
<tr>
<td>return</td>
<td>then</td>
<td>true</td>
<td>until</td>
</tr>
<tr>
<td>while</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。</p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>在默认情况下，变量总是认为是全局的。</p>
<p>全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：nil。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(b)</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">&gt; b=<span class="number">10</span></span><br><span class="line">&gt; <span class="built_in">print</span>(b)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>如果你想删除一个全局变量，只需要将变量赋值为nil。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">b = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(b)      <span class="comment">--&gt; nil</span></span><br></pre></td></tr></table></figure>

<p>这样变量b就好像从没被使用过一样。换句话说, 当且仅当一个变量不等于nil时，这个变量即存在。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- #!/usr/local/bin/lua开头，指定lua的解释器</span></span><br><span class="line"><span class="comment">-- 加上 # 号标记解释器会忽略它</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 两个中线时单行注释</span></span><br><span class="line"><span class="comment">-- 分号，加不加都可以。类似js</span></span><br><span class="line"><span class="comment">--  print控制天输出</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- lua hello.lua 控制台运行lua文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 错误命名标识符</span></span><br><span class="line"><span class="comment">-- local a@ = 1</span></span><br><span class="line"><span class="comment">-- local then = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正确命名标识符</span></span><br><span class="line"><span class="keyword">local</span> a_123 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment">-- 输出为nil</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Lua是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。</p>
<p>Lua中有8个基本类型分别为：nil、boolean、number、string、userdata、function、thread和table。</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">nil</td>
<td align="left">这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">包含两个值：false和true。</td>
</tr>
<tr>
<td align="left">number</td>
<td align="left">表示双精度类型的实浮点数</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">字符串由一对双引号或单引号来表示</td>
</tr>
<tr>
<td align="left">function</td>
<td align="left">由 C 或 Lua 编写的函数</td>
</tr>
<tr>
<td align="left">userdata</td>
<td align="left">表示任意存储在变量中的C数据结构</td>
</tr>
<tr>
<td align="left">thread</td>
<td align="left">表示执行的独立线路，用于执行协同程序</td>
</tr>
<tr>
<td align="left">table</td>
<td align="left">Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。</td>
</tr>
</tbody></table>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">---</span></span><br><span class="line"><span class="comment">--- Generated by EmmyLua(https://github.com/EmmyLua)</span></span><br><span class="line"><span class="comment">--- Created by Think.</span></span><br><span class="line"><span class="comment">--- DateTime: 2021/9/2 10:21</span></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;Hello world&quot;</span>))      <span class="comment">--&gt; string</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">10.4</span>*<span class="number">3</span>))             <span class="comment">--&gt; number</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">print</span>))              <span class="comment">--&gt; function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>))               <span class="comment">--&gt; function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">true</span>))               <span class="comment">--&gt; boolean</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">nil</span>))                <span class="comment">--&gt; nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(X))                      <span class="comment">--&gt; nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(X)))            <span class="comment">--&gt; string</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">控制台打印：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">lua.exe 数据类型.lua</span></span><br><span class="line"><span class="comment">string</span></span><br><span class="line"><span class="comment">number</span></span><br><span class="line"><span class="comment">function</span></span><br><span class="line"><span class="comment">function</span></span><br><span class="line"><span class="comment">boolean</span></span><br><span class="line"><span class="comment">nil</span></span><br><span class="line"><span class="comment">nil</span></span><br><span class="line"><span class="comment">string</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure>

<h2 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h2><p>nil 类型表示一种没有任何有效值，它只有一个值 – nil，例如打印一个没有赋值的变量，便会输出一个 nil 值：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>对于全局变量和 table，nil 还有一个”删除”作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">tab1 = &#123; key1 = <span class="string">&quot;val1&quot;</span>, key2 = <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span> &#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(tab1) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k .. <span class="string">&quot; - &quot;</span> .. v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">tab1.key1 = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(tab1) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k .. <span class="string">&quot; - &quot;</span> .. v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">控制台打印：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 - val3</span></span><br><span class="line"><span class="comment">key1 - val1 第一次有这个值，置空后没有这个值了</span></span><br><span class="line"><span class="comment">key2 - val2</span></span><br><span class="line"><span class="comment">1 - val3</span></span><br><span class="line"><span class="comment">key2 - val2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>使用 nil 作比较时应该加上双引号：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">type</span>(X)</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">&gt; <span class="built_in">type</span>(X)==<span class="literal">nil</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; <span class="built_in">type</span>(X)==<span class="string">&quot;nil&quot;</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h2 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h2><p>boolean 类型只有两个可选值：true（真） 和 false（假），<strong>Lua 把 false 和 nil 看作是”假”，其他的都为”真”（0也是真）:</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">true</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">false</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">nil</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">if</span> <span class="literal">false</span> <span class="keyword">or</span> <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;至少有一个是 true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;false 和 nil 都为 false&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数字 0 是 true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数字 0 为 false&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">控制台打印：</span></span><br><span class="line"><span class="comment">lua.exe 数据类型.lua</span></span><br><span class="line"><span class="comment">boolean</span></span><br><span class="line"><span class="comment">boolean</span></span><br><span class="line"><span class="comment">nil</span></span><br><span class="line"><span class="comment">number</span></span><br><span class="line"><span class="comment">false 和 nil 都为 false</span></span><br><span class="line"><span class="comment">数字 0 是 true</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="number"><a href="#number" class="headerlink" title="number"></a>number</h2><p>Lua 默认只有一种 number 类型 – double（双精度）类型（默认类型可以修改 luaconf.h 里的定义），以下几种写法都被看作是 number 类型：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">2.2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">0.2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">2e+1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">0.2e-1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">7.8263692594256e-06</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">number</span></span><br><span class="line"><span class="comment">number</span></span><br><span class="line"><span class="comment">number</span></span><br><span class="line"><span class="comment">number</span></span><br><span class="line"><span class="comment">number</span></span><br><span class="line"><span class="comment">number</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li><p>字符串由一对双引号或单引号来表示。</p>
</li>
<li><p>也可以用 2 个方括号 “[[]]” 来表示”一块”字符串。</p>
</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">string1 = <span class="string">&quot;this is string1&quot;</span></span><br><span class="line">string2 = <span class="string">&#x27;this is string2&#x27;</span></span><br><span class="line">html = <span class="string">[[</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;a href=&quot;//www.lvxiaoyi.top/&quot;&gt;吕小医&amp;博客&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(string1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(string2))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(html))</span><br><span class="line"><span class="built_in">print</span>(html)</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">string</span></span><br><span class="line"><span class="comment">string</span></span><br><span class="line"><span class="comment">string</span></span><br><span class="line"><span class="comment">&lt;html&gt;</span></span><br><span class="line"><span class="comment">&lt;head&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="comment">&lt;body&gt;</span></span><br><span class="line"><span class="comment">    &lt;a href=&quot;//www.lvxiaoyi.top/&quot;&gt;吕小医&amp;博客&lt;/a&gt;</span></span><br><span class="line"><span class="comment">&lt;/body&gt;</span></span><br><span class="line"><span class="comment">&lt;/html&gt;</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;2&quot;</span> + <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;2&quot;</span> + <span class="string">&quot;6&quot;</span>).</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure></li>
<li><p>字符串连接使用的是 .. ,而不是用的+</p>
</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;lvxiaoyi&quot;</span> + <span class="string">&quot;.top&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">lua.exe: ��������.lua:1: attempt to perform arithmetic on a string value</span></span><br><span class="line"><span class="comment">stack traceback:</span></span><br><span class="line"><span class="comment">	��������.lua:1: in main chunk</span></span><br><span class="line"><span class="comment">	[C]: ?</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;lvxiaoyi&quot;</span> .. <span class="string">&quot;.top&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">lvxiaoyi.top</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure>

<h2 id="table-表"><a href="#table-表" class="headerlink" title="table(表)"></a>table(表)</h2><p>在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。也可以在表里添加一些数据，直接初始化表:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建一个空的 table</span></span><br><span class="line"><span class="keyword">local</span> tbl1 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 直接初始表</span></span><br><span class="line"><span class="keyword">local</span> tbl2 = &#123;<span class="string">&quot;lvxiaoyi.top&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(tbl1))</span><br><span class="line"><span class="built_in">print</span>(tbl1)</span><br><span class="line"><span class="built_in">print</span>(tbl2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, val <span class="keyword">in</span> <span class="built_in">pairs</span>(tbl2) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>( key,val)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">table</span></span><br><span class="line"><span class="comment">table: 00CC99A0</span></span><br><span class="line"><span class="comment">table: 00CC99C8</span></span><br><span class="line"><span class="comment">1	lvxiaoyi.top</span></span><br><span class="line"><span class="comment">2	pear</span></span><br><span class="line"><span class="comment">3	orange</span></span><br><span class="line"><span class="comment">4	grape</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure>

<p>Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字或者是字符串。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">a[<span class="string">&quot;key&quot;</span>] = <span class="number">22</span></span><br><span class="line">key = <span class="string">&quot;blog&quot;</span></span><br><span class="line">a[key] = <span class="string">&quot;lvxioayi&quot;</span></span><br><span class="line">a[key] = a[key] .. <span class="string">&quot;.top&quot;</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k .. <span class="string">&quot; : &quot;</span> .. v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">key : 22</span></span><br><span class="line"><span class="comment">blog : lvxioayi.top</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure>

<p>不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> tbl2 = &#123;<span class="string">&quot;lvxiaoyi.top&quot;</span>, <span class="string">&quot;blog&quot;</span>, <span class="string">&quot;study&quot;</span>, <span class="string">&quot;lvxiaoyi&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, val <span class="keyword">in</span> <span class="built_in">pairs</span>(tbl2) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Key&quot;</span>, key)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">Key	1</span></span><br><span class="line"><span class="comment">Key	2</span></span><br><span class="line"><span class="comment">Key	3</span></span><br><span class="line"><span class="comment">Key	4</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure>

<p>table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。</p>
]]></content>
      <categories>
        <category>lua</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>lua基础教程1-环境安装</title>
    <url>/b35e3780.html</url>
    <content><![CDATA[<h1 id="什么是lua"><a href="#什么是lua" class="headerlink" title="什么是lua"></a>什么是lua</h1><p>Lua 是由巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组于1993年开发的一种轻量、小巧的脚本语言，用标准 C 语言编写，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p>
<p>官网：<a href="http://www.lua.org/">http://www.lua.org/</a></p>
<p>Redis 在 2.6 版本中推出了脚本功能，允许开发者将 Lua 语言编写的脚本传到 Redis 中执行。使用 Lua 脚本的优点有如下几点:</p>
<ul>
<li><p>减少网络开销：本来需要多次请求的操作，可以一次请求完成，从而节约网络开销；</p>
</li>
<li><p>原子操作：Redis 会将整个脚本作为一个整体执行，中间不会执行其它命令；</p>
</li>
<li><p>复用：客户端发送的脚本会存储在 Redis 中，从而实现脚本的复用。</p>
</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="基础lua环境安装"><a href="#基础lua环境安装" class="headerlink" title="基础lua环境安装"></a>基础lua环境安装</h2><h3 id="lua环境下载"><a href="#lua环境下载" class="headerlink" title="lua环境下载"></a>lua环境下载</h3><p>github项目地址：<a href="https://github.com/rjpcomputing/luaforwindows/releases">https://github.com/rjpcomputing/luaforwindows/releases</a></p>
<p>github下载地址：<a href="https://github.com/rjpcomputing/luaforwindows/releases/download/v5.1.5-52/LuaForWindows_v5.1.5-52.exe">https://github.com/rjpcomputing/luaforwindows/releases/download/v5.1.5-52/LuaForWindows_v5.1.5-52.exe</a></p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902092517785.png" alt="image-20210902092517785" style="zoom:50%;" />

<h3 id="lua环境安装"><a href="#lua环境安装" class="headerlink" title="lua环境安装"></a>lua环境安装</h3><p>安装说明：</p>
<p>Lua for Windows安装依赖于MSVC++ 2005运行时库，如果没有安装Lua for Windows安装目录自动下载运行时并安装；</p>
<ol>
<li>双击下载的exe文件</li>
</ol>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902093357173.png" alt="image-20210902093357173" style="zoom:50%;" />

<ol start="2">
<li>选择安装目录</li>
</ol>
<p>一般安装到D盘，直接把C改成D就可以</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902093430965.png" alt="image-20210902093430965" style="zoom:50%;" />

<ol start="3">
<li><p>选择安装组件（默认全选）</p>
<p>lua为核心苦，必须</p>
<p>DcliTe是ide，就是记事本编译器</p>
<p>剩下的就是一些module和document，因为本身也不大，默认全选</p>
</li>
</ol>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902093446343.png" alt="image-20210902093446343"></p>
<ol start="3">
<li><p>之后一直下一步</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902093627097.png" alt="image-20210902093627097" style="zoom:50%;" />



<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902093643267.png" alt="image-20210902093643267" style="zoom:50%;" /></li>
</ol>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902093711705.png" alt="image-20210902093711705"></p>
<ol start="4">
<li><p>安装完成</p>
</li>
<li><p>检验</p>
</li>
</ol>
<p>注意：这一步有延迟，可以安装完成后等待半分钟在检验</p>
<ul>
<li><code>win + R</code>命令</li>
<li><code>cmd</code>命令</li>
<li><code>lua</code>命令</li>
<li><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902093028533.png" alt="image-20210902093028533"></li>
</ul>
<h2 id="IDE环境"><a href="#IDE环境" class="headerlink" title="IDE环境"></a>IDE环境</h2><h3 id="EmmyLua插件基于idea"><a href="#EmmyLua插件基于idea" class="headerlink" title="EmmyLua插件基于idea"></a>EmmyLua插件基于idea</h3><p><a href="https://github.com/EmmyLua/IntelliJ-EmmyLua">https://github.com/EmmyLua/IntelliJ-EmmyLua</a></p>
<p><a href="https://emmylua.github.io/zh_CN/">https://emmylua.github.io/zh_CN/</a></p>
<h3 id="LDT-基于eclipse"><a href="#LDT-基于eclipse" class="headerlink" title="LDT 基于eclipse"></a>LDT 基于eclipse</h3><p><a href="https://www.eclipse.org/ldt/">https://www.eclipse.org/ldt/</a></p>
<p>本次使用的java的idea编译器，直接安装EmmyLua插件，安装后重启</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902085450831.png" alt="image-20210902085450831" style="zoom:67%;" />

<h1 id="创建第一个lua项目"><a href="#创建第一个lua项目" class="headerlink" title="创建第一个lua项目"></a>创建第一个lua项目</h1><h2 id="idea创建项目"><a href="#idea创建项目" class="headerlink" title="idea创建项目"></a>idea创建项目</h2><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902094157023.png" alt="image-20210902094157023"></p>
<h2 id="创建lua项目"><a href="#创建lua项目" class="headerlink" title="创建lua项目"></a>创建lua项目</h2><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902094233389.png" alt="image-20210902094233389" style="zoom: 67%;" />



<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902094312684.png" alt="image-20210902094312684" style="zoom:67%;" />



<h2 id="创建lua文件"><a href="#创建lua文件" class="headerlink" title="创建lua文件"></a>创建lua文件</h2><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902094359276.png" alt="image-20210902094359276" style="zoom:67%;" />



<p>然后输入文件名hello</p>
<h2 id="第一个项目"><a href="#第一个项目" class="headerlink" title="第一个项目"></a>第一个项目</h2><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902094508410.png" alt="image-20210902094508410" style="zoom: 80%;" />



<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>右键</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902094714491.png" alt="image-20210902094714491" style="zoom:67%;" />

<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902094809680.png" alt="image-20210902094809680" style="zoom:67%;" />



<h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902094845809.png" alt="image-20210902094845809"></p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/niuba123456/article/details/81197585">https://blog.csdn.net/niuba123456/article/details/81197585</a></p>
<p><a href="https://blog.csdn.net/weixin_41611450/article/details/104507532">https://blog.csdn.net/weixin_41611450/article/details/104507532</a></p>
]]></content>
      <categories>
        <category>lua</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm中对象的内存布局</title>
    <url>/561c47f9.html</url>
    <content><![CDATA[<h1 id="对象的创建、内存布局和访问定位"><a href="#对象的创建、内存布局和访问定位" class="headerlink" title="对象的创建、内存布局和访问定位"></a>对象的创建、内存布局和访问定位</h1><hr>
<h2 id="1-对象创建"><a href="#1-对象创建" class="headerlink" title="1. 对象创建"></a>1. 对象创建</h2><ul>
<li>在开发使用时，创建 <code>Java</code> 对象仅仅只是是通过关键字<code>new</code>：</li>
</ul>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A()；</span><br></pre></td></tr></table></figure>

<ul>
<li>可是 <code>Java</code>对象在虚拟机中创建则是相对复杂。今天，我将详解<code>Java</code>对象在虚拟机中的创建过程</li>
</ul>
<blockquote>
<p>限于普通对象，不包括数组和Class对象等</p>
</blockquote>
<h3 id="1-1-创建过程"><a href="#1-1-创建过程" class="headerlink" title="1.1 创建过程"></a>1.1 创建过程</h3><p>当遇到关键字<code>new</code>指令时，Java对象创建过程便开始，整个过程如下：</p>
<img src="https://upload-images.jianshu.io/upload_images/944365-2db1b11a4cb98f1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/290/format/webp" alt="img"  />

<p>Java对象创建过程</p>
<p>下面我将对每个步骤进行讲解。</p>
<h3 id="步骤1：类加载检查"><a href="#步骤1：类加载检查" class="headerlink" title="步骤1：类加载检查"></a>步骤1：类加载检查</h3><ol>
<li>检查 该<code>new</code>指令的参数 是否能在 常量池中 定位到一个类的符号引用</li>
<li>检查 该类符号引用 代表的类是否已被加载、解析和初始化过</li>
</ol>
<blockquote>
<p>如果没有，需要先执行相应的类加载过程</p>
</blockquote>
<h4 id="关于类加载请看文章："><a href="#关于类加载请看文章：" class="headerlink" title="关于类加载请看文章："></a>关于类加载请看文章：</h4><hr>
<h3 id="步骤2：为对象分配内存"><a href="#步骤2：为对象分配内存" class="headerlink" title="步骤2：为对象分配内存"></a>步骤2：为对象分配内存</h3><ul>
<li>虚拟机将为对象分配内存，即把一块确定大小的内存从 <code>Java</code> 堆中划分出来</li>
</ul>
<blockquote>
<p>对象所需内存的大小在类加载完成后便可完全确定</p>
</blockquote>
<ul>
<li>关于分配内存，此处主要讲解内存分配方式</li>
<li>内存分配 根据 <strong>Java堆内存是否绝对规整</strong> 分为两种方式：指针碰撞 &amp; 空闲列表</li>
</ul>
<blockquote>
<ol>
<li><code>Java</code>堆内存 规整：已使用的内存在一边，未使用内存在另一边</li>
<li><code>Java</code>堆内存 不规整：已使用的内存和未使用内存相互交错</li>
</ol>
</blockquote>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/944365-56bc4829fec010da.png" alt="img"></p>
<p>示意图</p>
<p>方式1：指针碰撞</p>
<ul>
<li>假设Java堆内存绝对规整，内存分配将采用指针碰撞</li>
<li>分配形式：已使用内存在一边，未使用内存在另一边，中间放一个作为分界点的指示器</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-139d8747844ca098.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/471/format/webp" alt="img"></p>
<p>正常状态</p>
<ul>
<li>那么，分配对象内存 = 把指针向 未使用内存 移动一段 与对象大小相等的距离</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-454f011a868e66d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/501/format/webp" alt="img"></p>
<p>分配内存空间</p>
<p>方式2：空闲列表</p>
<ul>
<li>假设Java堆内存不规整，内存分配将采用 空闲列表</li>
<li>分配形式：虚拟机维护着一个 记录可用内存块 的列表，在分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</li>
</ul>
<p>额外知识</p>
<ul>
<li><p>分配方式的选择 取决于 <code>Java</code>堆内存是否规整；</p>
</li>
<li><p>而<code>Java</code>堆是否规整 由所采用的垃圾收集器是否带有压缩整理功能决定。因此：</p>
<ol>
<li>使用带 <code>Compact</code> 过程的垃圾收集器时，采用指针碰撞；</li>
</ol>
</li>
</ul>
<blockquote>
<p>如<code>Serial、ParNew</code>垃圾收集器</p>
</blockquote>
<ol>
<li>使用基于 <code>Mark_sweep</code>算法的垃圾收集器时，采用空闲列表。</li>
</ol>
<blockquote>
<p>如 <code>CMS</code>垃圾收集器</p>
</blockquote>
<p>特别注意</p>
<ul>
<li>对象创建在虚拟机中是非常频繁的操作，即使仅仅修改一个指针所指向的位置，在并发情况下也会引起线程不安全</li>
</ul>
<blockquote>
<p>如，正在给对象A分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存</p>
</blockquote>
<p><strong>所以，给对象分配内存会存在线程不安全的问题。</strong></p>
<p>解决 线程不安全 有两种方案：</p>
<ol>
<li>同步处理分配内存空间的行为</li>
</ol>
<blockquote>
<p>虚拟机采用 <strong><code>CAS</code> + 失败重试的方式</strong> 保证更新操作的原子性</p>
</blockquote>
<ol>
<li>把内存分配行为 按照线程 划分在不同的内存空间进行</li>
</ol>
<blockquote>
<ol>
<li>即每个线程在 <code>Java</code>堆中预先分配一小块内存（本地线程分配缓冲（<code>Thread Local Allocation Buffer</code> ，<code>TLAB</code>）），哪个线程要分配内存，就在哪个线程的<code>TLAB上</code>分配，只有TLAB用完并分配新的TLAB时才需要同步锁。</li>
<li>虚拟机是否使用<code>TLAB</code>，可以通过<code>-XX:+/-UseTLAB</code>参数来设定。</li>
</ol>
</blockquote>
<hr>
<h3 id="步骤3：-将内存空间初始化为零值"><a href="#步骤3：-将内存空间初始化为零值" class="headerlink" title="步骤3： 将内存空间初始化为零值"></a>步骤3： 将内存空间初始化为零值</h3><p>内存分配完成后，虚拟机需要将分配到的内存空间初始化为零（不包括对象头）</p>
<blockquote>
<ol>
<li>保证了对象的实例字段在使用时可不赋初始值就直接使用（对应值 = 0）</li>
<li>如使用本地线程分配缓冲（TLAB），这一工作过程也可以提前至TLAB分配时进行。</li>
</ol>
</blockquote>
<hr>
<h3 id="步骤4：-对对象进行必要的设置"><a href="#步骤4：-对对象进行必要的设置" class="headerlink" title="步骤4： 对对象进行必要的设置"></a>步骤4： 对对象进行必要的设置</h3><blockquote>
<p>如，设置 这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。</p>
</blockquote>
<p><strong>这些信息存放在对象的对象头中</strong>。</p>
<hr>
<ul>
<li>至此，从 <code>Java</code> 虚拟机的角度来看，一个新的 <code>Java</code>对象创建完毕</li>
<li>但从 <code>Java</code> 程序开发来说，对象创建才刚开始，需要进行一些初始化操作。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>下面用一张图总结 <code>Java</code>对象创建的过程</p>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-dcaca2aa784300fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/892/format/webp" alt="img"></p>
<p>示意图</p>
<hr>
<h2 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2. 对象的内存布局"></a>2. 对象的内存布局</h2><ul>
<li><p>问题：在 <code>Java</code> 对象创建后，到底是如何被存储在Java内存里的呢？（美团面试题）</p>
</li>
<li><p>答：在<code>Java</code>虚拟机（<code>HotSpot</code>）中，对象在Java<br>内存中的 存储布局 可分为三块：</p>
<ol>
<li>对象头 存储区域<ol>
<li>运行时数据（<code>Mark Word</code>）</li>
<li>对象类型指针（KP）</li>
</ol>
</li>
<li>实例数据 存储区域</li>
<li>对齐填充 存储区域</li>
</ol>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-06bc64cd744e28b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/450/format/webp" alt="img"></p>
<h3 id="2-1-对象头-区域"><a href="#2-1-对象头-区域" class="headerlink" title="2.1 对象头 区域"></a>2.1 对象头 区域</h3><p>此处存储的信息包括两部分：</p>
<ul>
<li>对象自身的运行时数据（<code>Mark Word</code>）</li>
</ul>
<blockquote>
<ol>
<li>如哈希码（<code>HashCode</code>）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等</li>
<li>该部分数据被设计成1个 非固定的数据结构 以便在极小的空间存储尽量多的信息（会根据对象状态复用存储空间）</li>
<li>64位默认占据8个字节</li>
</ol>
</blockquote>
<ul>
<li>对象类型指针</li>
</ul>
<blockquote>
<ol>
<li>即对象指向它的类元数据的指针</li>
<li>虚拟机通过这个指针来确定这个对象是哪个类的实例</li>
<li>.64位默认占据4个字节</li>
</ol>
</blockquote>
<p>特别注意</p>
<p>如果对象 是 数组，那么在对象头中还必须有一块用于记录数组长度的数据</p>
<blockquote>
<p>因为虚拟机可以通过普通Java对象的元数据信息确定对象的大小，但是从数组的元数据中却无法确定数组的大小。</p>
</blockquote>
<hr>
<h3 id="2-2-实例数据-区域"><a href="#2-2-实例数据-区域" class="headerlink" title="2.2 实例数据 区域"></a>2.2 实例数据 区域</h3><ul>
<li>存储的信息：对象真正有效的信息</li>
</ul>
<blockquote>
<p>即代码中定义的字段内容</p>
</blockquote>
<p>​    注：这部分数据的存储顺序会受到虚拟机分配参数（FieldAllocationStyle）和字段在Java源码中定义顺序的影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HotSpot虚拟机默认的分配策略如下：</span></span><br><span class="line">longs/doubles、ints、shorts/chars、bytes/booleans、oop(Ordinary Object Pointers)</span><br><span class="line"><span class="comment">// 从分配策略中可以看出，相同宽度的字段总是被分配到一起</span></span><br><span class="line"><span class="comment">// 在满足这个前提的条件下，父类中定义的变量会出现在子类之前</span></span><br><span class="line"> </span><br><span class="line">CompactFields = <span class="keyword">true</span>；</span><br><span class="line"><span class="comment">// 如果 CompactFields 参数值为true，那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对齐：如果上面的数据长度不能被8整除，则添加一个最小的padding，使整个数据能被8整除（用于64位）</li>
</ul>
<p>参考文章：</p>
<p><a href="https://www.bilibili.com/video/BV1aQ4y1P7Me?p=3&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1aQ4y1P7Me?p=3&amp;spm_id_from=pageDriver</a></p>
<p><a href="https://www.jianshu.com/p/1952061502d0">https://www.jianshu.com/p/1952061502d0</a></p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>spring核心知识点</title>
    <url>/de7e93c2.html</url>
    <content><![CDATA[<h2 id="说一下spring-ioc的理解，原理和实现"><a href="#说一下spring-ioc的理解，原理和实现" class="headerlink" title="说一下spring ioc的理解，原理和实现"></a>说一下spring ioc的理解，原理和实现</h2><h3 id="总"><a href="#总" class="headerlink" title="总"></a>总</h3><p>ioc：控制反转。原来的对象是由使用者来控制的，有了spring，就直接把整个对象交给spring来帮我们管理。</p>
<p>​    DI：依赖注入。把对应的属性的值注入到具体的对象中，@autowired，populatebean完成属性值得注入</p>
<p>容器：存储对象，使用map结构存储，在spring中一般存在三级缓存，singletonOBjects存放文章的bean对象，在整个bean的生命周期中，从创建到使用到销毁都是由容器来管理的。</p>
<span id="more"></span>

<h3 id="分"><a href="#分" class="headerlink" title="分"></a>分</h3><h4 id="IOC和DI"><a href="#IOC和DI" class="headerlink" title="IOC和DI"></a>IOC和DI</h4><p>举一个例子：有车，底盘，轮胎，在没有spring之前，我们相对这样的整体架构进行设计，一个常用的方法就是通过构造器注入，我们在创建一个底盘的时候，需要new一个轮子的对象，把这个对象的尺寸，材料设置好后，通过底盘的构造器放入底盘中。同样，我们在最终创建一个车的时候，需要先创建一个轮胎对象，在创建一个底盘对象，最后才能创建出我们想要的车的对象。然后spring就帮我解决了这样的而问题，你可以直接去创建一个车的对象，而具体的底盘和轮胎的对象注入，由spring自己来进行，你只需要在开始创建这样的bean就行了</p>
<p><img src="https://pic2.zhimg.com/80/v2-24a96669241e81439c636e83976ba152_720w.jpg?source=1940ef5c" alt="img"></p>
<p>这里的ioc，就像是一个工厂</p>
<img src="https://pic3.zhimg.com/80/v2-5ca61395f37cef73c7bbe7808f9ea219_720w.jpg?source=1940ef5c" alt="img" style="zoom: 33%;" />

<p>所以我们在项目中经常回遇到bean找不到报错的问题，应为spring是只是帮你去把你创建的bean给找出来，所以在项目运行的时候需要有一个初始化好的bean。可以通过xml去定义一个bean，也可以通过注解@bean，@controller等等去定义一个bean</p>
<p>推荐文章：Spring IoC有什么好处呢？ - Mingqi的回答 - 知乎 <a href="https://www.zhihu.com/question/23277575/answer/169698662">https://www.zhihu.com/question/23277575/answer/169698662</a></p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ol>
<li>首先开始创建一个容器（beanFactory ， DefaultListableBeanFactory），然后想bean工厂中设置一些参数（beanPostProcessor，Aware接口的子类）等等属性</li>
<li>加载解析bean对象，准备要创建的bean对象的定义对象beanDefintion（XML或者注解）</li>
<li>beanFactoryPostProcessor的处理，在此处可以自定义扩展，PlaceHolderConfigurSupport,ConfigurationClassPostProcessor</li>
<li>BeanPostProcessor的注册功能，方便后续对bean’对象完成具体的扩展功能</li>
<li>通过反射的方式将BeanDefintion对象实例化成具体的bean对象</li>
<li>bean对象的初始化过程（填充属性，调用aware接口子类的方法，调用BeanPostProcesor的前置处理方法，调用init-method方法，调用BeanPostProcessor的后置处理方法）</li>
<li>生成完整的bean对象，通过getBean方法可以直接获取</li>
<li>销毁，（调用DisposableBean的destory方法，调用自定义销毁方法）</li>
<li>结束</li>
</ol>
<h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><ol>
<li><p>通过实现BeanPostProcessor接口，对beanFactory的创建过程进行整体修改</p>
</li>
<li><p>对bean的扩展，在项目中使用@value注入yml的属性，现在在分布式情况下，相对这个@value注入自定义扩展（比如添加前缀或者从特定位置读取默认值）</p>
</li>
</ol>
<h2 id="谈一下spring-IOC的底层实现"><a href="#谈一下spring-IOC的底层实现" class="headerlink" title="谈一下spring IOC的底层实现"></a>谈一下spring IOC的底层实现</h2><h3 id="总-1"><a href="#总-1" class="headerlink" title="总"></a>总</h3><p>createBeanFactory，getBean,doGetBean,doCreatBean,creatBeanInstance（getDeclaredConstructor，newinstance），populateBean，initializingBean</p>
<p>（备注：加do的方法都是主要业务逻辑方法）</p>
<h3 id="分-1"><a href="#分-1" class="headerlink" title="分"></a>分</h3><ol>
<li>先通过creatBeanFactory创建出一个bean工厂（DefaultListableBeanFactory）</li>
<li>开始循环创建对象，因为容器中的bean默认都是单例的，所以优先通过getBean，doGetBean从容器中查找，找不到的话</li>
<li>通过createBean，doCreateBean方法，以反射的放射创建对象，一般情况下使用无参的构造方法（getDeclaredConstructor，newInstance）</li>
<li>进行对象的属性填充populateBean</li>
<li>进行其他的初始化操作（initializingBean）</li>
</ol>
<h2 id="描述一下bena的生命周期"><a href="#描述一下bena的生命周期" class="headerlink" title="描述一下bena的生命周期"></a>描述一下bena的生命周期</h2><h3 id="总-2"><a href="#总-2" class="headerlink" title="总"></a>总</h3><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210819214343270.png" alt="image-20210819214343270" style="zoom:50%;" />

<h3 id="分-2"><a href="#分-2" class="headerlink" title="分"></a>分</h3><ol>
<li>实例化bean：反射的方式生成对象</li>
<li>填充bean的属性：populateBean（），循环依赖的问题（三级缓存）</li>
<li>调用aware接口相关的方法：invokeAwareMethod（完成BeanName，BeanFactory，BeanClassLoader对象的属性设置）</li>
<li>调用BeanPostProcessor中的前置处理方法：使用比较多的有（ApplicationContextPostProcessor，设置ApplicationContext，Environment，ResourceLoader，EmbeddValueResolver）</li>
<li>调用initmethod方法：invokeInitmethod（），判断是否实现了initializingBean接口，如果有，调用afterPropertiesSet方法，没有就不调用</li>
<li>调用BeanPostProcessor的后置处理方法：spring中的AOP就是在此处实习的，AbstractAutoProxyCreator。<ol>
<li>注册Destuction相关的回调接口：（钩子函数）</li>
</ol>
</li>
<li>获取到完成bean对象，可以通过getBean的方法进行对象的获取</li>
<li>销毁<ol>
<li>判断是否实现了DisproableBean接口</li>
<li>调用destoryMethod的方法</li>
</ol>
</li>
</ol>
<h2 id="Spring是如何解决循环依赖问题"><a href="#Spring是如何解决循环依赖问题" class="headerlink" title="Spring是如何解决循环依赖问题"></a>Spring是如何解决循环依赖问题</h2><p>核心思想：提前暴露对象，把不完整的对象注入</p>
<h3 id="总-3"><a href="#总-3" class="headerlink" title="总"></a>总</h3><p>使用三级缓存，提前暴露bean的对象，也就是把实例化和初始化分开操作，把不完整的对象注入</p>
<h3 id="分-3"><a href="#分-3" class="headerlink" title="分"></a>分</h3><p>假如A和B对象循环依赖</p>
<ol>
<li>先创建A对象，实例化A对象，此时A对象中的B属性为空，开始填充属性B</li>
<li>从容器中查找B对象，如果找到了，直接赋值不存在循环依赖问题（但是现在A和B对象循环依赖），没有找到直接创建B对象</li>
<li>实例化B对象，此时B对象中的A属性为空，填充A属性</li>
<li>从容器中查找A对象，找不到，直接创建</li>
</ol>
<p>​        在spring中，第四步的A对象是存在的，只不过此时的A对象不是一个完整的状态，只完成了实例化但是未完成初始化，如果在程序调用过程中，拥有了某个对象的引用，能否再后期给他完成赋值操作，可以优先把非完整的对象优先赋值，等待后续操作来完成赋值，相当于提前暴露了某个不完整的对象的引用。</p>
<p>​        所以解决循环依赖问题的关键就是，把实例化和初始化分开操作，当所有的对象都实例化和初始化操作后，还是要把完整的对象放到容器中，此时在容器中存在对象的几个状态：未完成实例化，完成实例化但为完成初始化，完整状态。因为都在容器中，所以要使用不同的map结构来进行存储，此时就有了一级缓存和二级缓存，如果一级缓存中有了，那么耳机缓存中就不会存在同名的对象，因为他们的查找顺序是1,2,3级缓存的方式进行查找的。在一级缓存中存放的是完整对象，二级缓存中存放的是非完整对象</p>
<p>​        为什么需要三级缓存？三级缓存的value类型是ObjectFactory，是一个函数式接口，存在的意义是保证整个容器的运行过程中同名的bean对象只能有一个。</p>
<p>​        如果一个对象需要被代理，或者需要生成代理对象，那么要不要优先生成一个普通对象？需要，在源码中调用的代理方法（BeanPostProcessor）的时候需要传入一个bean对象</p>
<p>​        普通对象和代理对象是不能同时出现在容器中，因此当一个对象需要被代理的时候，就要使用代理对象覆盖掉之前的普通对象，在实际的调用过程中，是没有办法确定什么时候对象被使用，所以就要求当某个对象被调用的时候，优先判断此对象是否需要被代理，类似于一种回调机制的实现，因此传入lambda表达式的时候，可以通过lambda表达式来执行对象的覆盖过程，getEarlyBeanReference（）</p>
<p>​        因此，所有的bean对象在创建的时候都要优先放到三级缓存中，在后续的使用过程中，如果需要被代理则返回代理对象，如果不需要被代理，则直接返回普通对象</p>
<h3 id="三级缓存的放置时间和删除时间"><a href="#三级缓存的放置时间和删除时间" class="headerlink" title="三级缓存的放置时间和删除时间"></a>三级缓存的放置时间和删除时间</h3><p>三级缓存：createBeanInstance之后，addSingletonFactory</p>
<p>二级缓存：第一次从三级缓存确定对象是代理对象还是普通对象，同时删除三级缓存getSingleton</p>
<p>一级缓存：生成完整对象之后放到一级缓存，删除二三级缓存：addSingleton</p>
<h2 id="BeanFactory与FactoryBean有什么区别"><a href="#BeanFactory与FactoryBean有什么区别" class="headerlink" title="BeanFactory与FactoryBean有什么区别"></a>BeanFactory与FactoryBean有什么区别</h2><p>相同点：都是创建bean对象</p>
<p>不同点：使用benaFactory创建对象的时候，必须要遵循严格的生命周期流程，太复杂了。如果想要简单的自定义某个对象的创建，同时创建完成的对象想交给spring来管理，那么就需要实习FactoryBean接口</p>
<p>​        isSingleton：创建的bean是否为单例bean</p>
<p>​        getObjectType：获取返回对象的类型</p>
<p>​        getObjet：自定义创建对象的过程（new，反射，动态代理）</p>
<h2 id="Spring中用的到的设计模式"><a href="#Spring中用的到的设计模式" class="headerlink" title="Spring中用的到的设计模式"></a>Spring中用的到的设计模式</h2><p>单例模式：bean默认都是单例的</p>
<p>原型模式：指定作用域为prototype</p>
<p>工厂模式：BeanFactory</p>
<p>模板方法：postProcessBeanFactory，onRefresh，initPropertyValue</p>
<p>策略模式：XmlBeanDefinitionReader，PropertiesBeanDefinitionReader</p>
<p>观察者模式：listener，event，multicast</p>
<p>适配器模式：Adapter</p>
<p>装饰者模式：BeanWrapper</p>
<p>责任链模式：使用aop的时候回先生成一个拦截器链</p>
<p>代理模式：动态代理</p>
<p>委托者模式：delegate</p>
<h2 id="Spring中AOP的底层实现原理"><a href="#Spring中AOP的底层实现原理" class="headerlink" title="Spring中AOP的底层实现原理"></a>Spring中AOP的底层实现原理</h2><h3 id="总-4"><a href="#总-4" class="headerlink" title="总"></a>总</h3><p>AOP是ioc的一个扩展功能，现有的ioc，在有的aop，只是在ioc的整个流程中新增的一个扩展点而已（BeanPostProcessor），底层是用的动态代理实现的，常用的应用场景油自定义注解等等</p>
<h3 id="分-4"><a href="#分-4" class="headerlink" title="分"></a>分</h3><p>在bean的创建过程中，可以在BeanPostProcessor的后置处理方法实习aop</p>
<ol>
<li>代理对象的创建过程（advice，切面（@around，@After），切点（@pointCut））</li>
<li>通过jdk或者cglib的方式来生成代理对象</li>
<li>在执行方法调用的时候，会调用生成的字节码文件，直接找到DynamicAdvisoredIntercepto类中的intercept方法，从此方法开始执行</li>
<li>根据之前定义好的通知来生成拦截器链</li>
<li>从拦截器链中依次获取每一个通知开始进行执行，在执行的过程中，为了方便找到下一个通知是哪个，会有一个InvocationInterceptor的对象，找的的时候从-1的位置依次开始查找并执行的</li>
</ol>
<h2 id="Spring的事务是如何回滚的"><a href="#Spring的事务是如何回滚的" class="headerlink" title="Spring的事务是如何回滚的"></a>Spring的事务是如何回滚的</h2><h3 id="总-5"><a href="#总-5" class="headerlink" title="总"></a>总</h3><p>spring的事务是由aop来实现的，首先要生成具体的代理对象，然后按照aop的整套流程来执行具体的操作逻辑。正常情况下要通过通知来完成核心功能，但是事务不是通过通知来实现的，而是通过一个TransactionInterceptor来实现的，然后调用invoke来实现具体的逻辑</p>
<h3 id="分-5"><a href="#分-5" class="headerlink" title="分"></a>分</h3><p>mysql中事务的实现机制（下图左）：</p>
<p>具体还设计到了myql的MVCC机制（一致性）、锁（隔离性）、redo log（持久性）、undolog（原子性）</p>
<p>推荐文章：<a href="https://blog.csdn.net/weixin_33560311/article/details/113138290">https://blog.csdn.net/weixin_33560311/article/details/113138290</a></p>
<p>AOP实现事务的机制（下图右）：</p>
<center class = "half"> 
    <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210820104629013.png" alt="mysql中事务的实现机制" style="zoom:50%;" />
    <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210820105158508.png" alt="AOP实现事务的机制" style="zoom: 50%;" />
</center>

<ol>
<li>先做准备工作，解析各个方法上事务的相关属性，根据具体的属性来判断是否开启新的事务</li>
<li>当需要开启的时候，获取数据库连接（这里也是用的连接池），关闭自动提交功能，开启事务</li>
<li>执行具体的sql逻辑操作</li>
<li>在操作过程中，如果执行失败了，那么会通过completeTransactionThrowing看来完成事务的回滚操作，回滚的具体逻辑是通过doRollBack方法来实现的，实现的时候也是先获取连接对象，通过连接对象来回滚</li>
<li>如果执行过程顺利完成，通过commitTransactionAfterReturning来完成事务的提交操作，提交的具体逻辑是通过doCommit方法来实习的，实现的时候也是要获取连接，通过连接对象提交（所以获取的链接对象要保持一致，currentConnection）</li>
<li>当前事务执行完毕后需要清楚相关的事务信息cleanupTransactionInfo(断开连接，释放资源)</li>
</ol>
<p>深入的话，还需要知道TransactionInfo，TransactionStatus</p>
<h2 id="spring事务传播"><a href="#spring事务传播" class="headerlink" title="spring事务传播"></a>spring事务传播</h2><p>一共有七种传播特性：</p>
<p>Required、Requies_new 、nested、support、not_support、never、mandatory</p>
<table>
<thead>
<tr>
<th>事务名称</th>
<th>解析</th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED)</td>
<td>支持当前事务：如果没有事务会创建一个新的事务</td>
</tr>
<tr>
<td>SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS)</td>
<td>支持当前事务：如果没有事务的话以非事务方式执行</td>
</tr>
<tr>
<td>MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY)</td>
<td>支持当前事务：如果没有事务抛出异常</td>
</tr>
<tr>
<td>REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW)</td>
<td>创建一个新的事务并挂起当前事务</td>
</tr>
<tr>
<td>NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED)</td>
<td>如果当前存在事务则将当前事务挂起，以无事务方式运行。外层没有事务，以无事务方式运行</td>
</tr>
<tr>
<td>NEVER(TransactionDefinition.PROPAGATION_NEVER)</td>
<td>如果存在事务则抛出异常</td>
</tr>
<tr>
<td>NESTED(TransactionDefinition.PROPAGATION_NESTED)</td>
<td>嵌套事务：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</td>
</tr>
</tbody></table>
<p>A方法调用B方法，AB都有自己的事务，并且传播特性不同，那么A如果有异常，B怎么办，B如果有异常，A怎么办</p>
<h3 id="总-6"><a href="#总-6" class="headerlink" title="总"></a>总</h3><p>事务的传播特性是在不同事务的嵌套方法调用中，事务应该怎么进行？是用一个事务（用哪个事务？），还是不同的事务？当出现异常的时候是全部回滚，还是提交，这不同事务之间的相关影响的解决。</p>
<h3 id="分-6"><a href="#分-6" class="headerlink" title="分"></a>分</h3><p>1.先说事务的不同分类，可以分为三类，支持当前事务，不支持当前事务，嵌套事务</p>
<p>​        2.如果外层方法是required，内层方法是：required，requireds_new,nested</p>
<p>​        3.如果外层方法是requireds_new，内层方法是：required，requireds_new,nested</p>
<p>​        4.如果外层方法是nested，内层方法是：required，requireds_new,nested</p>
<p>注意：新事物和子事务的区别：</p>
<p>新事物：外层事务回滚，不影响新事物；新事物的回滚，不影响外层事务，除非外层事务又异常处理，代码回滚新事务</p>
<p>子事务：外层事务回滚，子事务也会回滚；子事物的回滚，不影响外层事务，除非外层事务又异常处理，代码回滚子事务</p>
<table>
<thead>
<tr>
<th>外层</th>
<th>内层</th>
<th>结果（外层有事务）</th>
<th>结果（外层没有事务）</th>
<th>原因</th>
<th>外层有事务时出现异常</th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRED</td>
<td>REQUIRED，SUPPORTS，MANDATORY</td>
<td>使用外层事务</td>
<td>使用自己的事务逻辑（创建新事物，无事务运行或者抛异常）</td>
<td></td>
<td>整体回滚</td>
</tr>
<tr>
<td></td>
<td>REQUIRES_NEW，NOT_SUPPORTED，NEVER</td>
<td>使用自己的事务逻辑（外层事务挂起后创建新的事务，外层事务挂起后以无事务方式运行或者抛异常）</td>
<td>使用自己的事务逻辑（创建新事物，无事务运行或者抛异常）</td>
<td>这种有可能会造成死锁，因为会影响上一个事务，如果上一个事务已经表锁了，这个事务又操作表，但获取不到资源</td>
<td>外层事务回滚，不影响新事物</td>
</tr>
<tr>
<td></td>
<td>NESTED</td>
<td>使用自己的事务逻辑（外层事务挂起后创建子事务）</td>
<td>使用自己的事务逻辑（创建子事务）</td>
<td></td>
<td>外层事务回滚，子事务也会回滚</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210820211028606.png" alt="image-20210820211028606" style="zoom:50%;" />

<p>在spring中，主要是在beanPostProcessor中进行事务的处理，事务都会生成一个InfrastructureAdvisorAutoProxyCreator对象。</p>
<ol>
<li><p>getAdviceAndAdvisorsForBean（获取事务通知的方法）</p>
</li>
<li><p>creatProxy，创建代理对象</p>
</li>
<li><p>走代理（实现接口走Proxy或者没有实现接口cglib）</p>
</li>
<li><p>执行invoke方法，获取拦截器的链（TransactionInterceptor）</p>
</li>
<li><p>invokeWithTransaction，获取事务上的注解属性（rollbackRules，quailfer，descriptor，propagationBehavior，isolationLevel，timeout，readonly，name）</p>
</li>
<li><p>creatTransactionIfNessary，从当前线程（ThreadLocal）中获取事务（TransactionSynchronizationManager.getResource(obtainDataSource())）</p>
<ol>
<li>当前线程没有事务，就开始这个事务</li>
<li>dobegin，把这个事务绑定到当前线程中，把连接的自动提交关闭，把当前事务设置为活跃的事务</li>
<li>执行事务中的方法</li>
</ol>
</li>
<li><p>事务中的方法还有一个事务，指定方法</p>
</li>
<li><p>获取拦截器中的TransactionInterceptor</p>
</li>
<li><p>invokeWithTransaction，获取事务上的注解属性</p>
</li>
<li><p>creatTransactionIfNessary，从当前线程中获取事务</p>
<ol>
<li><p>这个时候当前线程已经有事务</p>
</li>
<li><p>handlerExistingTransaction，处理存在的事务</p>
</li>
<li><p>如果这个事务（difintion.getPropagationBehavior）是NEVER的话，直接抛出异常</p>
</li>
<li><p>如果事务是NOT_SUPPORTED的话，当前事务挂起</p>
</li>
<li><p>如果事务是REQUIRES_NEW的话，开始一个新的事务（dobegin）</p>
</li>
<li><p>如果是NESTED，开始子事务</p>
</li>
<li><p>执行事务中的方法，如果出现异常，则事务回滚（doRollback）</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>深究Spring中Bean的生命周期</title>
    <url>/440fb577.html</url>
    <content><![CDATA[<h2 id="深究Spring中Bean的生命周期"><a href="#深究Spring中Bean的生命周期" class="headerlink" title="深究Spring中Bean的生命周期"></a>深究Spring中Bean的生命周期</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这其实是一道面试题，是我在面试百度的时候被问到的，当时没有答出来(因为自己真的很菜)，后来在网上寻找答案，看到也是一头雾水，直到看到了《Spring in action》这本书，书上有对Bean声明周期的大致解释，但是没有代码分析，所以就自己上网寻找资料，一定要把这个Bean生命周期弄明白！</p>
<p>网上大部分都是验证的Bean 在面试问的生命周期，其实查阅JDK还有一个完整的Bean生命周期，这同时也验证了书是具有片面性的，最fresh 的资料还是查阅原始JDK!!!</p>
<span id="more"></span>
<h2 id="一、Bean-的完整生命周期"><a href="#一、Bean-的完整生命周期" class="headerlink" title="一、Bean 的完整生命周期"></a>一、Bean 的完整生命周期</h2><p>在传统的Java应用中，bean的生命周期很简单，使用Java关键字 new 进行Bean 的实例化，然后该Bean 就能够使用了。一旦bean不再被使用，则由Java自动进行垃圾回收。</p>
<p>相比之下，Spring管理Bean的生命周期就复杂多了，正确理解Bean 的生命周期非常重要，因为Spring对Bean的管理可扩展性非常强，下面展示了一个Bean的构造过程</p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/05/java0-1558500658.jpg" alt="深究Spring中Bean的生命周期"></p>
<p><strong>Bean 的生命周期</strong></p>
<p>如上图所示，Bean 的生命周期还是比较复杂的，下面来对上图每一个步骤做文字描述:</p>
<ol>
<li>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</li>
<li>Bean实例化后对将Bean的引入和值注入到Bean的属性中</li>
<li>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</li>
<li>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</li>
<li>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。</li>
<li>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</li>
<li>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</li>
<li>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</li>
<li>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</li>
<li>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</li>
</ol>
<blockquote>
<p><strong>上面是Spring 中Bean的核心接口和生命周期，面试回答上述过程已经足够了。但是翻阅JavaDoc文档发现除了以上接口外，还有另外的初始化过程涉及的接口：</strong></p>
<p><strong>摘自org.springframework.beans.factory.BeanFactory， 全部相关接口如下，上述已有的就不用着重标注，把额外的相关接口着重标注下</strong></p>
</blockquote>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/05/java10-1558500659.jpg" alt="深究Spring中Bean的生命周期"></p>
<p><strong>Bean 完整的生命周期</strong></p>
<p>文字解释如下：</p>
<p>————————————初始化————————————</p>
<ul>
<li>BeanNameAware.setBeanName() 在创建此bean的bean工厂中设置bean的名称，在普通属性设置之后调用，在InitializinngBean.afterPropertiesSet()方法之前调用</li>
<li><code>BeanClassLoaderAware.setBeanClassLoader()</code>: 在普通属性设置之后，InitializingBean.afterPropertiesSet()之前调用</li>
<li>BeanFactoryAware.setBeanFactory() : 回调提供了自己的bean实例工厂，在普通属性设置之后，在InitializingBean.afterPropertiesSet()或者自定义初始化方法之前调用</li>
<li><code>EnvironmentAware.setEnvironment()</code>: 设置environment在组件使用时调用</li>
<li><code>EmbeddedValueResolverAware.setEmbeddedValueResolver()</code>: 设置StringValueResolver 用来解决嵌入式的值域问题</li>
<li><code>ResourceLoaderAware.setResourceLoader()</code>: 在普通bean对象之后调用，在afterPropertiesSet 或者自定义的init-method 之前调用，在 ApplicationContextAware 之前调用。</li>
<li><code>ApplicationEventPublisherAware.setApplicationEventPublisher()</code>: 在普通bean属性之后调用，在初始化调用afterPropertiesSet 或者自定义初始化方法之前调用。在 ApplicationContextAware 之前调用。</li>
<li><code>MessageSourceAware.setMessageSource()</code>: 在普通bean属性之后调用，在初始化调用afterPropertiesSet 或者自定义初始化方法之前调用，在 ApplicationContextAware 之前调用。</li>
<li>ApplicationContextAware.setApplicationContext(): 在普通Bean对象生成之后调用，在InitializingBean.afterPropertiesSet之前调用或者用户自定义初始化方法之前。在ResourceLoaderAware.setResourceLoader，ApplicationEventPublisherAware.setApplicationEventPublisher，MessageSourceAware之后调用。</li>
<li><code>ServletContextAware.setServletContext()</code>: 运行时设置ServletContext，在普通bean初始化后调用，在InitializingBean.afterPropertiesSet之前调用，在 ApplicationContextAware 之后调用<strong>注：是在WebApplicationContext 运行时</strong></li>
<li>BeanPostProcessor.postProcessBeforeInitialization() : 将此BeanPostProcessor 应用于给定的新bean实例 在任何bean初始化回调方法(像是InitializingBean.afterPropertiesSet或者自定义的初始化方法）之前调用。这个bean将要准备填充属性的值。返回的bean示例可能被普通对象包装，默认实现返回是一个bean。</li>
<li>BeanPostProcessor.postProcessAfterInitialization() : 将此BeanPostProcessor 应用于给定的新bean实例 在任何bean初始化回调方法(像是InitializingBean.afterPropertiesSet或者自定义的初始化方法)之后调用。这个bean将要准备填充属性的值。返回的bean示例可能被普通对象包装</li>
<li>InitializingBean.afterPropertiesSet(): 被BeanFactory在设置所有bean属性之后调用(并且满足BeanFactory 和 ApplicationContextAware)。</li>
</ul>
<p>————————————销毁————————————</p>
<p>在BeanFactory 关闭的时候，Bean的生命周期会调用如下方法:</p>
<ul>
<li><code>DestructionAwareBeanPostProcessor.postProcessBeforeDestruction()</code>: 在销毁之前将此BeanPostProcessor 应用于给定的bean实例。能够调用自定义回调，像是DisposableBean 的销毁和自定义销毁方法，这个回调仅仅适用于工厂中的单例bean(包括内部bean)</li>
<li>实现了自定义的destory()方法</li>
</ul>
<h2 id="二、Bean-的生命周期验证"><a href="#二、Bean-的生命周期验证" class="headerlink" title="二、Bean 的生命周期验证"></a>二、Bean 的生命周期验证</h2><p>为了验证Bean生命周期的过程，有两种形式：一种是为面试而准备的，一种是为了解全过程而准备的，下面来看代码：</p>
<p>Book.class</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Book implements BeanNameAware,BeanFactoryAware,</span><br><span class="line">        ApplicationContextAware,InitializingBean,DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    private String bookName;</span><br><span class="line">    public Book()&#123;</span><br><span class="line">        System.out.println(&quot;Book Initializing &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;Book.setBeanFactory invoke&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBeanName(String name) &#123;</span><br><span class="line">        System.out.println(&quot;Book.setBeanName invoke&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroy() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;Book.destory invoke&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;Book.afterPropertiesSet invoke&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;Book.setApplicationContext invoke&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getBookName() &#123;</span><br><span class="line">        return bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBookName(String bookName) &#123;</span><br><span class="line">        this.bookName = bookName;</span><br><span class="line">        System.out.println(&quot;setBookName: Book name has set.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void myPostConstruct()&#123;</span><br><span class="line">        System.out.println(&quot;Book.myPostConstruct invoke&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     // 自定义初始化方法</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void springPostConstruct()&#123;</span><br><span class="line">        System.out.println(&quot;@PostConstruct&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void myPreDestory()&#123;</span><br><span class="line">        System.out.println(&quot;Book.myPreDestory invoke&quot;);</span><br><span class="line">        System.out.println(&quot;---------------destroy-----------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 自定义销毁方法</span><br><span class="line">    @PreDestroy</span><br><span class="line">    public void springPreDestory()&#123;</span><br><span class="line">        System.out.println(&quot;@PreDestory&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;------inside finalize-----&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>自定义实现BeanPostProcessor 的MyBeanPostProcessor：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyBeanPostProcessor implements BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    // 容器加载的时候会加载一些其他的bean，会调用初始化前和初始化后方法</span><br><span class="line">    // 这次只关注book(bean)的生命周期</span><br><span class="line">    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        if(bean instanceof Book)&#123;</span><br><span class="line">            System.out.println(&quot;MyBeanPostProcessor.postProcessBeforeInitialization&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        if(bean instanceof Book)&#123;</span><br><span class="line">            System.out.println(&quot;MyBeanPostProcessor.postProcessAfterInitialization&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<p>在resources 目录下新建Bean-Lifecycle.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- 扫描bean --&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.bean.lifecycle&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 实现了用户自定义初始化和销毁方法 --&gt;</span><br><span class="line">    &lt;bean id=&quot;book&quot; class=&quot;com.bean.lifecycle.Book&quot; init-method=&quot;myPostConstruct&quot; destroy-method=&quot;myPreDestory&quot;&gt;</span><br><span class="line">          &lt;!-- 注入bean 属性名称 --&gt;</span><br><span class="line">        &lt;property name=&quot;bookName&quot; value=&quot;thingking in java&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!--引入自定义的BeanPostProcessor--&gt;</span><br><span class="line">    &lt;bean class=&quot;com.bean.lifecycle.MyBeanPostProcessor&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>



<p>做一个启动类的测试，新建SpringBeanLifecycleApplication</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SpringBeanLifecycleApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        // 为面试而准备的Bean生命周期加载过程</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Bean-Lifecycle.xml&quot;);</span><br><span class="line">        Book book = (Book)context.getBean(&quot;book&quot;);</span><br><span class="line">        System.out.println(&quot;Book name = &quot; + book.getBookName());</span><br><span class="line">        ((ClassPathXmlApplicationContext) context).destroy();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>启动测试，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Book Initializing </span><br><span class="line">setBookName: Book name has set.</span><br><span class="line">Book.setBeanName invoke</span><br><span class="line">Book.setBeanFactory invoke</span><br><span class="line">Book.setApplicationContext invoke</span><br><span class="line">MyBeanPostProcessor.postProcessBeforeInitialization</span><br><span class="line">@PostConstruct</span><br><span class="line">Book.afterPropertiesSet invoke</span><br><span class="line">Book.myPostConstruct invoke</span><br><span class="line">MyBeanPostProcessor.postProcessAfterInitialization</span><br><span class="line">Book name = thingking in java</span><br><span class="line"></span><br><span class="line">@PreDestory</span><br><span class="line">Book.destory invoke</span><br><span class="line">Book.myPreDestory invoke</span><br><span class="line">---------------destroy-----------------</span><br></pre></td></tr></table></figure>



<p>为了验证Bean完整的生命周期，需要新建一个SubBookClass 继承Book类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SubBookClass extends Book implements BeanClassLoaderAware,</span><br><span class="line">        EnvironmentAware,EmbeddedValueResolverAware,ResourceLoaderAware,</span><br><span class="line">        ApplicationEventPublisherAware,MessageSourceAware&#123;</span><br><span class="line"></span><br><span class="line">    private String bookSystem;</span><br><span class="line"></span><br><span class="line">    public String getBookSystem() &#123;</span><br><span class="line">        return bookSystem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBookSystem(String bookSystem) &#123;</span><br><span class="line">        System.out.println(&quot;设置BookSystem 的属性值&quot;);</span><br><span class="line">        this.bookSystem = bookSystem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBeanClassLoader(ClassLoader classLoader) &#123;</span><br><span class="line">        System.out.println(&quot;SubBookClass.setBeanClassLoader() 方法被调用了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) &#123;</span><br><span class="line">        System.out.println(&quot;SubBookClass.setApplicationEventPublisher() 方法被调用了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEmbeddedValueResolver(StringValueResolver resolver) &#123;</span><br><span class="line">        System.out.println(&quot;SubBookClass.setEmbeddedValueResolver() 方法被调用了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEnvironment(Environment environment) &#123;</span><br><span class="line">        System.out.println(&quot;SubBookClass.setEnvironment() 方法被调用了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMessageSource(MessageSource messageSource) &#123;</span><br><span class="line">        System.out.println(&quot;SubBookClass.setMessageSource() 方法被调用了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setResourceLoader(ResourceLoader resourceLoader) &#123;</span><br><span class="line">        System.out.println(&quot;SubBookClass.setResourceLoader() 方法被调用了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>上述SubBookClass类与Book是<code>互补</code>关系。</p>
</blockquote>
<p>新建一个SubBean-Lifecycle.xml，注入SubBookClass</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;bookClass&quot; class=&quot;com.bean.lifecycle.SubBookClass&quot; init-method=&quot;myPostConstruct&quot; destroy-method=&quot;myPreDestory&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;bookSystem&quot; value=&quot;Java System&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;com.bean.lifecycle.MyBeanPostProcessor&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>



<p>完整的SpringBeanLifecycleApplication 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SpringBeanLifecycleApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        // 为面试而准备的Bean生命周期加载过程</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Bean-Lifecycle.xml&quot;);</span><br><span class="line">        Book book = (Book)context.getBean(&quot;book&quot;);</span><br><span class="line">        System.out.println(&quot;Book name = &quot; + book.getBookName());</span><br><span class="line">        ((ClassPathXmlApplicationContext) context).destroy();</span><br><span class="line"></span><br><span class="line">        // 完整的加载过程，当然了解的越多越好</span><br><span class="line">        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;SubBean-Lifecycle.xml&quot;);</span><br><span class="line">        SubBookClass subBookClass = (SubBookClass) applicationContext.getBean(&quot;bookClass&quot;);</span><br><span class="line">        System.out.println(&quot;BookSystemName = &quot; + subBookClass.getBookSystem());</span><br><span class="line">        ((ClassPathXmlApplicationContext) applicationContext).registerShutdownHook();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出完整的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Book Initializing </span><br><span class="line">setBookName: Book name has set.</span><br><span class="line">Book.setBeanName invoke</span><br><span class="line">Book.setBeanFactory invoke</span><br><span class="line">Book.setApplicationContext invoke</span><br><span class="line">MyBeanPostProcessor.postProcessBeforeInitialization</span><br><span class="line">@PostConstruct</span><br><span class="line">Book.afterPropertiesSet invoke</span><br><span class="line">Book.myPostConstruct invoke</span><br><span class="line">MyBeanPostProcessor.postProcessAfterInitialization</span><br><span class="line">Book name = thingking in java</span><br><span class="line">@PreDestory</span><br><span class="line">Book.destory invoke</span><br><span class="line">Book.myPreDestory invoke</span><br><span class="line">---------------destroy-----------------</span><br><span class="line"></span><br><span class="line">Book Initializing </span><br><span class="line">设置BookSystem 的属性值</span><br><span class="line">Book.setBeanName invoke</span><br><span class="line">SubBookClass.setBeanClassLoader() 方法被调用了</span><br><span class="line">Book.setBeanFactory invoke</span><br><span class="line">SubBookClass.setEnvironment() 方法被调用了</span><br><span class="line">SubBookClass.setEmbeddedValueResolver() 方法被调用了</span><br><span class="line">SubBookClass.setResourceLoader() 方法被调用了</span><br><span class="line">SubBookClass.setApplicationEventPublisher() 方法被调用了</span><br><span class="line">SubBookClass.setMessageSource() 方法被调用了</span><br><span class="line">Book.setApplicationContext invoke</span><br><span class="line">MyBeanPostProcessor.postProcessBeforeInitialization</span><br><span class="line">Book.afterPropertiesSet invoke</span><br><span class="line">Book.myPostConstruct invoke</span><br><span class="line">MyBeanPostProcessor.postProcessAfterInitialization</span><br><span class="line">BookSystemName = Java System</span><br><span class="line">Book.destory invoke</span><br><span class="line">Book.myPreDestory invoke</span><br><span class="line">---------------destroy-----------------</span><br></pre></td></tr></table></figure>



<p>后记：这篇文章是我翻阅各种书籍和从网上查找资料，包括国外一些网站从而得到的结论，记录下来，但是我没有发现<em>Spring Bean的生命周期（非常详细）</em> 这篇文章中InstantiationAwareBeanPostProcessorAdapter 这个类和工厂后置处理器接口方法，知道的朋友欢迎指教，感谢。</p>
<p><em><a href="https://www.cnblogs.com/zrtqsk/p/3735273.html">https://www.cnblogs.com/zrtqsk/p/3735273.html</a></em></p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><blockquote>
<p><a href="https://www.cnblogs.com/zrtqsk/p/3735273.html">https://www.cnblogs.com/zrtqsk/p/3735273.html</a><br><a href="https://www.journaldev.com/2637/spring-bean-life-cycle">https://www.journaldev.com/2637/spring-bean-life-cycle</a><br><a href="http://www.wideskills.com/spring/spring-bean-lifecycle">http://www.wideskills.com/spring/spring-bean-lifecycle</a><br><a href="http://www.concretepage.com/spring/spring-bean-life-cycle-tutorial">www.concretepage.com/spring/spring-bean-life-cycle-tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式id的生成方案</title>
    <url>/d56bbc9.html</url>
    <content><![CDATA[<h1 id="分布式id的生成方案"><a href="#分布式id的生成方案" class="headerlink" title="分布式id的生成方案"></a>分布式id的生成方案</h1><p>ID是数据的唯一标识，传统的做法是利用UUID和数据库的自增ID，在互联网企业中，大部分公司使用的都是Mysql，并且因为需要事务支持，所以通常会使用Innodb存储引擎，UUID太长以及无序，所以并不适合在Innodb中来作为主键，自增ID比较合适，但是随着公司的业务发展，数据量将越来越大，需要对数据进行分表，而分表后，每个表中的数据都会按自己的节奏进行自增，很有可能出现ID冲突。这时就需要一个单独的机制来负责生成唯一ID，生成出来的ID也可以叫做分布式ID，或全局ID。下面来分析各个生成分布式ID的机制。</p>
<span id="more"></span>

<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E5%88%86%E5%B8%83%E5%BC%8Fid%E6%96%B9%E6%A1%88.jpeg" alt="常用分布式id方案"></p>
<p>这篇文章并不会分析的特别详细，主要是做一些总结，以后再出一些详细某个方案的文章。</p>
<h2 id="数据库自增ID"><a href="#数据库自增ID" class="headerlink" title="数据库自增ID"></a>数据库自增ID</h2><p>第一种方案仍然还是基于数据库的自增ID，需要单独使用一个数据库实例，在这个实例中新建一个单独的表：</p>
<p>表结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE `SEQID`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE SEQID.SEQUENCE_ID (</span><br><span class="line">	id bigint(20) unsigned NOT NULL auto_increment, </span><br><span class="line">	stub char(10) NOT NULL default &#x27;&#x27;,</span><br><span class="line">	PRIMARY KEY (id),</span><br><span class="line">	UNIQUE KEY stub (stub)</span><br><span class="line">) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>

<p>可以使用下面的语句生成并获取到一个自增ID</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">replace into SEQUENCE_ID (stub) VALUES (&#x27;anyword&#x27;);</span><br><span class="line">select last_insert_id();</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>stub字段在这里并没有什么特殊的意义，只是为了方便的去插入数据，只有能插入数据才能产生自增id。而对于插入我们用的是replace，replace会先看是否存在stub指定值一样的数据，如果存在则先delete再insert，如果不存在则直接insert。</p>
<p>这种生成分布式ID的机制，需要一个单独的Mysql实例，虽然可行，但是基于性能与可靠性来考虑的话都不够，业务系统每次需要一个ID时，都需要请求数据库获取，性能低，并且如果此数据库实例下线了，那么将影响所有的业务系统。</p>
<p>为了解决数据库可靠性问题，我们可以使用第二种分布式ID生成方案。</p>
<h2 id="数据库多主模式"><a href="#数据库多主模式" class="headerlink" title="数据库多主模式"></a>数据库多主模式</h2><p>如果我们两个数据库组成一个主从模式集群，正常情况下可以解决数据库可靠性问题，但是如果主库挂掉后，数据没有及时同步到从库，这个时候会出现ID重复的现象。我们可以使用双主模式集群，也就是两个Mysql实例都能单独的生产自增ID，这样能够提高效率，但是如果不经过其他改造的话，这两个Mysql实例很可能会生成同样的ID。需要单独给每个Mysql实例配置不同的起始值和自增步长。</p>
<p>第一台Mysql实例配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @@auto_increment_offset = 1;     -- 起始值</span><br><span class="line">set @@auto_increment_increment = 2;  -- 步长</span><br></pre></td></tr></table></figure>

<p>第二台Mysql实例配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @@auto_increment_offset = 2;     -- 起始值</span><br><span class="line">set @@auto_increment_increment = 2;  -- 步长</span><br></pre></td></tr></table></figure>

<p>经过上面的配置后，这两个Mysql实例生成的id序列如下： mysql1,起始值为1,步长为2,ID生成的序列为：1,3,5,7,9,… mysql2,起始值为2,步长为2,ID生成的序列为：2,4,6,8,10,…</p>
<p>对于这种生成分布式ID的方案，需要单独新增一个生成分布式ID应用，比如DistributIdService，该应用提供一个接口供业务应用获取ID，业务应用需要一个ID时，通过rpc的方式请求DistributIdService，DistributIdService随机去上面的两个Mysql实例中去获取ID。</p>
<p>实行这种方案后，就算其中某一台Mysql实例下线了，也不会影响DistributIdService，DistributIdService仍然可以利用另外一台Mysql来生成ID。</p>
<p>但是这种方案的扩展性不太好，如果两台Mysql实例不够用，需要新增Mysql实例来提高性能时，这时就会比较麻烦。</p>
<p>现在如果要新增一个实例mysql3，要怎么操作呢？ 第一，mysql1、mysql2的步长肯定都要修改为3，而且只能是人工去修改，这是需要时间的。 第二，因为mysql1和mysql2是不停在自增的，对于mysql3的起始值我们可能要定得大一点，以给充分的时间去修改mysql1，mysql2的步长。 第三，在修改步长的时候很可能会出现重复ID，要解决这个问题，可能需要停机才行。</p>
<p>为了解决上面的问题，以及能够进一步提高DistributIdService的性能，如果使用第三种生成分布式ID机制。</p>
<h2 id="号段模式"><a href="#号段模式" class="headerlink" title="号段模式"></a>号段模式</h2><p>我们可以使用号段的方式来获取自增ID，号段可以理解成批量获取，比如DistributIdService从数据库获取ID时，如果能批量获取多个ID并缓存在本地的话，那样将大大提供业务应用获取ID的效率。</p>
<p>比如DistributIdService每次从数据库获取ID时，就获取一个号段，比如(1,1000]，这个范围表示了1000个ID，业务应用在请求DistributIdService提供ID时，DistributIdService只需要在本地从1开始自增并返回即可，而不需要每次都请求数据库，一直到本地自增到1000时，也就是当前号段已经被用完时，才去数据库重新获取下一号段。</p>
<p>所以，我们需要对数据库表进行改动，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE id_generator (</span><br><span class="line">  id int(10) NOT NULL,</span><br><span class="line">  current_max_id bigint(20) NOT NULL COMMENT &#x27;当前最大id&#x27;,</span><br><span class="line">  increment_step int(10) NOT NULL COMMENT &#x27;号段的长度&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p>这个数据库表用来记录自增步长以及当前自增ID的最大值（也就是当前已经被申请的号段的最后一个值），因为自增逻辑被移到DistributIdService中去了，所以数据库不需要这部分逻辑了。</p>
<p>这种方案不再强依赖数据库，就算数据库不可用，那么DistributIdService也能继续支撑一段时间。但是如果DistributIdService重启，会丢失一段ID，导致ID空洞。</p>
<p>为了提高DistributIdService的高可用，需要做一个集群，业务在请求DistributIdService集群获取ID时，会随机的选择某一个DistributIdService节点进行获取，对每一个DistributIdService节点来说，数据库连接的是同一个数据库，那么可能会产生多个DistributIdService节点同时请求数据库获取号段，那么这个时候需要利用乐观锁来进行控制，比如在数据库表中增加一个version字段，在获取号段时使用如下SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update id_generator set current_max_id=#&#123;newMaxId&#125;, version=version+1 where version = #&#123;version&#125;</span><br></pre></td></tr></table></figure>

<p>因为newMaxId是DistributIdService中根据oldMaxId+步长算出来的，只要上面的update更新成功了就表示号段获取成功了。</p>
<p>为了提供数据库层的高可用，需要对数据库使用多主模式进行部署，对于每个数据库来说要保证生成的号段不重复，这就需要利用最开始的思路，再在刚刚的数据库表中增加起始值和步长，比如如果现在是两台Mysql，那么 mysql1将生成号段（1,1001]，自增的时候序列为1，3，4，5，7…. mysql1将生成号段（2,1002]，自增的时候序列为2，4，6，8，10…</p>
<p>更详细的可以参考滴滴开源的TinyId：<a href="https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D">github.com/didi/tinyid…</a></p>
<p>在TinyId中还增加了一步来提高效率，在上面的实现中，ID自增的逻辑是在DistributIdService中实现的，而实际上可以把自增的逻辑转移到业务应用本地，这样对于业务应用来说只需要获取号段，每次自增时不再需要请求调用DistributIdService了。</p>
<h2 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h2><p>上面的三种方法总的来说是基于自增思想的，而接下来就介绍比较著名的雪花算法-snowflake。</p>
<p>我们可以换个角度来对分布式ID进行思考，      只要能让负责生成分布式ID的每台机器在每毫秒内生成不一样的ID就行了。</p>
<p>snowflake是twitter开源的分布式ID生成算法，是一种算法，所以它和上面的三种生成分布式ID机制不太一样，它不依赖数据库。</p>
<p>核心思想是：分布式ID固定是一个long型的数字，一个long型占8个字节，也就是64个bit，原始snowflake算法中对于bit的分配如下图：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95.png" alt="雪花算法"></p>
<ul>
<li>第一个bit位是标识部分，在java中由于long的最高位是符号位，正数是0，负数是1，一般生成的ID为正数，所以固定为0。</li>
<li>时间戳部分占41bit，这个是毫秒级的时间，一般实现上不会存储当前的时间戳，而是时间戳的差值（当前时间-固定的开始时间），这样可以使产生的ID从更小值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69年</li>
<li>工作机器id占10bit，这里比较灵活，比如，可以使用前5位作为数据中心机房标识，后5位作为单机房机器标识，可以部署1024个节点。</li>
<li>序列号部分占12bit，支持同一毫秒内同一个节点可以生成4096个ID</li>
</ul>
<p>根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。</p>
<p>snowflake算法实现起来并不难，提供一个github上用java实现的：<a href="https://github.com/beyondfengyu/SnowFlake">github.com/beyondfengy…</a></p>
<p>在大厂里，其实并没有直接使用snowflake，而是进行了改造，因为snowflake算法中最难实践的就是工作机器id，原始的snowflake算法需要人工去为每台机器去指定一个机器id，并配置在某个地方从而让snowflake从此处获取机器id。</p>
<p>但是在大厂里，机器是很多的，人力成本太大且容易出错，所以大厂对snowflake进行了改造。</p>
<h3 id="百度（uid-generator）"><a href="#百度（uid-generator）" class="headerlink" title="百度（uid-generator）"></a>百度（uid-generator）</h3><p>github地址：<a href="https://github.com/baidu/uid-generator">uid-generator</a></p>
<p>uid-generator使用的就是snowflake，只是在生产机器id，也叫做workId时有所不同。</p>
<p>uid-generator中的workId是由uid-generator自动生成的，并且考虑到了应用部署在docker上的情况，在uid-generator中用户可以自己去定义workId的生成策略，默认提供的策略是：应用启动时由数据库分配。说的简单一点就是：应用在启动时会往数据库表(uid-generator需要新增一个WORKER_NODE表)中去插入一条数据，数据插入成功后返回的该数据对应的自增唯一id就是该机器的workId，而数据由host，port组成。</p>
<p>对于uid-generator中的workId，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，需要注意的是，和原始的snowflake不太一样，时间的单位是秒，而不是毫秒，workId也不一样，同一个应用每重启一次就会消费一个workId。</p>
<p>具体可参考<a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">github.com/baidu/uid-g…</a></p>
<h3 id="美团（Leaf）"><a href="#美团（Leaf）" class="headerlink" title="美团（Leaf）"></a>美团（Leaf）</h3><p>github地址：<a href="https://github.com/Meituan-Dianping/Leaf">Leaf</a></p>
<p>美团的Leaf也是一个分布式ID生成框架。它非常全面，即支持号段模式，也支持snowflake模式。号段模式这里就不介绍了，和上面的分析类似。</p>
<p>Leaf中的snowflake模式和原始snowflake算法的不同点，也主要在workId的生成，Leaf中workId是基于ZooKeeper的顺序Id来生成的，每个应用在使用Leaf-snowflake时，在启动时都会都在Zookeeper中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个workId。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总得来说，上面两种都是自动生成workId，以让系统更加稳定以及减少人工成功。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>这里额外再介绍一下使用Redis来生成分布式ID，其实和利用Mysql自增ID类似，可以利用Redis中的incr命令来实现原子性的自增与返回，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set seq_id 1     // 初始化自增ID为1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr seq_id      // 增加1，并返回</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; incr seq_id      // 增加1，并返回</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<p>使用redis的效率是非常高的，但是要考虑持久化的问题。Redis支持RDB和AOF两种持久化的方式。</p>
<p>RDB持久化相当于定时打一个快照进行持久化，如果打完快照后，连续自增了几次，还没来得及做下一次快照持久化，这个时候Redis挂掉了，重启Redis后会出现ID重复。</p>
<p>AOF持久化相当于对每条写命令进行持久化，如果Redis挂掉了，不会出现ID重复的现象，但是会由于incr命令过得，导致重启恢复数据时间过长。</p>
<p>原文：<a href="https://www.cnblogs.com/wuwuyong/p/12212563.html">https://www.cnblogs.com/wuwuyong/p/12212563.html</a></p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>分布式ID</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式核心</title>
    <url>/3f9bb49b.html</url>
    <content><![CDATA[<h1 id="微服务中核心问题解决方案"><a href="#微服务中核心问题解决方案" class="headerlink" title="微服务中核心问题解决方案"></a>微服务中核心问题解决方案</h1><p>分布式id，分布式锁，鉴权，事务等等</p>
<span id="more"></span>





<h1 id="分布式id生成方案有哪些？"><a href="#分布式id生成方案有哪些？" class="headerlink" title="分布式id生成方案有哪些？"></a>分布式id生成方案有哪些？</h1><p>UUID,数据库主键自增，Redis自增ID，雪花算法。</p>
<table>
<thead>
<tr>
<th></th>
<th>描述</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>数据库主键自增</td>
<td>MySQL数据库设置主键且主键自动增长</td>
<td>1. INT和BIGINT类型占用空间较小；<br/>2. 主键自动增长，IO写入连续性好；<br/>3. 数字类型查询速度优于字符串</td>
<td>1. 并发性能不高，受限于数据库性能；<br/>2. 分库分表，需要改造，复杂；<br/>3. 自增：数据和数据量泄露</td>
</tr>
<tr>
<td>UUID</td>
<td>UUID是通用唯一标识码的缩写，其目的是让分布式系统中的所有元素都有唯一的辨识信息，而不需要通过中央控制器来指定唯一标识。</td>
<td>1. 降低全局节点的压力，使得主键生成速度更快；<br/>2. 生成的主键全局唯一；<br/>3. 跨服务器合并数据方便。</td>
<td>1. UUID占用16个字符，空间占用较多；<br/>2. 不是递增有序的数字，数据写入IO随机性很大，且索引效率下降（mysql的B+树索引机制）</td>
</tr>
<tr>
<td>号段模式</td>
<td>量获取多个ID并缓存在本地，集群中每个mysql使用不同的自增步长</td>
<td>1. 不依赖数据库，即使数据库挂了，还能坚持一段时间<br />2.</td>
<td>1. 重启后，会造成号段丢失，ID空洞<br />2.</td>
</tr>
<tr>
<td>Redis自增</td>
<td>Redis计数器，原子性自增</td>
<td>使用内存，并发性能好</td>
<td>1. 数据丢失或者数据恢复慢；<br />2. 需要引入redis‘，而且编码和配置工作量较大<br/>3. 自增：数据量泄露</td>
</tr>
<tr>
<td>雪花算法（snowflake）</td>
<td>大名鼎鼎的雪花算法，分布式ID的经典解决方案</td>
<td>1. 不依赖外部组件；<br/>2. 性能好</td>
<td>1. 时钟回拨（雪花算法中部分依赖当前时间，如果时间值回拨，回造成重复）<br />2.需要为每台机器配置机器id，这个需要手动配置，工作量大容易出错</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>推荐文章：<a href="https://www.cnblogs.com/wuwuyong/p/12212563.html">https://www.cnblogs.com/wuwuyong/p/12212563.html</a></p>
<h1 id="雪花算法生成的ID由哪些部分组成"><a href="#雪花算法生成的ID由哪些部分组成" class="headerlink" title="雪花算法生成的ID由哪些部分组成?"></a>雪花算法生成的ID由哪些部分组成?</h1><ol>
<li>符号位，占用1位。</li>
<li>时间戳，占用41位，可以支持69年的时间跨度。</li>
<li>机器ID，占用10位。</li>
<li>序列号，占用12位。一毫秒可以生成4095个ID。</li>
</ol>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210521124236027.png" alt="image-20210521124236027"></p>
<h1 id="分布式锁在项目中有哪些应用场景？"><a href="#分布式锁在项目中有哪些应用场景？" class="headerlink" title="分布式锁在项目中有哪些应用场景？"></a>分布式锁在项目中有哪些应用场景？</h1><p>使用分布式锁的场景一般需要满足以下场景：</p>
<ol>
<li>系统是一个分布式系统,集群集群，java的锁已经锁不住了。</li>
<li>操作共享资源，比如库里唯一的用户数据。</li>
<li>同步访问，即多个进程同时操作共享资源。</li>
</ol>
<h1 id="分布锁有哪些解决方案？"><a href="#分布锁有哪些解决方案？" class="headerlink" title="分布锁有哪些解决方案？"></a>分布锁有哪些解决方案？</h1><ol>
<li><p>Reids的分布式锁，很多大公司会基于Reidis做扩展开发。setnx key value ex 10s，Redisson。</p>
<p>watch dog.</p>
</li>
<li><p>基于Zookeeper。临时节点，顺序节点。</p>
</li>
<li><p>基于数据库，比如Mysql。主键或唯一索引的唯一性。</p>
</li>
</ol>
<h1 id="Redis做分布式锁用什么命令？"><a href="#Redis做分布式锁用什么命令？" class="headerlink" title="Redis做分布式锁用什么命令？"></a>Redis做分布式锁用什么命令？</h1><p>SETNX<br>格式：setnx key value 将 key 的值设为 value ，当且仅当 key 不存在。<br>若给定的 key 已经存在，则 SETNX 不做任何动作,操作失败。</p>
<p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p>
<p>加锁：set key value nx ex 10s</p>
<p>释放锁：delete key</p>
<h1 id="Redis做分布式锁死锁有哪些情况，如何解决？"><a href="#Redis做分布式锁死锁有哪些情况，如何解决？" class="headerlink" title="Redis做分布式锁死锁有哪些情况，如何解决？"></a>Redis做分布式锁死锁有哪些情况，如何解决？</h1><p>情况1：加锁，没有释放锁。需要加释放锁的操作。比如delete key。</p>
<p>情况2：加锁后，程序还没有执行释放锁，程序挂了。需要用的key的过期机制。</p>
<h1 id="Redis如何做分布式锁？"><a href="#Redis如何做分布式锁？" class="headerlink" title="Redis如何做分布式锁？"></a>Redis如何做分布式锁？</h1><p>假设有两个服务A、B都希望获得锁，执行过程大致如下:</p>
<p>Step1： 服务A为了获得锁，向Redis发起如下命令: SET productId:lock 0xx9p03001 NX EX 30000 其中，”productId”由自己定义，可以是与本次业务有关的id，”0xx9p03001”是一串随机值，必须保证全局唯一，“NX”指的是当且仅当key(也就是案例中的”productId:lock”)在Redis中不存在时，返回执行成功，否则执行失败。”EX 30000”指的是在30秒后，key将被自动删除。执行命令后返回成功，表明服务成功的获得了锁。</p>
<p>Step2: 服务B为了获得锁，向Redis发起同样的命令: SET productId:lock 0000111 NX  EX 30000<br>由于Redis内已经存在同名key，且并未过期，因此命令执行失败，服务B未能获得锁。服务B进入循环请求状态，比如每隔1秒钟(自行设置)向Redis发送请求，直到执行成功并获得锁。</p>
<p>Step3: 服务A的业务代码执行时长超过了30秒，导致key超时，因此Redis自动删除了key。此时服务B再次发送命令执行成功，假设本次请求中设置的value值为0000222。此时需要在服务A中对key进行续期，watch dog。</p>
<p>Step4: 服务A执行完毕，为了释放锁，服务A会主动向Redis发起删除key的请求。注意: 在删除key之前，一定要判断服务A持有的value与Redis内存储的value是否一致。比如当前场景下，Redis中的锁早就不是服务A持有的那一把了，而是由服务2创建，如果贸然使用服务A持有的key来删除锁，则会误将服务2的锁释放掉。此外，由于删除锁时涉及到一系列判断逻辑，因此一般使用lua脚本，具体如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;, KEYS[<span class="number">1</span>])<span class="operator">=</span><span class="operator">=</span>ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">return</span> redis.call(&quot;del&quot;, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h1 id="基于-ZooKeeper-的分布式锁实现原理是什么"><a href="#基于-ZooKeeper-的分布式锁实现原理是什么" class="headerlink" title="基于 ZooKeeper 的分布式锁实现原理是什么?"></a>基于 ZooKeeper 的分布式锁实现原理是什么?</h1><p>顺序节点特性：</p>
<p>使用 ZooKeeper 的顺序节点特性，假如我们在/lock/目录下创建3个节点，ZK集群会按照发起创建的顺序来创建节点，节点分别为/lock/0000000001、/lock/0000000002、/lock/0000000003，最后一位数是依次递增的，节点名由zk来完成。</p>
<p>临时节点特性：</p>
<p>ZK中还有一种名为临时节点的节点，临时节点由某个客户端创建，当客户端与ZK集群断开连接，则该节点自动被删除。EPHEMERAL_SEQUENTIAL为临时顺序节点。</p>
<p>根据ZK中节点是否存在，可以作为分布式锁的锁状态，以此来实现一个分布式锁，下面是分布式锁的基本逻辑：</p>
<ol>
<li>客户端1调用create()方法创建名为“/业务ID/lock-”的临时顺序节点。</li>
<li>客户端1调用getChildren(“业务ID”)方法来获取所有已经创建的子节点。</li>
<li>客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点是所有节点中序号最小的，就是看自己创建的序列号是否排第一，如果是第一，那么就认为这个客户端1获得了锁，在它前面没有别的客户端拿到锁。</li>
<li>如果创建的节点不是所有节点中需要最小的，那么则监视比自己创建节点的序列号小的最大的节点，进入等待。直到下次监视的子节点变更的时候，再进行子节点的获取，判断是否获取锁。</li>
</ol>
<h1 id="ZooKeeper和Reids做分布式锁的区别？"><a href="#ZooKeeper和Reids做分布式锁的区别？" class="headerlink" title="ZooKeeper和Reids做分布式锁的区别？"></a>ZooKeeper和Reids做分布式锁的区别？</h1><p>Reids：</p>
<ol>
<li>Redis只保证最终一致性，副本间的数据复制是异步进行（Set是写，Get是读，Reids集群一般是读写分离架构，存在主从同步延迟情况），主从切换之后可能有部分数据没有复制过去可能会 <strong>「丢失锁」</strong> 情况，故强一致性要求的业务不推荐使用Reids，推荐使用zk。</li>
<li>Redis集群各方法的响应时间均为最低。随着并发量和业务数量的提升其响应时间会有明显上升（公网集群影响因素偏大），但是极限qps可以达到最大且基本无异常</li>
</ol>
<p>ZooKeeper：</p>
<ol>
<li>使用ZooKeeper集群，锁原理是使用ZooKeeper的临时顺序节点，临时顺序节点的生命周期在Client与集群的Session结束时结束。因此如果某个Client节点存在网络问题，与ZooKeeper集群断开连接，Session超时同样会导致锁被错误的释放（导致被其他线程错误地持有），因此ZooKeeper也无法保证完全一致。</li>
<li>ZK具有较好的稳定性；响应时间抖动很小，没有出现异常。但是随着并发量和业务数量的提升其响应时间和qps会明显下降。</li>
</ol>
<p>总结：</p>
<ol>
<li>Zookeeper每次进行锁操作前都要创建若干节点，完成后要释放节点，会浪费很多时间；</li>
<li>而Redis只是简单的数据操作，没有这个问题。</li>
</ol>
<h1 id="MySQL如何做分布式锁？"><a href="#MySQL如何做分布式锁？" class="headerlink" title="MySQL如何做分布式锁？"></a>MySQL如何做分布式锁？</h1><p>在Mysql中创建一张表，设置一个 主键或者UNIQUE KEY 这个 KEY 就是要锁的 KEY（商品ID），所以同一个 KEY 在mysql表里只能插入一次了，这样对锁的竞争就交给了数据库，处理同一个 KEY 数据库保证了只有一个节点能插入成功，其他节点都会插入失败。</p>
<p>DB分布式锁的实现：通过主键id 或者 唯一索性 的唯一性进行加锁，说白了就是加锁的形式是向一张表中插入一条数据，该条数据的id就是一把分布式锁，例如当一次请求插入了一条id为1的数据，其他想要进行插入数据的并发请求必须等第一次请求执行完成后删除这条id为1的数据才能继续插入，实现了分布式锁的功能。</p>
<p>这样 lock 和 unlock 的思路就很简单了，伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def lock ：</span><br><span class="line">    exec sql: insert into locked—table (xxx) values (xxx)</span><br><span class="line">    if result == true :</span><br><span class="line">        return true</span><br><span class="line">    else :</span><br><span class="line">        return false</span><br><span class="line"></span><br><span class="line">def unlock ：</span><br><span class="line">    exec sql: delete from lockedOrder where order_id=&#x27;order_id&#x27;</span><br></pre></td></tr></table></figure>





<h1 id="计数器算法是什么？"><a href="#计数器算法是什么？" class="headerlink" title="计数器算法是什么？"></a>计数器算法是什么？</h1><p>​        计数器算法，是指在指定的时间周期内累加访问次数，达到设定的阈值时，触发限流策略。下一个时间周期进行访问时，访问次数清零。此算法无论在单机还是分布式环境下实现都非常简单，使用redis的incr原子自增性，再结合key的过期时间，即可轻松实现。</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/4-6%20%E8%AE%A1%E6%95%B0%E5%99%A8%E7%AE%97%E6%B3%95-1621753094321.jpg" alt="4-6 计数器算法" style="zoom: 33%;" />



<p>​        从上图我们来看，我们设置一分钟的阈值是100，在0:00到1:00内请求数是60，当到1:00时，请求数清零，从0开始计算，这时在1:00到2:00之间我们能处理的最大的请求为100，超过100个的请求，系统都拒绝。</p>
<p>​        这个算法有一个临界问题，比如在上图中，在0:00到1:00内，只在0:50有60个请求，而在1:00到2:00之间，只在1:10有60个请求，虽然在两个一分钟的时间内，都没有超过100个请求，但是在0:50到1:10这20秒内，确有120个请求，虽然在每个周期内，都没超过阈值，但是在这20秒内，已经远远超过了我们原来设置的1分钟内100个请求的阈值。</p>
<h1 id="滑动时间窗口算法是什么？"><a href="#滑动时间窗口算法是什么？" class="headerlink" title="滑动时间窗口算法是什么？"></a>滑动时间窗口算法是什么？</h1><p>​        为了解决计数器算法的临界值的问题，发明了滑动窗口算法。在TCP网络通信协议中，就采用滑动时间窗口算法来解决网络拥堵问题。</p>
<p>​        滑动时间窗口是将计数器算法中的实际周期切分成多个小的时间窗口，分别在每个小的时间窗口中记录访问次数，然后根据时间将窗口往前滑动并删除过期的小时间窗口。最终只需要统计滑动窗口范围内的小时间窗口的总的请求数即可。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/4-7%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95-1621753118270.jpg" alt="4-7 滑动窗口算法"></p>
<p>​        在上图中，假设我们设置一分钟的请求阈值是100，我们将一分钟拆分成4个小时间窗口，这样，每个小的时间窗口只能处理25个请求，我们用虚线方框表示滑动时间窗口，当前窗口的大小是2，也就是在窗口内最多能处理50个请求。随着时间的推移，滑动窗口也随着时间往前移动，比如上图开始时，窗口是0:00到0:30的这个范围，过了15秒后，窗口是0:15到0:45的这个范围，窗口中的请求重新清零，这样就很好的解决了计数器算法的临界值问题。</p>
<p>​        在滑动时间窗口算法中，我们的小窗口划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。</p>
<h1 id="漏桶限流算法是什么？"><a href="#漏桶限流算法是什么？" class="headerlink" title="漏桶限流算法是什么？"></a>漏桶限流算法是什么？</h1><p>​        漏桶算法的原理就像它的名字一样，我们维持一个漏斗，它有恒定的流出速度，不管水流流入的速度有多快，漏斗出水的速度始终保持不变，类似于消息中间件，不管消息的生产者请求量有多大，消息的处理能力取决于消费者。</p>
<p>​        漏桶的容量=漏桶的流出速度*可接受的等待时长。在这个容量范围内的请求可以排队等待系统的处理，超过这个容量的请求，才会被抛弃。</p>
<p>​        在漏桶限流算法中，存在下面几种情况：</p>
<ol>
<li><p>当请求速度大于漏桶的流出速度时，也就是请求量大于当前服务所能处理的最大极限值时，触发限流策略。</p>
</li>
<li><p>请求速度小于或等于漏桶的流出速度时，也就是服务的处理能力大于或等于请求量时，正常执行。</p>
<p>漏桶算法有一个缺点：当系统在短时间内有突发的大流量时，漏桶算法处理不了。</p>
</li>
</ol>
<h1 id="令牌桶限流算法是什么？"><a href="#令牌桶限流算法是什么？" class="headerlink" title="令牌桶限流算法是什么？"></a>令牌桶限流算法是什么？</h1><p>​        令牌桶算法，是增加一个大小固定的容器，也就是令牌桶，系统以恒定的速率向令牌桶中放入令牌，如果有客户端来请求，先需要从令牌桶中拿一个令牌，拿到令牌，才有资格访问系统，这时令牌桶中少一个令牌。当令牌桶满的时候，再向令牌桶生成令牌时，令牌会被抛弃。</p>
<p>​        在令牌桶算法中，存在以下几种情况：</p>
<ol>
<li><p>请求速度大于令牌的生成速度：那么令牌桶中的令牌会被取完，后续再进来的请求，由于拿不到令牌，会被限流。</p>
</li>
<li><p>请求速度等于令牌的生成速度：那么此时系统处于平稳状态。</p>
</li>
<li><p>请求速度小于令牌的生成速度：那么此时系统的访问量远远低于系统的并发能力，请求可以被正常处理。</p>
<p>令牌桶算法，由于有一个桶的存在，可以处理短时间大流量的场景。这是令牌桶和漏桶的一个区别。</p>
</li>
</ol>
<h1 id="你设计微服务时遵循什么原则？"><a href="#你设计微服务时遵循什么原则？" class="headerlink" title="你设计微服务时遵循什么原则？"></a>你设计微服务时遵循什么原则？</h1><ol>
<li>单一职责原则：让每个服务能独立，有界限的工作，每个服务只关注自己的业务。做到高内聚。</li>
<li>服务自治原则：每个服务要能做到独立开发、独立测试、独立构建、独立部署，独立运行。与其他服务进行解耦。</li>
<li>轻量级通信原则：让每个服务之间的调用是轻量级，并且能够跨平台、跨语言。比如采用RESTful风格，利用消息队列进行通信等。</li>
<li>粒度进化原则：对每个服务的粒度把控，其实没有统一的标准，这个得结合我们解决的具体业务问题。不要过度设计。服务的粒度随着业务和用户的发展而发展。</li>
</ol>
<p>​    总结一句话，软件是为业务服务的，好的系统不是设计出来的，而是进化出来的。</p>
<h1 id="CAP定理是什么？"><a href="#CAP定理是什么？" class="headerlink" title="CAP定理是什么？"></a>CAP定理是什么？</h1><p>​        CAP定理，又叫布鲁尔定理。指的是：在一个分布式系统中，最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p>
<ul>
<li><p>C：一致性（Consistency），数据在多个副本中保持一致，可以理解成两个用户访问两个系统A和B，当A系统数据有变化时，及时同步给B系统，让两个用户看到的数据是一致的。</p>
</li>
<li><p>A：可用性（Availability），系统对外提供服务必须一直处于可用状态，在任何故障下，客户端都能在合理时间内获得服务端非错误的响应。</p>
</li>
<li><p>P：分区容错性（Partition tolerance），在分布式系统中遇到任何网络分区故障，系统仍然能对外提供服务。网络分区，可以这样理解，在分布式系统中，不同的节点分布在不同的子网络中，有可能子网络中只有一个节点，在所有网络正常的情况下，由于某些原因导致这些子节点之间的网络出现故障，导致整个节点环境被切分成了不同的独立区域，这就是网络分区。</p>
<p>​    </p>
<p>我们来详细分析一下CAP，为什么只能满足两个。看下图所示：</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/10-4%20CAP%E6%BC%94%E7%A4%BA-1617721637028.jpg" alt="10-4 CAP演示" style="zoom: 33%;" />



<p>​        用户1和用户2分别访问系统A和系统B，系统A和系统B通过网络进行同步数据。理想情况是：用户1访问系统A对数据进行修改，将data1改成了data2，同时用户2访问系统B，拿到的是data2数据。</p>
<p>​        但是实际中，由于分布式系统具有八大谬论：</p>
<ul>
<li><p>网络相当可靠</p>
</li>
<li><p>延迟为零</p>
</li>
<li><p>传输带宽是无限的</p>
</li>
<li><p>网络相当安全</p>
</li>
<li><p>拓扑结构不会改变</p>
</li>
<li><p>必须要有一名管理员</p>
</li>
<li><p>传输成本为零</p>
</li>
<li><p>网络同质化</p>
</li>
</ul>
<p>我们知道，只要有网络调用，网络总是不可靠的。我们来一一分析。</p>
<ol>
<li>当网络发生故障时，系统A和系统B没法进行数据同步，也就是我们不满足P，同时两个系统依然可以访问，那么此时其实相当于是单机系统，就不是分布式系统了，所以既然我们是分布式系统，P必须满足。</li>
<li>当P满足时，如果用户1通过系统A对数据进行了修改将data1改成了data2，也要让用户2通过系统B正确的拿到data2，那么此时是满足C，就必须等待网络将系统A和系统B的数据同步好，并且在同步期间，任何人不能访问系统B（让系统不可用），否则数据就不是一致的。此时满足的是CP。</li>
<li>当P满足时，如果用户1通过系统A对数据进行了修改将data1改成了data2，也要让系统B能继续提供服务，那么此时，只能接受系统A没有将data2同步给系统B（牺牲了一致性）。此时满足的就是AP。</li>
</ol>
</li>
</ul>
<p>​        我们在前面学过的注册中心Eureka就是满足 的AP，它并不保证C。而Zookeeper是保证CP，它不保证A。在生产中，A和C的选择，没有正确的答案，是取决于自己的业务的。比如12306，是满足CP，因为买票必须满足数据的一致性，不然一个座位多卖了，对铁路运输都是不可以接受的。</p>
<h1 id="BASE理论是什么？"><a href="#BASE理论是什么？" class="headerlink" title="BASE理论是什么？"></a>BASE理论是什么？</h1><p>由于CAP中一致性C和可用性A无法兼得，eBay的架构师，提出了BASE理论，它是通过牺牲数据的强一致性，来获得可用性。它由于如下3种特征：</p>
<ul>
<li><p><strong>B</strong>asically <strong>A</strong>vailable（基本可用）：分布式系统在出现不可预知故障的时候，允许损失部分可用性，保证核心功能的可用。</p>
</li>
<li><p><strong>S</strong>oft state（软状态）：软状态也称为弱状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。、</p>
</li>
<li><p><strong>E</strong>ventually consistent（最终一致性）：最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
</li>
</ul>
<p>​        BASE理论并没有要求数据的强一致性，而是允许数据在一定的时间段内是不一致的，但在最终某个状态会达到一致。在生产环境中，很多公司，会采用BASE理论来实现数据的一致，因为产品的可用性相比强一致性来说，更加重要。比如在电商平台中，当用户对一个订单发起支付时，往往会调用第三方支付平台，比如支付宝支付或者微信支付，调用第三方成功后，第三方并不能及时通知我方系统，在第三方没有通知我方系统的这段时间内，我们给用户的订单状态显示支付中，等到第三方回调之后，我们再将状态改成已支付。虽然订单状态在短期内存在不一致，但是用户却获得了更好的产品体验。</p>
<h1 id="2PC提交协议是什么？"><a href="#2PC提交协议是什么？" class="headerlink" title="2PC提交协议是什么？"></a>2PC提交协议是什么？</h1><p>二阶段提交(Two-phaseCommit)是指，在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。通常，二阶段提交也被称为是一种协议(Protocol))。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。因此，<strong>二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</strong></p>
<p>所谓的两个阶段是指：第一阶段：<strong>准备阶段(投票阶段)<strong>和第二阶段：</strong>提交阶段（执行阶段）</strong>。</p>
<p>准备阶段</p>
<p>事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种“万事俱备，只欠东风”的状态。</p>
<p>可以进一步将准备阶段分为以下三个步骤：</p>
<blockquote>
<p>1）协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。</p>
<p>2）参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</p>
<p>3）各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</p>
</blockquote>
<p>提交阶段</p>
<blockquote>
<p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p>
<p>接下来分两种情况分别讨论提交阶段的过程。</p>
<p>当协调者节点从所有参与者节点获得的相应消息都为”同意”时:</p>
<p><a href="http://www.hollischuang.com/wp-content/uploads/2015/12/success.png"><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/success.png" alt="success"></a></p>
<blockquote>
<p>1）协调者节点向所有参与者节点发出”正式提交(commit)”的请求。</p>
<p>2）参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</p>
<p>3）参与者节点向协调者节点发送”完成”消息。</p>
<p>4）协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。</p>
</blockquote>
</blockquote>
<p>如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</p>
<p><a href="http://www.hollischuang.com/wp-content/uploads/2015/12/fail.png"><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/fail.png" alt="fail"></a></p>
<blockquote>
<p>1）协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。</p>
<p>2）参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</p>
<p>3）参与者节点向协调者节点发送”回滚完成”消息。</p>
<p>4）协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</p>
</blockquote>
<p>　　不管最后结果如何，第二阶段都会结束当前事务。</p>
<h1 id="2PC提交协议有什么缺点？"><a href="#2PC提交协议有什么缺点？" class="headerlink" title="2PC提交协议有什么缺点？"></a>2PC提交协议有什么缺点？</h1><ol>
<li><p><strong>同步阻塞问题</strong>。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</p>
</li>
<li><p><strong>单点故障</strong>。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</p>
</li>
<li><p><strong>数据不一致</strong>。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</p>
</li>
<li><p>二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p>
</li>
</ol>
<h1 id="3PC提交协议是什么？"><a href="#3PC提交协议是什么？" class="headerlink" title="3PC提交协议是什么？"></a>3PC提交协议是什么？</h1><p>CanCommit阶段</p>
<p>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。</p>
<blockquote>
<p><strong>1.事务询问</strong> 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</p>
<p><strong>2.响应反馈</strong> 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No</p>
</blockquote>
<p>PreCommit阶段</p>
<p>协调者根据参与者的反应情况来决定是否可以进行事务的PreCommit操作。根据响应情况，有以下两种可能。</p>
<p><strong>假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。</strong></p>
<blockquote>
<p><strong>1.发送预提交请求</strong> 协调者向参与者发送PreCommit请求，并进入Prepared阶段。</p>
<p><strong>2.事务预提交</strong> 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。</p>
<p><strong>3.响应反馈</strong> 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</p>
</blockquote>
<p><strong>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</strong></p>
<blockquote>
<p><strong>1.发送中断请求</strong> 协调者向所有参与者发送abort请求。</p>
<p><strong>2.中断事务</strong> 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</p>
</blockquote>
<p>pre阶段参与者没收到请求，rollback。</p>
<p>doCommit阶段</p>
<p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p>
<p><strong>执行提交</strong></p>
<blockquote>
<p><strong>1.发送提交请求</strong> 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。</p>
<p><strong>2.事务提交</strong> 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p>
<p><strong>3.响应反馈</strong> 事务提交完之后，向协调者发送Ack响应。</p>
<p><strong>4.完成事务</strong> 协调者接收到所有参与者的ack响应之后，完成事务。</p>
</blockquote>
<p><strong>中断事务</strong> 协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。</p>
<blockquote>
<p><strong>1.发送中断请求</strong> 协调者向所有参与者发送abort请求</p>
<p><strong>2.事务回滚</strong> 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p>
<p><strong>3.反馈结果</strong> 参与者完成事务回滚之后，向协调者发送ACK消息</p>
<p><strong>4.中断事务</strong> 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</p>
</blockquote>
<h1 id="2PC和3PC的区别是什么？"><a href="#2PC和3PC的区别是什么？" class="headerlink" title="2PC和3PC的区别是什么？"></a>2PC和3PC的区别是什么？</h1><p>1、引入超时机制。同时在协调者和参与者中都引入超时机制。</p>
<p>2、三阶段在2PC的第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</p>
<ul>
<li><h1 id="TCC解决方案是什么"><a href="#TCC解决方案是什么" class="headerlink" title="TCC解决方案是什么?"></a>TCC解决方案是什么?</h1><p>​        TCC（Try-Confirm-Cancel）是一种常用的分布式事务解决方案，它将一个事务拆分成三个步骤：</p>
<ul>
<li><p>T（Try）：业务检查阶段，这阶段主要进行业务校验和检查或者资源预留；也可能是直接进行业务操作。</p>
</li>
<li><p>C（Confirm）：业务确认阶段，这阶段对Try阶段校验过的业务或者预留的资源进行确认。</p>
</li>
<li><p>C（Cancel）：业务回滚阶段，这阶段和上面的C（Confirm）是互斥的，用于释放Try阶段预留的资源或者业务。</p>
</li>
</ul>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210521230854476-1621753201509.png" alt="image-20210521230854476" style="zoom: 50%;" />



<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210521230904203-1621753201509.png" alt="image-20210521230904203" style="zoom:50%;" />



<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210521230919795-1621753201509.png" alt="image-20210521230912365" style="zoom:50%;" />



<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210521230919795-1621753201509.png" alt="image-20210521230919795" style="zoom:50%;" /></li>
</ul>
<h1 id="TCC空回滚是解决什么问题的？"><a href="#TCC空回滚是解决什么问题的？" class="headerlink" title="TCC空回滚是解决什么问题的？"></a>TCC空回滚是解决什么问题的？</h1><p>​        在没有调用TCC资源Try方法的情况下，调用了二阶段的Cancel方法。比如当Try请求由于网络延迟或故障等原因，没有执行，结果返回了异常，那么此时Cancel就不能正常执行，因为Try没有对数据进行修改，如果Cancel进行了对数据的修改，那就会导致数据不一致。<br>​        解决思路是关键就是要识别出这个空回滚。思路很简单就是需要知道Try阶段是否执行，如果执行了，那就是正常回滚；如果没执行，那就是空回滚。建议TM在发起全局事务时生成全局事务记录，全局事务ID贯穿整个分布式事务调用链条。再额外增加一张<strong>分支事务记录表</strong>，其中有全局事务ID和分支事务ID，第一阶段Try方法里会插入一条记录，表示Try阶段执行了。Cancel接口里读取该记录，如果该记录存在，则正常回滚；如果该记录不存在，则是空回滚。</p>
<h1 id="如何解决TCC幂等问题？"><a href="#如何解决TCC幂等问题？" class="headerlink" title="如何解决TCC幂等问题？"></a>如何解决TCC幂等问题？</h1><p>为了保证TCC二阶段提交重试机制不会引发数据不一致，要求TCC的二阶段Confirm和Cancel接口保证幂等，这样不会重复使用或者释放资源。如果幂等控制没有做好，很有可能导致数据不一致等严重问题。<br>解决思路在上述 <strong>分支事务记录</strong>中增加执行状态，每次执行前都查询该状态。</p>
<p>分布式锁。</p>
<h1 id="如何解决TCC中悬挂问题？"><a href="#如何解决TCC中悬挂问题？" class="headerlink" title="如何解决TCC中悬挂问题？"></a>如何解决TCC中悬挂问题？</h1><p>悬挂就是对于一个分布式事务，其二阶段Cancel接口比Try接口先执行。<br>        出现原因是在调用分支事务Try时，由于网络发生拥堵，造成了超时，TM就会通知RM回滚该分布式事务，可能回滚完成后，Try请求才到达参与者真正执行，而一个Try方法预留的业务资源，只有该分布式事务才能使用，该分布式事务第一阶段预留的业务资源就再也没有人能够处理了，对于这种情况，我们就称为悬挂，即业务资源预留后无法继续处理。<br>        解决思路是如果二阶段执行完成，那一阶段就不能再继续执行。在执行一阶段事务时判断在该全局事务下，判断<strong>分支事务记录表</strong>中是否已经有二阶段事务记录，如果有则不执行Try。</p>
<h1 id="可靠消息服务方案是什么？"><a href="#可靠消息服务方案是什么？" class="headerlink" title="可靠消息服务方案是什么？"></a>可靠消息服务方案是什么？</h1><p>​        可靠消息最终一致性方案指的是：当事务的发起方（事务参与者，消息发送者）执行完本地事务后，同时发出一条消息，事务参与方（事务参与者，消息的消费者）一定能够接受消息并可以成功处理自己的事务。</p>
<p>​        这里面强调两点：</p>
<ol>
<li>可靠消息：发起方一定得把消息传递到消费者。</li>
<li>最终一致性：最终发起方的业务处理和消费方的业务处理得完成，达成最终一致。</li>
</ol>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210522125830646.png" alt="image-20210522125830646" style="zoom: 67%;" />



<h1 id="最大努力通知方案的关键是什么？"><a href="#最大努力通知方案的关键是什么？" class="headerlink" title="最大努力通知方案的关键是什么？"></a>最大努力通知方案的关键是什么？</h1><ol>
<li> 有一定的消息重复通知机制。因为接收通知方（上图中的我方支付系统）可能没有接收到通知，此时要有一定的机制对消息重复通知。</li>
<li> 消息校对机制。如果尽最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询消息信息来满足需求。</li>
</ol>
<h1 id="什么是分布式系统中的幂等？"><a href="#什么是分布式系统中的幂等？" class="headerlink" title="什么是分布式系统中的幂等？"></a>什么是分布式系统中的幂等？</h1><p>幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。</p>
<p>在编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。</p>
<p>例如，“getUsername()和 setTrue()”函数就是一个幂等函数. 更复杂的操作幂等保证是利用唯一交易号(流水号)实现. 我的理解：幂等就是一个操作，不论执行多少次，产生的效果和返回的结果都是一样的。</p>
<p>操作：查询，set固定值。逻辑删除。set 固定值。</p>
<p>流程：分布式系统中，网络调用，重试机制。</p>
<h1 id="幂等有哪些技术解决方案？"><a href="#幂等有哪些技术解决方案？" class="headerlink" title="幂等有哪些技术解决方案？"></a>幂等有哪些技术解决方案？</h1><p>1.查询操作</p>
<p>查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select 是天然的幂等操作；</p>
<p>2.删除操作</p>
<p>删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回 0，删除的数据多条，返回结果多个。</p>
<p>3.唯一索引</p>
<p>防止新增脏数据。比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建多个资金账户，那么给资金账户表中的用户 ID 加唯一索引，所以一个用户新增成功一个资金账户记录。要点：唯一索引或唯一组合索引来防止新增数据存在脏数据（当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可。</p>
<p>4.token 机制</p>
<p>防止页面重复提交。</p>
<p><strong>业务要求：</strong>页面的数据只能被点击提交一次；</p>
<p><strong>发生原因：</strong>由于重复点击或者网络重发，或者 nginx 重发等情况会导致数据被重复提交；</p>
<p><strong>解决办法：</strong>集群环境采用 token 加 redis(redis 单线程的，处理需要排队)；单 JVM 环境：采用 token 加 redis 或 token 加 jvm 锁。</p>
<p><strong>处理流程：</strong></p>
<ol>
<li>数据提交前要向服务的申请 token，token 放到 redis 或 jvm 内存，token 有效时间；</li>
<li>提交后后台校验 token，同时删除 token，生成新的 token 返回。</li>
</ol>
<p><strong>token 特点：</strong>要申请，一次有效性，可以限流。</p>
<p>注意：redis 要用删除操作来判断 token，删除成功代表 token 校验通过。</p>
<ol start="5">
<li><p>traceId</p>
<p>操作时唯一的。</p>
</li>
</ol>
<h1 id="对外提供的API如何保证幂等？"><a href="#对外提供的API如何保证幂等？" class="headerlink" title="对外提供的API如何保证幂等？"></a>对外提供的API如何保证幂等？</h1><p>举例说明： 银联提供的付款接口：需要接入商户提交付款请求时附带：source 来源，seq 序列号。</p>
<p>source+seq 在数据库里面做唯一索引，防止多次付款(并发时，只能处理一个请求) 。重点：对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源 source，一个是来源方序列号 seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。</p>
<p>注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理。</p>
<h1 id="双写一致性问题如何解决？"><a href="#双写一致性问题如何解决？" class="headerlink" title="双写一致性问题如何解决？"></a>双写一致性问题如何解决？</h1><p>先做一个说明，从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力更新即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。因此，接下来讨论的思路不依赖于给缓存设置过期时间这个方案。<br>在这里，我们讨论<strong>三种</strong>更新策略：</p>
<ol>
<li>先更新缓存，再更新数据库。（不可取）</li>
<li>先更新数据库，再更新缓存。（不可取）</li>
<li>先删除缓存，再更新数据库。（不可取）</li>
<li>先更新数据库，再删除缓存。（可取，有问题待解决）</li>
</ol>
<h3 id="大前提："><a href="#大前提：" class="headerlink" title="大前提："></a>大前提：</h3><p>先读缓存，如果缓存没有，才从数据库读取。</p>
<h3 id="1-先更新数据库，再更新缓存"><a href="#1-先更新数据库，再更新缓存" class="headerlink" title="(1)先更新数据库，再更新缓存"></a>(1)先更新数据库，再更新缓存</h3><p>这套方案，大家是普遍反对的。为什么呢？有如下两点原因。<br><strong>原因一（线程安全角度）</strong><br>同时有请求A和请求B进行更新操作，那么会出现<br>（1）线程A更新了数据库<br>（2）线程B更新了数据库<br>（3）线程B更新了缓存<br>（4）线程A更新了缓存<br>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。<br><strong>原因二（业务场景角度）</strong><br>有如下两点：<br>（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。<br>（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</p>
<p>接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。</p>
<h3 id="2-先删缓存，再更新数据库"><a href="#2-先删缓存，再更新数据库" class="headerlink" title="(2)先删缓存，再更新数据库"></a>(2)先删缓存，再更新数据库</h3><p>该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:<br>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库<br>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。<br>那么，<strong>如何解决呢？采用延时双删策略</strong></p>
<p>（1）先淘汰缓存<br>（2）再写数据库（这两步和原来一样）<br>（3）休眠1秒，再次淘汰缓存<br>这么做，可以将1秒内所造成的缓存脏数据，再次删除。<br><strong>那么，这个1秒怎么确定的，具体该休眠多久呢？</strong><br>针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。<br><strong>如果你用了mysql的读写分离架构怎么办？</strong><br>ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。<br>（1）请求A进行写操作，删除缓存<br>（2）请求A将数据写入数据库了，<br>（3）请求B查询缓存发现，缓存没有值<br>（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值<br>（5）请求B将旧值写入缓存<br>（6）数据库完成主从同步，从库变为新值<br>上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。<br><strong>采用这种同步淘汰策略，吞吐量降低怎么办？</strong><br>ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。<br><strong>第二次删除,如果删除失败怎么办？</strong><br>这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：<br>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库<br>（6）请求A试图去删除，请求B写入对的缓存值，结果失败了。<br>ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。<br><strong>如何解决呢？</strong></p>
<h3 id="3-先更新数据库，再删缓存"><a href="#3-先更新数据库，再删缓存" class="headerlink" title="(3)先更新数据库，再删缓存"></a>(3)先更新数据库，再删缓存</h3><p>首先，先说一下。老外提出了一个缓存更新套路，名为<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside">《Cache-Aside pattern》</a>。其中就指出</p>
<ul>
<li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>
<li><strong>命中</strong>：应用程序从cache中取数据，取到后返回。</li>
<li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li>
</ul>
<p>另外，知名社交网站facebook也在论文<a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf">《Scaling Memcache at Facebook》</a>中提出，他们用的也是先更新数据库，再删缓存的策略。<br><strong>这种情况不存在并发问题么？</strong><br>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生<br>（1）缓存刚好失效<br>（2）请求A查询数据库，得一个旧值<br>（3）请求B将新值写入数据库<br>（4）请求B删除缓存<br>（5）请求A将查到的旧值写入缓存<br>ok，如果发生上述情况，确实是会发生脏数据。<br><strong>然而，发生这种情况的概率又有多少呢？</strong><br>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。<br>假设，有人非要抬杠，有强迫症，一定要解决怎么办？<br><strong>如何解决上述并发问题？</strong><br>首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。<br><strong>还有其他造成不一致的原因么？</strong><br>有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。<br><strong>如何解决？</strong><br>提供一个保障的重试机制即可，这里给出两套方案。<br><strong>方案一</strong>：<br>如下图所示<br><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/o_update1.png" alt="image"  /><br>流程如下所示<br>（1）更新数据库数据；<br>（2）缓存因为种种问题删除失败<br>（3）将需要删除的key发送至消息队列<br>（4）自己消费消息，获得需要删除的key<br>（5）继续重试删除操作，直到成功<br>然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。<br><strong>方案二</strong>：<br><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/o_update2.png" alt="image"><br>流程如下图所示：<br>（1）更新数据库数据<br>（2）数据库会将操作信息写入binlog日志当中<br>（3）订阅程序提取出所需要的数据以及key<br>（4）另起一段非业务代码，获得该信息<br>（5）尝试删除缓存操作，发现删除失败<br>（6）将这些信息发送至消息队列<br>（7)重新从消息队列中获得该数据，重试操作。</p>
<p><strong>备注说明：</strong>上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。至于oracle中，博主目前不知道有没有现成中间件可以使用。另外，重试机制，博主是采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，这些大家可以灵活自由发挥，只是提供一个思路。</p>
<h1 id="分布式微服务项目你是如何设计的？"><a href="#分布式微服务项目你是如何设计的？" class="headerlink" title="分布式微服务项目你是如何设计的？"></a>分布式微服务项目你是如何设计的？</h1><p>我一般设计成两层：业务层和能力层（中台），业务层接受用户请求，然后通过调用能力层来完成业务逻辑。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210522172654370.png" alt="image-20210522172654370"></p>
<h1 id="认证-Authentication-和授权-Authorization-的区别是什么？"><a href="#认证-Authentication-和授权-Authorization-的区别是什么？" class="headerlink" title="认证 (Authentication) 和授权 (Authorization)的区别是什么？"></a>认证 (Authentication) 和授权 (Authorization)的区别是什么？</h1><p>Authentication（认证） 是验证您的身份的凭据（例如用户名/用户ID和密码），通过这个凭据，系统得以知道你就是你，也就是说系统存在你这个用户。所以，Authentication 被称为身份/用户验证。<br>Authorization（授权） 发生在 Authentication（认证） 之后。授权，它主要掌管我们访问系统的权限。比如有些特定资源只能具有特定权限的人才能访问比如admin，有些对系统资源操作比如删除、添加、更新只能特定人才具有。<br>这两个一般在我们的系统中被结合在一起使用，目的就是为了保护我们系统的安全性。</p>
<h1 id="Cookie-和-Session-有什么区别？如何使用Session进行身份验证？"><a href="#Cookie-和-Session-有什么区别？如何使用Session进行身份验证？" class="headerlink" title="Cookie 和 Session 有什么区别？如何使用Session进行身份验证？"></a>Cookie 和 Session 有什么区别？如何使用Session进行身份验证？</h1><p>Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<p>那么，如何使用Session进行身份验证？</p>
<p>很多时候我们都是通过 SessionID 来实现特定的用户，SessionID 一般会选择存放在 Redis 中。举个例子：用户成功登陆系统，然后返回给客户端具有 SessionID 的 Cookie，当用户向后端发起请求的时候会把 SessionID 带上，这样后端就知道你的身份状态了。关于这种认证方式更详细的过程如下：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210520130119426.png" alt="image-20210520130119426"></p>
<p>用户向服务器发送用户名和密码用于登陆系统。<br>服务器验证通过后，服务器为用户创建一个 Session，并将 Session信息存储 起来。<br>服务器向用户返回一个 SessionID，写入用户的 Cookie。<br>当用户保持登录状态时，Cookie 将与每个后续请求一起被发送出去。<br>服务器可以将存储在 Cookie 上的 Session ID 与存储在内存中或者数据库中的 Session 信息进行比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态。<br>使用 Session 的时候需要注意下面几个点：</p>
<p>依赖Session的关键业务一定要确保客户端开启了Cookie。<br>注意Session的过期时间</p>
<h1 id="为什么Cookie-无法防止CSRF攻击，而token可以？"><a href="#为什么Cookie-无法防止CSRF攻击，而token可以？" class="headerlink" title="为什么Cookie 无法防止CSRF攻击，而token可以？"></a>为什么Cookie 无法防止CSRF攻击，而token可以？</h1><p><strong>CSRF（Cross Site Request Forgery）</strong>一般被翻译为 跨站请求伪造 。那么什么是 跨站请求伪造 呢？说简单用你的身份去发送一些对你不友好的请求。举个简单的例子：</p>
<p>小壮登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小壮好奇的点开了这个链接，结果发现自己的账户少了10000元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求,也就是通过你的 Cookie 向银行发出请求。</p>
<p>&lt;a src=<a href="http://www.mybank.com/Transfer?bankId=11&amp;money=10000&gt;%E7%A7%91%E5%AD%A6%E7%90%86%E8%B4%A2%EF%BC%8C%E5%B9%B4%E7%9B%88%E5%88%A9%E7%8E%87%E8%BF%87%E4%B8%87">http://www.mybank.com/Transfer?bankId=11&amp;money=10000&gt;科学理财，年盈利率过万</a>&lt;/&gt;<br>进行Session 认证的时候，我们一般使用 Cookie 来存储 SessionId,当我们登陆后后端生成一个SessionId放在Cookie中返回给客户端，服务端通过Redis或者其他存储工具记录保存着这个Sessionid，客户端登录以后每次请求都会带上这个SessionId，服务端通过这个SessionId来标示你这个人。如果别人通过 cookie拿到了 SessionId 后就可以代替你的身份访问系统了。</p>
<p>Session 认证中 Cookie 中的 SessionId是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。</p>
<p>但是，我们使用 token 的话就不会存在这个问题，在我们登录成功获得 token 之后，一般会选择存放在 local storage 中。然后我们在前端通过某些方式会给每个发到后端的请求加上这个 token,这样就不会出现 CSRF 漏洞的问题。因为，即使有个你点击了非法链接发送了请求到服务端，这个非法请求是不会携带 token 的，所以这个请求将是非法的。</p>
<h1 id="什么是-Token-什么是-JWT-如何基于Token进行身份验证？"><a href="#什么是-Token-什么是-JWT-如何基于Token进行身份验证？" class="headerlink" title="什么是 Token?什么是 JWT?如何基于Token进行身份验证？"></a>什么是 Token?什么是 JWT?如何基于Token进行身份验证？</h1><p>我们知道 Session 信息需要保存一份在服务器端。这种方式会带来一些麻烦，比如需要我们保证保存 Session 信息服务器的可用性、不适合移动端（依赖Cookie）等等。</p>
<p>有没有一种不需要自己存放 Session 信息就能实现身份验证的方式呢？使用 Token 即可！JWT （JSON Web Token） 就是这种方式的实现，通过这种方式服务器端就不需要保存 Session 数据了，只用在客户端保存服务端返回给客户的 Token 就可以了，扩展性得到提升。</p>
<p>JWT 本质上就一段签名的 JSON 格式的数据。由于它是带有签名的，因此接收者便可以验证它的真实性。</p>
<p>下面是 RFC 7519 对 JWT 做的较为正式的定义。</p>
<p>JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted. ——JSON Web Token (JWT)</p>
<p>JWT 由 3 部分构成:</p>
<p>Header :描述 JWT 的元数据。定义了生成签名的算法以及 Token 的类型。<br>Payload（负载）:用来存放实际需要传递的数据<br>Signature（签名）：服务器通过Payload、Header和一个密钥(secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。<br>在基于 Token 进行身份验证的的应用程序中，服务器通过Payload、Header和一个密钥(secret)创建令牌（Token）并将 Token 发送给客户端，客户端将 Token 保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 Authorization字段中：Authorization: Bearer Token。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210520130410868.png" alt="image-20210520130410868"></p>
<p>用户向服务器发送用户名和密码用于登陆系统。<br>身份验证服务响应并返回了签名的 JWT，上面包含了用户是谁的内容。<br>用户以后每次向后端发请求都在Header中带上 JWT。<br>服务端检查 JWT 并从中获取用户相关信息。</p>
<h1 id="分布式架构下，Session-共享有什么方案"><a href="#分布式架构下，Session-共享有什么方案" class="headerlink" title="分布式架构下，Session 共享有什么方案?"></a>分布式架构下，Session 共享有什么方案?</h1><ol>
<li>不要有session：但是确实在某些场景下，是可以没有session的，其实在很多接口类系统当中，都提倡【API无状态服务】；也就是每一次的接口访问，都不依赖于session、不依赖于前一次的接口访问；</li>
<li>存入cookie中：将session存储到cookie中，但是缺点也很明显，例如每次请求都得带着session，数据存储在客户端本地，是有风险的；</li>
<li>session同步：对个服务器之间同步session，这样可以保证每个服务器上都有全部的session信息，不过当服务器数量比较多的时候，同步是会有延迟甚至同步失败；</li>
<li>使用Nginx（或其他复杂均衡软硬件）中的ip绑定策略，同一个ip只能在指定的同一个机器访问，但是这样做风险也比较大，而且也是去了负载均衡的意义；</li>
<li>我们现在的系统会把session放到Redis中存储，虽然架构上变得复杂，并且需要多访问一次Redis，但是这种方案带来的好处也是很大的：实现session共享，可以水平扩展（增加Redis服务器），服务器重启session不丢失（不过也要注意session在Redis中的刷新/失效机制），不仅可以跨服务器session共享，甚至可以跨平台（例如网页端和APP端）。</li>
</ol>
]]></content>
      <categories>
        <category>分布式</category>
        <category>分布式核心</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>redis核心问题</title>
    <url>/e1fa6938.html</url>
    <content><![CDATA[<h2 id="redis核心问题"><a href="#redis核心问题" class="headerlink" title="redis核心问题"></a>redis核心问题</h2><p>redis线程，高并发下的缓存穿透、击穿、血崩、缓存淘汰策略、持久化机制，redis的分布式锁</p>
<span id="more"></span>

<h2 id="01-说一下在你项目中的redis的应用场景"><a href="#01-说一下在你项目中的redis的应用场景" class="headerlink" title="01.说一下在你项目中的redis的应用场景"></a>01.说一下在你项目中的redis的应用场景</h2><p>1,5大value类型 :根据我的redis课有场景的介绍</p>
<p>2,基本上就是缓存~!</p>
<p>3,为的是服务无状态,延申思考,看你的项目有哪些数据结构或对象,再单机里需要单机锁,在多机需要分布式锁,抽出来放入redis中;</p>
<p>4,无锁化</p>
<h2 id="02-redis是单线程还是多线程"><a href="#02-redis是单线程还是多线程" class="headerlink" title="02.redis是单线程还是多线程"></a>02.redis是单线程还是多线程</h2><p>1, 无论什么版本,工作线程就是一个</p>
<p>2, 6.x高版本出现了IO多线程</p>
<p>3,使用上来说,没有变化</p>
<hr>
<p>4, [去学一下系统IO课],你要真正的理解面向IO模型编程的时候,有内核的事,从内核把数据搬运到程序里这是第一步,然后,搬运回来的数据做的计算是第二步,netty</p>
<p>5,单线程,满足redis的串行原子,只不过IO多线程后,把输入/输出放到更多的线程里去并行,好处如下: 1,执行时间短,更快; 2,更好的压榨系统及硬件的资源(网卡能够高效的使用);</p>
<p>*,客户端被读取的顺序不能被保障<br>哪个顺序是可以被保障的: 在一个连接里,socket里</p>
<p>6.x以前</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210309122215735.png" alt="6.x以前" style="zoom: 67%;" />缓存不严谨,尽量去分片</p>
<p> 6.x以后</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210309123037436.png" alt=" 6.x以后" style="zoom:67%;" />

<h2 id="03-redis存在线程安全的问题么"><a href="#03-redis存在线程安全的问题么" class="headerlink" title="03.redis存在线程安全的问题么"></a>03.redis存在线程安全的问题么</h2><p>重复2中的单线程串行</p>
<p>redis可以保障内部串行</p>
<p>外界使用的时候要保障,业务上要自行保障顺序~!</p>
<h2 id="04-遇到过缓存穿透么"><a href="#04-遇到过缓存穿透么" class="headerlink" title="04.遇到过缓存穿透么"></a>04.遇到过缓存穿透么</h2><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210309132305485.png" alt="image-20210309132305485" style="zoom:67%;" />

<h2 id="05-遇到过缓存击穿么"><a href="#05-遇到过缓存击穿么" class="headerlink" title="05.遇到过缓存击穿么"></a>05.遇到过缓存击穿么</h2><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210309133256790.png" alt="image-20210309133256790" style="zoom:67%;" />

<h2 id="06-如何避免缓存雪崩"><a href="#06-如何避免缓存雪崩" class="headerlink" title="06.如何避免缓存雪崩"></a>06.如何避免缓存雪崩</h2><p>以上问题,核心就是避免DB无效/重复请求,结合图去理解</p>
<p>涉及一些架构思想上的提升</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210309133911287.png" alt="image-20210309133911287" style="zoom:67%;" />



<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210309134226303.png" alt="image-20210309134226303" style="zoom:67%;" />



<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210309134154406.png" alt="image-20210309134154406" style="zoom:67%;" />

<h2 id="07-缓存课后解答"><a href="#07-缓存课后解答" class="headerlink" title="07.缓存课后解答"></a>07.缓存课后解答</h2><ol>
<li><p>如果查询的key缓存也没有DB也没有,访问的量又比较大会怎么样?</p>
</li>
<li><p>6.x多线程IO模式下,是怎么保证事务的?<br>事务有queue的</p>
</li>
</ol>
<h2 id="08-redis是怎么删除过期key的-缓存时如何回收的"><a href="#08-redis是怎么删除过期key的-缓存时如何回收的" class="headerlink" title="08.redis是怎么删除过期key的(缓存时如何回收的)"></a>08.redis是怎么删除过期key的(缓存时如何回收的)</h2><p>1,后台在轮询,分段分批的删除那些过期的key</p>
<p>2,请求的时候判断是否已经过期了</p>
<p>尽量的把内存无用空间回收回来</p>
<h2 id="09-缓存是如何淘汰的"><a href="#09-缓存是如何淘汰的" class="headerlink" title="09.缓存是如何淘汰的"></a>09.缓存是如何淘汰的</h2><p>0,内存空间不足的情况下:</p>
<p>1,淘汰机制里有不允许淘汰</p>
<p>2,lru/lfu/random/TTL</p>
<p>3,全空间</p>
<p>4,设置过期的key的</p>
<h2 id="10-如何进行缓存预热"><a href="#10-如何进行缓存预热" class="headerlink" title="10.如何进行缓存预热"></a>10.如何进行缓存预热</h2><p>1,提前把数据塞入redis,(你知道那些是热数据么?肯定不知道,会造成上线很多数据没有缓存命中)</p>
<p>2,开发逻辑上也要规避差集(你没缓存的),会造成击穿,穿透,雪崩,实施4,5,6中的锁方案</p>
<p>3,一劳永逸,未来也不怕了</p>
<p>*结合4,5,</p>
<h2 id="10-如何进行缓存预热-1"><a href="#10-如何进行缓存预热-1" class="headerlink" title="10.如何进行缓存预热"></a>10.如何进行缓存预热</h2><p>1,提前把数据塞入redis,(你知道那些是热数据么?肯定不知道,会造成上线很多数据没有缓存命中)</p>
<p>2,开发逻辑上也要规避差集(你没缓存的),会造成击穿,穿透,雪崩,实施4,5,6中的锁方案</p>
<p>3,一劳永逸,未来也不怕了</p>
<p>*结合4,5,</p>
<h2 id="12-简述一下主从不一致的问题"><a href="#12-简述一下主从不一致的问题" class="headerlink" title="12.简述一下主从不一致的问题?"></a>12.简述一下主从不一致的问题?</h2><p>1,redis的确默认时弱一致性,异步的同步</p>
<p>2,锁不能用主从(单实例/分片集群/redlock)==&gt;redisson</p>
<p>3,在配置中提供了必须有多少个client连接能同步,你可以配置同步因子,趋向于强一致性</p>
<p>4,wait 2 0    小心</p>
<p>5,34点就有点违背</p>
<h2 id="13-描述一下持久化原理"><a href="#13-描述一下持久化原理" class="headerlink" title="13.描述一下持久化原理"></a>13.描述一下持久化原理</h2><p>当前线程阻塞服务</p>
<p>异步后台进程完成持久</p>
<p>fork + cow</p>
<h2 id="14-描述一下redis持久化方式"><a href="#14-描述一下redis持久化方式" class="headerlink" title="14.描述一下redis持久化方式?"></a>14.描述一下redis持久化方式?</h2><p>1,RDB,AOF;主从同步也算持久化</p>
<p>2,高版本;开启AOF,AOF时可以通过执行日志得到全部内存数据的方式,但是追求性能</p>
<p>2.1,体积变大,重复无效指令    重写,后台用线程把内存的kv生成指令写个新的aof</p>
<p>2.2,4.x 新</p>
<h2 id="15-Redis也打不住了-万级流量回答到DB上-该怎么处理"><a href="#15-Redis也打不住了-万级流量回答到DB上-该怎么处理" class="headerlink" title="15.Redis也打不住了,万级流量回答到DB上,该怎么处理?"></a>15.Redis也打不住了,万级流量回答到DB上,该怎么处理?</h2><p>见456</p>
<h2 id="16-redis中的事务三条指令是什么-第三条指令到达后执行失败了-怎么处理"><a href="#16-redis中的事务三条指令是什么-第三条指令到达后执行失败了-怎么处理" class="headerlink" title="16.redis中的事务三条指令是什么,第三条指令到达后执行失败了,怎么处理"></a>16.redis中的事务三条指令是什么,第三条指令到达后执行失败了,怎么处理</h2><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210308195931941.png" alt="image-20210308195931941" style="zoom:67%;" />

<h2 id="17-为什么使用setnx-redis实现分布式锁的指令"><a href="#17-为什么使用setnx-redis实现分布式锁的指令" class="headerlink" title="17.为什么使用setnx(redis实现分布式锁的指令)"></a>17.为什么使用setnx(redis实现分布式锁的指令)</h2><p>1,好东西,原子    (不存在的情况下完成创建)</p>
<p>1,如果要做分布式锁,就要用set k v nx ex    (不存在,过期时间,避免死锁)</p>
]]></content>
      <categories>
        <category>redis</category>
        <category>redis核心问题</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL进阶部分</title>
    <url>/353ffb0.html</url>
    <content><![CDATA[<ul>
<li><a href="#%E4%B8%80mysql%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D">一、MySQL的架构介绍</a><ul>
<li><a href="#1mysql%E7%AE%80%E4%BB%8B">1.MySql简介</a></li>
<li><a href="#2mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D">2.MySQL逻辑架构介绍</a><ul>
<li><a href="#1connectors">1.Connectors</a></li>
<li><a href="#2-management-serveices--utilities%EF%BC%9A">2 Management Serveices &amp; Utilities：</a></li>
<li><a href="#3-connection-pool-%E8%BF%9E%E6%8E%A5%E6%B1%A0">3 Connection Pool: 连接池</a></li>
<li><a href="#4-sql-interface-sql%E6%8E%A5%E5%8F%A3%E3%80%82">4 SQL Interface: SQL接口。</a></li>
<li><a href="#5-parser-%E8%A7%A3%E6%9E%90%E5%99%A8%E3%80%82">5 Parser: 解析器。</a></li>
<li><a href="#6-optimizer-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E3%80%82">6 Optimizer: 查询优化器。</a></li>
<li><a href="#7-cache%E5%92%8Cbuffer%EF%BC%9A-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E3%80%82">7 Cache和Buffer： 查询缓存。</a></li>
<li><a href="#8-%E3%80%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%8E%A5%E5%8F%A3">8 、存储引擎接口</a></li>
</ul>
</li>
<li><a href="#3mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">3.MySQL存储引擎</a><ul>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%EF%BC%9A">查看命令：</a></li>
<li><a href="#myisam%E5%92%8Cinnodb%E5%8C%BA%E5%88%AB%EF%BC%9A">MyISAM和InnoDB区别：</a></li>
</ul>
<span id="more"></span></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90">二、索引优化分析</a><ul>
<li><a href="#1%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B">1.索引简介</a><ul>
<li><a href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">是什么？</a></li>
<li><a href="#%E4%BC%98%E5%8A%BF%EF%BC%9A">优势：</a></li>
<li><a href="#%E5%8A%A3%E5%8A%BF%EF%BC%9A">劣势：</a></li>
<li><a href="#mysql%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB">mysql索引分类</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%EF%BC%9A">基本语法：</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8alter%E5%91%BD%E4%BB%A4%EF%BC%9A">使用Alter命令：</a></li>
<li><a href="#mysql%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%EF%BC%9A">mysql索引结构：</a></li>
<li><a href="#btree%EF%BC%9A">BTree：</a></li>
<li><a href="#btree">B+Tree</a></li>
<li><a href="#b%E6%A0%91%E7%B4%A2%E5%BC%95%EF%BC%9A">B树索引：</a></li>
<li><a href="#b%E6%A0%91%E7%B4%A2%E5%BC%95%EF%BC%9A-1">B+树索引：</a></li>
<li><a href="#%E5%85%B6%E4%B8%ADmyisam%E5%92%8Cinnodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E9%83%BD%E9%87%87%E7%94%A8b%E6%A0%91%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BD%86%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C">其中MyISAM和InnoDB存储引擎都采用B+树索引，但底层实现方式不同</a></li>
<li><a href="#hash%E7%B4%A2%E5%BC%95%EF%BC%9A">Hash索引：</a></li>
<li><a href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95">哪些情况需要创建索引</a></li>
<li><a href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8D%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95">哪些情况不要创建索引</a></li>
</ul>
</li>
<li><a href="#2%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">2.性能分析</a><ul>
<li><a href="#mysql-query-optimizer">MySQL Query Optimizer</a></li>
<li><a href="#mysql%E5%B8%B8%E8%A7%81%E7%93%B6%E9%A2%88">MySQL常见瓶颈:</a></li>
<li><a href="#explain">Explain</a><ul>
<li><a href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E6%9F%A5%E7%9C%8B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%89">是什么（查看执行计划）</a></li>
<li><a href="#%E6%80%8E%E4%B9%88%E7%8E%A9">怎么玩</a></li>
<li><a href="#%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%A1%E6%81%AF">执行计划包含的信息</a></li>
<li><a href="#%E5%90%84%E4%B8%AA%E5%AD%97%E6%AE%B5%E8%A7%A3%E9%87%8A">各个字段解释</a></li>
<li><a href="#id">id</a></li>
<li><a href="#select_type">select_type</a></li>
<li><a href="#table">table</a></li>
<li><a href="#type">type</a></li>
<li><a href="#possible_keys">possible_keys</a></li>
<li><a href="#key">key</a></li>
<li><a href="#key_len">key_len</a></li>
<li><a href="#ref">ref</a></li>
<li><a href="#rows">rows</a></li>
<li><a href="#extra">Extra</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96">3.索引优化</a><ul>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%EF%BC%88%E5%BA%94%E8%AF%A5%E9%81%BF%E5%85%8D%EF%BC%89">索引失效（应该避免）</a></li>
<li><a href="#%E4%B8%80%E8%88%AC%E6%80%A7%E5%BB%BA%E8%AE%AE">一般性建议</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89%E6%9F%A5%E8%AF%A2%E6%88%AA%E5%8F%96%E5%88%86%E6%9E%90">三、查询截取分析</a><ul>
<li><a href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96">查询优化</a><ul>
<li><a href="#order-by%E5%85%B3%E9%94%AE%E5%AD%97%E4%BC%98%E5%8C%96">order by关键字优化</a></li>
<li><a href="#%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5">优化策略</a></li>
<li><a href="#%E5%B0%8F%E6%80%BB%E7%BB%93">小总结:</a></li>
<li><a href="#group-by%E5%85%B3%E9%94%AE%E5%AD%97%E4%BC%98%E5%8C%96">GROUP BY关键字优化</a></li>
</ul>
</li>
<li><a href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97">慢查询日志</a><ul>
<li><a href="#%E6%98%AF%E4%BB%80%E4%B9%88">是什么</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7mysqldumpslow">日志分析工具mysqldumpslow</a></li>
</ul>
</li>
<li><a href="#%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E8%84%9A%E6%9C%AC">批量数据脚本</a><ul>
<li><a href="#%E5%BE%80%E8%A1%A8%E9%87%8C%E6%8F%92%E5%85%A51000w%E6%95%B0%E6%8D%AE">往表里插入1000W数据</a></li>
</ul>
</li>
<li><a href="#show-profiles">Show profiles</a><ul>
<li><a href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9A">是什么：</a></li>
<li><a href="#%E5%88%86%E6%9E%90%E6%AD%A5%E9%AA%A4">分析步骤:</a></li>
</ul>
</li>
<li><a href="#%E5%85%A8%E5%B1%80%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97">全局查询日志</a><ul>
<li><a href="#%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%BC%80%E5%90%AF%E8%BF%99%E4%B8%AA%E5%8A%9F%E8%83%BD%E3%80%82">永远不要在生产环境开启这个功能。</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9B%9Bmysql%E9%94%81%E6%9C%BA%E5%88%B6">四、MySQL锁机制</a><ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a><ul>
<li><a href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB">锁的分类</a><ul>
<li><a href="#%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%88%E8%AF%BB%E3%80%81%E5%86%99%EF%BC%89%E5%88%86%EF%BC%9A">从数据操作的类型（读、写）分：</a></li>
<li><a href="#%E4%BB%8E%E5%AF%B9%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E9%A2%97%E7%B2%92%E5%BA%A6%EF%BC%9A">从对数据操作的颗粒度：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%A1%A8%E9%94%81%EF%BC%88%E5%81%8F%E8%AF%BB%EF%BC%89">表锁（偏读）</a><ul>
<li><a href="#%E7%89%B9%E7%82%B9">特点</a></li>
<li><a href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90">案例分析</a><ul>
<li><a href="#%E5%BB%BA%E8%A1%A8sql">建表SQL</a></li>
<li><a href="#%E5%8A%A0%E8%AF%BB%E9%94%81">加读锁</a></li>
<li><a href="#%E5%8A%A0%E5%86%99%E9%94%81">加写锁</a></li>
</ul>
</li>
<li><a href="#%E6%A1%88%E4%BE%8B%E7%BB%93%E8%AE%BA">案例结论</a></li>
<li><a href="#%E8%A1%A8%E9%94%81%E5%88%86%E6%9E%90">表锁分析</a></li>
</ul>
</li>
<li><a href="#%E8%A1%8C%E9%94%81%EF%BC%88%E5%81%8F%E5%86%99%EF%BC%89">行锁（偏写）</a><ul>
<li><a href="#%E7%89%B9%E7%82%B9-1">特点</a></li>
<li><a href="#%E7%94%B1%E4%BA%8E%E8%A1%8C%E9%94%81%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%A4%8D%E4%B9%A0%E8%80%81%E7%9F%A5%E8%AF%86">由于行锁支持事务，复习老知识</a><ul>
<li><a href="#%E4%BA%8B%E5%8A%A1%EF%BC%88transation%EF%BC%89%E5%8F%8A%E5%85%B6acid%E5%B1%9E%E6%80%A7">事务（Transation）及其ACID属性</a></li>
<li><a href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98">并发事务处理带来的问题</a></li>
<li><a href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">事务隔离级别</a></li>
</ul>
</li>
<li><a href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-1">案例分析</a><ul>
<li><a href="#%E5%BB%BA%E8%A1%A8sql-1">建表SQL</a></li>
<li><a href="#%E8%A1%8C%E9%94%81%E5%AE%9A%E5%9F%BA%E6%9C%AC%E6%BC%94%E7%A4%BA">行锁定基本演示</a></li>
<li><a href="#%E6%97%A0%E7%B4%A2%E5%BC%95%E8%A1%8C%E9%94%81%E5%8D%87%E7%BA%A7%E4%B8%BA%E8%A1%A8%E9%94%81">无索引行锁升级为表锁</a></li>
<li><a href="#%E9%97%B4%E9%9A%99%E9%94%81%E5%8D%B1%E5%AE%B3">间隙锁危害</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%B8%B8%E8%80%83%E5%A6%82%E4%BD%95%E9%94%81%E5%AE%9A%E4%B8%80%E8%A1%8C">面试题：常考如何锁定一行</a></li>
</ul>
</li>
<li><a href="#%E6%A1%88%E4%BE%8B%E7%BB%93%E8%AE%BA-1">案例结论</a></li>
<li><a href="#%E8%A1%8C%E9%94%81%E5%88%86%E6%9E%90">行锁分析</a></li>
<li><a href="#%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE">优化建议</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%94%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">五、主从复制</a><ul>
<li><a href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">复制的基本原理</a><ul>
<li><a href="#%E4%B8%89%E5%A4%A7%E6%AD%A5%E9%AA%A4%EF%BC%9A">三大步骤：</a></li>
</ul>
</li>
<li><a href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99">复制的基本原则</a></li>
<li><a href="#%E5%A4%8D%E5%88%B6%E6%9C%80%E5%A4%A7%E9%97%AE%E9%A2%98">复制最大问题</a><ul>
<li><a href="#%E5%BB%B6%E6%97%B6">延时</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%AD%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">六、参考资料</a>  <pre><code>* [尚硅谷讲堂](#尚硅谷讲堂)  
* [图灵学院](#图灵学院)
</code></pre>
</li>
</ul>
<h2 id="一、MySQL的架构介绍"><a href="#一、MySQL的架构介绍" class="headerlink" title="一、MySQL的架构介绍"></a>一、MySQL的架构介绍</h2><h3 id="1-MySql简介"><a href="#1-MySql简介" class="headerlink" title="1.MySql简介"></a>1.MySql简介</h3><p>​        概述：<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/1.png"></p>
<h3 id="2-MySQL逻辑架构介绍"><a href="#2-MySQL逻辑架构介绍" class="headerlink" title="2.MySQL逻辑架构介绍"></a>2.MySQL逻辑架构介绍</h3><p>​        <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/2.png" alt="2"></p>
<p>​    <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/3.png" alt="2"></p>
<h5 id="1-Connectors"><a href="#1-Connectors" class="headerlink" title="1.Connectors"></a>1.Connectors</h5><p>指的是不同语言中与SQL的交互</p>
<h5 id="2-Management-Serveices-amp-Utilities："><a href="#2-Management-Serveices-amp-Utilities：" class="headerlink" title="2 Management Serveices &amp; Utilities："></a>2 Management Serveices &amp; Utilities：</h5><p>系统管理和控制工具</p>
<h5 id="3-Connection-Pool-连接池"><a href="#3-Connection-Pool-连接池" class="headerlink" title="3 Connection Pool: 连接池"></a>3 Connection Pool: 连接池</h5><p>管理缓冲用户连接，线程处理等需要缓存的需求。<br>负责监听对 MySQL Server 的各种请求，接收连接请求，转发所有连接请求到线程管理模块。每一个连接上 MySQL Server 的客户端请求都会被分配（或创建）一个连接线程为其单独服务。而连接线程的主要工作就是负责 MySQL Server 与客户端的通信，<br>接受客户端的命令请求，传递 Server 端的结果信息等。线程管理模块则负责管理维护这些连接线程。包括线程的创建，线程的 cache 等。</p>
<h5 id="4-SQL-Interface-SQL接口。"><a href="#4-SQL-Interface-SQL接口。" class="headerlink" title="4 SQL Interface: SQL接口。"></a>4 SQL Interface: SQL接口。</h5><p>接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface</p>
<h5 id="5-Parser-解析器。"><a href="#5-Parser-解析器。" class="headerlink" title="5 Parser: 解析器。"></a>5 Parser: 解析器。</h5><p>SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由Lex和YACC实现的，是一个很长的脚本。<br>在 MySQL中我们习惯将所有 Client 端发送给 Server 端的命令都称为 query ，在 MySQL Server 里面，连接线程接收到客户端的一个 Query 后，会直接将该 query 传递给专门负责将各种 Query 进行分类然后转发给各个对应的处理模块。<br>主要功能：<br>a . 将SQL语句进行语义和语法的分析，分解成数据结构，然后按照不同的操作类型进行分类，然后做出针对性的转发到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。<br>b.  如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的</p>
<h5 id="6-Optimizer-查询优化器。"><a href="#6-Optimizer-查询优化器。" class="headerlink" title="6 Optimizer: 查询优化器。"></a>6 Optimizer: 查询优化器。</h5><p>SQL语句在查询之前会使用查询优化器对查询进行优化。就是优化客户端请求的 query（sql语句） ，根据客户端请求的 query 语句，和数据库中的一些统计信息，在一系列算法的基础上进行分析，得出一个最优的策略，告诉后面的程序如何取得这个 query 语句的结果<br>他使用的是“选取-投影-联接”策略进行查询。<br>       用一个例子就可以理解： select uid,name from user where gender = 1;<br>       这个select 查询先根据where 语句进行选取，而不是先将表全部查询出来以后再进行gender过滤<br>       这个select查询先根据uid和name进行属性投影，而不是将属性全部取出以后再进行过滤<br>       将这两个查询条件联接起来生成最终查询结果</p>
<h5 id="7-Cache和Buffer：-查询缓存。"><a href="#7-Cache和Buffer：-查询缓存。" class="headerlink" title="7 Cache和Buffer： 查询缓存。"></a>7 Cache和Buffer： 查询缓存。</h5><p>他的主要功能是将客户端提交 给MySQL 的 Select 类 query 请求的返回结果集 cache 到内存中，与该 query 的一个 hash 值 做一个对应。该 Query 所取数据的基表发生任何数据的变化之后， MySQL 会自动使该 query 的Cache 失效。在读写比例非常高的应用系统中， Query Cache 对性能的提高是非常显著的。当然它对内存的消耗也是非常大的。<br>如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等</p>
<h5 id="8-、存储引擎接口"><a href="#8-、存储引擎接口" class="headerlink" title="8 、存储引擎接口"></a>8 、存储引擎接口</h5><p>存储引擎接口模块可以说是 MySQL 数据库中最有特色的一点了。目前各种数据库产品中，基本上只有 MySQL 可以实现其底层数据存储引擎的插件式管理。这个模块实际上只是 一个抽象类，但正是因为它成功地将各种数据处理高度抽象化，才成就了今天 MySQL 可插拔存储引擎的特色。<br>     从图2还可以看出，MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。<br>    注意：存储引擎是基于表的，而不是数据库。</p>
<h3 id="3-MySQL存储引擎"><a href="#3-MySQL存储引擎" class="headerlink" title="3.MySQL存储引擎"></a>3.MySQL存储引擎</h3><h4 id="查看命令："><a href="#查看命令：" class="headerlink" title="查看命令："></a>查看命令：</h4><p>​        <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/4.png" alt="2"></p>
<h4 id="MyISAM和InnoDB区别："><a href="#MyISAM和InnoDB区别：" class="headerlink" title="MyISAM和InnoDB区别："></a>MyISAM和InnoDB区别：</h4><p>​    <img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/5.png" alt="2"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210629172838705.png" alt="image-20210629172838705"></p>
<h2 id="InnoDB四大特性"><a href="#InnoDB四大特性" class="headerlink" title="InnoDB四大特性"></a>InnoDB四大特性</h2><h4 id="1、插入缓冲（insert-buffer）"><a href="#1、插入缓冲（insert-buffer）" class="headerlink" title="1、插入缓冲（insert buffer）"></a>1、插入缓冲（insert buffer）</h4><p>插入缓冲（Insert Buffer/Change Buffer）：提升插入性能，change buffering是insert buffer的加强，insert buffer只针对insert有效，change buffering对insert、delete、update(delete+insert)、purge都有效</p>
<p>使用插入缓冲的条件：</p>
<ul>
<li><p>非聚集索引（辅助索引）</p>
</li>
<li><p>非唯一索引</p>
</li>
</ul>
<p>Change buffer是作为buffer pool中的一部分存在。<code>Innodb_change_buffering</code>参数缓存所对应的操作(update会被认为是delete+insert)：</p>
<ul>
<li><p><code>all</code>: 默认值，缓存insert, delete, purges操作</p>
</li>
<li><p><code>none</code>: 不缓存</p>
</li>
<li><p><code>inserts</code>: 缓存insert操作</p>
</li>
<li><p><code>deletes</code>: 缓存delete操作</p>
</li>
<li><p><code>changes</code>: 缓存insert和delete操作</p>
</li>
<li><p><code>purges</code>: 缓存后台执行的物理删除操作</p>
</li>
</ul>
<p><code>innodb_change_buffer_max_size</code>参数：控制使用的大小，默认25%，最大可设置50%，如果mysql实例中有大量的修改操作，可考虑增大该参数；</p>
<p>对满足插入缓存条件的插入，每一次的插入不是写到索引页中，而是：</p>
<ol>
<li><p>会先判断插入的非聚集索引页是否在缓冲池中，如果在直接插入；</p>
</li>
<li><p>如果不在，则先放到insert buffer中，再按照一定的频率进行合并操作，再写会磁盘；</p>
</li>
<li><p>通常可以将多个插入合并到一个操作中，目的是为了减少随机IO带来的性能损耗；</p>
</li>
</ol>
<p>这样通常能将多个插入合并到一个操作中，目的还是为了<strong>减少随机IO带来性能损耗</strong>。</p>
<p><strong>上面提过在一定频率下进行合并，那所谓的频率是什么条件</strong>？</p>
<ol>
<li><p>辅助索引页被读取到缓冲池中。正常的select先检查Insert Buffer是否有该非聚集索引页存在，若有则合并插入。</p>
</li>
<li><p>辅助索引页没有可用空间。空间小于1/32页的大小，则会强制合并操作。</p>
</li>
<li><p>Master Thread 每秒和每10秒的合并操作。</p>
</li>
</ol>
<p>insert buffer的数据结构是一颗B+树；</p>
<ul>
<li><p>全局只有一颗insert buffer B+树，负责对所有表的辅助索引进行insert buffer；</p>
</li>
<li><p>这颗B+树放在共享表空间中，试图通过独立表空间ibd文件恢复表中数据时，往往会导致check table失败，因为表中的辅助索引中的数据可能还在insert buffer中，也就是共享表空间中，所以ibd文件恢复后，还需要repair table操作来重建表上所有的辅助索引；</p>
</li>
</ul>
<h4 id="2、二次写（double-write）"><a href="#2、二次写（double-write）" class="headerlink" title="2、二次写（double write）"></a>2、二次写（double write）</h4><ol>
<li><p>doublewrite缓存位于系统表空间的存储区域，用来缓存innodb的数据页从innodb buffer pool中flush之后并写入到数据文件之前；</p>
</li>
<li><p>当操作系统或数据库进程在数据页写入磁盘的过程中崩溃，可以在doublewrite缓存中找到数据页的备份，用来执行crash恢复；</p>
</li>
<li><p>数据页写入到doublewrite缓存的动作所需要的io消耗要小于写入到数据文件的消耗，因为此写入操作会以一次大的连续块的方式写入；</p>
</li>
</ol>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20210627104446.png" alt="img"></p>
<p>从上图可知：</p>
<ol>
<li><p>内存中doublewrite buffer大小2M；物理磁盘上共享表空间中连续的128个页，也就是2个区（extent）大小同样为2M</p>
</li>
<li><p>对缓冲池脏页进行刷新时，不是直接写磁盘。流程： </p>
</li>
<li><p>通过memcpy()函数将脏页先复制到内存中的doublewrite buffer</p>
</li>
<li><p>通过doublewrite分两次，每次1M顺序的写入共享表空间的物理磁盘上。这个过程中，doublewrite页是连续的，因此这个过程是顺序的，所以开销并不大；</p>
</li>
<li><p>完成doublewrite页的写入后，再将doublewrite buffer中的页写入各个表空间文件中，此时写入是离散的，可能会较慢；</p>
</li>
<li><p>如果操作系统在第三步的过程中发生了崩溃，在恢复过程中，可以从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件中，再应用重做日志；</p>
</li>
</ol>
<h4 id="3、自适应hash索引（ahi）"><a href="#3、自适应hash索引（ahi）" class="headerlink" title="3、自适应hash索引（ahi）"></a>3、自适应hash索引（ahi）</h4><p>innodb存储引擎会监控对表上二级索引的查找，如果发现某二级索引被频繁访问，此索引成为热数据，建立hash索引以提升查询速度，此建立是自动建立哈希索引，故称为自适应哈希索引（adaptive hash index）。</p>
<p>该属性通过<code>innodb_adapitve_hash_index</code>开启，也可以通过<code>—skip-innodb_adaptive_hash_index</code>参数关闭</p>
<p>注意事项：</p>
<ul>
<li><p>自适应哈希索引会占用innodb buffer pool</p>
</li>
<li><p>只适合搜索等值（=）的查询，对于范围查找等操作，是不能使用的</p>
</li>
<li><p>极端情况下，自适应hash索引才有比较大的意义，可以降低逻辑读</p>
</li>
</ul>
<h4 id="4、预读-read-ahead"><a href="#4、预读-read-ahead" class="headerlink" title="4、预读(read ahead)"></a>4、预读(read ahead)</h4><p><strong>extent 定义</strong>：表空间（tablespace 中的一组 page）</p>
<p>InnoDB使用两种预读算法来提高I/O性能：线性预读（linear read-ahead）和随机预读（randomread-ahead）。</p>
<ul>
<li><p>线性预读：以extent为单位，将下一个extent提前读取到buffer pool中；</p>
</li>
<li><p>随机预读：以extent中的page为单位，将当前extent中的剩余的page提前读取到buffer pool中；</p>
</li>
</ul>
<p>线性预读一个重要参数：innodb_read_ahead_threshold，控制什么时间（访问extent中多少页的阈值）触发预读；</p>
<ul>
<li><p>默认：56，范围：0～64，值越高，访问模式检查越严格；</p>
</li>
<li><p>没有该变量之前，当访问到extent最后一个page时，innodb会决定是否将下一个extent放入到buffer pool中；</p>
</li>
</ul>
<p>随机预读说明：</p>
<ul>
<li><p>当同一个extent的一些page在buffer pool中发现时，innodb会将extent中剩余page一并读取到buffer pool中；</p>
</li>
<li><p>随机预读给innodb code带来一些不必要的复杂性，性能上也不稳定，在5.5版本已经废弃，如果启用，需要修改变量：innodb_random_read_ahead为ON；</p>
</li>
</ul>
<h2 id="二、索引优化分析"><a href="#二、索引优化分析" class="headerlink" title="二、索引优化分析"></a>二、索引优化分析</h2><h3 id="1-索引简介"><a href="#1-索引简介" class="headerlink" title="1.索引简介"></a>1.索引简介</h3><h5 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h5><p>MySQL官方对索引的定义为：索引(Index)是帮助MySQL高校获取数据的数据结构。可以得到索引的本质：索引是数据结构。可以简单理解为”排好序的快速查找数据结构”。</p>
<p>结论：数据本身之外,数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，<br>这样就可以在这些数据结构的基础上实现高级查找算法,这种数据结构就是索引。</p>
<p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以文件形式存储在硬盘上。</p>
<h5 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h5><p>通过索引列对数据进行排序，降低数据排序成本，降低了CPU的消耗</p>
<h5 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h5><p>1.实际上索引也是一张表，该表保存了主键和索引字段，并指向实体表的记录,所以索引列也是要占用空间的。</p>
<p>2.虽然索引大大提高了查询速度，同时却会降低更新表的速度,如果对表INSERT,UPDATE和DELETE。因为更新表时，MySQL不仅要不存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</p>
<p>3.索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立优秀的索引，或优化查询语句。</p>
<h5 id="mysql索引分类"><a href="#mysql索引分类" class="headerlink" title="mysql索引分类"></a>mysql索引分类</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单值索引：即一个索引只包含单个列，一个表可以有多个单列索引</span><br><span class="line"></span><br><span class="line">唯一索引：索引列的值必须唯一，但允许有空值</span><br><span class="line"></span><br><span class="line">复合索引：即一个索引包含多个列</span><br></pre></td></tr></table></figure>

<h5 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建：</span><br><span class="line">1.CREATE [UNIQUE] INDEX  indexName ON mytable(columnname(length));</span><br><span class="line">	//如果是CHAR,VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定length。</span><br><span class="line">2.ALTER mytable ADD [UNIQUE]  INDEX [indexName] ON(columnname(length));</span><br><span class="line"></span><br><span class="line">删除：</span><br><span class="line">DROP INDEX [indexName] ON mytable;</span><br><span class="line"></span><br><span class="line">查看：</span><br><span class="line">SHOW INDEX FROM table_name\G</span><br></pre></td></tr></table></figure>

<h5 id="使用Alter命令："><a href="#使用Alter命令：" class="headerlink" title="使用Alter命令："></a>使用Alter命令：</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/6.png" alt="2"></p>
<h5 id="mysql索引结构："><a href="#mysql索引结构：" class="headerlink" title="mysql索引结构："></a>mysql索引结构：</h5><h5 id="BTree："><a href="#BTree：" class="headerlink" title="BTree："></a>BTree：</h5><p>B树（Balance Tree）是一种多路平衡查找树，他的<strong>每一个节点最多包含M个孩子，M就是B树的阶。</strong>M的大小取决于磁盘页的大小。</p>
<p><a href="https://www.bilibili.com/video/BV1UJ411J7CU?p=2&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1UJ411J7CU?p=2&amp;spm_id_from=pageDriver</a></p>
<p><a href="https://www.bilibili.com/video/BV1BK4y1X7Gp?from=search&amp;seid=1872408051532032494">https://www.bilibili.com/video/BV1BK4y1X7Gp?from=search&amp;seid=1872408051532032494</a></p>
<p><a href="https://blog.csdn.net/whoamiyang/article/details/51926985">https://blog.csdn.net/whoamiyang/article/details/51926985</a></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210629183227536.png" alt="image-20210629183227536"></p>
<p><strong>B-树就是B树，中间的横线不是减号，所以不要读成B减树。</strong></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/7.jpg" alt="2"></p>
<h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h5><p>一个m阶的B+树具有如下几个特征：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</span><br><span class="line"></span><br><span class="line">2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</span><br><span class="line"></span><br><span class="line">3.每个父节点的元素都同时存在于子节点中，是子节点中的最大（或最小）元素。</span><br><span class="line"></span><br><span class="line">4.根节点的最大元素是整个B+树的最大元素。</span><br><span class="line"></span><br><span class="line">5.由于父节点的元素都包含在子节点，因此所有叶子节点包括了全部的元素信息。</span><br><span class="line"></span><br><span class="line">6.每个叶子节点都带有指向下一个节点的指针，形成一个有序链表。</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/8.png" alt="2"></p>
<h5 id="B树索引："><a href="#B树索引：" class="headerlink" title="B树索引："></a>B树索引：</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/9.jpg" alt="2"></p>
<h5 id="B-树索引："><a href="#B-树索引：" class="headerlink" title="B+树索引："></a>B+树索引：</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/10.jpg" alt="2"></p>
<h5 id="其中MyISAM和InnoDB存储引擎都采用B-树索引，但底层实现方式不同"><a href="#其中MyISAM和InnoDB存储引擎都采用B-树索引，但底层实现方式不同" class="headerlink" title="其中MyISAM和InnoDB存储引擎都采用B+树索引，但底层实现方式不同"></a>其中MyISAM和InnoDB存储引擎都采用B+树索引，但底层实现方式不同</h5><p>InnoDB实现方式：其中叶子节点存储数据和键值即是原表中数据（聚集索引）</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/11.jpg" alt="2"></p>
<p>MyISAM实现方式：其中叶子节点存储键值和数据表中对应数据的物理地址（非聚集索引）</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/12.jpg" alt="2"></p>
<h5 id="Hash索引："><a href="#Hash索引：" class="headerlink" title="Hash索引："></a>Hash索引：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.只能使用=或&lt;=&gt;操作符的等式比较</span><br><span class="line"></span><br><span class="line">2.优化器不能使用hash索引来加速order by操作</span><br><span class="line"></span><br><span class="line">3.mysql不能确定在两个值之间大约有多少行。如果将一个myisam表改为hash索引的memory表，会影响一些查询的执行效率。</span><br><span class="line"></span><br><span class="line">4.只能使用整个关键字来搜索一行</span><br></pre></td></tr></table></figure>

<p> hash index是基于哈希表实现的，只有精确匹配索引所有列的查询才会生效。对于每一行数据，存储引擎都会对所有的索引列计算一个hash code,并将的有的hash code存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/13.jpg" alt="2"></p>
<h5 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.主键自动建立唯一索引</span><br><span class="line"></span><br><span class="line">2.频繁作为查询的条件的字段应该创建索引</span><br><span class="line"></span><br><span class="line">3.查询中与其他表关联的字段，外键关系建立索引</span><br><span class="line"></span><br><span class="line">4.频繁更新的字段不适合创建索引</span><br><span class="line"></span><br><span class="line">5.Where条件里用不到的字段不创建索引</span><br><span class="line"></span><br><span class="line">6.单间/组合索引的选择问题，who？（在高并发下倾向创建组合索引）</span><br><span class="line"></span><br><span class="line">7.查询中排序的字段，排序字段若通过索引去访问将大大提高排序的速度</span><br><span class="line"></span><br><span class="line">8.查询中统计或者分组字段</span><br></pre></td></tr></table></figure>

<h5 id="哪些情况不要创建索引"><a href="#哪些情况不要创建索引" class="headerlink" title="哪些情况不要创建索引"></a>哪些情况不要创建索引</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.表记录太少</span><br><span class="line"></span><br><span class="line">2.经常增删改的表</span><br><span class="line"></span><br><span class="line">3.数据重复且分布平均的表字段，因此应该只为经常查询和经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</span><br></pre></td></tr></table></figure>



<h3 id="2-性能分析"><a href="#2-性能分析" class="headerlink" title="2.性能分析"></a>2.性能分析</h3><h5 id="MySQL-Query-Optimizer"><a href="#MySQL-Query-Optimizer" class="headerlink" title="MySQL Query Optimizer"></a>MySQL Query Optimizer</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/14.png" alt="2"></p>
<h5 id="MySQL常见瓶颈"><a href="#MySQL常见瓶颈" class="headerlink" title="MySQL常见瓶颈:"></a>MySQL常见瓶颈:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU:CPU在饱和的时候一般发生在数据装入在内存或从磁盘上读取数据时候</span><br><span class="line"></span><br><span class="line">IO:磁盘I/O瓶颈发生在装入数据远大于内存容量时</span><br><span class="line"></span><br><span class="line">服务器硬件的性能瓶颈：top,free,iostat和vmstat来查看系统的性能状态</span><br></pre></td></tr></table></figure>



<h4 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h4><h5 id="是什么（查看执行计划）"><a href="#是什么（查看执行计划）" class="headerlink" title="是什么（查看执行计划）"></a>是什么（查看执行计划）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用EXPLAIN关键字可以模拟优化器执行SQL语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是结构的性能瓶颈</span><br></pre></td></tr></table></figure>

<h5 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Explain+SQL语句</span><br></pre></td></tr></table></figure>

<h5 id="执行计划包含的信息"><a href="#执行计划包含的信息" class="headerlink" title="执行计划包含的信息"></a>执行计划包含的信息</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/15.png" alt="2"></p>
<h5 id="各个字段解释"><a href="#各个字段解释" class="headerlink" title="各个字段解释"></a>各个字段解释</h5><h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序<br>三种情况<br>id相同，执行顺序由上至下</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/16.png" alt="2"></p>
<p>id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/17.png" alt="2"></p>
<p>id相同不同，同时存在</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/18.png" alt="2"></p>
<h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h5><p>有哪些：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/19.png" alt="2"></p>
<p>查询的类型，主要用于区别普通查询、联合查询、子查询等的复杂查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.SIMPLE：简单的select查询，查询中不包含子查询或者UNION</span><br><span class="line"></span><br><span class="line">2.PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记为</span><br><span class="line"></span><br><span class="line">3.SUBQUERY：在SELECT或者WHERE列表中包含了子查询</span><br><span class="line"></span><br><span class="line">4.DERIVED：在FROM列表中包含的子查询被标记为DERIVED（衍生）MySQL会递归执行这些子查询，把结果放						在临时表里。</span><br><span class="line"></span><br><span class="line">5.UNION：若第二个SELECT出现在UNION之后，则被标记为UNION;若UNION包含在FROM子句的子查询中，外					层SELECT将被标记为：DERIVED</span><br><span class="line"></span><br><span class="line">6.UNION RESULT：从UNION表获取结果的SELECT</span><br></pre></td></tr></table></figure>



<h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><p>显示这一行的数据是关于哪张表的</p>
<h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>显示查询使用了何种类型<br>从最好到最差依次是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system&gt;con st&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，这个也可以忽略不计</span><br><span class="line"></span><br><span class="line">const：表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很			快。如将主键至于where列表中，MySQL就能将该查询转换为一个常量</span><br><span class="line"></span><br><span class="line">eq_ref：唯一性索引，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描</span><br><span class="line"></span><br><span class="line">ref：非唯一索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的		行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</span><br><span class="line"></span><br><span class="line">range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引一般就是在你的where语句中				出现了between、&lt;、&gt;、in等的查询这种范围扫描索引扫描比全表扫描要好，因为他只需要开始索引的				某一点，而结束语另一点，不用扫描全部索引</span><br><span class="line"></span><br><span class="line">index：Full Index Scan,index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据		文件小。（也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）</span><br><span class="line"></span><br><span class="line">all：FullTable Scan,将遍历全表以找到匹配的行</span><br></pre></td></tr></table></figure>

<h5 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h5><p>显示可能应用在这张表中的索引,一个或多个。查询涉及的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p>
<h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><p>实际使用的索引。如果为null则没有使用索引</p>
<h5 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h5><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好key_len显示的值为索引最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</p>
<h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h5><p>显示索引那一列被使用了，如果可能的话，是一个常数。那些列或常量被用于查找索引列上的值</p>
<h5 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h5><p>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数</p>
<h5 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h5><p>包含不适合在其他列中显示但十分重要的额外信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Using filesort：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。</span><br><span class="line">MySQL中无法利用索引完成排序操作成为“文件排序”</span><br><span class="line"></span><br><span class="line">2.Using temporary：使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序order by 和分组查询 group by</span><br><span class="line"></span><br><span class="line">3.USING index：表示相应的select操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！</span><br><span class="line">如果同时出现using where，表明索引被用来执行索引键值的查找；</span><br><span class="line">如果没有同时出现using where，表面索引用来读取数据而非执行查找动作。</span><br></pre></td></tr></table></figure>

<p>覆盖索引（Covering Index）：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/20.png" alt="2"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.Using where：表面使用了where过滤</span><br><span class="line"></span><br><span class="line">5.using join buffer：使用了连接缓存</span><br><span class="line"></span><br><span class="line">6.impossible where：where子句的值总是false，不能用来获取任何元组</span><br><span class="line"></span><br><span class="line">7.select tables optimized away：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者</span><br><span class="line">对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，</span><br><span class="line">查询执行计划生成的阶段即完成优化。</span><br><span class="line"></span><br><span class="line">8.distinct：优化distinct，在找到第一匹配的元组后即停止找同样值的工作</span><br></pre></td></tr></table></figure>



<h3 id="3-索引优化"><a href="#3-索引优化" class="headerlink" title="3.索引优化"></a>3.索引优化</h3><h5 id="索引失效（应该避免）"><a href="#索引失效（应该避免）" class="headerlink" title="索引失效（应该避免）"></a>索引失效（应该避免）</h5><p>1.全值匹配我最爱</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/21.png" alt="2"></p>
<p>2.最佳左前缀法则</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/22.png" alt="2"></p>
<p>3.不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/23.png" alt="2"></p>
<p>4.存储引擎不能使用索引中范围条件右边的列</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/24.png" alt="2"></p>
<p>5.尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select*</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/26.png" alt="2"></p>
<p><img src="MySQL%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86-img/27.png" alt="2"></p>
<p>6.mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/28.png" alt="2"></p>
<p>7.is null,is not null 也无法使用索引</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/29.png" alt="2"></p>
<p>8.like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/30.png" alt="2"></p>
<p>​    建立全文索引：<a href="https://blog.csdn.net/Samdy_Chan/article/details/78138420">https://blog.csdn.net/Samdy_Chan/article/details/78138420</a></p>
<p>如果要使用全值匹配，，但是又不想要索引失效，则对要匹配的值和要筛选的值建立索引，要符合索引覆盖。</p>
<p>9.字符串不加单引号索引失效</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/31.png" alt="2"></p>
<p>10.少用or,用它连接时会索引失效</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/32.png" alt="2"></p>
<p>11.小总结</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/33.png" alt="2"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/34.png" alt="2"></p>
<h4 id="一般性建议"><a href="#一般性建议" class="headerlink" title="一般性建议"></a>一般性建议</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于单键索引，尽量选择针对当前query过滤性更好的索引</span><br><span class="line"></span><br><span class="line">在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</span><br><span class="line"></span><br><span class="line">在选择组合索引的时候，尽量选择可以能包含当前query中的where子句中更多字段的索引</span><br><span class="line"></span><br><span class="line">尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</span><br></pre></td></tr></table></figure>







<h3 id="4-索引下推"><a href="#4-索引下推" class="headerlink" title="4.索引下推"></a>4.索引下推</h3><p><a href="https://blog.csdn.net/sinat_29774479/article/details/103470244">https://blog.csdn.net/sinat_29774479/article/details/103470244</a></p>
<h3 id="为什么范围查找索引回失效，后续索引回失效"><a href="#为什么范围查找索引回失效，后续索引回失效" class="headerlink" title="为什么范围查找索引回失效，后续索引回失效"></a>为什么范围查找索引回失效，后续索引回失效</h3><p>作者：Limit<br>链接：<a href="https://www.zhihu.com/question/304037770/answer/1287557228">https://www.zhihu.com/question/304037770/answer/1287557228</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>假设 表T1有字段a,b,c,d,e，其中a是主键，除e为varchar其余为int类型，并创建了一个联合索引idx_t1_bcd(b,c,d)，然后b、c、d三列作为联合索引。Tip:基于InnoDB存储引擎。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/v2-3d8cde8ac15ee65c6e7f0554246b2f97_720w.jpg" alt="img"><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/v2-3d8cde8ac15ee65c6e7f0554246b2f97_720w.jpg" alt="img">T1表</p>
<p>联合索引：<strong>联合索引的所有索引列都出现在索引数上，并依次比较三列的大小。</strong></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/v2-9dab07a4adc00c794f80e91bc0289e36_720w.jpg" alt="img"><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/v2-9dab07a4adc00c794f80e91bc0289e36_720w.jpg" alt="img">联合索引B+树的结构</p>
<p>先看T1表，他的主键暂且我们将它设为整型自增的（PS：为什么是整型自增），InnoDB会使用主键索引在B+树维护索引和数据文件，<strong>然后我们创建了一个联合索引（b，c，d）也会生成一个索引树</strong>，同样是B+树的结构，<strong>只不过它的data部分存储的是联合索引所在行的主键值</strong>（上图叶子节点紫色背景部分）</p>
<p>对于联合索引来说只不过比单值索引多了几列，而这些索引列全都出现在索引树上。对于联合索引，存储引擎会首先根据第一个索引列排序，如上图我们可以单看第一个索引列，如，1 1 5 12 13…他是单调递增的；如果第一列相等则再根据第二列排序，依次类推就构成了上图的索引树，上图中的1 1 4 ，1 1 5以及13 12 4,13 16 1,13 16 5就可以说明这种情况。</p>
<p><strong>联合索引的查找方式</strong></p>
<p>当我们的SQL语言可以应用到索引的时候，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from T1 where b = 12 and c = 14 and d = 3;  </span><br></pre></td></tr></table></figure>

<p>也就是T1表中a列为4的这条记录。存储引擎首先从根节点（一般常驻内存）开始查找，<strong>第一个索引的第一个索引列为1,12大于1，第二个索引的第一个索引列为56,12小于56，于是从这俩索引的中间读到下一个节点的磁盘文件地址</strong>，从磁盘上Load这个节点，通常伴随一次磁盘IO，然后在内存里去查找。当Load叶子节点的第二个节点时又是一次磁盘IO，比较第一个元素，b=12,c=14,d=3完全符合，于是找到该索引下的data元素即ID值，再从主键索引树上找到最终数据。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/v2-60d787835b462e2ee2151ddce8340002_720w.jpg" alt="img"><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/v2-60d787835b462e2ee2151ddce8340002_720w.jpg" alt="img"></p>
<h2 id="三、查询截取分析"><a href="#三、查询截取分析" class="headerlink" title="三、查询截取分析"></a>三、查询截取分析</h2><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><p>永远小表驱动大表，类似嵌套循环Nested Loop</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/35.png" alt="2"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/36.png" alt="2"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/37.png" alt="2"></p>
<h5 id="order-by关键字优化"><a href="#order-by关键字优化" class="headerlink" title="order by关键字优化"></a>order by关键字优化</h5><p>ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序</p>
<p>尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀</p>
<p>如果不在索引列上，filesort有两种算法：<br>mysql就要启动双路排序和单路排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">双路排序</span><br><span class="line">1.MySQL4.1之前是使用双路排序，字面意思是两次扫描磁盘，最终得到数据。</span><br><span class="line">读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据传输</span><br><span class="line">2.从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。</span><br><span class="line">取一批数据，要对磁盘进行两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二张改进的算法，就是单路排序。</span><br><span class="line"></span><br><span class="line">单路排序</span><br><span class="line">从磁盘读取查询需要的所有列，按照orderby列在buffer对它们进行排序，然后扫描排序后的列表进行输出，</span><br><span class="line">它的效率更快一些，避免了第二次读取数据，并且把随机IO变成顺序IO，但是它会使用更多的空间，</span><br><span class="line">因为它把每一行都保存在内存中了。</span><br><span class="line"></span><br><span class="line">结论及引申出的问题</span><br><span class="line">由于单路是后出来的，总体而言好过双路</span><br><span class="line">但是用单路有问题</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/38.png" alt="2"></p>
<h5 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h5><p>增大sort_buffer_size参数的设置</p>
<p>增大max_length_for_sort_data参数的设置</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/39.png" alt="2"></p>
<h5 id="小总结"><a href="#小总结" class="headerlink" title="小总结:"></a>小总结:</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/40.png" alt="2"></p>
<h5 id="GROUP-BY关键字优化"><a href="#GROUP-BY关键字优化" class="headerlink" title="GROUP BY关键字优化"></a>GROUP BY关键字优化</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupby实质是先排序后进行分组，遵照索引建的最佳左前缀</span><br><span class="line"></span><br><span class="line">当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置</span><br><span class="line"></span><br><span class="line">where高于having,能写在where限定的条件就不要去having限定了。</span><br></pre></td></tr></table></figure>



<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><h5 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/41.png" alt="2"></p>
<h5 id="日志分析工具mysqldumpslow"><a href="#日志分析工具mysqldumpslow" class="headerlink" title="日志分析工具mysqldumpslow"></a>日志分析工具mysqldumpslow</h5><p>查看mysqldumpshow的帮助信息</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/42.png" alt="2"></p>
<h3 id="批量数据脚本"><a href="#批量数据脚本" class="headerlink" title="批量数据脚本"></a>批量数据脚本</h3><h5 id="往表里插入1000W数据"><a href="#往表里插入1000W数据" class="headerlink" title="往表里插入1000W数据"></a>往表里插入1000W数据</h5><p>1.建表</p>
<p>2.设置参数log_trust_function_createors</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/43.png" alt="2"></p>
<p>3创建函数保证每条数据都不同</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/44.png" alt="2"></p>
<p>​    随机产生字符串</p>
<p>​    随机产生部门编号</p>
<p>4.创建存储过程</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/45.png" alt="2"></p>
<p>​    创建往emp表中插入数据的存储过程</p>
<p>​    创建往dept表中插入数据的存储过程</p>
<p>5.调用存储过程</p>
<h3 id="Show-profiles"><a href="#Show-profiles" class="headerlink" title="Show profiles"></a>Show profiles</h3><h5 id="是什么："><a href="#是什么：" class="headerlink" title="是什么："></a>是什么：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优测量</span><br></pre></td></tr></table></figure>

<p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p>
<h5 id="分析步骤"><a href="#分析步骤" class="headerlink" title="分析步骤:"></a>分析步骤:</h5><p>1.是否支持，看看当前的SQL版本是否支持</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/46.png" alt="2"></p>
<p>2.开启功能，默认是关闭，使用前需要开启</p>
<p>3.运行SQL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp group by id%10 limit 150000</span><br></pre></td></tr></table></figure>

<p>4.查看结果，show profiles;</p>
<p>5.诊断SQL，show profile cpu,block io for query 上一步前面的问题SQL 数字号码；</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/47.png" alt="2"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/48.png" alt="2"></p>
<p>6.日常开发需要注意的结论</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">converting HEAP to MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。</span><br><span class="line"></span><br><span class="line">Creating tmp table 创建临时表</span><br><span class="line"></span><br><span class="line">Copying to tmp table on disk 把内存中临时表复制到磁盘，危险！！！</span><br><span class="line"></span><br><span class="line">locked</span><br></pre></td></tr></table></figure>







<h3 id="全局查询日志"><a href="#全局查询日志" class="headerlink" title="全局查询日志"></a>全局查询日志</h3><p>配置启用</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/49.png" alt="2"></p>
<p>编码启用</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/50.png" alt="2"></p>
<h5 id="永远不要在生产环境开启这个功能。"><a href="#永远不要在生产环境开启这个功能。" class="headerlink" title="永远不要在生产环境开启这个功能。"></a>永远不要在生产环境开启这个功能。</h5><h2 id="四、MySQL锁机制"><a href="#四、MySQL锁机制" class="headerlink" title="四、MySQL锁机制"></a>四、MySQL锁机制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><a href="https://blog.csdn.net/qq_44766883/article/details/105879308">https://blog.csdn.net/qq_44766883/article/details/105879308</a></p>
<h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><h5 id="从数据操作的类型（读、写）分："><a href="#从数据操作的类型（读、写）分：" class="headerlink" title="从数据操作的类型（读、写）分："></a>从数据操作的类型（读、写）分：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响</span><br><span class="line"></span><br><span class="line">写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。</span><br></pre></td></tr></table></figure>

<h5 id="从对数据操作的颗粒度："><a href="#从对数据操作的颗粒度：" class="headerlink" title="从对数据操作的颗粒度："></a>从对数据操作的颗粒度：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表锁</span><br><span class="line"></span><br><span class="line">行锁</span><br></pre></td></tr></table></figure>

<p>从程度上划分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">悲观锁</span><br><span class="line"></span><br><span class="line">乐观锁</span><br></pre></td></tr></table></figure>



<h3 id="表锁（偏读）"><a href="#表锁（偏读）" class="headerlink" title="表锁（偏读）"></a>表锁（偏读）</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">偏向MyISAM存储引擎，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率最高，并发最低</span><br></pre></td></tr></table></figure>

<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><h5 id="建表SQL"><a href="#建表SQL" class="headerlink" title="建表SQL"></a>建表SQL</h5><p><img src="MySQL%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86-img/51.png" alt="2"></p>
<h5 id="加读锁"><a href="#加读锁" class="headerlink" title="加读锁"></a>加读锁</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/52.png" alt="2"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/53.png" alt="2"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/54.png" alt="2"></p>
<h5 id="加写锁"><a href="#加写锁" class="headerlink" title="加写锁"></a>加写锁</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/55.png" alt="2"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/56.png" alt="2"></p>
<h4 id="案例结论"><a href="#案例结论" class="headerlink" title="案例结论"></a>案例结论</h4><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/57.png" alt="2"></p>
<h4 id="表锁分析"><a href="#表锁分析" class="headerlink" title="表锁分析"></a>表锁分析</h4><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/58.png" alt="2"></p>
<h3 id="行锁（偏写）"><a href="#行锁（偏写）" class="headerlink" title="行锁（偏写）"></a>行锁（偏写）</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</span><br><span class="line"></span><br><span class="line">InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）;二是采用了行级锁</span><br></pre></td></tr></table></figure>



<h4 id="由于行锁支持事务，复习老知识"><a href="#由于行锁支持事务，复习老知识" class="headerlink" title="由于行锁支持事务，复习老知识"></a>由于行锁支持事务，复习老知识</h4><h5 id="事务（Transation）及其ACID属性"><a href="#事务（Transation）及其ACID属性" class="headerlink" title="事务（Transation）及其ACID属性"></a>事务（Transation）及其ACID属性</h5><h5 id="并发事务处理带来的问题"><a href="#并发事务处理带来的问题" class="headerlink" title="并发事务处理带来的问题"></a>并发事务处理带来的问题</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">脏读:（Dirty Reads）：事务A读到了事务B已修改但尚未提交的数据，还在这个数据基础上做了操作，此时，如果						B事务回滚，A读取的数据无效，不符合一致性要求。</span><br><span class="line">不可重复读（Non-Repeatable Reads）：事务A读取到事务B已经提交的数据,不符合隔离性</span><br><span class="line">幻读（Phantom Reads）:事务A读取到事务B新增的数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">脏读和幻读的区别：脏读是事务B修改了数据，幻读是事务B新增了数据.</span><br></pre></td></tr></table></figure>



<h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/59.png" alt="2"></p>
<h4 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h4><h5 id="建表SQL-1"><a href="#建表SQL-1" class="headerlink" title="建表SQL"></a>建表SQL</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/60.png" alt="2"></p>
<h5 id="行锁定基本演示"><a href="#行锁定基本演示" class="headerlink" title="行锁定基本演示"></a>行锁定基本演示</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/61.png" alt="2"></p>
<h5 id="无索引行锁升级为表锁"><a href="#无索引行锁升级为表锁" class="headerlink" title="无索引行锁升级为表锁"></a>无索引行锁升级为表锁</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">varchar  不用 &#x27; &#x27;  导致系统自动转换类型, 行锁变表锁</span><br></pre></td></tr></table></figure>

<h5 id="间隙锁危害"><a href="#间隙锁危害" class="headerlink" title="间隙锁危害"></a>间隙锁危害</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/62.png" alt="2"></p>
<h5 id="面试题：常考如何锁定一行"><a href="#面试题：常考如何锁定一行" class="headerlink" title="面试题：常考如何锁定一行"></a>面试题：常考如何锁定一行</h5><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/63.png" alt="2"></p>
<h4 id="案例结论-1"><a href="#案例结论-1" class="headerlink" title="案例结论"></a>案例结论</h4><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/64.png" alt="2"></p>
<h4 id="行锁分析"><a href="#行锁分析" class="headerlink" title="行锁分析"></a>行锁分析</h4><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/65.png" alt="2"></p>
<h4 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</span><br><span class="line">合理设计索引，尽量缩小锁的范围</span><br><span class="line">尽可能较少检索条件，避免间隙锁</span><br><span class="line">尽量控制事务大小，减少锁定资源量和时间长度</span><br><span class="line">尽可能低级别事务隔离</span><br></pre></td></tr></table></figure>





<h2 id="五、主从复制"><a href="#五、主从复制" class="headerlink" title="五、主从复制"></a>五、主从复制</h2><h3 id="复制的基本原理"><a href="#复制的基本原理" class="headerlink" title="复制的基本原理"></a>复制的基本原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slave会从master读取binlog来进行数据同步</span><br></pre></td></tr></table></figure>

<h5 id="三大步骤："><a href="#三大步骤：" class="headerlink" title="三大步骤："></a>三大步骤：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志时间，binary log events</span><br><span class="line"></span><br><span class="line">slave将master的binary log ebents拷贝到它的中继日志（relay log</span><br><span class="line"></span><br><span class="line">slave重做中继日志中的时间，将改变应用到自己的数据库中。MySQL复制是异步的且串行化的</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/66.png" alt="2"></p>
<h3 id="复制的基本原则"><a href="#复制的基本原则" class="headerlink" title="复制的基本原则"></a>复制的基本原则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每个slave只有一个master</span><br><span class="line"></span><br><span class="line">每个slave只能有一个唯一的服务器ID</span><br><span class="line"></span><br><span class="line">每个master可以有多个salve</span><br></pre></td></tr></table></figure>



<h3 id="复制最大问题"><a href="#复制最大问题" class="headerlink" title="复制最大问题"></a>复制最大问题</h3><h5 id="延时"><a href="#延时" class="headerlink" title="延时"></a>延时</h5><h2 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h2><h5 id="哔哩哔哩尚硅谷讲堂"><a href="#哔哩哔哩尚硅谷讲堂" class="headerlink" title="哔哩哔哩尚硅谷讲堂"></a>哔哩哔哩尚硅谷讲堂</h5><h5 id="哔哩哔哩图灵学院"><a href="#哔哩哔哩图灵学院" class="headerlink" title="哔哩哔哩图灵学院"></a>哔哩哔哩图灵学院</h5><p><strong>github：java2020</strong></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础部分</title>
    <url>/220c1acb.html</url>
    <content><![CDATA[<ul>
<li><a href="#%E4%B8%80%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E5%BA%93">一、为什么要学习数据库</a></li>
<li><a href="#%E4%BA%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">二、数据库的相关概念</a></li>
<li><a href="#%E4%B8%89%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E7%89%B9%E7%82%B9">三、数据库存储数据的特点</a></li>
<li><a href="#%E5%9B%9B%E5%88%9D%E5%A7%8BMySQL">四、初始MySQL</a></li>
<li><a href="#%E4%BA%94DQL%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0">五、DQL语言的学习</a></li>
<li><a href="#%E5%85%ADDML%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0">六、DML语言的学习 </a></li>
<li><a href="#%E4%B8%83DDL%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0">七、DDL语言的学习</a></li>
<li><a href="#%E5%85%ABTCL%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%A6%E4%B9%A0">八、TCL语言的学习</a></li>
<li><a href="#%E4%B9%9D%E8%A7%86%E5%9B%BE%E7%9A%84%E8%AE%B2%E8%A7%A3">九、视图的讲解</a></li>
<li><a href="#%E5%8D%81%E5%8F%98%E9%87%8F">十、变量</a></li>
<li><a href="#%E5%8D%81%E4%B8%80%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0">十一、存储过程和函数</a></li>
<li><a href="#%E5%8D%81%E4%BA%8C%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84">十二、流程控制结构</a></li>
<li><a href="#%E5%8D%81%E4%B8%89%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F">十三、数据库三大范式</a><span id="more"></span></li>
</ul>
<h2 id="一、为什么要学习数据库"><a href="#一、为什么要学习数据库" class="headerlink" title="一、为什么要学习数据库"></a>一、为什么要学习数据库</h2><p>数据库的好处<br>    1.持久化数据到本地<br>    2.可以实现结构化查询，方便管理</p>
<h2 id="二、数据库的相关概念"><a href="#二、数据库的相关概念" class="headerlink" title="二、数据库的相关概念"></a>二、数据库的相关概念</h2><p>​    1、DB：数据库，保存一组有组织的数据的容器<br>​    2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据<br>​    3、SQL:结构化查询语言，用于和DBMS通信的语言</p>
<h2 id="三、数据库存储数据的特点"><a href="#三、数据库存储数据的特点" class="headerlink" title="三、数据库存储数据的特点"></a>三、数据库存储数据的特点</h2><p>​    1、将数据放到表中，表再放到库中<br>​    2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。<br>​    3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。<br>​    4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”<br>​    5、表中的数据是按行存储的，每一行类似于java中的“对象”。</p>
<h2 id="四、初始MySQL"><a href="#四、初始MySQL" class="headerlink" title="四、初始MySQL"></a>四、初始MySQL</h2><h3 id="MySQL产品的介绍"><a href="#MySQL产品的介绍" class="headerlink" title="MySQL产品的介绍"></a>MySQL产品的介绍</h3><h3 id="MySQL产品的安装"><a href="#MySQL产品的安装" class="headerlink" title="MySQL产品的安装"></a>MySQL产品的安装</h3><h3 id="MySQL服务的启动和停止"><a href="#MySQL服务的启动和停止" class="headerlink" title="MySQL服务的启动和停止"></a>MySQL服务的启动和停止</h3><p>​    方式一：计算机——右击管理——服务<br>​    方式二：通过管理员身份运行<br>​    net start 服务名（启动服务）<br>​    net stop 服务名（停止服务）</p>
<h3 id="MySQL服务的登录和退出"><a href="#MySQL服务的登录和退出" class="headerlink" title="MySQL服务的登录和退出"></a>MySQL服务的登录和退出</h3><p>​    方式一：通过mysql自带的客户端<br>​    只限于root用户</p>
<p>​    方式二：通过windows自带的客户端<br>​    登录：<br>​        mysql 【-h主机名 -P端口号 】-u用户名 -p密码</p>
<p>​    退出：<br>​        exit或ctrl+C</p>
<h3 id="MySQL的常见命令和语法规范"><a href="#MySQL的常见命令和语法规范" class="headerlink" title="MySQL的常见命令和语法规范"></a>MySQL的常见命令和语法规范</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.查看当前所有的数据库</span><br><span class="line">show databases;</span><br><span class="line">2.打开指定的库</span><br><span class="line">use 库名</span><br><span class="line">3.查看当前库的所有表</span><br><span class="line">show tables;</span><br><span class="line">4.查看其它库的所有表</span><br><span class="line">show tables from 库名;</span><br><span class="line">5.创建表</span><br><span class="line">create table 表名(</span><br><span class="line"></span><br><span class="line">​	列名 列类型,</span><br><span class="line">​	列名 列类型，</span><br><span class="line">​	。。。</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">6.查看表结构</span><br><span class="line">desc 表名;</span><br><span class="line"></span><br><span class="line">7.查看服务器的版本</span><br><span class="line">方式一：登录到mysql服务端</span><br><span class="line">select version();</span><br><span class="line">方式二：没有登录到mysql服务端</span><br><span class="line">mysql --version</span><br><span class="line">或</span><br><span class="line">mysql --V</span><br><span class="line"></span><br><span class="line">MySQL的语法规范</span><br><span class="line">	1.不区分大小写,但建议关键字大写，表名、列名小写</span><br><span class="line">	2.每条命令最好用分号结尾</span><br><span class="line">	3.每条命令根据需要，可以进行缩进 或换行</span><br><span class="line">	4.注释</span><br><span class="line">		单行注释：#注释文字</span><br><span class="line">		单行注释：-- 注释文字</span><br><span class="line">		多行注释：/* 注释文字  */</span><br><span class="line">	</span><br><span class="line">	</span><br></pre></td></tr></table></figure>



<h2 id="五、DQL语言的学习"><a href="#五、DQL语言的学习" class="headerlink" title="五、DQL语言的学习"></a>五、DQL语言的学习</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h4 id="SQL的语言分类"><a href="#SQL的语言分类" class="headerlink" title="SQL的语言分类"></a>SQL的语言分类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DQL（Data Query Language）：数据查询语言</span><br><span class="line">		select </span><br><span class="line">	DML(Data Manipulate Language):数据操作语言</span><br><span class="line">		insert 、update、delete</span><br><span class="line">	DDL（Data Define Languge）：数据定义语言</span><br><span class="line">		create、drop、alter</span><br><span class="line">	TCL（Transaction Control Language）：事务控制语言</span><br><span class="line">		commit、rollback</span><br></pre></td></tr></table></figure>

<h4 id="SQL的常见命令"><a href="#SQL的常见命令" class="headerlink" title="SQL的常见命令"></a>SQL的常见命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show databases； 查看所有的数据库</span><br><span class="line">use 库名； 打开指定 的库</span><br><span class="line">show tables ; 显示库中的所有表</span><br><span class="line">show tables from 库名;显示指定库中的所有表</span><br><span class="line">create table 表名(</span><br><span class="line">	字段名 字段类型,	</span><br><span class="line">	字段名 字段类型</span><br><span class="line">); 创建表</span><br><span class="line"></span><br><span class="line">desc 表名; 查看指定表的结构</span><br><span class="line">select * from 表名;显示表中的所有数据</span><br></pre></td></tr></table></figure>



<h3 id="进阶1：基础查询"><a href="#进阶1：基础查询" class="headerlink" title="进阶1：基础查询"></a>进阶1：基础查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">	SELECT 要查询的东西</span><br><span class="line">	【FROM 表名】;</span><br></pre></td></tr></table></figure>

<pre><code>类似于Java中 :System.out.println(要打印的东西);
特点：
①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在
② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数
</code></pre>
<h3 id="进阶2：条件查询"><a href="#进阶2：条件查询" class="headerlink" title="进阶2：条件查询"></a>进阶2：条件查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件查询：根据条件过滤原始表的数据，查询到想要的数据</span><br><span class="line">	语法：</span><br><span class="line">	select </span><br><span class="line">		要查询的字段|表达式|常量值|函数</span><br><span class="line">	from </span><br><span class="line">		表</span><br><span class="line">	where </span><br><span class="line">		条件 ;</span><br></pre></td></tr></table></figure>



<pre><code>分类：
一、条件表达式
    示例：salary&gt;10000
    条件运算符：
    &gt; &lt; &gt;= &lt;= = != &lt;&gt;

二、逻辑表达式
示例：salary&gt;10000 &amp;&amp; salary&lt;20000

逻辑运算符：

    and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false
    or(||)：两个条件只要有一个成立，结果为true，否则为false
    not(!)：如果条件成立，则not后为false，否则为true

三、模糊查询
示例：last_name like &#39;a%&#39;
</code></pre>
<h3 id="进阶3：排序查询"><a href="#进阶3：排序查询" class="headerlink" title="进阶3：排序查询"></a>进阶3：排序查询</h3><pre><code>语法：
select
    要查询的东西
from
    表
where 
    条件

order by 排序的字段|表达式|函数|别名 【asc|desc】
</code></pre>
<p>​    </p>
<h3 id="进阶4：常见函数"><a href="#进阶4：常见函数" class="headerlink" title="进阶4：常见函数"></a>进阶4：常见函数</h3><h4 id="一、单行函数"><a href="#一、单行函数" class="headerlink" title="一、单行函数"></a>一、单行函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">​	1、字符函数</span><br><span class="line">​		concat拼接</span><br><span class="line">​		substr截取子串</span><br><span class="line">​		upper转换成大写</span><br><span class="line">​		lower转换成小写</span><br><span class="line">​		trim去前后指定的空格和字符</span><br><span class="line">​		ltrim去左边空格</span><br><span class="line">​		rtrim去右边空格</span><br><span class="line">​		replace替换</span><br><span class="line">​		lpad左填充</span><br><span class="line">​		rpad右填充</span><br><span class="line">​		instr返回子串第一次出现的索引</span><br><span class="line">​		length 获取字节个数</span><br><span class="line">​		</span><br><span class="line">	2、数学函数</span><br><span class="line">		round 四舍五入</span><br><span class="line">		rand 随机数</span><br><span class="line">		floor向下取整</span><br><span class="line">		ceil向上取整</span><br><span class="line">		mod取余</span><br><span class="line">		truncate截断</span><br><span class="line">	3、日期函数</span><br><span class="line">		now当前系统日期+时间</span><br><span class="line">		curdate当前系统日期</span><br><span class="line">		curtime当前系统时间</span><br><span class="line">		str_to_date 将字符转换成日期</span><br><span class="line">		date_format将日期转换成字符</span><br><span class="line">	4、流程控制函数</span><br><span class="line">		if 处理双分支</span><br><span class="line">		case语句 处理多分支</span><br><span class="line">			情况1：处理等值判断</span><br><span class="line">			情况2：处理条件判断</span><br><span class="line">	5、其他函数</span><br><span class="line">		version版本</span><br><span class="line">		database当前库</span><br><span class="line">		user当前连接用户</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h4 id="二、分组函数"><a href="#二、分组函数" class="headerlink" title="二、分组函数"></a>二、分组函数</h4><pre><code>    sum 求和
    max 最大值
    min 最小值
    avg 平均值
    count 计数

    特点：
    1、以上五个分组函数都忽略null值，除了count(*)
    2、sum和avg一般用于处理数值型
        max、min、count可以处理任何数据类型
    3、都可以搭配distinct使用，用于统计去重后的结果
    4、count的参数可以支持：
        字段、*、常量值，一般放1

       建议使用 count(*)
</code></pre>
<h3 id="进阶5：分组查询"><a href="#进阶5：分组查询" class="headerlink" title="进阶5：分组查询"></a>进阶5：分组查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">	select 查询的字段，分组函数</span><br><span class="line">	from 表</span><br><span class="line">	group by 分组的字段</span><br></pre></td></tr></table></figure>

<pre><code>特点：
1、可以按单个字段分组
2、和分组函数一同查询的字段最好是分组后的字段！！！！
3、分组筛选
            针对的表        位置                    关键字
分组前筛选：    原始表            group by的前面            where
分组后筛选：    分组后的结果集        group by的后面         having

4、可以按多个字段分组，字段之间用逗号隔开
5、可以支持排序
6、having后可以支持别名
</code></pre>
<h3 id="进阶6：多表连接查询"><a href="#进阶6：多表连接查询" class="headerlink" title="进阶6：多表连接查询"></a>进阶6：多表连接查询</h3><pre><code>笛卡尔乘积：如果连接条件省略或无效则会出现
解决办法：添加上连接条件
</code></pre>
<h4 id="一、传统模式下的连接-：等值连接——非等值连接"><a href="#一、传统模式下的连接-：等值连接——非等值连接" class="headerlink" title="一、传统模式下的连接 ：等值连接——非等值连接"></a>一、传统模式下的连接 ：等值连接——非等值连接</h4><pre><code>1.等值连接的结果 = 多个表的交集
2.n表连接，至少需要n-1个连接条件
3.多个表不分主次，没有顺序要求
4.一般为表起别名，提高阅读性和性能
</code></pre>
<h4 id="二、sql99语法：通过join关键字实现连接"><a href="#二、sql99语法：通过join关键字实现连接" class="headerlink" title="二、sql99语法：通过join关键字实现连接"></a>二、sql99语法：通过join关键字实现连接</h4><pre><code>含义：1999年推出的sql语法
支持：
等值连接、非等值连接 （内连接）
外连接
交叉连接

语法：

select 字段，...
from 表1
【inner|left outer|right outer|cross】join 表2 on  连接条件
【inner|left outer|right outer|cross】join 表3 on  连接条件
【where 筛选条件】
【group by 分组字段】
【having 分组后的筛选条件】
【order by 排序的字段或表达式】

好处：语句上，连接条件和筛选条件实现了分离，简洁明了！
</code></pre>
<h4 id="三、自连接"><a href="#三、自连接" class="headerlink" title="三、自连接"></a>三、自连接</h4><h5 id="案例：查询员工名和直接上级的名称"><a href="#案例：查询员工名和直接上级的名称" class="headerlink" title="案例：查询员工名和直接上级的名称"></a>案例：查询员工名和直接上级的名称</h5><h5 id="sql99"><a href="#sql99" class="headerlink" title="sql99"></a>sql99</h5><pre><code>SELECT e.last_name,m.last_name
FROM employees e
JOIN employees m 
ON e.`manager_id`=m.`employee_id`;
</code></pre>
<h5 id="sql92"><a href="#sql92" class="headerlink" title="sql92"></a>sql92</h5><pre><code>SELECT e.last_name,m.last_name
FROM employees e,employees m 
WHERE e.`manager_id`=m.`employee_id`;
</code></pre>
<h3 id="进阶7：子查询"><a href="#进阶7：子查询" class="headerlink" title="进阶7：子查询"></a>进阶7：子查询</h3><p>含义：</p>
<pre><code>一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询
在外面的查询语句，称为主查询或外查询
</code></pre>
<p>特点：</p>
<pre><code>1、子查询都放在小括号内
2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧
3、子查询优先于主查询执行，主查询使用了子查询的执行结果
4、子查询根据查询结果的行数不同分为以下两类：
① 单行子查询
    结果集只有一行
    一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= 
    非法使用子查询的情况：
    a、子查询的结果为一组值
    b、子查询的结果为空
    
② 多行子查询
    结果集有多行
    一般搭配多行操作符使用：any、all、in、not in
    in： 属于子查询结果中的任意一个就行
    any和all往往可以用其他查询代替
</code></pre>
<h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><h5 id="1-标量子查询★"><a href="#1-标量子查询★" class="headerlink" title="1.标量子查询★"></a>1.标量子查询★</h5><h5 id="案例1：谁的工资比-Abel-高"><a href="#案例1：谁的工资比-Abel-高" class="headerlink" title="案例1：谁的工资比 Abel 高?"></a>案例1：谁的工资比 Abel 高?</h5><pre><code>①查询Abel的工资
SELECT salary
FROM employees
WHERE last_name = &#39;Abel&#39;

②查询员工的信息，满足 salary&gt;①结果
SELECT *
FROM employees
WHERE salary&gt;(

    SELECT salary
    FROM employees
    WHERE last_name = &#39;Abel&#39;

);  
</code></pre>
<h5 id="案例2：返回job-id与141号员工相同，salary比143号员工多的员工-姓名，job-id-和工资"><a href="#案例2：返回job-id与141号员工相同，salary比143号员工多的员工-姓名，job-id-和工资" class="headerlink" title="案例2：返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资"></a>案例2：返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资</h5><pre><code>①查询141号员工的job_id
SELECT job_id
FROM employees
WHERE employee_id = 141

②查询143号员工的salary
SELECT salary
FROM employees
WHERE employee_id = 143

③查询员工的姓名，job_id 和工资，要求job_id=①并且salary&gt;②

SELECT last_name,job_id,salary
FROM employees
WHERE job_id = (
    SELECT job_id
    FROM employees
    WHERE employee_id = 141
) AND salary&gt;(
    SELECT salary
    FROM employees
    WHERE employee_id = 143

);
</code></pre>
<h5 id="2-列子查询（多行子查询）★"><a href="#2-列子查询（多行子查询）★" class="headerlink" title="2.列子查询（多行子查询）★"></a>2.列子查询（多行子查询）★</h5><h5 id="案例1：返回其它工种中比job-id为‘IT-PROG’工种任一工资低的员工的员工号、姓名、job-id-以及salary"><a href="#案例1：返回其它工种中比job-id为‘IT-PROG’工种任一工资低的员工的员工号、姓名、job-id-以及salary" class="headerlink" title="案例1：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary"></a>案例1：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary</h5><pre><code>①查询job_id为‘IT_PROG’部门任一工资

SELECT DISTINCT salary
FROM employees
WHERE job_id = &#39;IT_PROG&#39;

②查询员工号、姓名、job_id 以及salary，salary&lt;(①)的任意一个
SELECT last_name,employee_id,job_id,salary
FROM employees
WHERE salary&lt;ANY(
    SELECT DISTINCT salary
    FROM employees
    WHERE job_id = &#39;IT_PROG&#39;

) AND job_id&lt;&gt;&#39;IT_PROG&#39;;

或
SELECT last_name,employee_id,job_id,salary
FROM employees
WHERE salary&lt;(
    SELECT MAX(salary)
    FROM employees
    WHERE job_id = &#39;IT_PROG&#39;

) AND job_id&lt;&gt;&#39;IT_PROG&#39;;
</code></pre>
<h5 id="3、行子查询（结果集一行多列或多行多列）"><a href="#3、行子查询（结果集一行多列或多行多列）" class="headerlink" title="3、行子查询（结果集一行多列或多行多列）"></a>3、行子查询（结果集一行多列或多行多列）</h5><h5 id="案例：查询员工编号最小并且工资最高的员工信息"><a href="#案例：查询员工编号最小并且工资最高的员工信息" class="headerlink" title="案例：查询员工编号最小并且工资最高的员工信息"></a>案例：查询员工编号最小并且工资最高的员工信息</h5><pre><code>SELECT * 
FROM employees
WHERE (employee_id,salary)=(
    SELECT MIN(employee_id),MAX(salary)
    FROM employees
);
</code></pre>
<h4 id="二、select后面"><a href="#二、select后面" class="headerlink" title="二、select后面"></a>二、select后面</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">仅仅支持标量子查询</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h4 id="案例：查询每个部门的员工个数"><a href="#案例：查询每个部门的员工个数" class="headerlink" title="案例：查询每个部门的员工个数"></a>案例：查询每个部门的员工个数</h4><p>案例：查询每个部门的员工个数</p>
<pre><code>SELECT d.*,(

    SELECT COUNT(*)
    FROM employees e
    WHERE e.department_id = d.`department_id`
 ) 个数
 FROM departments d;
</code></pre>
<h4 id="三、exists后面（相关子查询）"><a href="#三、exists后面（相关子查询）" class="headerlink" title="三、exists后面（相关子查询）"></a>三、exists后面（相关子查询）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">语法：</span><br><span class="line">exists(完整的查询语句)</span><br><span class="line">结果：</span><br><span class="line">1或0</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>



<pre><code>SELECT EXISTS(SELECT employee_id FROM employees WHERE salary=300000);
</code></pre>
<h3 id="进阶8：分页查询"><a href="#进阶8：分页查询" class="headerlink" title="进阶8：分页查询"></a>进阶8：分页查询</h3><p>应用场景：</p>
<pre><code>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句
</code></pre>
<p>语法：</p>
<pre><code>select 字段|表达式,...
from 表
【where 条件】
【group by 分组字段】
【having 条件】
【order by 排序的字段】
limit 【起始的条目索引，】条目数;
</code></pre>
<p>特点：</p>
<pre><code>1.起始条目索引从0开始

2.limit子句放在查询语句的最后

3.公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage
假如:
每页显示条目数sizePerPage
要显示的页数 page
</code></pre>
<h3 id="进阶9：联合查询"><a href="#进阶9：联合查询" class="headerlink" title="进阶9：联合查询"></a>进阶9：联合查询</h3><p>引入：<br>    union 联合、合并</p>
<p>语法：</p>
<pre><code>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】
select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】
select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】
.....
select 字段|常量|表达式|函数 【from 表】 【where 条件】
</code></pre>
<p>特点：</p>
<pre><code>1、多条查询语句的查询的列数必须是一致的
2、多条查询语句的查询的列的类型几乎相同
3、union代表去重，union all代表不去重
</code></pre>
<h2 id="六、DML语言的学习"><a href="#六、DML语言的学习" class="headerlink" title="六、DML语言的学习"></a>六、DML语言的学习</h2><h3 id="插入语句"><a href="#插入语句" class="headerlink" title="插入语句"></a>插入语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">	insert into 表名(字段名，...)</span><br><span class="line">	values(值1，...);</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<pre><code>1、字段类型和值类型一致或兼容，而且一一对应
2、可以为空的字段，可以不用插入值，或用null填充
3、不可以为空的字段，必须插入值
4、字段个数和值的个数必须一致
5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致
</code></pre>
<h3 id="修改语句"><a href="#修改语句" class="headerlink" title="修改语句"></a>修改语句</h3><pre><code>修改单表语法：
update 表名 set 字段=新值,字段=新值
【where 条件】
修改多表语法：
update 表1 别名1,表2 别名2
set 字段=新值，字段=新值
where 连接条件
and 筛选条件
</code></pre>
<h3 id="删除语句"><a href="#删除语句" class="headerlink" title="删除语句"></a>删除语句</h3><h4 id="方式1：delete语句"><a href="#方式1：delete语句" class="headerlink" title="方式1：delete语句"></a>方式1：delete语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单表的删除： ★</span><br><span class="line">	delete from 表名 【where 筛选条件】</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多表的删除：</span><br><span class="line">	delete 别名1，别名2</span><br><span class="line">	from 表1 别名1，表2 别名2</span><br><span class="line">	where 连接条件</span><br><span class="line">	and 筛选条件;</span><br></pre></td></tr></table></figure>

<h4 id="方式2：truncate语句"><a href="#方式2：truncate语句" class="headerlink" title="方式2：truncate语句"></a>方式2：truncate语句</h4><pre><code>truncate table 表名
</code></pre>
<h4 id="两种方式的区别【面试题】"><a href="#两种方式的区别【面试题】" class="headerlink" title="两种方式的区别【面试题】"></a>两种方式的区别【面试题】</h4><pre><code>1.truncate不能加where条件，而delete可以加where条件
2.truncate的效率高一丢丢
3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始
    delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始
4.truncate删除不能回滚，delete删除可以回滚
</code></pre>
<h2 id="七、DDL语言的学习"><a href="#七、DDL语言的学习" class="headerlink" title="七、DDL语言的学习"></a>七、DDL语言的学习</h2><h3 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h3><h4 id="库的管理："><a href="#库的管理：" class="headerlink" title="库的管理："></a>库的管理：</h4><pre><code>一、创建库
create database 库名
二、删除库
drop database 库名
</code></pre>
<h4 id="表的管理："><a href="#表的管理：" class="headerlink" title="表的管理："></a>表的管理：</h4><h5 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1.创建表"></a>1.创建表</h5><pre><code>CREATE TABLE IF NOT EXISTS stuinfo(
    stuId INT,
    stuName VARCHAR(20),
    gender CHAR,
    bornDate DATETIME
);
DESC studentinfo;
</code></pre>
<h5 id="2-修改表-alter"><a href="#2-修改表-alter" class="headerlink" title="2.修改表 alter"></a>2.修改表 alter</h5><pre><code>语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;

①修改字段名
ALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;

②修改表名
ALTER TABLE stuinfo RENAME [TO]  studentinfo;

③修改字段类型和列级约束
ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;

④添加字段
ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;

⑤删除字段
ALTER TABLE studentinfo DROP COLUMN email;
</code></pre>
<p>​    </p>
<h5 id="3-删除表"><a href="#3-删除表" class="headerlink" title="3.删除表"></a>3.删除表</h5><pre><code>DROP TABLE [IF EXISTS] studentinfo;
</code></pre>
<h5 id="4-复制表"><a href="#4-复制表" class="headerlink" title="4.复制表"></a>4.复制表</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.仅仅复制表的结构</span><br><span class="line">	CREATE TABLE 新表名 LIKE 旧表名;</span><br><span class="line"></span><br><span class="line">2.复制表的结构+数据</span><br><span class="line">	CREATE TABLE 新表名 </span><br><span class="line">	SELECT * FROM 旧表名;</span><br><span class="line"></span><br><span class="line">3.只复制部分数据</span><br><span class="line">	CREATE TABLE 新表名</span><br><span class="line">	SELECT id,au_name</span><br><span class="line">	FROM 旧表名 </span><br><span class="line">	WHERE nation=&#x27;中国&#x27;;</span><br><span class="line">	</span><br><span class="line">4.仅仅复制某些字段</span><br><span class="line">	CREATE TABLE 新表名 </span><br><span class="line">	SELECT id,au_name</span><br><span class="line">	FROM 旧表名</span><br><span class="line">	WHERE 0;</span><br></pre></td></tr></table></figure>



<h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><pre><code>整型：      Tinyint 1个字节
        Smallint 2个字节
        Mediumint 3个字节
        Int、Integer 4个字节
        Bigint   8个字节
特点：
① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字
② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值
③ 如果不设置长度，会有默认的长度
长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！

小数：
    分类：
    1.浮点型
    float(M,D)
    double(M,D)
    2.定点型
    dec(M，D)
    decimal(M,D)
    
    特点：
    
    ①
    M：整数部位+小数部位
    D：小数部位
    如果超过范围，则插入临界值
    
    ②
    M和D都可以省略
    如果是decimal，则M默认为10，D默认为0
    如果是float和double，则会根据插入的数值的精度来决定精度
    
    ③定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用

字符型：
特点：
        写法            M的意思                            特点            空间的耗费        效率
char    char(M)        最大的字符数，可以省略，默认为1    固定长度的字符        比较耗费           高
varchar varchar(M)    最大的字符数，不可以省略        可变长度的字符            比较节省          低


日期型：
分类：
    date只保存日期
    time 只保存时间
    year只保存年
    
    datetime保存日期+时间
    timestamp保存日期+时间
特点：
            字节        范围                      时区等的影响
datetime    8        1000——9999                      不受
timestamp    4        1970-2038                        受
</code></pre>
<p>​    </p>
<h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><pre><code>NOT NULL
DEFAULT
UNIQUE
CHECK
PRIMARY KEY
FOREIGN KEY
分类：六大约束
    NOT NULL：非空，用于保证该字段的值不能为空
    比如姓名、学号等
    DEFAULT:默认，用于保证该字段有默认值
    比如性别
    PRIMARY KEY:主键，用于保证该字段的值具有唯一性，并且非空
    比如学号、员工编号等
    UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为空
    比如座位号
    CHECK:检查约束【mysql中不支持】
    比如年龄、性别
    FOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值
        在从表添加外键约束，用于引用主表中某列的值
    比如学生表的专业编号，员工表的部门编号，员工表的工种编号
</code></pre>
<p>​    </p>
<pre><code>添加约束的时机：
        1.创建表时
        2.修改表时
        
约束的添加分类：
    列级约束：
            六大约束语法上都支持，但外键约束没有效果
    表级约束：
            除了非空、默认，其他的都支持
</code></pre>
<p>​            </p>
<h5 id="主键和唯一的大对比："><a href="#主键和唯一的大对比：" class="headerlink" title="主键和唯一的大对比："></a>主键和唯一的大对比：</h5><pre><code>        保证唯一性  是否允许为空    一个表中可以有多少个   是否允许组合
    主键    √            ×                至多有1个           √，但不推荐
    唯一    √            √                可以有多个          √，但不推荐
外键：
    1、要求在从表设置外键关系
    2、从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求
    3、主表的关联列必须是一个key（一般是主键或唯一）
    4、插入数据时，先插入主表，再插入从表
        删除数据时，先删除从表，再删除主表
</code></pre>
<p>​    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看stuinfo中的所有索引，包括主键、外键、唯一</span><br><span class="line">SHOW INDEX FROM stuinfo;</span><br></pre></td></tr></table></figure>

<h5 id="2-添加表级约束"><a href="#2-添加表级约束" class="headerlink" title="2.添加表级约束"></a>2.添加表级约束</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">语法：在各个字段的最下面</span><br><span class="line"> 【constraint 约束名】 约束类型(字段名) </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<pre><code>DROP TABLE IF EXISTS stuinfo;
CREATE TABLE stuinfo(
    id INT,
    stuname VARCHAR(20),
    gender CHAR(1),
    seat INT,
    age INT,
    majorid INT,
CONSTRAINT pk PRIMARY KEY(id),#主键
CONSTRAINT uq UNIQUE(seat),#唯一键
CONSTRAINT ck CHECK(gender =&#39;男&#39; OR gender  = &#39;女&#39;),#检查
CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键
);
</code></pre>
<h5 id="二、修改表时添加约束"><a href="#二、修改表时添加约束" class="headerlink" title="二、修改表时添加约束"></a>二、修改表时添加约束</h5><pre><code>1、添加列级约束
alter table 表名 modify column 字段名 字段类型 新约束;

2、添加表级约束
alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;    */
    1.添加非空约束
    ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;
    2.添加默认约束
    ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;
3.添加主键
    ①列级约束
    ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;
    ②表级约束
    ALTER TABLE stuinfo ADD PRIMARY KEY(id);
    
4.添加唯一
①列级约束
ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;
②表级约束
ALTER TABLE stuinfo ADD UNIQUE(seat);

5.添加外键
ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); 
</code></pre>
<p>​    </p>
<h5 id="三、修改表时删除约束"><a href="#三、修改表时删除约束" class="headerlink" title="三、修改表时删除约束"></a>三、修改表时删除约束</h5><pre><code>1.删除非空约束
ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;

2.删除默认约束
ALTER TABLE stuinfo MODIFY COLUMN age INT ;

3.删除主键
ALTER TABLE stuinfo DROP PRIMARY KEY;

4.删除唯一
ALTER TABLE stuinfo DROP INDEX seat;

5.删除外键
ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;

SHOW INDEX FROM stuinfo;
</code></pre>
<p>​    </p>
<h5 id="标识列"><a href="#标识列" class="headerlink" title="标识列"></a>标识列</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line">又称为自增长列</span><br><span class="line">含义：可以不用手动的插入值，系统提供默认的序列值</span><br><span class="line">	特点：</span><br><span class="line">	1、标识列必须和主键搭配吗？不一定，但要求是一个key</span><br><span class="line">	2、一个表可以有几个标识列？至多一个！</span><br><span class="line">	3、标识列的类型只能是数值型</span><br><span class="line">	4、标识列可以通过 SET auto_increment_increment=3;设置步长</span><br><span class="line">		可以通过 手动插入值，设置起始值</span><br><span class="line"></span><br><span class="line">​	</span><br><span class="line">​	*/</span><br></pre></td></tr></table></figure>






<h2 id="八、TCL语言的学习"><a href="#八、TCL语言的学习" class="headerlink" title="八、TCL语言的学习"></a>八、TCL语言的学习</h2><h3 id="事务和事务处理"><a href="#事务和事务处理" class="headerlink" title="事务和事务处理"></a>事务和事务处理</h3><h4 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h4><h5 id="含义"><a href="#含义" class="headerlink" title="含义:"></a>含义:</h5><p>​    通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（ACID）</span><br><span class="line">	原子性：要么都执行，要么都回滚</span><br><span class="line">	一致性：保证数据的状态操作前和操作后保持一致</span><br><span class="line">	隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰</span><br><span class="line">	持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改</span><br></pre></td></tr></table></figure>

<h5 id="相关步骤："><a href="#相关步骤：" class="headerlink" title="相关步骤："></a>相关步骤：</h5><pre><code>1、开启事务
2、编写事务的一组逻辑操作单元（多条sql语句）
3、提交事务或回滚事务
</code></pre>
<h5 id="事务的分类："><a href="#事务的分类：" class="headerlink" title="事务的分类："></a>事务的分类：</h5><pre><code>一、隐式事务，没有明显的开启和结束事务的标志
比如
insert、update、delete语句本身就是一个事务

二、显式事务，具有明显的开启和结束事务的标志
        1、开启事务
            取消自动提交事务的功能

        2、编写事务的一组逻辑操作单元（多条sql语句）
            insert
            update
            delete
    
        3、提交事务或回滚事务
</code></pre>
<h5 id="使用到的关键字："><a href="#使用到的关键字：" class="headerlink" title="使用到的关键字："></a>使用到的关键字：</h5><pre><code>set autocommit=0;
start transaction;
commit;
rollback;

savepoint  断点
commit to 断点
rollback to 断点
</code></pre>
<h5 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别:"></a>事务的隔离级别:</h5><h5 id="事务并发问题如何发生？"><a href="#事务并发问题如何发生？" class="headerlink" title="事务并发问题如何发生？"></a>事务并发问题如何发生？</h5><pre><code>当多个事务同时操作同一个数据库的相同数据时
</code></pre>
<h5 id="事务的并发问题有哪些？"><a href="#事务的并发问题有哪些？" class="headerlink" title="事务的并发问题有哪些？"></a>事务的并发问题有哪些？</h5><pre><code>脏读：一个事务读取到了另外一个事务未提交的数据
不可重复读：同一个事务中，多次读取到的数据不一致
幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据
</code></pre>
<h5 id="如何避免事务的并发问题？"><a href="#如何避免事务的并发问题？" class="headerlink" title="如何避免事务的并发问题？"></a>如何避免事务的并发问题？</h5><pre><code>通过设置事务的隔离级别
1、READ UNCOMMITTED
2、READ COMMITTED 可以避免脏读
3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读
4、SERIALIZABLE可以避免脏读、不可重复读和幻读

    事务的隔离级别：
                  脏读        不可重复读    幻读
read uncommitted：√                √        √
read committed：  ×                √        √
repeatable read： ×                ×        √
serializable      ×             ×       ×
</code></pre>
<p>​<br>    mysql中默认 第三个隔离级别 repeatable read<br>    oracle中默认第二个隔离级别 read committed</p>
<pre><code>设置隔离级别：
set session|global  transaction isolation level 隔离级别名;

查看隔离级别：
select @@tx_isolation;
</code></pre>
<h2 id="九、视图的讲解"><a href="#九、视图的讲解" class="headerlink" title="九、视图的讲解"></a>九、视图的讲解</h2><h4 id="含义："><a href="#含义：" class="headerlink" title="含义："></a>含义：</h4><p>​    理解成一张虚拟的表</p>
<h4 id="视图和表的区别："><a href="#视图和表的区别：" class="headerlink" title="视图和表的区别："></a>视图和表的区别：</h4><pre><code>    使用方式    占用物理空间

视图    完全相同    不占用，仅仅保存的是sql逻辑

表    完全相同    占用
</code></pre>
<h4 id="视图的好处："><a href="#视图的好处：" class="headerlink" title="视图的好处："></a>视图的好处：</h4><pre><code>1、sql语句提高重用性，效率高
2、和表实现了分离，提高了安全性
</code></pre>
<h3 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">	CREATE VIEW  视图名</span><br><span class="line">	AS</span><br><span class="line">	查询语句;</span><br></pre></td></tr></table></figure>



<pre><code>例如：1.查询姓名中包含a字符的员工名、部门名和工种信息
①创建
CREATE VIEW myv1
AS

SELECT last_name,department_name,job_title
FROM employees e
JOIN departments d ON e.department_id  = d.department_id
JOIN jobs j ON j.job_id  = e.job_id;

②使用
SELECT * FROM myv1 WHERE last_name LIKE &#39;%a%&#39;;
</code></pre>
<p>​    </p>
<h3 id="视图的增删改查"><a href="#视图的增删改查" class="headerlink" title="视图的增删改查"></a>视图的增删改查</h3><pre><code>1、查看视图的数据 ★
SELECT * FROM my_v4;
SELECT * FROM my_v1 WHERE last_name=&#39;Partners&#39;;

2、插入视图的数据
INSERT INTO my_v4(last_name,department_id) VALUES(&#39;虚竹&#39;,90);

3、修改视图的数据
UPDATE my_v4 SET last_name =&#39;梦姑&#39; WHERE last_name=&#39;虚竹&#39;;

4、删除视图的数据
DELETE FROM my_v4;
</code></pre>
<p>​    </p>
<h3 id="某些视图不能更新"><a href="#某些视图不能更新" class="headerlink" title="某些视图不能更新"></a>某些视图不能更新</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all</span><br><span class="line">	常量视图</span><br><span class="line">	Select中包含子查询</span><br><span class="line">	join</span><br><span class="line">	from一个不能更新的视图</span><br><span class="line">	where子句的子查询引用了from子句中的表</span><br></pre></td></tr></table></figure>



<h3 id="视图逻辑的更新"><a href="#视图逻辑的更新" class="headerlink" title="视图逻辑的更新"></a>视图逻辑的更新</h3><pre><code>方式一：
    CREATE OR REPLACE VIEW test_v7
    AS
    SELECT last_name FROM employees
    WHERE employee_id&gt;100;
    
方式二:
ALTER VIEW test_v7
AS
SELECT employee_id FROM employees;

SELECT * FROM test_v7;
</code></pre>
<h3 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW test_v1,test_v2,test_v3;</span><br></pre></td></tr></table></figure>



<h3 id="视图结构的查看"><a href="#视图结构的查看" class="headerlink" title="视图结构的查看"></a>视图结构的查看</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC test_v7;</span><br><span class="line">	SHOW CREATE VIEW test_v7;</span><br></pre></td></tr></table></figure>





<h2 id="十、变量"><a href="#十、变量" class="headerlink" title="十、变量"></a>十、变量</h2><h3 id="一、全局变量"><a href="#一、全局变量" class="headerlink" title="一、全局变量"></a>一、全局变量</h3><h5 id="作用域：针对于所有会话（连接）有效，但不能跨重启"><a href="#作用域：针对于所有会话（连接）有效，但不能跨重启" class="headerlink" title="作用域：针对于所有会话（连接）有效，但不能跨重启"></a>作用域：针对于所有会话（连接）有效，但不能跨重启</h5><pre><code>查看所有全局变量
SHOW GLOBAL VARIABLES;
查看满足条件的部分系统变量
SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;
查看指定的系统变量的值
SELECT @@global.autocommit;
为某个系统变量赋值
SET @@global.autocommit=0;
SET GLOBAL autocommit=0;
</code></pre>
<h3 id="二、会话变量"><a href="#二、会话变量" class="headerlink" title="二、会话变量"></a>二、会话变量</h3><h5 id="作用域：针对于当前会话（连接）有效"><a href="#作用域：针对于当前会话（连接）有效" class="headerlink" title="作用域：针对于当前会话（连接）有效"></a>作用域：针对于当前会话（连接）有效</h5><pre><code>查看所有会话变量
SHOW SESSION VARIABLES;
查看满足条件的部分会话变量
SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;
查看指定的会话变量的值
SELECT @@autocommit;
SELECT @@session.tx_isolation;
为某个会话变量赋值
SET @@session.tx_isolation=&#39;read-uncommitted&#39;;
SET SESSION tx_isolation=&#39;read-committed&#39;;
</code></pre>
<h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><h4 id="一、用户变量"><a href="#一、用户变量" class="headerlink" title="一、用户变量"></a>一、用户变量</h4><h5 id="声明并初始化："><a href="#声明并初始化：" class="headerlink" title="声明并初始化："></a>声明并初始化：</h5><pre><code>SET @变量名=值;
SET @变量名:=值;
SELECT @变量名:=值;
</code></pre>
<h5 id="赋值："><a href="#赋值：" class="headerlink" title="赋值："></a>赋值：</h5><pre><code>方式一：一般用于赋简单的值
SET 变量名=值;
SET 变量名:=值;
SELECT 变量名:=值;


方式二：一般用于赋表 中的字段值
SELECT 字段名或表达式 INTO 变量
FROM 表;
</code></pre>
<h5 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h5><pre><code>select @变量名;
</code></pre>
<h4 id="二、局部变量"><a href="#二、局部变量" class="headerlink" title="二、局部变量"></a>二、局部变量</h4><h5 id="声明："><a href="#声明：" class="headerlink" title="声明："></a>声明：</h5><pre><code>declare 变量名 类型 【default 值】;
</code></pre>
<h5 id="赋值：-1"><a href="#赋值：-1" class="headerlink" title="赋值："></a>赋值：</h5><pre><code>方式一：一般用于赋简单的值
SET 变量名=值;
SET 变量名:=值;
SELECT 变量名:=值;


方式二：一般用于赋表 中的字段值
SELECT 字段名或表达式 INTO 变量
FROM 表;
</code></pre>
<h5 id="使用：-1"><a href="#使用：-1" class="headerlink" title="使用："></a>使用：</h5><pre><code>select 变量名
</code></pre>
<h5 id="二者的区别："><a href="#二者的区别：" class="headerlink" title="二者的区别："></a>二者的区别：</h5><pre><code>            作用域                定义位置            语法
用户变量    当前会话        会话的任何地方            加@符号，不用指定类型  
局部变量    定义它的BEGIN END中     BEGIN END的第一句话    一般不用加@,需要指定类型
</code></pre>
<h2 id="十一、存储过程和函数"><a href="#十一、存储过程和函数" class="headerlink" title="十一、存储过程和函数"></a>十一、存储过程和函数</h2><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><h4 id="含义：一组经过预先编译的sql语句的集合"><a href="#含义：一组经过预先编译的sql语句的集合" class="headerlink" title="含义：一组经过预先编译的sql语句的集合"></a>含义：一组经过预先编译的sql语句的集合</h4><h5 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h5><pre><code>1、提高了sql语句的重用性，减少了开发程序员的压力
2、提高了效率
3、减少了传输次数
</code></pre>
<h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><pre><code>1、无返回无参
2、仅仅带in类型，无返回有参
3、仅仅带out类型，有返回无参
4、既带in又带out，有返回有参
5、带inout，有返回有参
注意：in、out、inout都可以在一个存储过程中带多个
</code></pre>
<h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><pre><code>create procedure 存储过程名(in|out|inout 参数名  参数类型,...)
begin
    存储过程体

end
</code></pre>
<h5 id="类似于方法："><a href="#类似于方法：" class="headerlink" title="类似于方法："></a>类似于方法：</h5><pre><code>修饰符 返回类型 方法名(参数类型 参数名,...)&#123;

    方法体;
&#125;
</code></pre>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><pre><code>1、需要设置新的结束标记
delimiter 新的结束标记
示例：
delimiter $

CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)
BEGIN
    sql语句1;
    sql语句2;

END $

2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end

3、参数前面的符号的意思
in:该参数只能作为输入 （该参数不能做返回值）
out：该参数只能作为输出（该参数只能做返回值）
inout：既能做输入又能做输出
</code></pre>
<h4 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h4><p>​    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call 存储过程名(实参列表)</span><br></pre></td></tr></table></figure>



<h5 id="案例：-1"><a href="#案例：-1" class="headerlink" title="案例："></a>案例：</h5><pre><code>1.创建带in模式参数的存储过程
案例1：创建存储过程实现 根据女神名，查询对应的男神信息

CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))
DELIMITER $
BEGIN
    SELECT bo.*
    FROM boys bo
    RIGHT JOIN beauty b ON bo.id = b.boyfriend_id
    WHERE b.name=beautyName;
END $

调用
CALL myp2(&#39;柳岩&#39;)$
</code></pre>
<p>​<br>​<br>​<br>    案例2 ：创建存储过程实现，用户是否登录成功</p>
<pre><code>CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))
BEGIN
    DECLARE result INT DEFAULT 0;#声明并初始化
    
    SELECT COUNT(*) INTO result#赋值
    FROM admin
    WHERE admin.username = username
    AND admin.password = PASSWORD;
    
    SELECT IF(result&gt;0,&#39;成功&#39;,&#39;失败&#39;);#使用
END $

#调用
CALL myp3(&#39;张飞&#39;,&#39;8888&#39;)$
</code></pre>
<h4 id="三、删除存储过程"><a href="#三、删除存储过程" class="headerlink" title="三、删除存储过程"></a>三、删除存储过程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：drop procedure 存储过程名</span><br><span class="line">		DROP PROCEDURE p1;</span><br></pre></td></tr></table></figure>



<h4 id="四、查看存储过程的信息"><a href="#四、查看存储过程的信息" class="headerlink" title="四、查看存储过程的信息"></a>四、查看存储过程的信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC myp2;×//错误</span><br><span class="line">SHOW CREATE PROCEDURE  myp2;</span><br></pre></td></tr></table></figure>



<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h4><p>学过的函数：LENGTH、SUBSTR、CONCAT等<br>语法：</p>
<pre><code>CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型
BEGIN
    函数体

END
</code></pre>
<h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 函数名（实参列表）</span><br></pre></td></tr></table></figure>



<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><pre><code>案例1：根据部门名，返回该部门的平均工资
CREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLE
BEGIN
    DECLARE sal DOUBLE ;
    SELECT AVG(salary) INTO sal
    FROM employees e
    JOIN departments d ON e.department_id = d.department_id
    WHERE d.department_name=deptName;
    RETURN sal;
END $

SELECT myf3(&#39;IT&#39;)$
</code></pre>
<h5 id="函数和存储过程的区别"><a href="#函数和存储过程的区别" class="headerlink" title="函数和存储过程的区别"></a>函数和存储过程的区别</h5><pre><code>        关键字        调用语法    返回值            应用场景
函数        FUNCTION    SELECT 函数()    只能是一个        一般用于查询结果为一个值并返回时，当有返回值而                                                        且仅仅一个
存储过程    PROCEDURE    CALL 存储过程()    可以有0个或多个        一般用于更新
</code></pre>
<h2 id="十二、流程控制结构"><a href="#十二、流程控制结构" class="headerlink" title="十二、流程控制结构"></a>十二、流程控制结构</h2><h3 id="一、if函数"><a href="#一、if函数" class="headerlink" title="一、if函数"></a>一、if函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：if(条件，值1，值2)</span><br></pre></td></tr></table></figure>


<p>​    特点：可以用在任何位置</p>
<h3 id="二、case语句"><a href="#二、case语句" class="headerlink" title="二、case语句"></a>二、case语句</h3><h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><pre><code>情况一：类似于switch
case 表达式
when 值1 then 结果1或语句1(如果是语句，需要加分号) 
when 值2 then 结果2或语句2(如果是语句，需要加分号)
...
else 结果n或语句n(如果是语句，需要加分号)
end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）

情况二：类似于多重if
case 
when 条件1 then 结果1或语句1(如果是语句，需要加分号) 
when 条件2 then 结果2或语句2(如果是语句，需要加分号)
...
else 结果n或语句n(如果是语句，需要加分号)
end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）
</code></pre>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>​    可以用在任何位置</p>
<h3 id="三、if-elseif语句"><a href="#三、if-elseif语句" class="headerlink" title="三、if elseif语句"></a>三、if elseif语句</h3><h5 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h5><pre><code>if 情况1 then 语句1;
elseif 情况2 then 语句2;
...
else 语句n;
end if;
</code></pre>
<h5 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h5><p>​    只能用在begin end中！！！！！！！！！！！！！！！</p>
<p>三者比较：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">				应用场合</span><br><span class="line">if函数			简单双分支</span><br><span class="line">case结构		等值判断 的多分支</span><br><span class="line">if结构		区间判断 的多分支</span><br></pre></td></tr></table></figure>



<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>语法：</p>
<pre><code>【标签：】WHILE 循环条件  DO
    循环体
END WHILE 【标签】;
</code></pre>
<p>特点：</p>
<pre><code>只能放在BEGIN END里面

如果要搭配leave跳转语句，需要使用标签，否则可以不用标签

leave类似于java中的break语句，跳出所在循环！！！
</code></pre>
<h5 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h5><pre><code>/*一、已知表stringcontent
    其中字段：
    id 自增长
    content varchar(20)
向该表插入指定个数的，随机的字符串
*/
DROP TABLE IF EXISTS stringcontent;
CREATE TABLE stringcontent(
    id INT PRIMARY KEY AUTO_INCREMENT,
    content VARCHAR(20)
    
);
DELIMITER $
CREATE PROCEDURE test_randstr_insert(IN insertCount INT)
BEGIN
    DECLARE i INT DEFAULT 1;
    DECLARE str VARCHAR(26) DEFAULT &#39;abcdefghijklmnopqrstuvwxyz&#39;;
    DECLARE startIndex INT;#代表初始索引
    DECLARE len INT;#代表截取的字符长度
    WHILE i&lt;=insertcount DO
        SET startIndex=FLOOR(RAND()*26+1);#代表初始索引，随机范围1-26
        SET len=FLOOR(RAND()*(20-startIndex+1)+1);#代表截取长度，随机范围1-（20-startIndex+1）
        INSERT INTO stringcontent(content) VALUES(SUBSTR(str,startIndex,len));
        SET i=i+1;
    END WHILE;

END $

CALL test_randstr_insert(10)$
</code></pre>
<h2 id="十三、数据库三大范式"><a href="#十三、数据库三大范式" class="headerlink" title="十三、数据库三大范式"></a>十三、数据库三大范式</h2><p> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  	  1NF:字段不可再分,原子性。  </span><br><span class="line">     2NF:满足第二范式( 2NF )必须先满足第一范式( 1NF )。 一个表只能说明一个事物。非主键属性必须完全依赖于主键属性。  </span><br><span class="line">     3NF:满足第三范式( 3NF ) 必须先满足第二范式( 2NF ) 。每 列都与主键有直接关系,不存在传递依赖。 任何非主属性不依赖于其它 非主属性。</span><br></pre></td></tr></table></figure>



<p>参考：</p>
<h5 id="哔哩哔哩尚硅谷讲堂"><a href="#哔哩哔哩尚硅谷讲堂" class="headerlink" title="哔哩哔哩尚硅谷讲堂"></a>哔哩哔哩尚硅谷讲堂</h5><h5 id="哔哩哔哩图灵学院"><a href="#哔哩哔哩图灵学院" class="headerlink" title="哔哩哔哩图灵学院"></a>哔哩哔哩图灵学院</h5><p><strong>github：java2020</strong></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>基本排序算法</title>
    <url>/981a96f7.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>排序类型</th>
<th>平均情况</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>辅助空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>直接插入排序</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>折半插入排序</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(n^1.3)</td>
<td>O(nlogn)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(n²)</td>
<td>O(nlog₂n)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(k)</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n²)</td>
<td>O(n+k)</td>
<td>(不)稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(d(n+k))</td>
<td>O(d(n+k))</td>
<td>O(d(n+kd))</td>
<td>O(n+kd)</td>
<td>稳定</td>
</tr>
</tbody></table>
<span id="more"></span>

<p>推荐文章：<a href="https://www.cnblogs.com/morethink/p/8419151.html#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">https://www.cnblogs.com/morethink/p/8419151.html#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F</a></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>原理：从第一个数开始，连续两个数取最大的那个数，然后最大的数和后面的数进行对比，在一轮循环后最大的数一定冒泡到最后，然后下一轮冒泡，最后的数就不用参与（因为最后的数经过冒泡后一定是这一轮最大的）、</p>
<p>实现：</p>
<ol>
<li>for循环，因为是当前数和下一个数比较，最后一个数没有下一个，所以一共进行length - 1轮</li>
<li>每一次比较的都是前面没有排好的数字（0到（长度-经过排序的轮数也就是i）</li>
<li>如果当前数比后面的数大，进行交换</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaoPaoSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化冒泡排序"><a href="#优化冒泡排序" class="headerlink" title="优化冒泡排序"></a>优化冒泡排序</h3><p>当数组中已经是有序数据，或者经过冒泡后已经使上面的数据变得有序，那么上面的程序还是会继续进行下去，进行无意义的比较</p>
<p>当一个数组变的有序的时候，那么在第二次比较的过程中一定不会发生交换，而数组无序的时候，在进行冒泡的时候一定会发生至少一次比较交换。</p>
<p>可以设置一个变量，来标记当前数组是否已经有序。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/java-interview/bubble.gif" alt="img"></p>
<p>实现：</p>
<ol>
<li><p>在冒泡排序的基础上，添加一个标志位flag</p>
</li>
<li><p>在第一个for循环中初始化</p>
</li>
<li><p>在第二个for循环全部结束后判断是否发生了交换，如果为发生交换则数组已经有序，跳出循环</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/26 18:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaoPaoSortPlus</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;-<span class="number">1</span>, -<span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span> , <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            flag=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>必须把flag=true放到第一次for循环内部，在没一轮冒泡前都要对flag进行一次初始化，因为可能经过上一轮数组已经变得有序，此时发生了交换flag = false，如果不对flag进行初始化，那么在下一轮之后一直都是false，就算已经排序好了未发生交换也不能跳出循环。</p>
<hr>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>原理：选择一轮中最小的那个数据，然后把最小的数据放到最开始的位置，这样在每一轮循环完毕后数组前面的数一定是本次循环中最小的那个数。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/java-interview/28749720-90304278-7503-11e7-9bc8-e3b56539d8bf.gif" alt="img"></p>
<p>实现：</p>
<ol>
<li>定义本轮循环开始的初始位置下标min（因为min个前面数字一定是最小的且已经是有序的）</li>
<li>for循环，因为是当前数和下一个数比较，最后一个数没有下一个，所以一共进行length - 1轮</li>
<li>获取当前开始下标i，min = i</li>
<li>for循环，初始值为i + 1，（自身和自身比较没有意义），循环到最后</li>
<li>如果中间有数据比minValue（arr[min]）小，拿到这个下标j，min = j</li>
<li>在一轮循环结束后，交换min和本轮开始的最初下标i的位置，使本轮循环的最小数放到最前的位置</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/26 21:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">8</span>, -<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        <span class="keyword">int</span> minValue;<span class="comment">//这个变量可有可无，如果没有可以用arr[min]代替，用少许空间换少许时间，没有太大影响</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            min = i;</span><br><span class="line">            minValue = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minValue &gt; arr[j]) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                    minValue = arr[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[min];</span><br><span class="line">                arr[min] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>和冒泡排序对比：</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>原理</th>
<th>实现</th>
<th>交换次数</th>
<th>核心</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>最大值放最后，每一轮最后的数一定是所有数里面最大的，数值对比后立马发生交换，最大的继续和下面的数比较</td>
<td>第一个数和后面的数比较，如果第一个数大则交换位置，大的数继续和下一位数比较一直到length-i；</td>
<td>每一轮比较都有可能发生(length-i-1)次交换</td>
<td>第i轮一定是，length-i个数里面最大的，最后i个数一定是整体有序</td>
</tr>
<tr>
<td>选择排序</td>
<td>最小值放最前，每一轮的第一个数一定是所有数里面最小的，数值对比后，记录最小值，在一轮结束后，最小值和开始的arr[i]交换</td>
<td>从i开始，选择最小的数，记录最小数的下标，一直到length；在一轮循环结束后，交换i和最小数的下标，把最小的数放在最前面；</td>
<td>在没一轮结束后，发生一次交换</td>
<td>第i轮一定是，ength-i个数里面最小 的，前面i个一定是整体有序</td>
</tr>
</tbody></table>
<hr>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>原理：从第i个数开始，对前面的数进行比较，如果前面的数比arr[i]大则前面的数后移（或交换位置），继续和前面的数比较，直到前面的一位数小于arr[i]，这样保证了每一轮前i个数是从小到大有序的，只需要给i这个数选择一个合适的位置</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/java-interview/28749729-ca072084-7503-11e7-881c-92aa915ce369.gif" alt="img"></p>
<p>实现：</p>
<ol>
<li>for循环从1开始到length，（如果发生比较次数都为lentth-1，无论是从0开始还是从1开始都可以实现算法，以为是和前面的发生比较，所以从1开始更好，如果和后面的发生比较，从0开始更好）</li>
<li>因为第一轮从1开始，第二次for循环从i开始，和前面的i发生比较，如果前面的值大于当前值，发生交换</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/26 21:32</span></span><br><span class="line"><span class="comment"> * 通过交换实现插入排序，类似于冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSortWithExchange</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> ; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j -<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                    arr[j - <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现：</p>
<ol>
<li>for循环从1开始到length，（如果发生比较次数都为lentth-1，无论是从0开始还是从1开始都可以实现算法，以为是和前面的发生比较，所以从1开始更好，如果和后面的发生比较，从0开始更好）</li>
<li>因为第一轮从1开始，第二次for循环从i开始，和前面的i发生比较，如果前面的值大于当前值，发生较大的值向后移，最后结束的时候才交换位置</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/26 21:42</span></span><br><span class="line"><span class="comment"> * 后移但是不交换，最后才发生交换，类似选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSortWithInsert</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        <span class="keyword">int</span> minValue;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            min = i;</span><br><span class="line">            minValue = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> ; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minValue &lt;  arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                   arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">                   min -- ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[min] = minValue;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>算法</th>
<th>原理</th>
<th>实现</th>
<th>交换次数</th>
<th>核心</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>最大值放最后，每一轮最后的数一定是<strong>所有数里面最大</strong>的，数值对比后立马发生交换，最大的继续和下面的数比较</td>
<td>第一个数和后面的数比较，如果第一个数大则交换位置，大的数继续和下一位数比较一直到length-i；</td>
<td>每一轮比较都有可能发生(length-i-1)次交换</td>
<td>第i轮一定是，length-i个数里面最大的，最后i个数一定是<strong>整体有序</strong></td>
<td></td>
</tr>
<tr>
<td>选择排序</td>
<td>最小值放最前，每一轮的第一个数一定是<strong>所有数里面最小</strong>的，数值对比后，记录最小值，在一轮结束后，最小值和开始的arr[i]交换</td>
<td>从i开始，选择最小的数，记录最小数的下标，一直到length；在一轮循环结束后，交换i和最小数的下标，把最小的数放在最前面；</td>
<td>在没一轮结束后，发生一次交换</td>
<td>第i轮一定是，ength-i个数里面最小 的，前面i个一定是<strong>整体有序</strong></td>
<td></td>
</tr>
<tr>
<td>插入排序</td>
<td>最小值放全面卖弄，每一轮第一个数一定是<strong>本轮数最小</strong>的</td>
<td></td>
<td>不确定</td>
<td>从i开始，保证i前面的数是<strong>本轮有序</strong>的，最小的值向前移动</td>
<td></td>
</tr>
</tbody></table>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>原理：希尔排序是插入排序的升级版，对于插入排序而言如果数组已经是有序的那么时间复杂度为O（N），找需要经历一次循环就可以，而希尔排序，就会分批次尽可能的让数组有序，</p>
<p>实现：</p>
<ol>
<li>对数组划分步长，进行for循环每次的步长为数组总长度的1/2，直到步长小于0</li>
<li>对插入排序的直接使用，知识插入排序的步长为1，而希尔排序的步长是动态变化的</li>
<li>for循环，以步长为开始，步长后的第一个数开始比较</li>
<li>while循环，当前位置大于一个步长且与前面对此，minValue &lt; arr[min - grap]，则之前打的数后移</li>
<li>在一轮驯化结束后，把较小的数放回步长开始的位置</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSortWithInsert</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        <span class="keyword">int</span> minValue;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> grap = arr.length / <span class="number">2</span>; grap &gt; <span class="number">0</span>; grap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = grap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                min = i;</span><br><span class="line">                minValue = arr[i];</span><br><span class="line">                <span class="keyword">while</span> (min &gt;= grap &amp;&amp; minValue &lt; arr[min - grap]) &#123;</span><br><span class="line">                    arr[min] = arr[min - grap];</span><br><span class="line">                    min -= grap;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[min] = minValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>原理：快速排序就是使用分治算法把一个序列分成为两个子序列。</p>
<ol>
<li>从数列中挑出一个原色，称为“基准”</li>
<li>重新排序数列，所有比基准值小的元素排在基准面前，所有比基准大的元素摆在基准后面（相同的数可以放到任何一边）。在分区结束后，基准就处于数列的中间位置</li>
<li>递归的把小于基准元素的子数列和大于基准元素的子数列排序。</li>
</ol>
<p>（左右）双指针，从右端开始，如果右端值大于基准值，则右指针向左移动（保证右边的值大于基准值），如果发现右端值小于基准值，则把左指针值放在右指针位置；如果左端的值小于基准值，则左指针向右移动，如果左端的值大于基准值，则把右指针值放到左指针位置；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuiteSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] sort = sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(sort));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//低位指针和高位指针要保存起来，在最后递归调用的时候需要这两个指针</span></span><br><span class="line">        <span class="keyword">int</span> left = low;</span><br><span class="line">        <span class="keyword">int</span> right = high;</span><br><span class="line">        <span class="keyword">int</span> temp = a[left];</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 当left小于right的时候，才进行移位操作</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= temp) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[left] = a[right];</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= temp) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            a[right] = a[left];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        a[left] = temp;</span><br><span class="line">        sort(a, low, left - <span class="number">1</span>);</span><br><span class="line">        sort(a, left + <span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>原理：先将数组拆分知道不能拆分为两个为止（也就是最小是两个数为一组），然后对两个数排序，在一次合并</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergerSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">9</span>&#125;;</span><br><span class="line">        MergerSort mergerSort = <span class="keyword">new</span> MergerSort();</span><br><span class="line">        <span class="keyword">int</span>[] sort = mergerSort.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(sort));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (high &lt;= low) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        sort(arr, low, mid);</span><br><span class="line">        sort(arr, mid + <span class="number">1</span>, high);</span><br><span class="line">        merge(arr, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = low;</span><br><span class="line">        <span class="keyword">int</span> right = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt;= high; i++) &#123;</span><br><span class="line">            aux[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt;= high; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left &gt; mid) &#123;</span><br><span class="line">                arr[i] = aux[right++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &gt; high) &#123;</span><br><span class="line">                arr[i] = aux[left++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[right] &lt; aux[left]) &#123;</span><br><span class="line">                arr[i] = aux[right++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[i] = aux[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>原理：将所有带比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从低位开始，一次进行一次排序。这样从最低位一直到最高位排序完成后，数列就变成有序数列</p>
<p>实现：</p>
<ol>
<li>取得数组中的最大数，获取位数</li>
<li>arr为原始数组，从最低位开始去每个位组成radix长度</li>
<li>对radix进行计数排序</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lvzixin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/28 22:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">radixSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">362</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] sort = sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(sort));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxDigit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((max /= <span class="number">10</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            maxDigit++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        <span class="keyword">int</span>[] bktLen = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">//存储桶中存放的数量</span></span><br><span class="line">        <span class="keyword">int</span> base = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++) &#123;</span><br><span class="line">            bktLen = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">                <span class="keyword">int</span> bktValue = (value / base) % <span class="number">10</span>;</span><br><span class="line">                buckets[bktValue][bktLen[bktValue]++] = value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; buckets.length; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bktLen[j]; k++) &#123;</span><br><span class="line">                    arr[index++] = buckets[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            base *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h2 id="java中arrys-sort的实现"><a href="#java中arrys-sort的实现" class="headerlink" title="java中arrys.sort的实现"></a>java中arrys.sort的实现</h2><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210803112615693.png" alt="image-20210803112615693" style="zoom: 50%;" />





<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210803143429250.png" alt="image-20210803143429250" style="zoom: 67%;" />

<p>核心算法是由插入排序算法完成了，如果长度大于32则将数组拆分为小的连续序列，然后对连续序列进行合并</p>
<p>在小规模的数据排序算法中，O(n^2)的排序算法并不一定比O（nlogn）的排序算法执行时间长。对于小数据量的排序，选择了比较简单，不需要递归的插入排序算法。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210803143828200.png" alt="image-20210803143828200"></p>
<h2 id="说一个常用的稳定的排序算法和适用场景"><a href="#说一个常用的稳定的排序算法和适用场景" class="headerlink" title="说一个常用的稳定的排序算法和适用场景"></a>说一个常用的稳定的排序算法和适用场景</h2><p>稳定的排序算法：冒泡排序、插入排序、归并排序、基数排序</p>
<p>基数排序适用于对时间、字符串这些数据（能够分割出独立的位，而且位之间具有明显的递进关系，且位之间的范围不是太大）</p>
<h2 id="时间复杂度为nlog2n的排序算法有哪些"><a href="#时间复杂度为nlog2n的排序算法有哪些" class="headerlink" title="时间复杂度为nlog2n的排序算法有哪些"></a>时间复杂度为nlog2n的排序算法有哪些</h2><p>归并、快排、堆排</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>基本排序算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 11. 旋转数组的最小数字</title>
    <url>/3d94766b.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>] 为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] 的一个旋转，该数组的最小值为<span class="number">1</span>。  </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h2><p>毫无算法可言</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = numbers[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min &gt; numbers[i])&#123;</span><br><span class="line">            min = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="二分求解"><a href="#二分求解" class="headerlink" title="二分求解"></a>二分求解</h3><p>什么？二分只能用于有序？那我是不是要把数组排列为有序？</p>
<p>二分不仅仅是只能用于有序，难道部分有序不行吗？</p>
<p>因为 这个不是整体有序，所以我们在使用二分法的时候要注意临界值，即旋转点的位置。</p>
<p>重要：<strong>题目：原来的数组是整体有序递增的，这个数组一定是经过翻转的</strong></p>
<p>所以原来的数组在经过翻转后，一定是分为两端递增，而且中间（最左或最右的一个）一定有一个最低点</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/2.png" alt="fig2"></p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/4.png" alt="fig4"></p>
<p>先拿到两头的两个数据：<code>numbers[i]</code>，<code>numbers[j]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>中间的数据：<code>numbers[m]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = (i+j)/<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>主要为三种情况：</p>
<ol>
<li><p>numbers[m] &gt; numbers[j]</p>
<p>这个时候最低点的那个数据，一定在m的右侧。</p>
<p><strong>因为一个递增数组，只翻转了一次，那么比numbers[j]大的数据一定在最低点左侧，比numbers[小]大的数据一定在最低点右侧。可以自己画一个图然后截取翻转一下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = m + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>什么？不可靠？那你举出一个反例我看看</p>
</li>
<li><p>numbers[m] &lt; numbers[j]</p>
<p>这个时候最低点的那个数据，一定在m的左侧。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">j = m</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>numbers[m] == numbers[j]</p>
<p>如果两个数想等，说明这个序列存在重复的数据，这个时候我们无法判断，这个最低点的位置，所以需要向左或者向右移动再次比较，但是因为我们最开始就是拿的两头的值进行的比较，所以我们只能m和j左侧的数据比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">j--</span><br></pre></td></tr></table></figure></li>
</ol>
<p>因为i和j一直在变化，所以最后循环跳出的条件就是<code>i==j</code>，所以最后返回<code>numbers[i]</code>，<code>numbers[j]</code>都行</p>
<h2 id="二分法实现"><a href="#二分法实现" class="headerlink" title="二分法实现"></a>二分法实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[m] &gt; numbers[j]) &#123;</span><br><span class="line">                i = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[m] &lt; numbers[j]) &#123;</span><br><span class="line">                j = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>时间复杂度</strong> :O(log 2N) ： 在特例情况下（例如 [1, 1, 1, 1])，会退化到 O(N)。<br>空间复杂度 :O(1) ： i , j , m 变量使用常数大小的额外空间。</p>
<h2 id="二分法优化"><a href="#二分法优化" class="headerlink" title="二分法优化"></a>二分法优化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="comment">//主要是在这一步进行了优化，防止溢出</span></span><br><span class="line">                <span class="keyword">int</span> m = i+  (j - i) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (numbers[m] &gt; numbers[j]) &#123;</span><br><span class="line">                    i = m + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[m] &lt; numbers[j]) &#123;</span><br><span class="line">                    j = m;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> numbers[i];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h2 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h2><p>输入一个递减排序的数组的一个旋转，求最大值（最小值）</p>
<h3 id="求最大值"><a href="#求最大值" class="headerlink" title="求最大值"></a>求最大值</h3><p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210906104851529.png" alt="image-20210906104851529"></p>
<p>同样的思路：</p>
<ol>
<li><p>numbers[m] &gt; numbers[j]</p>
<p>那么这个最大值一定在m的右侧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">j = m</span><br></pre></td></tr></table></figure></li>
<li><p>numbers[m] &lt; numbers[j]</p>
<p>那么这个最大值一定在m的左侧</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = m + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>numbers[m] == numbers[j]</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">j--</span><br></pre></td></tr></table></figure>

<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static class Solution &#123;</span><br><span class="line">    public int minArray(int[] numbers) &#123;</span><br><span class="line">        int i = 0, j = numbers.length - 1;</span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            int m = i+  (j - i) / 2;</span><br><span class="line">            if (numbers[m] &gt; numbers[j]) &#123;</span><br><span class="line">                j = m;</span><br><span class="line">            &#125; else if (numbers[m] &lt; numbers[j]) &#123;</span><br><span class="line">                i = m +1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求最小值"><a href="#求最小值" class="headerlink" title="求最小值"></a>求最小值</h3><p>求最小值就是求最大值得一个变形，最小值一定在最大值得左侧</p>
<p>而且在求的得最大值，如果有重复值，一定是最左的那一个，因为如果<code>numbers[m] == numbers[j]</code>相等，那么j会一直向左移动，伴随着m也会向左移动，知道j和i相当，获取遇到了<code>numbers[m] != numbers[j]</code>，这个过程都是在想左移动</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = i+  (j - i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[m] &gt; numbers[j]) &#123;</span><br><span class="line">                j = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[m] &lt; numbers[j]) &#123;</span><br><span class="line">                i = m +<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="验证最值"><a href="#验证最值" class="headerlink" title="验证最值"></a>验证最值</h3><p>这次我们没有leetcode的在线验证工具，因为这道题是自己临时想到的，这个时候我们可以使用<strong>对数器</strong>来检验我们的设计的算法的正确性</p>
<h4 id="绝对正确的答案"><a href="#绝对正确的答案" class="headerlink" title="绝对正确的答案"></a>绝对正确的答案</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt;  numbers[i]) &#123;</span><br><span class="line">                max = numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用Arrays的api</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(numbers).max().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="对数器设计："><a href="#对数器设计：" class="headerlink" title="对数器设计："></a>对数器设计：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArryRotateMinPlus</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] numbers = getNumbers(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">int</span>[] numbers1 = Arrays.copyOf(numbers, numbers.length);</span><br><span class="line">            rotate(numbers, (<span class="keyword">int</span>) (Math.random() * numbers.length));</span><br><span class="line">            <span class="keyword">if</span> (getmax(numbers) != solution.minArray(numbers)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;算法错误啦!你的答案是&quot;</span> + solution.minArray(numbers) + <span class="string">&quot;正确答案是：&quot;</span> + getmax(numbers));</span><br><span class="line">                System.out.println(<span class="string">&quot;错误的原始递减数组是：&quot;</span> + Arrays.toString(numbers1));</span><br><span class="line">                System.out.println(<span class="string">&quot;错误的翻转递减数组是：&quot;</span> + Arrays.toString(numbers));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;恭喜你！吕小医，你的算法正确啦！&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递减数组求最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="keyword">int</span> m = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (numbers[m] &gt; numbers[j]) &#123;</span><br><span class="line">                    j = m;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[m] &lt; numbers[j]) &#123;</span><br><span class="line">                    i = m + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递减数组求最小值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="keyword">int</span> m = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (numbers[m] &gt; numbers[j]) &#123;</span><br><span class="line">                    j = m;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[m] &lt; numbers[j]) &#123;</span><br><span class="line">                    i = m + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> numbers[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绝对正确的算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getmax</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(numbers).max().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个递减的数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNumbers(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            numbers[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对数组进行从小到大排序</span></span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        reserve(numbers, <span class="number">0</span>, numbers.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> numbers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得递减的反战数组，k是反转的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k = k % length;</span><br><span class="line">        reserve(nums, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">        reserve(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reserve(nums, k, length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reserve</span><span class="params">(<span class="keyword">int</span>[] nums, Integer start, Integer end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="博客首先发布于："><a href="#博客首先发布于：" class="headerlink" title="博客首先发布于："></a>博客首先发布于：</h1><p><a href="https://lvxiaoyi.top/">https://lvxiaoyi.top/</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 10- II. 青蛙跳台阶问题</title>
    <url>/ee60b5f6.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一只青蛙一次可以跳上<span class="number">1</span>级台阶，也可以跳上<span class="number">2</span>级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</span><br><span class="line"></span><br><span class="line">答案需要取模 <span class="number">1e9</span>+<span class="number">7</span>（<span class="number">1000000007</span>），如计算初始结果为：<span class="number">1000000008</span>，请返回 <span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">7</span></span><br><span class="line">输出：<span class="number">21</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">0</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= n &lt;= <span class="number">100</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>寻找之间的关系：</p>
<p>n=1 输出：1  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;1&#125;</span><br></pre></td></tr></table></figure>

<p>n=2 输出：2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最后一次跳了一阶台阶&#123;1，1&#125;</span><br><span class="line">最后一次跳了两阶台阶&#123;2&#125;</span><br></pre></td></tr></table></figure>

<p>n=3 输出：3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最后一次跳了一阶台阶&#123;1，1，1&#125;，&#123;2,1&#125;</span><br><span class="line">最后一次跳了两阶台阶&#123;1,2&#125;</span><br></pre></td></tr></table></figure>

<p>n=4 输出：5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最后一次跳了一阶台阶&#123;1，1，1，1&#125;，&#123;2,1,1&#125;，&#123;1,2，1&#125;</span><br><span class="line">最后一次跳了两阶台阶&#123;1,1,2&#125;，&#123;2,2&#125;</span><br></pre></td></tr></table></figure>

<p>用<code>数学思想</code>推导：</p>
<p>最后一次跳了一阶台阶，这类方法一共有f（n-1）种；</p>
<p>最后一次跳了两阶台阶，这类方法一共有f（n-2）</p>
<p>可以推出来:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n阶台阶的次数 = 最后一次跳了一阶台阶 + 最后一次跳了两阶台阶</span><br><span class="line">f(n)=f(n−1)+f(n−2)</span><br></pre></td></tr></table></figure>



<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="记忆化递归法"><a href="#记忆化递归法" class="headerlink" title="记忆化递归法"></a>记忆化递归法</h3><p>看到这样的题目首先想到了汉诺塔问题和斐波那契数列，递归实现</p>
<p>和斐波那契数列的记忆化递归类似，主要就是求出推到公式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span>[] memorization = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            memorization[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            memorization[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> numWays(n, memorization);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] memorization)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (n &lt; <span class="number">2</span> || memorization[n] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> memorization[n];</span><br><span class="line">            &#125;</span><br><span class="line">            memorization[n] = (numWays(n - <span class="number">1</span>, memorization) + numWays(n - <span class="number">2</span>, memorization)) % <span class="number">1000000007</span>;</span><br><span class="line">            <span class="keyword">return</span> memorization[n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>不从f（n）开始，而是从f（1）和f（2）开始，逐渐累加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(n + 1) = f(n) + f(n - 1)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, sum ;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">             sum = (a + b)  % <span class="number">1000000007</span>;</span><br><span class="line">             a = b;</span><br><span class="line">             b = sum;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="博客首先发布于："><a href="#博客首先发布于：" class="headerlink" title="博客首先发布于："></a>博客首先发布于：</h1><p><a href="https://lvxiaoyi.top/">https://lvxiaoyi.top/</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 10- I. 斐波那契数列</title>
    <url>/7eea4da1.html</url>
    <content><![CDATA[<h2 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</span><br><span class="line"></span><br><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br><span class="line">斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</span><br><span class="line"></span><br><span class="line">答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">0 &lt;= n &lt;= 100</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>这是一个典型的递归问题，但是递归算法往往不是最优的</p>
<h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>原理：把 f(n)f(n) 问题的计算拆分成 f(n-1)f(n−1) 和 f(n-2)f(n−2) 两个子问题的计算，并递归，以 f(0) 和 f(1)为终止条件。</p>
<p>缺点：</p>
<ol>
<li>有大量的重复的递归计算</li>
<li>递归一直嵌套，效率比较低</li>
</ol>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/25e913ab8d7a22bb017669e4a097cf51d10861f365002f2d8556ee7a64464cd8-Picture0.png" alt="Picture0.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.0版本 递归版本</span></span><br><span class="line">  <span class="comment">// leetcode：超出时间限制</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.0版本 递归版本</span></span><br><span class="line"><span class="comment">// leetcode：超出时间限制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibV2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="记忆化递归法"><a href="#记忆化递归法" class="headerlink" title="记忆化递归法"></a>记忆化递归法</h3><p>原理：在递归算法的基础上，新建一个长度为n的数组，用于在递归是存储f(0)至 f(n)的数字值，重复遇到某数字则直接从数组取用，避免了重复的递归计算。</p>
<p>缺点：</p>
<ol>
<li>递归一直嵌套，效率比较低</li>
<li>记忆化存储需要使用O（N）的额外空间</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.0版本 记忆化递归</span></span><br><span class="line"><span class="comment">// 解决递归版本中的重复计算递归的值</span></span><br><span class="line"><span class="comment">// leetcode：超出时间限制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibV3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] memorization = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    memorization[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    memorization[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> myFibonacci(n, memorization);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myFibonacci</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] memorization)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span> || memorization[n] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memorization[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (myFibonacci(n - <span class="number">1</span>, memorization) + myFibonacci(n - <span class="number">2</span>, memorization))%<span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>原理：以斐波那契数列性质 f(n + 1) = f(n) + f(n - 1)为转移方程。</p>
<p>递归算法是一种倒序进行，直接进行 f(n)的计算，在 f(n)的计算过程中进行递归，求解f(n - 1)和f(n - 2)的值，而且递归算法本身就不适合大数据量的计算容易造成栈移出</p>
<p>而动态规划怎事从f(0)开始，逐渐求解f(n)的过程</p>
<p>从计算效率、空间复杂度上看，动态规划是本题的最佳解法。</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/f653118d5c80fc44dde284c9b9c4f2d2115916f0123e384733526279f9b23302-Picture1.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.0版本 动态规划</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// leetcode：超出40%提交</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibV4</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span> , b = <span class="number">1</span> , sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 每次求解最新的数，舍弃之前的数据</span></span><br><span class="line">        sum = (a + b)%<span class="number">1000000007</span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5.0版本 动态规划</span></span><br><span class="line"><span class="comment">// 解决动态规划重复计算问题</span></span><br><span class="line"><span class="comment">// leetcode：超出40%提交</span></span><br><span class="line"><span class="comment">// 这种没有太大的意义，因为动态规划算法没有重复的值得计算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibV5</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] memorization = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    memorization[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    memorization[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        memorization[i] = (memorization[i-<span class="number">1</span>] + memorization[i - <span class="number">2</span>])%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memorization[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="博客首先发布于："><a href="#博客首先发布于：" class="headerlink" title="博客首先发布于："></a>博客首先发布于：</h1><p><a href="https://lvxiaoyi.top/">https://lvxiaoyi.top/</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 09. 用两个栈实现队列</title>
    <url>/6fda8efa.html</url>
    <content><![CDATA[<h4 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -<span class="number">1</span> )</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;CQueue&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>]</span><br><span class="line">[[],[<span class="number">3</span>],[],[]]</span><br><span class="line">输出：[<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">3</span>,-<span class="number">1</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;CQueue&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>]</span><br><span class="line">[[],[],[<span class="number">5</span>],[<span class="number">2</span>],[],[]]</span><br><span class="line">输出：[<span class="keyword">null</span>,-<span class="number">1</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= values &lt;= <span class="number">10000</span></span><br><span class="line">最多会对 appendTail、deleteHead 进行 <span class="number">10000</span> 次调用</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack1 ;</span><br><span class="line">    Deque&lt;Integer&gt; stack2 ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="博客首先发布于："><a href="#博客首先发布于：" class="headerlink" title="博客首先发布于："></a>博客首先发布于：</h1><p><a href="https://lvxiaoyi.top/">https://lvxiaoyi.top/</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 07. 重建二叉树</title>
    <url>/73d0ff75.html</url>
    <content><![CDATA[<h1 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</span><br><span class="line"></span><br><span class="line">假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</span><br><span class="line"></span><br><span class="line">Input: preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>], inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">Input: preorder = [-<span class="number">1</span>], inorder = [-<span class="number">1</span>]</span><br><span class="line">Output: [-<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &lt;= 节点个数 &lt;= <span class="number">5000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/tree.jpg" alt="img"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="先按照题目自己构建一个二叉树，不考虑代码实现"><a href="#先按照题目自己构建一个二叉树，不考虑代码实现" class="headerlink" title="先按照题目自己构建一个二叉树，不考虑代码实现"></a>先按照题目自己构建一个二叉树，不考虑代码实现</h3><p>前序遍历：preorder = [3,9,20,15,7]</p>
<p> 中序遍历：inorder = [9,3,15,20,7]</p>
<ol>
<li>前序遍历一定能够确定3是根节点</li>
<li>这样在中序遍历中，3左边的值一定是这个根节点的左子树，3右边的值一定是根的右子树</li>
<li>3左边只有一个数9，说明这个数的左子树只有一个是9</li>
<li>3的右子树有三个值，（15,20,7），然后在看前序遍历，前序遍历中的（20,15,7）一定是根的右子树，所以20一定是3的右孩子</li>
<li>然后在看中序遍历，20是右孩子的根节点，那么15一定是20的左孩子，7一定是20的右孩子</li>
<li>最后代入前序遍历验证</li>
<li>正确</li>
</ol>
<p>所以一个前序一定能确定一个根，然后在结合后续一定能确定根的左右孩子，这样在去前序遍历和中序遍历中对比，那么一定能构建一个二叉树</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>不要看下面代码感觉挺多的，其实很简单就是一个递归的过程，只是传递的参数多，然后一行放不下了而已</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建map结构是因为，在每次在中序数组中中查找当前根节点都要遍历一次，这样可以避免遍历，直接拿到当前根节点的index</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; indexMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = inorder.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            indexMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = buildTree(preorder, <span class="number">0</span>, length - <span class="number">1</span>, inorder, <span class="number">0</span>, length - <span class="number">1</span>, indexMap);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preorderStart, <span class="keyword">int</span> preorderEnd, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inorderStart, <span class="keyword">int</span> inorderEnd, HashMap&lt;Integer, Integer&gt; indexMap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (preorderStart &gt; preorderEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先找出根节点</span></span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[preorderStart];</span><br><span class="line">        <span class="comment">//然后在中序遍历中找到根节点的位置，之前一定是根节点的左子树，之后一定是根节点的右子树</span></span><br><span class="line">        <span class="comment">//构建树的根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="comment">//如果左节点的长度为零，说明这个就是根节点，且没有子节点，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (preorderStart == preorderEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//拿到根节点在中序遍历数组的索引</span></span><br><span class="line">            <span class="keyword">int</span> rootIndex = indexMap.get(rootVal);</span><br><span class="line">            <span class="comment">//拿到根节点的索引后，可以在前序遍历中拿到根节点左孩子的数量（最后一个节点的index），和右孩子的数量（）</span></span><br><span class="line">            <span class="comment">// 然后就需要对，根节点的左子树部分进行构建</span></span><br><span class="line">            <span class="comment">// 需要找到左子树中对应的前序遍历和中序遍历，分别对应的数组的位置</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1. 前序遍历的数组还是这个数组</span></span><br><span class="line"><span class="comment">             * 2. 左子树中在前序遍历数组的开始索引：preorderStart + 1，根节点左边的第一个节点就是左子树的第一个索引位置</span></span><br><span class="line"><span class="comment">             * 3. 左子树中在前序遍历数组结束的索引：preorderStart + (rootIndex - inorderStart)，</span></span><br><span class="line"><span class="comment">             *  根节点 + 在中序遍历中根节点距离开始节点的位置  = 根节点 + （在中序遍历中根节点的索引 - 在中序遍历中开始的索引）</span></span><br><span class="line"><span class="comment">             * 4. 中序遍历数组还是这个数组</span></span><br><span class="line"><span class="comment">             * 5. 左子树中在中序遍历数组的开始索引：inorderStart，中序遍历数组中的开始位置</span></span><br><span class="line"><span class="comment">             * 6. 左子树中在中序遍历数组结束的索引：rootIndex - 1，根节点索引位置减一</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            TreeNode leftNode = buildTree(preorder, preorderStart + <span class="number">1</span>, preorderStart + (rootIndex - inorderStart),</span><br><span class="line">                    inorder, inorderStart, rootIndex - <span class="number">1</span>, indexMap);</span><br><span class="line">            <span class="comment">//需要找到右子树中对应的前序遍历和中序遍历，分别对应的数组的位置</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1. 前序遍历的数组还是这个数组</span></span><br><span class="line"><span class="comment">             * 2. 右子树中在前序遍历数组的开始索引：preorderEnd - (inorderEnd - rootIndex) + 1，</span></span><br><span class="line"><span class="comment">             * 前序遍历数组的末尾索引 - 右子树数的数量 + 1  = 前序遍历数组的末尾索引 - （中序遍历末尾位置 - 中序遍历根节点的索引 ） + 1</span></span><br><span class="line"><span class="comment">             * 3. 右子树中在前序遍历数组结束的索引：preorderEnd，</span></span><br><span class="line"><span class="comment">             * 4. 中序遍历数组还是这个数组</span></span><br><span class="line"><span class="comment">             * 5. 右子树中在中序遍历数组的开始索引：rootIndex + 1，根节点索引位置加一</span></span><br><span class="line"><span class="comment">             * 6. 右子树中在中序遍历数组结束的索引：inorderEnd，</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            TreeNode rightNode = buildTree(preorder, preorderEnd - (inorderEnd - rootIndex) + <span class="number">1</span>, preorderEnd,</span><br><span class="line">                    inorder, rootIndex + <span class="number">1</span>, inorderEnd, indexMap);</span><br><span class="line">            root.left = leftNode;</span><br><span class="line">            root.right = rightNode;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">//        int val;</span></span><br><span class="line"><span class="comment">//        TreeNode left;</span></span><br><span class="line"><span class="comment">//        TreeNode right;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        TreeNode(int x) &#123;</span></span><br><span class="line"><span class="comment">//            val = x;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点有一个地方：</p>
<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><h3 id="二叉树的前序、中序、后序遍历"><a href="#二叉树的前序、中序、后序遍历" class="headerlink" title="二叉树的前序、中序、后序遍历"></a>二叉树的前序、中序、后序遍历</h3><h3 id="小学数学加减法"><a href="#小学数学加减法" class="headerlink" title="小学数学加减法"></a>小学数学加减法</h3><p><strong>求左子树中在前序遍历数组结束的索引</strong>和<strong>右子树中在前序遍历数组的开始索引</strong></p>
<p>这里为什么有的地方加一，有的地方不加一，而有的地方需要减一</p>
<p>这个是在算法中经常会遇到的问题：</p>
<p>其实还是小学数学：</p>
<p>请听题：</p>
<p>一个有六棵树分别叫，0号，1号 ，2号，3号，4号，5号</p>
<ol>
<li><p>5号和2号<strong>间有几颗树</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="number">5</span> - <span class="number">2</span>) - <span class="number">1</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><p>2号树向右<strong>移动几次</strong>能到达5号树的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> - <span class="number">2</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure></li>
<li><p>5号树向右移动两次是第几颗树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="number">5</span> - <span class="number">2</span>) + <span class="number">1</span> = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>因为索引是从0开始的，所以引号加1，如果索引不是从零开始的直接间就可以了</p>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>两个数之间的差值，为小的数向大的数移动的次数</li>
<li>如果要求两个数之间的数字数量，需要差值减一</li>
</ol>
<h1 id="博客首先发布于："><a href="#博客首先发布于：" class="headerlink" title="博客首先发布于："></a>博客首先发布于：</h1><p><a href="https://lvxiaoyi.top/">https://lvxiaoyi.top/</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 06. 从尾到头打印链表</title>
    <url>/8c70c103.html</url>
    <content><![CDATA[<h2 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：head = [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line">0 &lt;= 链表长度 &lt;= 10000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>原理：</p>
<p>链表只有一个头结点，想要到尾结点只能从头开始遍历</p>
<h3 id="辅助空间"><a href="#辅助空间" class="headerlink" title="辅助空间"></a>辅助空间</h3><p>声明一个辅助空间，先遍历一遍确定辅助空间的大小，然后对辅助空间倒序打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">       ListNode first = head;</span><br><span class="line">		 <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">		 <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">			head = head.next;</span><br><span class="line">			len ++;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">		 <span class="keyword">while</span>(first != <span class="keyword">null</span>) &#123;</span><br><span class="line">			 len--;</span><br><span class="line">			 array[len] = first.val;</span><br><span class="line">			 first = first.next;</span><br><span class="line">		&#125;</span><br><span class="line">		 <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="博客首先发布于："><a href="#博客首先发布于：" class="headerlink" title="博客首先发布于："></a>博客首先发布于：</h1><p><a href="https://lvxiaoyi.top/">https://lvxiaoyi.top/</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 05. 替换空格</title>
    <url>/baec5e48.html</url>
    <content><![CDATA[<h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line">0 &lt;= s 的长度 &lt;= 10000</span><br></pre></td></tr></table></figure>

<span id="more"></span>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		 </span><br><span class="line">		 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line">			 str.append(String.valueOf(s.charAt(i)).equals(<span class="string">&quot; &quot;</span>) ? <span class="string">&quot;%20&quot;</span> : s.charAt(i));</span><br><span class="line">		&#125;</span><br><span class="line">		 <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="博客首先发布于："><a href="#博客首先发布于：" class="headerlink" title="博客首先发布于："></a>博客首先发布于：</h1><p><a href="https://lvxiaoyi.top/">https://lvxiaoyi.top/</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 04. 二维数组中的查找</title>
    <url>/58b0f60b.html</url>
    <content><![CDATA[<h2 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">现有矩阵 matrix 如下：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target = 5，返回 true。</span><br><span class="line"></span><br><span class="line">给定 target = 20，返回 false。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line">0 &lt;= n &lt;= 1000</span><br><span class="line"></span><br><span class="line">0 &lt;= m &lt;= 1000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>直接利用for循环查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArrayV1</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == matrix[i][j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉搜索法"><a href="#二叉搜索法" class="headerlink" title="二叉搜索法"></a>二叉搜索法</h3><p><code>每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序</code></p>
<p>根据本题的题目描述，这个数组是一个有序递增的数组，可以把数组转化为图的形式，类似于二叉搜索树</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png" alt="Picture1.png" style="zoom:50%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArrayV2</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    	<span class="comment">// 从左上角开始</span></span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> j = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">while</span> (i &lt; matrix.length &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果相等则找到了目标值</span></span><br><span class="line">           <span class="keyword">if</span> (matrix[i][j] == target) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; matrix[i][j]) &#123;</span><br><span class="line">               <span class="comment">// 目标值比较大，则向下查找</span></span><br><span class="line">               i++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 目标值比较小，则向左查找</span></span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h1 id="博客首先发布于："><a href="#博客首先发布于：" class="headerlink" title="博客首先发布于："></a>博客首先发布于：</h1><p><a href="https://lvxiaoyi.top/">https://lvxiaoyi.top/</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 03. 数组中重复的数字</title>
    <url>/7e9ab8a.html</url>
    <content><![CDATA[<h2 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找出数组中重复的数字。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line">2 &lt;= n &lt;= 100000</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="哈希表（set）"><a href="#哈希表（set）" class="headerlink" title="哈希表（set）"></a>哈希表（set）</h3><p>hashset中数组的唯一性，当hash表中不能在添加的时候，表示有重复数据，返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 利用hash</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findRepeatNumberV1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      Set&lt;Integer&gt; integers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!integers.add(num)) &#123;</span><br><span class="line">              <span class="keyword">return</span> num;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="原地交换"><a href="#原地交换" class="headerlink" title="原地交换"></a>原地交换</h3><p>这个是针对本题目的特殊性</p>
<p> <code>nums 里的所有数字都在 0～n-1</code></p>
<p>也就是说，所有的数字在数组中都能找到他以该数组为索引的位置，而不会造成数组下标越界，所以可以建立索引和值得映射</p>
<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/1618146573-bOieFQ-Picture0.png" alt="Picture0.png" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findRepeatNumberV2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ) &#123;</span><br><span class="line">           <span class="comment">// 注意：只有在第一个数放到了正确的位置才i++，对第二个数照对应的值</span></span><br><span class="line">           <span class="keyword">if</span> (nums[i] == i) &#123;</span><br><span class="line">               i++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 这个是跳出循环的条件，如果这个值和要替换的目标值说明两个值发生了重复</span></span><br><span class="line">           <span class="keyword">if</span> (nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">               <span class="keyword">return</span> nums[i];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">           nums[i] = nums[temp];</span><br><span class="line">           nums[temp] = temp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findRepeatNumberV3</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 这里使用的事while循环，更容易直观理解</span></span><br><span class="line">        <span class="comment">// 当这个数的值和索引下标不对应的时候，一直为当前值寻找对应的位置</span></span><br><span class="line">        <span class="keyword">while</span> (i != nums[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[nums[i]])&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            temp = nums[i];</span><br><span class="line">            nums[i] = nums[temp];</span><br><span class="line">            nums[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="博客首先发布："><a href="#博客首先发布：" class="headerlink" title="博客首先发布："></a>博客首先发布：</h1><p><a href="https://lvxiaoyi.top/">https://lvxiaoyi.top/</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper分布式锁</title>
    <url>/ecd467f2.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>为了保证数据的一致性，在一些业务处理中都会选择加锁来保证数据的一致性。在单机模式下我们通常选择使用synchronized等这种JAVA提供好的jvm锁来实现，但是在集群和分布式情况下，这种jvm级别的锁式无法满足我们的需求，因为一个服务部署在多台服务器上，这些服务器上的jvm是无法通讯的，所以我们需要一种方案来解决分布式情况下数据一致性。</p>
<p>在互联网公司，基本上企业内部都会有自己的一套分布式锁开发框架</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式锁一般有三种实现方式：</p>
<ol>
<li>数据库乐观锁</li>
<li>基于redis实现分布式锁</li>
<li>基于zooKeeper实习哪分布式锁</li>
</ol>
<p>本次讲着重介绍zooKeeper实现分布式锁，和与数据库和redis实习分布式锁的对比。</p>
<h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><p>zookeeper的分布式锁主要是依据临时节点和事件监听机制来完成的</p>
<h1 id="curator框架实现zookeeper分布式锁"><a href="#curator框架实现zookeeper分布式锁" class="headerlink" title="curator框架实现zookeeper分布式锁"></a>curator框架实现zookeeper分布式锁</h1><p>前提：需要搭建起zookeeper基础架构，并且使用gateway网关做负载均衡</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.cloud.zookeeper.connect-string&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String zookeeperConnectionString;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;start&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CuratorFramework <span class="title">curatorFramework</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> CuratorFrameworkFactory.newClient(zookeeperConnectionString, retryPolicy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> CuratorFramework curatorFramework;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">curatorDecuctStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String returnResult = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">       InterProcessMutex interProcessMutex = <span class="keyword">new</span> InterProcessMutex(curatorFramework, <span class="string">&quot;/stockLock&quot;</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           interProcessMutex.acquire();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>)));</span><br><span class="line">           <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">               stringRedisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, realStock + <span class="string">&quot;&quot;</span>);</span><br><span class="line">               System.out.println(<span class="string">&quot;扣减库存成功，剩余库存：&quot;</span> + realStock + <span class="string">&quot;         卖出数量为：&quot;</span> + count.addAndGet(<span class="number">1</span>));</span><br><span class="line">               returnResult = <span class="string">&quot;扣减库存成功&quot;</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;扣减库存失败，库存不足&quot;</span>);</span><br><span class="line">               returnResult = <span class="string">&quot;扣减库存失败，库存不足&quot;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               interProcessMutex.release();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> returnResult;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="集群压测"><a href="#集群压测" class="headerlink" title="集群压测"></a>集群压测</h3><ul>
<li>jmeter压测<ul>
<li>100个线程并发</li>
<li>延迟0秒</li>
<li>循环4次</li>
</ul>
</li>
<li>总库存为200</li>
<li>redis单机本地部署</li>
<li>三个服务集群</li>
<li>geteway（本地部署）轮询负载均衡</li>
<li>zookeeper做分布式锁（本地单机）</li>
</ul>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210901220545870.png" alt="image-20210901220545870"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">1</span>         卖出数量为：<span class="number">67</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">// 第二台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">0</span>         卖出数量为：<span class="number">67</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">// 第三台服务</span></span><br><span class="line">扣减库存成功，剩余库存：<span class="number">2</span>         卖出数量为：<span class="number">66</span></span><br><span class="line">扣减库存失败，库存不足</span><br><span class="line"><span class="comment">//总卖出数量为：67+67+66=200</span></span><br></pre></td></tr></table></figure>



<h1 id="redisson（redis）分布式锁和curator（zookeeper）分布式锁对比"><a href="#redisson（redis）分布式锁和curator（zookeeper）分布式锁对比" class="headerlink" title="redisson（redis）分布式锁和curator（zookeeper）分布式锁对比"></a>redisson（redis）分布式锁和curator（zookeeper）分布式锁对比</h1><p>通过jmeter压测发现，在同样的并发请求，redis本地单机，zookeeper本地单机的情况下，redis的300线程的200库存量用时平均在3秒左右，而zookeeper的300线程的200库存量用时平均在28秒左右。</p>
<p>可以明显看的出来，针对本次的300线程200库存，redis单机和zookeeper单机</p>
<table>
<thead>
<tr>
<th>对比</th>
<th>zookeeper</th>
<th>redis</th>
</tr>
</thead>
<tbody><tr>
<td>时间</td>
<td>28秒</td>
<td>3秒</td>
</tr>
<tr>
<td>CAP</td>
<td>CP</td>
<td>AP</td>
</tr>
<tr>
<td>性能</td>
<td>较低</td>
<td>高</td>
</tr>
<tr>
<td>可靠</td>
<td>高</td>
<td>较低</td>
</tr>
</tbody></table>
<p> 参考：</p>
<p><a href="https://blog.csdn.net/java_66666/article/details/81015302">https://blog.csdn.net/java_66666/article/details/81015302</a></p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>分布式锁</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装redis集群</title>
    <url>/a988d1a2.html</url>
    <content><![CDATA[<h1 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker  pull  redis:5.0.5</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902175726397.png" alt="image-20210902175726397"></p>
<h1 id="创建redis容器"><a href="#创建redis容器" class="headerlink" title="创建redis容器"></a>创建redis容器</h1><p>创建三个 redis 容器：</p>
<ul>
<li>redis-node1：6380</li>
<li>redis-node2：6381</li>
<li>redis-node3：6382</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker create --name redis-node1 --net host -v /data/redis-data/node1:/data redis:5.0.5 --cluster-enabled yes --cluster-config-file nodes-node-1.conf --port 6380</span><br><span class="line"></span><br><span class="line">docker create --name redis-node2 --net host -v /data/redis-data/node2:/data redis:5.0.5 --cluster-enabled yes --cluster-config-file nodes-node-2.conf --port 6381</span><br><span class="line"></span><br><span class="line">docker create --name redis-node3 --net host -v /data/redis-data/node3:/data redis:5.0.5 --cluster-enabled yes --cluster-config-file nodes-node-3.conf --port 6382</span><br></pre></td></tr></table></figure>

<h1 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start redis-node1 redis-node2 redis-node3</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902175954106.png" alt="image-20210902175954106"></p>
<p>执行完运行命令后检查一下容器的启动情况：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20200531105644785.png" alt="img"></p>
<p>如上提示的是权限问题，我们尝试修改一下权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod -R  777 /data</span><br></pre></td></tr></table></figure>

<p>启动成功后如下图所示：</p>
<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20200531115746286.png" alt="img"></p>
<h1 id="组建群组"><a href="#组建群组" class="headerlink" title="组建群组"></a>组建群组</h1><p> <code>--net</code> 网络类型为 <code>host</code></p>
<p><strong>Docker</strong>在使用<code>host模式</code>下创建的容器是没有自己独立的网络命名空间的，是跟物理机共享一个网络空间，进而可以共享物理机的所有<strong>端口与IP</strong>，这样就可以让公共网络直接访问容器了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 组建集群,10.211.55.4为当前物理机的ip地址</span></span><br><span class="line"></span><br><span class="line">redis-cli --cluster create 10.211.55.4:6379 10.211.55.4:6380 10.211.55.4:6381 --cluster-replicas 0</span><br></pre></td></tr></table></figure>

<img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20200531141853380.png" alt="img" style="zoom: 50%;" />



<h2 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h2><h3 id="Waiting-for-the-cluster-to-join"><a href="#Waiting-for-the-cluster-to-join" class="headerlink" title="Waiting for the cluster to join"></a>Waiting for the cluster to join</h3><p>到这一步后一直在等待，无法进行到下一步</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>我在搭建的时候用的阿里云，启动有端口限制，redis集群在通讯的时候还需要开始一个通讯端口，通讯端口地址：reids端口号+10000</p>
<p>例如：redis端口号为6380，那么不仅要开启6380端口，还有开启16380端口</p>
<p>所以在阿里云控制台安全组中开启<code>16380/16381</code>后，没有在一直等待</p>
<h1 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@CentOS7:/data# redis-cli</span><br><span class="line">127.0.0.1:6379&gt; cluster nodes</span><br><span class="line">72c291c32815194b64d1f6d0fdf771f5cc04e14a 10.211.55.4:6380@16380 master - 0 1590905997358 2 connected 5461-10922</span><br><span class="line">6a595b67bbff15c94e5874c2d2cd556d6a6a6c17 10.211.55.4:6381@16381 master - 0 1590905998362 3 connected 10923-16383</span><br><span class="line">4e3dbdc8f835dcbc38291c88f08165ee51d53d3d 10.211.55.4:6379@16379 myself,master - 0 1590905997000 1 connected 0-5460</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="打印不了集群信息"><a href="#打印不了集群信息" class="headerlink" title="打印不了集群信息"></a>打印不了集群信息</h3><p>在查看cluster的时候显示没有权限</p>
<p>使用下面的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -h 10.211.55.4 -p 6381 </span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@CentOS7:/data# redis-cli -h 10.211.55.4 -p 6381 </span><br><span class="line">127.0.0.1:6379&gt; cluster nodes</span><br><span class="line">72c291c32815194b64d1f6d0fdf771f5cc04e14a 10.211.55.4:6380@16380 master - 0 1590905997358 2 connected 5461-10922</span><br><span class="line">6a595b67bbff15c94e5874c2d2cd556d6a6a6c17 10.211.55.4:6381@16381 master - 0 1590905998362 3 connected 10923-16383</span><br><span class="line">4e3dbdc8f835dcbc38291c88f08165ee51d53d3d 10.211.55.4:6379@16379 myself,master - 0 1590905997000 1 connected 0-5460</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>



<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210902221725956.png" alt="image-20210902221725956"></p>
<h3 id="外部连接访问不到或者连接上一会就报错断开"><a href="#外部连接访问不到或者连接上一会就报错断开" class="headerlink" title="外部连接访问不到或者连接上一会就报错断开"></a>外部连接访问不到或者连接上一会就报错断开</h3><h4 id="发现原因"><a href="#发现原因" class="headerlink" title="发现原因"></a>发现原因</h4><p>因为我发现，操作的时候总有一个redsi的主节点，显示的是非外网的ip地址，而是本地的物理ip地址</p>
<p>查看ip地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<p>docker0 开头的 docker ip 地址<br>eth0 开头的宿主机ip</p>
<p>我发现总有一个是用的宿主机的ip，但是阿里云服务器提供的ip地址又不是这个</p>
<h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim  /data/redis-data/node1/nodes-node-1.conf </span><br></pre></td></tr></table></figure>

<p><img src="https://typora-lvxiaoyi.oss-cn-beijing.aliyuncs.com/typora-img/image-20210903090624390.png" alt="image-20210903090624390"></p>
<p>然后把ip地址全部改成外网的ip地址</p>
<h1 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h1><p>参考文章：</p>
<p><a href="https://www.cnblogs.com/niceyoo/p/13011626.html">https://www.cnblogs.com/niceyoo/p/13011626.html</a></p>
]]></content>
      <categories>
        <category>redis</category>
        <category>redis集群</category>
      </categories>
      <tags>
        <tag>redis集群</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper基础</title>
    <url>/88815d0a.html</url>
    <content><![CDATA[<h1 id="什么是zookeeper"><a href="#什么是zookeeper" class="headerlink" title="什么是zookeeper"></a>什么是zookeeper</h1><p>zookeeper是一个分布式协调框架，主要用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。</p>
<span id="more"></span>

<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><p><img src="https://img-blog.csdn.net/201807121434154?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmFfNjY2NjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>每个子目录如NameService都被称为zNode（目录节点），和文件系统一样，我们能够自由的增减、删除zNode，在一个znode下增加、删除子znode，唯一的不同在于znode是可以存储数据的。</p>
<h2 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h2><p>有四种类型的znode：</p>
<ul>
<li>PERSISTENT(持久化目录节点)<ul>
<li>客户端与zookeeper断开连接后，该节点依旧存在</li>
</ul>
</li>
<li>PERSISTENT_SEQUENTIAL(持久化顺序编号目录节点)<ul>
<li>客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</li>
</ul>
</li>
<li><strong>EPHEMERAL-临时目录节点</strong><ul>
<li>客户端与zookeeper断开连接后，该节点被删除</li>
</ul>
</li>
<li><strong>EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点</strong><ul>
<li>客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</li>
</ul>
</li>
</ul>
<p> 参考：</p>
<p><a href="https://blog.csdn.net/java_66666/article/details/81015302">https://blog.csdn.net/java_66666/article/details/81015302</a></p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>netty基础-3</title>
    <url>/dec4a27c.html</url>
    <content><![CDATA[<h1 id="Google-Protobuf"><a href="#Google-Protobuf" class="headerlink" title="Google Protobuf"></a>Google Protobuf</h1><h2 id="编码和解码的基本介绍"><a href="#编码和解码的基本介绍" class="headerlink" title="编码和解码的基本介绍"></a>编码和解码的基本介绍</h2><ol>
<li>编写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送数据时就需要编码，接收数据时就需要解码[示意图]</li>
<li><code>codec</code>（编解码器）的组成部分有两个：<code>decoder</code>（解码器）和 <code>encoder</code>（编码器）。<code>encoder</code> 负责把业务数据转换成字节码数据，<code>decoder</code> 负责把字节码数据转换成业务数据</li>
</ol>
<span id="more"></span>

<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0001.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0001.png" alt="img"></a></p>
<h2 id="Netty-本身的编码解码的机制和问题分析"><a href="#Netty-本身的编码解码的机制和问题分析" class="headerlink" title="Netty 本身的编码解码的机制和问题分析"></a>Netty 本身的编码解码的机制和问题分析</h2><ol>
<li><p><code>Netty</code> 自身提供了一些 <code>codec</code>(编解码器)</p>
</li>
<li><p><code>Netty</code>提供的编码器</p>
<ul>
<li><code>StringEncoder</code>：对字符串数据进行编码。</li>
<li><code>ObjectEncoder</code>：对Java对象进行编码。</li>
</ul>
</li>
<li><p><code>Netty</code>提供的解码器</p>
<ul>
<li><code>StringDecoder</code>,对字符串数据进行解码</li>
<li><code>ObjectDecoder</code>，对 Java 对象进行解码</li>
</ul>
</li>
<li><p><code>Netty</code>本身自带的<code>ObjectDecoder</code>和<code>ObjectEncoder</code>可以用来实现<code>POJO</code>对象或各种业务对象的编码和解码，底层使用的仍是Java序列化技术,而Java序列化技术本身效率就不高，存在如下问题</p>
<ul>
<li>无法跨语言</li>
<li>序列化后的体积太大，是二进制编码的5倍多。</li>
<li>序列化性能太低</li>
</ul>
</li>
<li><p>引出新的解决方案[<code>Google</code> 的 <code>Protobuf</code>]</p>
</li>
</ol>
<h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><ol>
<li><code>Protobuf</code> 基本介绍和使用示意图</li>
<li><code>Protobuf</code> 是 <code>Google</code> 发布的开源项目，全称 <code>Google Protocol Buffers</code>，是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 <code>RPC</code> [远程过程调用 <code>remote procedure call</code> ]数据交换格式。目前很多公司 从<code>http + json 转向tcp + protobuf</code>，效率会更高。</li>
<li>参考文档：<a href="https://developers.google.com/protocol-buffers/docs/proto">https://developers.google.com/protocol-buffers/docs/proto</a> 语言指南</li>
<li><code>Protobuf</code> 是以 <code>message</code> 的方式来管理数据的.</li>
<li>支持跨平台、跨语言，即[客户端和服务器端可以是不同的语言编写的]（支持目前绝大多数语言，例如 <code>C++</code>、<code>C#</code>、<code>Java</code>、<code>python</code> 等）</li>
<li>高性能，高可靠性</li>
<li>使用 <code>protobuf</code> 编译器能自动生成代码，<code>Protobuf</code> 是将类的定义使用 <code>.proto</code> 文件进行描述。说明，在 <code>idea</code> 中编写 <code>.proto</code> 文件时，会自动提示是否下载 <code>.ptoto</code> 编写插件.可以让语法高亮。</li>
<li>然后通过 <code>protoc.exe</code> 编译器根据 <code>.proto</code> 自动生成 <code>.java</code> 文件</li>
<li><code>protobuf</code> 使用示意图</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0002.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0002.png" alt="img"></a></p>
<h2 id="Protobuf-快速入门实例"><a href="#Protobuf-快速入门实例" class="headerlink" title="Protobuf 快速入门实例"></a>Protobuf 快速入门实例</h2><p>编写程序，使用 <code>Protobuf</code> 完成如下功能</p>
<ol>
<li>客户端可以发送一个 <code>StudentPoJo</code> 对象到服务器(通过 <code>Protobuf</code> 编码)</li>
<li>服务端能接收 <code>StudentPoJo</code> 对象，并显示信息(通过 <code>Protobuf</code> 解码)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CODE</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;3.6.1&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Student-proto"><a href="#Student-proto" class="headerlink" title="Student.proto"></a>Student.proto</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PROTOBUF</span><br><span class="line">syntax = &quot;proto3&quot;; //版本</span><br><span class="line">option java_outer_classname = &quot;StudentPOJO&quot;;//生成的外部类名，同时也是文件名</span><br><span class="line">//protobuf 使用message 管理数据</span><br><span class="line">message Student &#123; //会在 StudentPOJO 外部类生成一个内部类 Student， 他是真正发送的POJO对象</span><br><span class="line">    int32 id = 1; // Student 类中有 一个属性 名字为 id 类型为int32(protobuf类型) 1表示属性序号，不是值</span><br><span class="line">    string name = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译<br>protoc.exe –java_out=.Student.proto<br>将生成的 StudentPOJO 放入到项目使用</p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0003.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0003.png" alt="img"></a></p>
<p>生成的StudentPOJO代码太长就不贴在这里了</p>
<h3 id="NettyServer"><a href="#NettyServer" class="headerlink" title="NettyServer"></a>NettyServer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.codec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.protobuf.ProtobufDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建BossGroup 和 WorkerGroup</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. 创建两个线程组 bossGroup 和 workerGroup</span></span><br><span class="line">        <span class="comment">//2. bossGroup 只是处理连接请求 , 真正的和客户端业务处理，会交给 workerGroup完成</span></span><br><span class="line">        <span class="comment">//3. 两个都是无限循环</span></span><br><span class="line">        <span class="comment">//4. bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数</span></span><br><span class="line">        <span class="comment">//   默认实际 cpu核数 * 2</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端的启动对象，配置参数</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用链式编程来进行设置</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup) <span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">//使用NioSocketChannel 作为服务器的通道实现</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) <span class="comment">// 设置线程队列得到连接个数</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>) <span class="comment">//设置保持活动连接状态</span></span><br><span class="line"><span class="comment">//                    .handler(null) // 该 handler对应 bossGroup , childHandler 对应 workerGroup</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<span class="comment">//创建一个通道初始化对象(匿名对象)</span></span><br><span class="line">                        <span class="comment">//给pipeline 设置处理器</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//在pipeline加入ProtoBufDecoder</span></span><br><span class="line">                            <span class="comment">//指定对哪种对象进行解码</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> ProtobufDecoder(StudentPOJO.Student.getDefaultInstance()));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;); <span class="comment">// 给我们的workerGroup 的 EventLoop 对应的管道设置处理器</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;.....服务器 is ready...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绑定一个端口并且同步, 生成了一个 ChannelFuture 对象</span></span><br><span class="line">            <span class="comment">//启动服务器(并绑定端口)</span></span><br><span class="line">            ChannelFuture cf = bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给cf 注册监听器，监控我们关心的事件</span></span><br><span class="line"></span><br><span class="line">            cf.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (cf.isSuccess()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口 6668 成功&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口 6668 失败&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NettyServerHandler"><a href="#NettyServerHandler" class="headerlink" title="NettyServerHandler"></a>NettyServerHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.codec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明</span></span><br><span class="line"><span class="comment">1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范)</span></span><br><span class="line"><span class="comment">2. 这时我们自定义一个Handler , 才能称为一个handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">StudentPOJO</span>.<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span></span><br><span class="line"><span class="comment">    2. Object msg: 就是客户端发送的数据 默认Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, StudentPOJO.Student msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取从客户端发送的StudentPojo.Student</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发送的数据 id=&quot;</span> + msg.getId() + <span class="string">&quot; 名字=&quot;</span> + msg.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//writeAndFlush 是 write + flush</span></span><br><span class="line">        <span class="comment">//将数据写入到缓存，并刷新</span></span><br><span class="line">        <span class="comment">//一般讲，我们对这个发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵1&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常, 一般是需要关闭通道</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NettyClient"><a href="#NettyClient" class="headerlink" title="NettyClient"></a>NettyClient</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.codec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.protobuf.ProtobufEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            <span class="comment">//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(group) <span class="comment">//设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel.class) <span class="comment">// 设置客户端通道的实现类(反射)</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//在pipeline中加入 ProtoBufEncoder</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> ProtobufEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyClientHandler()); <span class="comment">//加入自己的处理器</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端 ok..&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动客户端去连接服务器端</span></span><br><span class="line">            <span class="comment">//关于 ChannelFuture 要分析，涉及到netty的异步模型</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//给关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NettyClientHandler"><a href="#NettyClientHandler" class="headerlink" title="NettyClientHandler"></a>NettyClientHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.codec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通道就绪就会触发该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发生一个Student 对象到服务器</span></span><br><span class="line"></span><br><span class="line">        StudentPOJO.Student student = StudentPOJO.Student.newBuilder().setId(<span class="number">4</span>).setName(<span class="string">&quot;智多星 吴用&quot;</span>).build();</span><br><span class="line">        <span class="comment">//Teacher , Member ,Message</span></span><br><span class="line">        ctx.writeAndFlush(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通道有读取事件时，会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器回复的消息:&quot;</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器的地址： &quot;</span>+ ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Protobuf-快速入门实例-2"><a href="#Protobuf-快速入门实例-2" class="headerlink" title="Protobuf 快速入门实例 2"></a>Protobuf 快速入门实例 2</h2><ol>
<li>编写程序，使用 <code>Protobuf</code> 完成如下功能</li>
<li>客户端可以随机发送 <code>StudentPoJo</code> / <code>WorkerPoJo</code> 对象到服务器(通过 <code>Protobuf</code> 编码)</li>
<li>服务端能接收 <code>StudentPoJo</code> / <code>WorkerPoJo</code> 对象(需要判断是哪种类型)，并显示信息(通过 <code>Protobuf</code> 解码)</li>
</ol>
<h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a>proto</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PROTOBUF</span><br><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line">option optimize_for = SPEED; // 加快解析</span><br><span class="line">option java_package=&quot;com.atguigu.netty.codec2&quot;;   //指定生成到哪个包下</span><br><span class="line">option java_outer_classname=&quot;MyDataInfo&quot;; // 外部类名, 文件名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">1.protobuf 可以使用message 管理其他的message。最终决定使用哪一个message作为传输对象</span><br><span class="line">2.假设你某个项目需要传输20个对象，你不可能新建20个proto文件吧。此时你就可以</span><br><span class="line">在一个文件里定义20个message，最后再用一个总的message（比方说这里的MyMessage）</span><br><span class="line">来决定在实际传输时真正需要传输哪一个对象</span><br><span class="line">3.因为你实际传输的时候大部分情况传输的都是一个对象，所以下面用oneof进行了限制</span><br><span class="line">4.是否可以传多个对象呢？我个人认为是可以的，比如可以通过map(目前我也不太了解proto的语法)</span><br><span class="line"> */</span><br><span class="line">message MyMessage &#123;</span><br><span class="line"></span><br><span class="line">    //定义一个枚举类型,DataType如果是0则表示一个Student对象实例，DataType这个名称自定义</span><br><span class="line">    enum DataType &#123;</span><br><span class="line">        StudentType = 0; //在proto3 要求enum的编号从0开始</span><br><span class="line">        WorkerType = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //用data_type 来标识传的是哪一个枚举类型，这里才真正开始定义MyMessage的数据类型</span><br><span class="line">    DataType data_type = 1;  //所有后面的数字都只是编号而已</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    1.oneof关键字 表示每次枚举类型进行传输时，限制最多只能传输一个对象。</span><br><span class="line">    dataBody名称也是自定义的</span><br><span class="line">    2.为什么这里的序号是2呢？因为上面DataType data_type = 1  占了第一个序号了</span><br><span class="line">    3.MyMessage里真正出现的类型只有两个</span><br><span class="line">      ①DataType类型</span><br><span class="line">      ②Student类型或者Worker类型（这两个在真正传输的时候只会有一个出现）</span><br><span class="line">    */</span><br><span class="line">    oneof dataBody &#123;</span><br><span class="line">        Student student = 2;  //注意这后面的数字也都只是编号而已</span><br><span class="line">        Worker worker = 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message Student &#123;</span><br><span class="line">    int32 id = 1;//Student类的属性</span><br><span class="line">    string name = 2; //</span><br><span class="line">&#125;</span><br><span class="line">message Worker &#123;</span><br><span class="line">    string name=1;</span><br><span class="line">    int32 age=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NettyServer-1"><a href="#NettyServer-1" class="headerlink" title="NettyServer"></a>NettyServer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.codec2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.codec.StudentPOJO;</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.protobuf.ProtobufDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端的启动对象，配置参数</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用链式编程来进行设置</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup) <span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">//使用NioSocketChannel 作为服务器的通道实现</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) <span class="comment">// 设置线程队列得到连接个数</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>) <span class="comment">//设置保持活动连接状态</span></span><br><span class="line"><span class="comment">//                    .handler(null) // 该 handler对应 bossGroup , childHandler 对应 workerGroup</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<span class="comment">//创建一个通道初始化对象(匿名对象)</span></span><br><span class="line">                        <span class="comment">//给pipeline 设置处理器</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//在pipeline加入ProtoBufDecoder</span></span><br><span class="line">                            <span class="comment">//指定对哪种对象进行解码</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> ProtobufDecoder(MyDataInfo.MyMessage.getDefaultInstance()));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;); <span class="comment">// 给我们的workerGroup 的 EventLoop 对应的管道设置处理器</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;.....服务器 is ready...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绑定一个端口并且同步, 生成了一个 ChannelFuture 对象</span></span><br><span class="line">            <span class="comment">//启动服务器(并绑定端口)</span></span><br><span class="line">            ChannelFuture cf = bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给cf 注册监听器，监控我们关心的事件</span></span><br><span class="line"></span><br><span class="line">            cf.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (cf.isSuccess()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口 6668 成功&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口 6668 失败&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NettyServerHandler-1"><a href="#NettyServerHandler-1" class="headerlink" title="NettyServerHandler"></a>NettyServerHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.codec2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.codec.StudentPOJO;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MyDataInfo</span>.<span class="title">MyMessage</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span></span><br><span class="line"><span class="comment">    2. Object msg: 就是客户端发送的数据 默认Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MyDataInfo.MyMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据dataType 来显示不同的信息</span></span><br><span class="line"></span><br><span class="line">        MyDataInfo.MyMessage.DataType dataType = msg.getDataType();</span><br><span class="line">        <span class="keyword">if</span>(dataType == MyDataInfo.MyMessage.DataType.StudentType) &#123;</span><br><span class="line"></span><br><span class="line">            MyDataInfo.Student student = msg.getStudent();</span><br><span class="line">            System.out.println(<span class="string">&quot;学生id=&quot;</span> + student.getId() + <span class="string">&quot; 学生名字=&quot;</span> + student.getName());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dataType == MyDataInfo.MyMessage.DataType.WorkerType) &#123;</span><br><span class="line">            MyDataInfo.Worker worker = msg.getWorker();</span><br><span class="line">            System.out.println(<span class="string">&quot;工人的名字=&quot;</span> + worker.getName() + <span class="string">&quot; 年龄=&quot;</span> + worker.getAge());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;传输的类型不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//writeAndFlush 是 write + flush</span></span><br><span class="line">        <span class="comment">//将数据写入到缓存，并刷新</span></span><br><span class="line">        <span class="comment">//一般讲，我们对这个发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵1&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常, 一般是需要关闭通道</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NettyClient-1"><a href="#NettyClient-1" class="headerlink" title="NettyClient"></a>NettyClient</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.codec2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.protobuf.ProtobufEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            <span class="comment">//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(group) <span class="comment">//设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel.class) <span class="comment">// 设置客户端通道的实现类(反射)</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//在pipeline中加入 ProtoBufEncoder</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> ProtobufEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyClientHandler()); <span class="comment">//加入自己的处理器</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端 ok..&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动客户端去连接服务器端</span></span><br><span class="line">            <span class="comment">//关于 ChannelFuture 要分析，涉及到netty的异步模型</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//给关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NettyClientHandler-1"><a href="#NettyClientHandler-1" class="headerlink" title="NettyClientHandler"></a>NettyClientHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.codec2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.codec.StudentPOJO;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通道就绪就会触发该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//随机的发送Student 或者 Workder 对象</span></span><br><span class="line">        <span class="keyword">int</span> random = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">        MyDataInfo.MyMessage myMessage = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == random) &#123; <span class="comment">//发送Student 对象</span></span><br><span class="line"></span><br><span class="line">            myMessage = MyDataInfo.MyMessage.newBuilder().setDataType(MyDataInfo.MyMessage.DataType.StudentType).setStudent(MyDataInfo.Student.newBuilder().setId(<span class="number">5</span>).setName(<span class="string">&quot;玉麒麟 卢俊义&quot;</span>).build()).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 发送一个Worker 对象</span></span><br><span class="line"></span><br><span class="line">            myMessage = MyDataInfo.MyMessage.newBuilder().setDataType(MyDataInfo.MyMessage.DataType.WorkerType).setWorker(MyDataInfo.Worker.newBuilder().setAge(<span class="number">20</span>).setName(<span class="string">&quot;老李&quot;</span>).build()).build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(myMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通道有读取事件时，会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器回复的消息:&quot;</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器的地址： &quot;</span>+ ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Netty-编解码器和-Handler-调用机制"><a href="#Netty-编解码器和-Handler-调用机制" class="headerlink" title="Netty 编解码器和 Handler 调用机制"></a>Netty 编解码器和 Handler 调用机制</h1><h2 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h2><ol>
<li><code>Netty</code> 的组件设计：<code>Netty</code> 的主要组件有 <code>Channel</code>、<code>EventLoop</code>、<code>ChannelFuture</code>、<code>ChannelHandler</code>、<code>ChannelPipe</code> 等</li>
<li><code>ChannelHandler</code> 充当了处理入站和出站数据的应用程序逻辑的容器。例如，实现 <code>ChannelInboundHandler</code> 接口（或 <code>ChannelInboundHandlerAdapter</code>），你就可以接收入站事件和数据，这些数据会被业务逻辑处理。当要给客户端发送响应时，也可以从 <code>ChannelInboundHandler</code> 冲刷数据。业务逻辑通常写在一个或者多个 <code>ChannelInboundHandler</code> 中。<code>ChannelOutboundHandler</code> 原理一样，只不过它是用来处理出站数据的</li>
<li><code>ChannelPipeline</code> 提供了 <code>ChannelHandler</code> 链的容器。以客户端应用程序为例，如果事件的运动方向是从客户端到服务端的，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过 <code>pipeline</code> 中的一系列 <code>ChannelOutboundHandler</code>，并被这些 <code>Handler</code> 处理，反之则称为入站的</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0004.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0004.png" alt="img"></a></p>
<blockquote>
<p>出站，入站如果搞不清楚，看下面的<strong>Netty的handler链的调用机制</strong>，通过一个例子和图讲清楚</p>
</blockquote>
<h2 id="编码解码器"><a href="#编码解码器" class="headerlink" title="编码解码器"></a>编码解码器</h2><ol>
<li>当 <code>Netty</code> 发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如 <code>java</code> 对象）；如果是出站消息，它会被编码成字节。</li>
<li><code>Netty</code> 提供一系列实用的编解码器，他们都实现了 <code>ChannelInboundHadnler</code> 或者 <code>ChannelOutboundHandler</code> 接口。在这些类中，<code>channelRead</code> 方法已经被重写了。以入站为例，对于每个从入站 <code>Channel</code> 读取的消息，这个方法会被调用。随后，它将调用由解码器所提供的 <code>decode()</code> 方法进行解码，并将已经解码的字节转发给 <code>ChannelPipeline</code> 中的下一个 <code>ChannelInboundHandler</code>。</li>
</ol>
<h2 id="解码器-ByteToMessageDecoder"><a href="#解码器-ByteToMessageDecoder" class="headerlink" title="解码器 - ByteToMessageDecoder"></a>解码器 - ByteToMessageDecoder</h2><ol>
<li>关系继承图</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0005.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0005.png" alt="img"></a></p>
<ol>
<li>由于不可能知道远程节点是否会一次性发送一个完整的信息，<code>tcp</code> 有可能出现粘包拆包的问题，这个类会对入站数据进行缓冲，直到它准备好被处理.【后面有说TCP的粘包和拆包问题】</li>
<li>一个关于 <code>ByteToMessageDecoder</code> 实例分析</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0006.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0006.png" alt="img"></a></p>
<h2 id="Netty的handler链的调用机制"><a href="#Netty的handler链的调用机制" class="headerlink" title="Netty的handler链的调用机制"></a>Netty的handler链的调用机制</h2><p>实例要求:</p>
<ol>
<li>使用自定义的编码器和解码器来说明 <code>Netty</code> 的 <code>handler</code> 调用机制<br>客户端发送 <code>long</code> -&gt; 服务器<br>服务端发送 <code>long</code> -&gt; 客户端</li>
</ol>
<blockquote>
<p>读者可以看下这个图，带着这个图去看下面的例子。</p>
</blockquote>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0007.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0007.png" alt="img"></a></p>
<h3 id="MyServer"><a href="#MyServer" class="headerlink" title="MyServer"></a>MyServer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(<span class="keyword">new</span> MyServerInitializer()); <span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyServerInitializer"><a href="#MyServerInitializer" class="headerlink" title="MyServerInitializer"></a>MyServerInitializer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();<span class="comment">//一会下断点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//入站的handler进行解码 MyByteToLongDecoder</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyByteToLongDecoder());</span><br><span class="line">        <span class="comment">//出站的handler进行编码</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyLongToByteEncoder());</span><br><span class="line">        <span class="comment">//自定义的handler 处理业务逻辑</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">        System.out.println(<span class="string">&quot;xx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyServerHandler"><a href="#MyServerHandler" class="headerlink" title="MyServerHandler"></a>MyServerHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Long msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;从客户端&quot;</span> + ctx.channel().remoteAddress() + <span class="string">&quot; 读取到long &quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给客户端发送一个long</span></span><br><span class="line">        ctx.writeAndFlush(<span class="number">98765L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyClient"><a href="#MyClient" class="headerlink" title="MyClient"></a>MyClient</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group).channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> MyClientInitializer()); <span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>).sync();</span><br><span class="line"></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyClientInitializer"><a href="#MyClientInitializer" class="headerlink" title="MyClientInitializer"></a>MyClientInitializer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入一个出站的handler 对数据进行一个编码</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyLongToByteEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这时一个入站的解码器(入站handler )</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyByteToLongDecoder());</span><br><span class="line">        <span class="comment">//加入一个自定义的handler ， 处理业务</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyClientHandler());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyClientHandler"><a href="#MyClientHandler" class="headerlink" title="MyClientHandler"></a>MyClientHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span>  <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Long msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器的ip=&quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line">        System.out.println(<span class="string">&quot;收到服务器消息=&quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写channelActive 发送数据</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyClientHandler 发送数据&quot;</span>);</span><br><span class="line">        <span class="comment">//ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;&quot;))</span></span><br><span class="line">        ctx.writeAndFlush(<span class="number">123456L</span>); <span class="comment">//发送的是一个long</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyByteToLongDecoder"><a href="#MyByteToLongDecoder" class="headerlink" title="MyByteToLongDecoder"></a>MyByteToLongDecoder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyByteToLongDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * decode 会根据接收的数据，被调用多次, 直到确定没有新的元素被添加到list</span></span><br><span class="line"><span class="comment">     * , 或者是ByteBuf 没有更多的可读字节为止</span></span><br><span class="line"><span class="comment">     * 如果list out 不为空，就会将list的内容传递给下一个 channelinboundhandler处理,</span></span><br><span class="line"><span class="comment">     * 该处理器的方法也会被调用多次</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 入站的 ByteBuf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out List 集合，将解码后的数据传给下一个handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;MyByteToLongDecoder 被调用&quot;</span>);</span><br><span class="line">        <span class="comment">//因为 long 8个字节, 需要判断有8个字节，才能读取一个long</span></span><br><span class="line">        <span class="keyword">if</span>(in.readableBytes() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">            out.add(in.readLong());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyLongToByteEncoder"><a href="#MyLongToByteEncoder" class="headerlink" title="MyLongToByteEncoder"></a>MyLongToByteEncoder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.MessageToByteEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLongToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//编码方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Long msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;MyLongToByteEncoder encode 被调用&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;msg=&quot;</span> + msg);</span><br><span class="line">        out.writeLong(msg);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0008.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0008.png" alt="img"></a><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0009.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0009.png" alt="img"></a></p>
<h3 id="出站入站"><a href="#出站入站" class="headerlink" title="出站入站"></a>出站入站</h3><p>关于出站入站，很多人可能有点迷糊<br>1）客户端有出站入站，服务端也有出站入站<br>2）以客户端为例，如果有服务端传送的数据到达客户端，那么对于客户端来说就是入站；<br>如果客户端传送数据到服务端，那么对于客户端来说就是出站；<br>同理，对于服务端来说，也是一样的，有数据来就是入站，有数据输出就是出站<br>3）为什么服务端和客户端的Serverhandler都是继承<code>SimpleChannelInboundHandler</code>，而没有<code>ChannelOutboundHandler</code>出站类？<br>实际上当我们在handler中调用ctx.writeAndFlush()方法后，就会将数据交给ChannelOutboundHandler进行出站处理，只是我们没有去定义出站类而已，若有需求可以自己去实现ChannelOutboundHandler出站类<br>4）总结就是客户端和服务端都有出站和入站的操作<br><strong>服务端发数据给客户端：</strong>服务端—&gt;出站—&gt;Socket通道—&gt;入站—&gt;客户端</p>
<p> <strong>客户端发数据给服务端：</strong>客户端—&gt;出站—&gt;Socket通道—&gt;入站—&gt;服务端</p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0007.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0007.png" alt="img"></a></p>
<blockquote>
<p>下面是Netty官方源码给的图，我个人觉的不是太好理解，上面的图好理解一些</p>
</blockquote>
<p><a href="https://imlql.cn/post/image/chapter08_05.png"><img src="https://imlql.cn/post/image/chapter08_05.png" alt="img"></a></p>
<h2 id="ByteToMessageDecoder的小细节"><a href="#ByteToMessageDecoder的小细节" class="headerlink" title="ByteToMessageDecoder的小细节"></a>ByteToMessageDecoder的小细节</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span>  <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Long msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器的ip=&quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line">        System.out.println(<span class="string">&quot;收到服务器消息=&quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写channelActive 发送数据</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyClientHandler 发送数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分析</span></span><br><span class="line">        <span class="comment">//1. &quot;abcdabcdabcdabcd&quot; 是 16个字节</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;abcdabcdabcdabcd&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyByteToLongDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * decode 会根据接收的数据，被调用多次, 直到确定没有新的元素被添加到list</span></span><br><span class="line"><span class="comment">     * , 或者是ByteBuf 没有更多的可读字节为止</span></span><br><span class="line"><span class="comment">     * 如果list out 不为空，就会将list的内容传递给下一个 channelinboundhandler处理,</span></span><br><span class="line"><span class="comment">     * 该处理器的方法也会被调用多次</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 入站的 ByteBuf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out List 集合，将解码后的数据传给下一个handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;MyByteToLongDecoder 被调用&quot;</span>);</span><br><span class="line">        <span class="comment">//因为 long 8个字节, 需要判断有8个字节，才能读取一个long</span></span><br><span class="line">        <span class="keyword">if</span>(in.readableBytes() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">            out.add(in.readLong());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>由于发送的字符串是16字节，根据上面注释说的内容，decode会被调用两次</li>
</ol>
<p>如下图验证结果：</p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0010.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0010.png" alt="img"></a></p>
<ol>
<li><p>同时又引出了一个小问题</p>
<p><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0011.png" alt="img"></p>
<p>当我们<code>MyClientHandler</code>传一个Long时，会调用我们的<code>MyLongToByteEncoder</code>的编码器。那么控制台就会打印这样一句话：<strong>MyLongToByteEncoder encode 被调用</strong>。但是这里并没有调用编码器，这是为什么呢？</p>
<ol>
<li><code>MyClientHandler</code>这个处理器的后一个处理器是<code>MyLongToByteEncoder</code></li>
<li><code>MyLongToByteEncoder</code>的父类是<code>MessageToByteEncoder</code>，在<code>MessageToByteEncoder</code>中有下面的一个方法</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf buf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里会判断当前msg 是不是应该处理的类型，如果是就处理，不是就跳过encode</span></span><br><span class="line">            <span class="keyword">if</span> (acceptOutboundMessage(msg)) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                I cast = (I) msg;</span><br><span class="line">                buf = allocateBuffer(ctx, cast, preferDirect);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    encode(ctx, cast, buf);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ReferenceCountUtil.release(cast);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (buf.isReadable()) &#123;</span><br><span class="line">                    ctx.write(buf, promise);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    buf.release();</span><br><span class="line">                    ctx.write(Unpooled.EMPTY_BUFFER, promise);</span><br><span class="line">                &#125;</span><br><span class="line">                buf = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ctx.write(msg, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (EncoderException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EncoderException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (buf != <span class="keyword">null</span>) &#123;</span><br><span class="line">                buf.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>当我们以这样的形式发送数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;abcdabcdabcdabcd&quot;</span>,CharsetUtil.UTF_8));</span><br></pre></td></tr></table></figure>

<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0012.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0012.png" alt="img"></a></p>
<p>这两个类型并不匹配，也就不会走编码器。因此我们编写 Encoder 是要注意传入的数据类型和处理的数据类型一致</p>
<p><strong>结论：</strong></p>
<ul>
<li>不论解码器 <code>handler</code> 还是编码器 <code>handler</code> 即接收的消息类型必须与待处理的消息类型一致，否则该 <code>handler</code> 不会被执行</li>
<li>在解码器进行数据解码时，需要判断缓存区（<code>ByteBuf</code>）的数据是否足够，否则接收到的结果会期望结果可能不一致。</li>
</ul>
<h2 id="解码器-ReplayingDecoder"><a href="#解码器-ReplayingDecoder" class="headerlink" title="解码器 - ReplayingDecoder"></a>解码器 - ReplayingDecoder</h2><ol>
<li><code>public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder</code></li>
<li><code>ReplayingDecoder</code> 扩展了 <code>ByteToMessageDecoder</code> 类，使用这个类，我们不必调用 <code>readableBytes()</code> 方法，也就不用判断还有没有足够的数据来读取。参数 <code>S</code> 指定了用户状态管理的类型，其中 <code>Void</code> 代表不需要状态管理</li>
<li>应用实例：使用 <code>ReplayingDecoder</code> 编写解码器，对前面的案例进行简化[案例演示]</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ReplayingDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyByteToLongDecoder2</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyByteToLongDecoder2 被调用&quot;</span>);</span><br><span class="line">        <span class="comment">//在 ReplayingDecoder 不需要判断数据是否足够读取，内部会进行处理判断</span></span><br><span class="line">        out.add(in.readLong());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>```<br>ReplayingDecoder<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">   使用方便，但它也有一些局限性：</span><br><span class="line"></span><br><span class="line">   - 并不是所有的 `ByteBuf` 操作都被支持，如果调用了一个不被支持的方法，将会抛出一个 `UnsupportedOperationException`。</span><br><span class="line">   - `ReplayingDecoder` 在某些情况下可能稍慢于 `ByteToMessageDecoder`，例如网络缓慢并且消息格式复杂时，消息会被拆成了多个碎片，速度变慢</span><br><span class="line"></span><br><span class="line">## 其它编解码器</span><br><span class="line"></span><br><span class="line">[![img](https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0013.png)](https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0013.png)</span><br><span class="line"></span><br><span class="line">1. `LineBasedFrameDecoder`：这个类在 `Netty` 内部也有使用，它使用行尾控制字符（\n或者\r\n）作为分隔符来解析数据。</span><br><span class="line">2. `DelimiterBasedFrameDecoder`：使用自定义的特殊字符作为消息的分隔符。</span><br><span class="line">3. `HttpObjectDecoder`：一个 `HTTP` 数据的解码器</span><br><span class="line">4. `LengthFieldBasedFrameDecoder`：通过指定长度来标识整包消息，这样就可以自动的处理黏包和半包消息。</span><br><span class="line"></span><br><span class="line">## Log4j 整合到 Netty</span><br><span class="line"></span><br><span class="line">1. 在 `Maven` 中添加对 `Log4j` 的依赖在 `pom.xml`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
XML<dependency>
 <groupId>log4j</groupId>
 <artifactId>log4j</artifactId>
 <version>1.2.17</version>
</dependency>
<dependency>
 <groupId>org.slf4j</groupId>
 <artifactId>slf4j-api</artifactId>
 <version>1.7.25</version>
</dependency>
<dependency>
 <groupId>org.slf4j</groupId>
 <artifactId>slf4j-log4j12</artifactId>
 <version>1.7.25</version>
 <scope>test</scope>
</dependency>
<dependency>
 <groupId>org.slf4j</groupId>
 <artifactId>slf4j-simple</artifactId>
 <version>1.7.25</version>
 <scope>test</scope>
</dependency>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. 配置 `Log4j`，在 `resources/log4j.properties`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
PROPERTIES
log4j.rootLogger=DEBUG,stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=[%p]%C{1}-%m%n
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. 演示整合</span><br><span class="line"></span><br><span class="line">[![img](https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0014.jpg)](https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0014.jpg)</span><br><span class="line"></span><br><span class="line"># TCP 粘包和拆包及解决方案</span><br><span class="line"></span><br><span class="line">## TCP 粘包和拆包基本介绍</span><br><span class="line"></span><br><span class="line">1. `TCP` 是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的 `socket`，因此，发送端为了将多个发给接收端的包，更有效的发给对方，使用了优化方法（`Nagle` 算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难于分辨出完整的数据包了，因为面向流的通信是无消息保护边界的</span><br><span class="line">2. 由于 `TCP` 无消息保护边界,需要在接收端处理消息边界问题，也就是我们所说的粘包、拆包问题,看一张图</span><br><span class="line">3. `TCP` 粘包、拆包图解</span><br><span class="line"></span><br><span class="line">[![img](https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0015.png)](https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0015.png)</span><br><span class="line"></span><br><span class="line">假设客户端分别发送了两个数据包 `D1` 和 `D2` 给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下四种情况：</span><br><span class="line"></span><br><span class="line">1. 服务端分两次读取到了两个独立的数据包，分别是 `D1` 和 `D2`，没有粘包和拆包</span><br><span class="line">2. 服务端一次接受到了两个数据包，`D1` 和 `D2` 粘合在一起，称之为 `TCP` 粘包</span><br><span class="line">3. 服务端分两次读取到了数据包，第一次读取到了完整的 `D1` 包和 `D2` 包的部分内容，第二次读取到了 `D2` 包的剩余内容，这称之为 `TCP` 拆包</span><br><span class="line">4. 服务端分两次读取到了数据包，第一次读取到了 `D1` 包的部分内容 `D1_1`，第二次读取到了 `D1` 包的剩余部分内容 `D1_2` 和完整的 `D2` 包。</span><br><span class="line"></span><br><span class="line">## TCP 粘包和拆包现象实例</span><br><span class="line"></span><br><span class="line">在编写 `Netty` 程序时，如果没有做处理，就会发生粘包和拆包的问题</span><br><span class="line"></span><br><span class="line">看一个具体的实例：</span><br><span class="line"></span><br><span class="line">### MyServer</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">package com.atguigu.netty.tcp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import io.netty.bootstrap.ServerBootstrap;</span><br><span class="line">import io.netty.channel.ChannelFuture;</span><br><span class="line">import io.netty.channel.EventLoopGroup;</span><br><span class="line">import io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line">import io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line">public class MyServer &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = new NioEventLoopGroup(1);</span><br><span class="line">        EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = new ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(new MyServerInitializer()); //自定义一个初始化类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(7000).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="MyServerInitializer-1"><a href="#MyServerInitializer-1" class="headerlink" title="MyServerInitializer"></a>MyServerInitializer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.tcp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyServerHandler-1"><a href="#MyServerHandler-1" class="headerlink" title="MyServerHandler"></a>MyServerHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//cause.printStackTrace();</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[msg.readableBytes()];</span><br><span class="line">        msg.readBytes(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将buffer转成字符串</span></span><br><span class="line">        String message = <span class="keyword">new</span> String(buffer, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器接收到数据 &quot;</span> + message);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器接收到消息量=&quot;</span> + (++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务器回送数据给客户端, 回送一个随机id ,</span></span><br><span class="line">        ByteBuf responseByteBuf = Unpooled.copiedBuffer(UUID.randomUUID().toString() + <span class="string">&quot; &quot;</span>, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        ctx.writeAndFlush(responseByteBuf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyClient-1"><a href="#MyClient-1" class="headerlink" title="MyClient"></a>MyClient</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.tcp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group).channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> MyClientInitializer()); <span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>).sync();</span><br><span class="line"></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyClientInitializer-1"><a href="#MyClientInitializer-1" class="headerlink" title="MyClientInitializer"></a>MyClientInitializer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyClientHandler-1"><a href="#MyClientHandler-1" class="headerlink" title="MyClientHandler"></a>MyClientHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//使用客户端发送10条数据 hello,server 编号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            ByteBuf buffer = Unpooled.copiedBuffer(<span class="string">&quot;hello,server &quot;</span> + i, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            ctx.writeAndFlush(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[msg.readableBytes()];</span><br><span class="line">        msg.readBytes(buffer);</span><br><span class="line"></span><br><span class="line">        String message = <span class="keyword">new</span> String(buffer, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端接收到消息=&quot;</span> + message);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端接收消息数量=&quot;</span> + (++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3><p><strong>第一次运行：</strong></p>
<p><strong>Client</strong></p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0016.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0016.png" alt="img"></a></p>
<p><strong>Server</strong></p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0017.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0017.png" alt="img"></a></p>
<p><strong>第二次运行：</strong></p>
<p><strong>Client</strong></p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0018.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0018.png" alt="img"></a></p>
<p><strong>Server</strong></p>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0019.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0019.png" alt="img"></a></p>
<p>可以看到第一次运行时，服务器一次性将10个数据都接收了，第二次运行时分六次接收的，这就很形象的看出了TCP的粘包现象。</p>
<h2 id="TCP-粘包和拆包解决方案"><a href="#TCP-粘包和拆包解决方案" class="headerlink" title="TCP 粘包和拆包解决方案"></a>TCP 粘包和拆包解决方案</h2><ol>
<li>常用方案：使用自定义协议+编解码器来解决</li>
<li>关键就是要解决服务器端每次读取数据长度的问题，这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的 <code>TCP</code> 粘包、拆包。</li>
</ol>
<p><strong>看一个具体的实例</strong></p>
<ol>
<li>要求客户端发送 <code>5</code> 个 <code>Message</code> 对象，客户端每次发送一个 <code>Message</code> 对象</li>
<li>服务器端每次接收一个 <code>Message</code>，分 <code>5</code> 次进行解码，每读取到一个 <code>Message</code>，会回复一个 <code>Message</code> 对象给客户端。</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0020.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0020.png" alt="img"></a></p>
<h3 id="MessageProtocol"><a href="#MessageProtocol" class="headerlink" title="MessageProtocol"></a>MessageProtocol</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//协议包</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len; <span class="comment">//关键</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLen</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.len = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getContent() &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(<span class="keyword">byte</span>[] content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyServer-1"><a href="#MyServer-1" class="headerlink" title="MyServer"></a>MyServer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(<span class="keyword">new</span> MyServerInitializer()); <span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyServerInitializer-2"><a href="#MyServerInitializer-2" class="headerlink" title="MyServerInitializer"></a>MyServerInitializer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageDecoder());<span class="comment">//解码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageEncoder());<span class="comment">//编码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyServerHandler-2"><a href="#MyServerHandler-2" class="headerlink" title="MyServerHandler"></a>MyServerHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理业务的handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MessageProtocol</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//cause.printStackTrace();</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收到数据，并处理</span></span><br><span class="line">        <span class="keyword">int</span> len = msg.getLen();</span><br><span class="line">        <span class="keyword">byte</span>[] content = msg.getContent();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器接收到信息如下&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;长度=&quot;</span> + len);</span><br><span class="line">        System.out.println(<span class="string">&quot;内容=&quot;</span> + <span class="keyword">new</span> String(content, Charset.forName(<span class="string">&quot;utf-8&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器接收到消息包数量=&quot;</span> + (++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回复消息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;服务端开始回复消息------&quot;</span>);</span><br><span class="line">        String responseContent = UUID.randomUUID().toString();</span><br><span class="line">        <span class="keyword">int</span> responseLen = responseContent.getBytes(<span class="string">&quot;utf-8&quot;</span>).length;</span><br><span class="line">        <span class="keyword">byte</span>[]  responseContent2 = responseContent.getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//构建一个协议包</span></span><br><span class="line">        MessageProtocol messageProtocol = <span class="keyword">new</span> MessageProtocol();</span><br><span class="line">        messageProtocol.setLen(responseLen);</span><br><span class="line">        messageProtocol.setContent(responseContent2);</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(messageProtocol);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyClient-2"><a href="#MyClient-2" class="headerlink" title="MyClient"></a>MyClient</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group).channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> MyClientInitializer()); <span class="comment">//自定义一个初始化类</span></span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>).sync();</span><br><span class="line"></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyClientInitializer-2"><a href="#MyClientInitializer-2" class="headerlink" title="MyClientInitializer"></a>MyClientInitializer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageEncoder()); <span class="comment">//加入编码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageDecoder()); <span class="comment">//加入解码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyClientHandler-2"><a href="#MyClientHandler-2" class="headerlink" title="MyClientHandler"></a>MyClientHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MessageProtocol</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//使用客户端发送10条数据 &quot;今天天气冷，吃火锅&quot; 编号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            String mes = <span class="string">&quot;今天天气冷，吃火锅&quot;</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] content = mes.getBytes(Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            <span class="keyword">int</span> length = mes.getBytes(Charset.forName(<span class="string">&quot;utf-8&quot;</span>)).length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建协议包对象</span></span><br><span class="line">            MessageProtocol messageProtocol = <span class="keyword">new</span> MessageProtocol();</span><br><span class="line">            messageProtocol.setLen(length);</span><br><span class="line">            messageProtocol.setContent(content);</span><br><span class="line">            ctx.writeAndFlush(messageProtocol);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = msg.getLen();</span><br><span class="line">        <span class="keyword">byte</span>[] content = msg.getContent();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;客户端接收到消息如下&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;长度=&quot;</span> + len);</span><br><span class="line">        System.out.println(<span class="string">&quot;内容=&quot;</span> + <span class="keyword">new</span> String(content, Charset.forName(<span class="string">&quot;utf-8&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;客户端接收消息数量=&quot;</span> + (++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常消息=&quot;</span> + cause.getMessage());</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyMessageDecoder"><a href="#MyMessageDecoder" class="headerlink" title="MyMessageDecoder"></a>MyMessageDecoder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ReplayingDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;MyMessageDecoder decode 被调用&quot;</span>);</span><br><span class="line">        <span class="comment">//需要将得到二进制字节码-&gt; MessageProtocol 数据包(对象)</span></span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] content = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装成 MessageProtocol 对象，放入 out， 传递下一个handler业务处理</span></span><br><span class="line">        MessageProtocol messageProtocol = <span class="keyword">new</span> MessageProtocol();</span><br><span class="line">        messageProtocol.setLen(length);</span><br><span class="line">        messageProtocol.setContent(content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放入out传给下一个hanlder进行处理</span></span><br><span class="line">        out.add(messageProtocol);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyMessageEncoder"><a href="#MyMessageEncoder" class="headerlink" title="MyMessageEncoder"></a>MyMessageEncoder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.protocoltcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.MessageToByteEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">MessageProtocol</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, MessageProtocol msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyMessageEncoder encode 方法被调用&quot;</span>);</span><br><span class="line">        out.writeInt(msg.getLen());</span><br><span class="line">        out.writeBytes(msg.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h3><p><strong>Client输出</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyMessageEncoder encode 方法被调用</span><br><span class="line">MyMessageEncoder encode 方法被调用</span><br><span class="line">MyMessageEncoder encode 方法被调用</span><br><span class="line">MyMessageEncoder encode 方法被调用</span><br><span class="line">MyMessageEncoder encode 方法被调用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是客户端开始一个一个的收到服务端的回复</span></span><br><span class="line">MyMessageDecoder decode 被调用</span><br><span class="line">客户端接收到消息如下</span><br><span class="line">长度=<span class="number">36</span></span><br><span class="line">内容=1b5286dd-0fc2-4f62-9bf7-d5fad84179b5</span><br><span class="line">客户端接收消息数量=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyMessageDecoder decode 被调用</span><br><span class="line">客户端接收到消息如下</span><br><span class="line">长度=<span class="number">36</span></span><br><span class="line">内容=653d18cb-ab72-<span class="number">4163</span>-8b95-09c94ecac873</span><br><span class="line">客户端接收消息数量=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyMessageDecoder decode 被调用</span><br><span class="line">客户端接收到消息如下</span><br><span class="line">长度=<span class="number">36</span></span><br><span class="line">内容=3be6e403-91bb-<span class="number">4437</span>-ada8-6cdb9eb7ef00</span><br><span class="line">客户端接收消息数量=<span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyMessageDecoder decode 被调用</span><br><span class="line">客户端接收到消息如下</span><br><span class="line">长度=<span class="number">36</span></span><br><span class="line">内容=94c8f306-fd9c-455a-956c-16698ce4150b</span><br><span class="line">客户端接收消息数量=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyMessageDecoder decode 被调用</span><br><span class="line">客户端接收到消息如下</span><br><span class="line">长度=<span class="number">36</span></span><br><span class="line">内容=7890de9c-0fa2-<span class="number">4317</span>-8de1-1d464315fa1b</span><br><span class="line">客户端接收消息数量=<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>Server输出</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyMessageDecoder decode 被调用</span><br><span class="line">服务器接收到信息如下</span><br><span class="line">长度=<span class="number">27</span></span><br><span class="line">内容=今天天气冷，吃火锅</span><br><span class="line">服务器接收到消息包数量=<span class="number">1</span></span><br><span class="line">服务端开始回复消息------</span><br><span class="line">MyMessageEncoder encode 方法被调用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyMessageDecoder decode 被调用</span><br><span class="line">服务器接收到信息如下</span><br><span class="line">长度=<span class="number">27</span></span><br><span class="line">内容=今天天气冷，吃火锅</span><br><span class="line">服务器接收到消息包数量=<span class="number">2</span></span><br><span class="line">服务端开始回复消息------</span><br><span class="line">MyMessageEncoder encode 方法被调用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyMessageDecoder decode 被调用</span><br><span class="line">服务器接收到信息如下</span><br><span class="line">长度=<span class="number">27</span></span><br><span class="line">内容=今天天气冷，吃火锅</span><br><span class="line">服务器接收到消息包数量=<span class="number">3</span></span><br><span class="line">服务端开始回复消息------</span><br><span class="line">MyMessageEncoder encode 方法被调用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyMessageDecoder decode 被调用</span><br><span class="line">服务器接收到信息如下</span><br><span class="line">长度=<span class="number">27</span></span><br><span class="line">内容=今天天气冷，吃火锅</span><br><span class="line">服务器接收到消息包数量=<span class="number">4</span></span><br><span class="line">服务端开始回复消息------</span><br><span class="line">MyMessageEncoder encode 方法被调用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyMessageDecoder decode 被调用</span><br><span class="line">服务器接收到信息如下</span><br><span class="line">长度=<span class="number">27</span></span><br><span class="line">内容=今天天气冷，吃火锅</span><br><span class="line">服务器接收到消息包数量=<span class="number">5</span></span><br><span class="line">服务端开始回复消息------</span><br><span class="line">MyMessageEncoder encode 方法被调用</span><br></pre></td></tr></table></figure>

<p>无论运行几次，Server都是分5次接收的，这样就解决了TCP粘包问题。</p>
<h1 id="用-Netty-自己实现简单的RPC"><a href="#用-Netty-自己实现简单的RPC" class="headerlink" title="用 Netty 自己实现简单的RPC"></a>用 Netty 自己实现简单的RPC</h1><h2 id="RPC-基本介绍"><a href="#RPC-基本介绍" class="headerlink" title="RPC 基本介绍"></a>RPC 基本介绍</h2><ol>
<li><code>RPC（Remote Procedure Call）</code>—远程过程调用，是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程</li>
<li>两个或多个应用程序都分布在不同的服务器上，它们之间的调用都像是本地方法调用一样(如图)</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0021.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0021.png" alt="img"></a></p>
<p>过程：</p>
<ol>
<li><p>调用者(<code>Caller</code>)，调用远程API(<code>Remote API</code>)</p>
</li>
<li><p>调用远程API会通过一个RPC代理(<code>RpcProxy</code>)</p>
</li>
<li><p>RPC代理再去调用<code>RpcInvoker</code>(这个是PRC的调用者)</p>
</li>
<li><p><code>RpcInvoker</code>通过RPC连接器(<code>RpcConnector</code>)</p>
</li>
<li><p>RPC连接器用两台机器规定好的PRC协议(<code>RpcProtocol</code>)把数据进行编码</p>
</li>
<li><p>接着RPC连接器通过RpcChannel通道发送到对方的PRC接收器(RpcAcceptor)</p>
</li>
<li><p>PRC接收器通过PRC协议进行解码拿到数据</p>
</li>
<li><p>然后将数据传给<code>RpcProcessor</code></p>
</li>
<li><p><code>RpcProcessor</code>再传给<code>RpcInvoker</code></p>
</li>
<li><p><code>RpcInvoker</code>调用<code>Remote API</code></p>
</li>
<li><p>最后推给被调用者(Callee)</p>
</li>
<li><p>常见的 <code>RPC</code> 框架有：比较知名的如阿里的 <code>Dubbo</code>、<code>Google</code> 的 <code>gRPC</code>、<code>Go</code> 语言的 <code>rpcx</code>、<code>Apache</code> 的 <code>thrift</code>，<code>Spring</code> 旗下的 <code>SpringCloud</code>。</p>
</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0022.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0022.png" alt="img"></a></p>
<h2 id="我们的RPC-调用流程图"><a href="#我们的RPC-调用流程图" class="headerlink" title="我们的RPC 调用流程图"></a>我们的RPC 调用流程图</h2><p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0023.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0023.png" alt="img"></a></p>
<p><strong>RPC 调用流程说明</strong></p>
<ol>
<li>服务消费方（<code>client</code>）以本地调用方式调用服务</li>
<li><code>client stub</code> 接收到调用后负责将方法、参数等封装成能够进行网络传输的消息体</li>
<li><code>client stub</code> 将消息进行编码并发送到服务端</li>
<li><code>server stub</code> 收到消息后进行解码</li>
<li><code>server stub</code> 根据解码结果调用本地的服务</li>
<li>本地服务执行并将结果返回给 <code>server stub</code></li>
<li><code>server stub</code> 将返回导入结果进行编码并发送至消费方</li>
<li><code>client stub</code> 接收到消息并进行解码</li>
<li>服务消费方（<code>client</code>）得到结果</li>
</ol>
<p>小结：<code>RPC</code> 的目标就是将 <code>2 - 8</code> 这些步骤都封装起来，用户无需关心这些细节，可以像调用本地方法一样即可完成远程服务调用</p>
<h2 id="己实现-Dubbo-RPC（基于-Netty）"><a href="#己实现-Dubbo-RPC（基于-Netty）" class="headerlink" title="己实现 Dubbo RPC（基于 Netty）"></a>己实现 Dubbo RPC（基于 Netty）</h2><h3 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h3><ol>
<li><code>Dubbo</code> 底层使用了 <code>Netty</code> 作为网络通讯框架，要求用 <code>Netty</code> 实现一个简单的 <code>RPC</code> 框架</li>
<li>模仿 <code>Dubbo</code>，消费者和提供者约定接口和协议，消费者远程调用提供者的服务，提供者返回一个字符串，消费者打印提供者返回的数据。底层网络通信使用 <code>Netty 4.1.20</code></li>
</ol>
<h3 id="设计说明"><a href="#设计说明" class="headerlink" title="设计说明"></a>设计说明</h3><ol>
<li>创建一个接口，定义抽象方法。用于消费者和提供者之间的约定。</li>
<li>创建一个提供者，该类需要监听消费者的请求，并按照约定返回数据。</li>
<li>创建一个消费者，该类需要透明的调用自己不存在的方法，内部需要使用 <code>Netty</code> 请求提供者返回数据</li>
<li>开发的分析图</li>
</ol>
<p><a href="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0024.png"><img src="https://cdn.jsdelivr.net/gh/youthlql/lqlp@master/netty/introduction/chapter_003/0024.png" alt="img"></a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="封装的RPC"><a href="#封装的RPC" class="headerlink" title="封装的RPC"></a>封装的RPC</h4><blockquote>
<p>可以把这块代码理解成封装的dubbo</p>
</blockquote>
<h5 id="NettyServer-2"><a href="#NettyServer-2" class="headerlink" title="NettyServer"></a>NettyServer</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.dubborpc.netty;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">(String hostName, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        startServer0(hostName,port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，完成对NettyServer的初始化和启动</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startServer0</span><span class="params">(String hostname, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                                      <span class="meta">@Override</span></span><br><span class="line">                                      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                          ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                                          pipeline.addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                                          pipeline.addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                                          pipeline.addLast(<span class="keyword">new</span> NettyServerHandler()); <span class="comment">//业务处理器</span></span><br><span class="line"></span><br><span class="line">                                      &#125;</span><br><span class="line">                                  &#125;</span><br><span class="line"></span><br><span class="line">                    );</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(hostname, port).sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;服务提供方开始提供服务~~&quot;</span>);</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="NettyServerHandler-2"><a href="#NettyServerHandler-2" class="headerlink" title="NettyServerHandler"></a>NettyServerHandler</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.dubborpc.netty;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.dubborpc.customer.ClientBootstrap;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.dubborpc.provider.HelloServiceImpl;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器这边handler比较简单</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---服务端开始收到来自客户单的消息---&quot;</span>);</span><br><span class="line">        <span class="comment">//获取客户端发送的消息，并调用服务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原始消息：&quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         1.客户端在调用服务器的api 时，我们需要定义一个协议，比如我们要求 每次发消息是都</span></span><br><span class="line"><span class="comment">         必须以某个字符串开头 &quot;HelloService#hello#你好&quot;</span></span><br><span class="line"><span class="comment">         2.Dubbo注册在Zookeeper里时，这种就是类的全路径字符串，你用IDEA的zookeeper插件</span></span><br><span class="line"><span class="comment">         就可以清楚地看到</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(msg.toString().startsWith(ClientBootstrap.providerName)) &#123;</span><br><span class="line"></span><br><span class="line">            String result = <span class="keyword">new</span> HelloServiceImpl().hello(msg.toString().substring(msg.toString().lastIndexOf(<span class="string">&quot;#&quot;</span>) + <span class="number">1</span>));</span><br><span class="line">            ctx.writeAndFlush(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="NettyClientHandler-2"><a href="#NettyClientHandler-2" class="headerlink" title="NettyClientHandler"></a>NettyClientHandler</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.dubborpc.netty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ChannelHandlerContext context;<span class="comment">//上下文</span></span><br><span class="line">    <span class="keyword">private</span> String result; <span class="comment">//返回的结果</span></span><br><span class="line">    <span class="keyword">private</span> String para; <span class="comment">//客户端调用方法时，传入的参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//与服务器的连接创建后，就会被调用, 这个方法是第一个被调用(1)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; channelActive 被调用  &quot;</span>);</span><br><span class="line">        context = ctx; <span class="comment">//因为我们在其它方法会使用到 ctx</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收到服务器的数据后，调用方法 (4)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; channelRead 被调用  &quot;</span>);</span><br><span class="line">        result = msg.toString();</span><br><span class="line">        notify(); <span class="comment">//唤醒等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被代理对象调用, 发送数据给服务器，-&gt; wait -&gt; 等待被唤醒(channelRead) -&gt; 返回结果 (3)-》5</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; call1 被调用  &quot;</span>);</span><br><span class="line">        context.writeAndFlush(para);</span><br><span class="line">        <span class="comment">//进行wait</span></span><br><span class="line">        wait(); <span class="comment">//等待channelRead 方法获取到服务器的结果后，唤醒</span></span><br><span class="line">        System.out.println(<span class="string">&quot; call2 被调用  &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>  result; <span class="comment">//服务方返回的结果</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(2)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPara</span><span class="params">(String para)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; setPara  &quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.para = para;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="NettyClient-2"><a href="#NettyClient-2" class="headerlink" title="NettyClient"></a>NettyClient</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.dubborpc.netty;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NettyClientHandler client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写方法使用代理模式，获取一个代理对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; serivceClass, <span class="keyword">final</span> String providerName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class&lt;?&gt;[]&#123;serivceClass&#125;, (proxy, method, args) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;(proxy, method, args) 进入....&quot;</span> + (++count) + <span class="string">&quot; 次&quot;</span>);</span><br><span class="line">                    <span class="comment">//&#123;&#125;  部分的代码，客户端每调用一次 hello, 就会进入到该代码</span></span><br><span class="line">                    <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        initClient();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//设置要发给服务器端的信息</span></span><br><span class="line">                    <span class="comment">//providerName：协议头，args[0]：就是客户端要发送给服务端的数据</span></span><br><span class="line">                    client.setPara(providerName + args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">return</span> executor.submit(client).get();</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化客户端</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client = <span class="keyword">new</span> NettyClientHandler();</span><br><span class="line">        <span class="comment">//创建EventLoopGroup</span></span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                .handler(</span><br><span class="line">                        <span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                                pipeline.addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                                pipeline.addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                                pipeline.addLast(client);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7000</span>).sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.dubborpc.publicinterface;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个是接口，是服务提供方和 服务消费方都需要</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String mes)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务端-provider"><a href="#服务端-provider" class="headerlink" title="服务端(provider)"></a>服务端(provider)</h4><h5 id="HelloServiceImpl"><a href="#HelloServiceImpl" class="headerlink" title="HelloServiceImpl"></a>HelloServiceImpl</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.dubborpc.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.dubborpc.publicinterface.HelloService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当有消费方调用该方法时， 就返回一个结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String mes)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到客户端消息=&quot;</span> + mes);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//根据mes 返回不同的结果</span></span><br><span class="line">        <span class="keyword">if</span>(mes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你好客户端, 我已经收到你的消息。消息为：[&quot;</span> + mes + <span class="string">&quot;] ，第&quot;</span> + (++count) + <span class="string">&quot; 次 \n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你好客户端, 我已经收到你的消息 &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ServerBootstrap"><a href="#ServerBootstrap" class="headerlink" title="ServerBootstrap"></a>ServerBootstrap</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.dubborpc.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.dubborpc.netty.NettyServer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ServerBootstrap 会启动一个服务提供者，就是 NettyServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerBootstrap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代码代填..</span></span><br><span class="line">        NettyServer.startServer(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端-消费者"><a href="#客户端-消费者" class="headerlink" title="客户端(消费者)"></a>客户端(消费者)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.dubborpc.customer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.dubborpc.netty.NettyClient;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.dubborpc.publicinterface.HelloService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里定义协议头</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String providerName = <span class="string">&quot;HelloService#hello#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个消费者</span></span><br><span class="line">        NettyClient customer = <span class="keyword">new</span> NettyClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        HelloService service = (HelloService) customer.getBean(HelloService.class, providerName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;; ) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line">            <span class="comment">//通过代理对象调用服务提供者的方法(服务)</span></span><br><span class="line">            String res = service.hello(<span class="string">&quot;你好 dubbo~&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;调用的结果 res= &quot;</span> + res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h3><ol>
<li><code>ClientBootstrap#main</code>发起调用</li>
<li>走到下面这一行代码后</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HelloService service = (HelloService) customer.getBean(HelloService.class, providerName);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>调用<code>NettyClient#getBean</code>，在此方法里与服务端建立链接。</p>
</li>
<li><p>于是就执行<code>NettyClientHandler#channelActive</code></p>
</li>
<li><p>接着回到<code>NettyClient#getBean</code>调用<code>NettyClientHandler#setPara</code>，调用完之后再回到<code>NettyClient#getBean</code>，用线程池提交任务</p>
</li>
<li><p>因为用线程池提交了任务，就准备执行<code>NettyClientHandler#call</code>线程任务</p>
</li>
<li><p>在<code>NettyClientHandler#call</code>中发送数据给服务提供者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">context.writeAndFlush(para);</span><br></pre></td></tr></table></figure>

<p>由于还没收到服务提供者的数据结果，所以wait住</p>
</li>
<li><p>来到了服务提供者这边，从Socket通道中收到了数据，所以执行<code>NettyServerHandler#channelRead</code>，然后因为此方法中执行了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">String result = new HelloServiceImpl().hello(msg.toString().substring(msg.toString().lastIndexOf(&quot;#&quot;) + 1));</span><br></pre></td></tr></table></figure></li>
<li><p>就去<code>HelloServiceImpl#hello</code>中执行业务逻辑，返回数据给<code>NettyServerHandler#channelRead</code>，<code>NettyServerHandler#channelRead</code>再把数据发给客户端</p>
</li>
<li><p><code>NettyClientHandler#channelRead</code>收到服务提供者发来的数据，唤醒之前wait的线程</p>
</li>
<li><p>所以之前wait的线程从<code>NettyClientHandler#call</code>苏醒，返回result给<code>NettyClient#getBean</code></p>
</li>
<li><p><code>NettyClient#getBean</code>get()到数据，<code>ClientBootstrap#main</code>中的此函数调用返回，得到服务端提供的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">String res = service.hello(&quot;你好 dubbo~&quot;);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>13.至此，一次RPC调用结束。</p>
<h3 id="效果-3"><a href="#效果-3" class="headerlink" title="效果"></a>效果</h3><p><strong>ClientBootstrap打印</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(proxy, method, args) 进入...<span class="number">.1</span> 次</span><br><span class="line"> setPara  </span><br><span class="line"> channelActive 被调用  </span><br><span class="line"> call1 被调用  </span><br><span class="line"> channelRead 被调用  </span><br><span class="line"> call2 被调用  </span><br><span class="line">调用的结果 res= 你好客户端, 我已经收到你的消息。消息为：[你好 dubbo~] ，第<span class="number">1</span> 次 </span><br><span class="line"></span><br><span class="line">(proxy, method, args) 进入...<span class="number">.2</span> 次</span><br><span class="line"> setPara  </span><br><span class="line"> call1 被调用  </span><br><span class="line"> channelRead 被调用  </span><br><span class="line"> call2 被调用  </span><br><span class="line">调用的结果 res= 你好客户端, 我已经收到你的消息。消息为：[你好 dubbo~] ，第<span class="number">2</span> 次 </span><br><span class="line"></span><br><span class="line">(proxy, method, args) 进入...<span class="number">.3</span> 次</span><br><span class="line"> setPara  </span><br><span class="line"> call1 被调用  </span><br><span class="line"> channelRead 被调用  </span><br><span class="line"> call2 被调用  </span><br><span class="line">调用的结果 res= 你好客户端, 我已经收到你的消息。消息为：[你好 dubbo~] ，第<span class="number">3</span> 次 </span><br><span class="line"></span><br><span class="line">(proxy, method, args) 进入...<span class="number">.4</span> 次</span><br><span class="line"> setPara  </span><br><span class="line"> call1 被调用  </span><br><span class="line"> channelRead 被调用  </span><br><span class="line"> call2 被调用  </span><br><span class="line">调用的结果 res= 你好客户端, 我已经收到你的消息。消息为：[你好 dubbo~] ，第<span class="number">4</span> 次 </span><br><span class="line"></span><br><span class="line">(proxy, method, args) 进入...<span class="number">.5</span> 次</span><br><span class="line"> setPara  </span><br><span class="line"> call1 被调用  </span><br><span class="line"> channelRead 被调用  </span><br><span class="line"> call2 被调用  </span><br><span class="line">调用的结果 res= 你好客户端, 我已经收到你的消息。消息为：[你好 dubbo~] ，第<span class="number">5</span> 次 </span><br></pre></td></tr></table></figure>

<p><strong>ServerBootstrap打印</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">服务提供方开始提供服务~~</span><br><span class="line">---服务端开始收到来自客户单的消息---</span><br><span class="line">原始消息：HelloService#hello#你好 dubbo~</span><br><span class="line">收到客户端消息=你好 dubbo~</span><br><span class="line"></span><br><span class="line">---服务端开始收到来自客户单的消息---</span><br><span class="line">原始消息：HelloService#hello#你好 dubbo~</span><br><span class="line">收到客户端消息=你好 dubbo~</span><br><span class="line"></span><br><span class="line">---服务端开始收到来自客户单的消息---</span><br><span class="line">原始消息：HelloService#hello#你好 dubbo~</span><br><span class="line">收到客户端消息=你好 dubbo~</span><br><span class="line"></span><br><span class="line">---服务端开始收到来自客户单的消息---</span><br><span class="line">原始消息：HelloService#hello#你好 dubbo~</span><br><span class="line">收到客户端消息=你好 dubbo~</span><br><span class="line"></span><br><span class="line">---服务端开始收到来自客户单的消息---</span><br><span class="line">原始消息：HelloService#hello#你好 dubbo~</span><br><span class="line">收到客户端消息=你好 dubbo~</span><br></pre></td></tr></table></figure>



<p>参考：</p>
<p><strong>视频：</strong><a href="https://www.bilibili.com/video/BV1DJ411m7NR?from=search&amp;seid=7455267981675039441">https://www.bilibili.com/video/BV1DJ411m7NR?from=search&amp;seid=7455267981675039441</a></p>
<p><strong>文章链接:</strong> <a href="https://imlql.cn/post/3f9283e7.html">https://imlql.cn/post/3f9283e7.html</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>netty</category>
      </categories>
  </entry>
</search>
